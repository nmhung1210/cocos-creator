
                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'engine-dev/external/cannon/cannon.js';
                    var __require = nodeEnv ? function (request) {
                        return require(request);
                    } : function (request) {
                        return __quick_compile_engine__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_engine__.registerModule(__filename, module);}"use strict";

// Mon, 04 Nov 2019 05:14:37 GMT

/*
 * Copyright (c) 2015 cannon.js Authors
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
!function (e) {
  if ("object" == typeof exports && "undefined" != typeof module) module.exports = e();else if ("function" == typeof define && define.amd) define([], e);else {
    var f;
    "undefined" != typeof window ? f = window : "undefined" != typeof global ? f = global : "undefined" != typeof self && (f = self), f.CANNON = e();
  }
}(function () {
  var define, module, exports;
  return function e(t, n, r) {
    function s(o, u) {
      if (!n[o]) {
        if (!t[o]) {
          var a = typeof require == "function" && require;
          if (!u && a) return a(o, !0);
          if (i) return i(o, !0);
          throw new Error("Cannot find module '" + o + "'");
        }

        var f = n[o] = {
          exports: {}
        };
        t[o][0].call(f.exports, function (e) {
          var n = t[o][1][e];
          return s(n ? n : e);
        }, f, f.exports, e, t, n, r);
      }

      return n[o].exports;
    }

    var i = typeof require == "function" && require;

    for (var o = 0; o < r.length; o++) {
      s(r[o]);
    }

    return s;
  }({
    1: [function (_dereq_, module, exports) {
      module.exports = {
        "name": "@cocos/cannon",
        "version": "1.0.3",
        "description": "A lightweight 3D physics engine written in JavaScript.",
        "homepage": "https://github.com/cocos-creator/cannon.js",
        "author": "Stefan Hedman <schteppe@gmail.com> (http://steffe.se), JayceLai",
        "keywords": ["cannon", "cocos", "creator", "physics", "engine", "3d"],
        "scripts": {
          "build": "grunt && npm run preprocess && grunt addLicense && grunt addDate",
          "preprocess": "node node_modules/uglify-js/bin/uglifyjs build/cannon.js -o build/cannon.min.js -d doProfiling=false,DEBUG=false -c -m"
        },
        "main": "./build/cannon.min.js",
        "engines": {
          "node": "*"
        },
        "repository": {
          "type": "git",
          "url": "https://github.com/cocos-creator/cannon.js.git"
        },
        "bugs": {
          "url": "https://github.com/cocos-creator/cannon.js/issues"
        },
        "licenses": [{
          "type": "MIT"
        }],
        "devDependencies": {
          "jshint": "latest",
          "uglify-js": "latest",
          "nodeunit": "^0.9.0",
          "grunt": "~0.4.0",
          "grunt-contrib-jshint": "~0.1.1",
          "grunt-contrib-nodeunit": "^0.4.1",
          "grunt-contrib-concat": "~0.1.3",
          "grunt-contrib-uglify": "^0.5.1",
          "grunt-browserify": "^2.1.4",
          "grunt-contrib-yuidoc": "^0.5.2",
          "browserify": "*"
        },
        "dependencies": {}
      };
    }, {}],
    2: [function (_dereq_, module, exports) {
      // Export classes
      module.exports = {
        version: _dereq_('../package.json').version,
        AABB: _dereq_('./collision/AABB'),
        ArrayCollisionMatrix: _dereq_('./collision/ArrayCollisionMatrix'),
        Body: _dereq_('./objects/Body'),
        Box: _dereq_('./shapes/Box'),
        Broadphase: _dereq_('./collision/Broadphase'),
        Constraint: _dereq_('./constraints/Constraint'),
        ContactEquation: _dereq_('./equations/ContactEquation'),
        Narrowphase: _dereq_('./world/Narrowphase'),
        ConeTwistConstraint: _dereq_('./constraints/ConeTwistConstraint'),
        ContactMaterial: _dereq_('./material/ContactMaterial'),
        ConvexPolyhedron: _dereq_('./shapes/ConvexPolyhedron'),
        Cylinder: _dereq_('./shapes/Cylinder'),
        DistanceConstraint: _dereq_('./constraints/DistanceConstraint'),
        Equation: _dereq_('./equations/Equation'),
        EventTarget: _dereq_('./utils/EventTarget'),
        FrictionEquation: _dereq_('./equations/FrictionEquation'),
        GSSolver: _dereq_('./solver/GSSolver'),
        GridBroadphase: _dereq_('./collision/GridBroadphase'),
        Heightfield: _dereq_('./shapes/Heightfield'),
        HingeConstraint: _dereq_('./constraints/HingeConstraint'),
        LockConstraint: _dereq_('./constraints/LockConstraint'),
        Mat3: _dereq_('./math/Mat3'),
        Material: _dereq_('./material/Material'),
        NaiveBroadphase: _dereq_('./collision/NaiveBroadphase'),
        ObjectCollisionMatrix: _dereq_('./collision/ObjectCollisionMatrix'),
        Pool: _dereq_('./utils/Pool'),
        Particle: _dereq_('./shapes/Particle'),
        Plane: _dereq_('./shapes/Plane'),
        PointToPointConstraint: _dereq_('./constraints/PointToPointConstraint'),
        Quaternion: _dereq_('./math/Quaternion'),
        Ray: _dereq_('./collision/Ray'),
        RaycastVehicle: _dereq_('./objects/RaycastVehicle'),
        RaycastResult: _dereq_('./collision/RaycastResult'),
        RigidVehicle: _dereq_('./objects/RigidVehicle'),
        RotationalEquation: _dereq_('./equations/RotationalEquation'),
        RotationalMotorEquation: _dereq_('./equations/RotationalMotorEquation'),
        SAPBroadphase: _dereq_('./collision/SAPBroadphase'),
        SPHSystem: _dereq_('./objects/SPHSystem'),
        Shape: _dereq_('./shapes/Shape'),
        Solver: _dereq_('./solver/Solver'),
        Sphere: _dereq_('./shapes/Sphere'),
        SplitSolver: _dereq_('./solver/SplitSolver'),
        Spring: _dereq_('./objects/Spring'),
        Transform: _dereq_('./math/Transform'),
        Trimesh: _dereq_('./shapes/Trimesh'),
        Vec3: _dereq_('./math/Vec3'),
        Vec3Pool: _dereq_('./utils/Vec3Pool'),
        World: _dereq_('./world/World')
      };
    }, {
      "../package.json": 1,
      "./collision/AABB": 3,
      "./collision/ArrayCollisionMatrix": 4,
      "./collision/Broadphase": 5,
      "./collision/GridBroadphase": 6,
      "./collision/NaiveBroadphase": 7,
      "./collision/ObjectCollisionMatrix": 8,
      "./collision/Ray": 10,
      "./collision/RaycastResult": 11,
      "./collision/SAPBroadphase": 12,
      "./constraints/ConeTwistConstraint": 13,
      "./constraints/Constraint": 14,
      "./constraints/DistanceConstraint": 15,
      "./constraints/HingeConstraint": 16,
      "./constraints/LockConstraint": 17,
      "./constraints/PointToPointConstraint": 18,
      "./equations/ContactEquation": 20,
      "./equations/Equation": 21,
      "./equations/FrictionEquation": 22,
      "./equations/RotationalEquation": 23,
      "./equations/RotationalMotorEquation": 24,
      "./material/ContactMaterial": 25,
      "./material/Material": 26,
      "./math/Mat3": 28,
      "./math/Quaternion": 29,
      "./math/Transform": 30,
      "./math/Vec3": 31,
      "./objects/Body": 32,
      "./objects/RaycastVehicle": 33,
      "./objects/RigidVehicle": 34,
      "./objects/SPHSystem": 35,
      "./objects/Spring": 36,
      "./shapes/Box": 38,
      "./shapes/ConvexPolyhedron": 39,
      "./shapes/Cylinder": 40,
      "./shapes/Heightfield": 41,
      "./shapes/Particle": 42,
      "./shapes/Plane": 43,
      "./shapes/Shape": 44,
      "./shapes/Sphere": 45,
      "./shapes/Trimesh": 46,
      "./solver/GSSolver": 47,
      "./solver/Solver": 48,
      "./solver/SplitSolver": 49,
      "./utils/EventTarget": 50,
      "./utils/Pool": 52,
      "./utils/Vec3Pool": 55,
      "./world/Narrowphase": 56,
      "./world/World": 57
    }],
    3: [function (_dereq_, module, exports) {
      var Vec3 = _dereq_('../math/Vec3');

      var Utils = _dereq_('../utils/Utils');

      module.exports = AABB;
      /**
       * Axis aligned bounding box class.
       * @class AABB
       * @constructor
       * @param {Object} [options]
       * @param {Vec3}   [options.upperBound]
       * @param {Vec3}   [options.lowerBound]
       */

      function AABB(options) {
        options = options || {};
        /**
         * The lower bound of the bounding box.
         * @property lowerBound
         * @type {Vec3}
         */

        this.lowerBound = new Vec3();

        if (options.lowerBound) {
          this.lowerBound.copy(options.lowerBound);
        }
        /**
         * The upper bound of the bounding box.
         * @property upperBound
         * @type {Vec3}
         */


        this.upperBound = new Vec3();

        if (options.upperBound) {
          this.upperBound.copy(options.upperBound);
        }
      }

      var tmp = new Vec3();
      /**
       * Set the AABB bounds from a set of points.
       * @method setFromPoints
       * @param {Array} points An array of Vec3's.
       * @param {Vec3} position
       * @param {Quaternion} quaternion
       * @param {number} skinSize
       * @return {AABB} The self object
       */

      AABB.prototype.setFromPoints = function (points, position, quaternion, skinSize) {
        var l = this.lowerBound,
            u = this.upperBound,
            q = quaternion; // Set to the first point

        l.copy(points[0]);

        if (q) {
          q.vmult(l, l);
        }

        u.copy(l);

        for (var i = 1; i < points.length; i++) {
          var p = points[i];

          if (q) {
            q.vmult(p, tmp);
            p = tmp;
          }

          if (p.x > u.x) {
            u.x = p.x;
          }

          if (p.x < l.x) {
            l.x = p.x;
          }

          if (p.y > u.y) {
            u.y = p.y;
          }

          if (p.y < l.y) {
            l.y = p.y;
          }

          if (p.z > u.z) {
            u.z = p.z;
          }

          if (p.z < l.z) {
            l.z = p.z;
          }
        } // Add offset


        if (position) {
          position.vadd(l, l);
          position.vadd(u, u);
        }

        if (skinSize) {
          l.x -= skinSize;
          l.y -= skinSize;
          l.z -= skinSize;
          u.x += skinSize;
          u.y += skinSize;
          u.z += skinSize;
        }

        return this;
      };
      /**
       * Copy bounds from an AABB to this AABB
       * @method copy
       * @param  {AABB} aabb Source to copy from
       * @return {AABB} The this object, for chainability
       */


      AABB.prototype.copy = function (aabb) {
        this.lowerBound.copy(aabb.lowerBound);
        this.upperBound.copy(aabb.upperBound);
        return this;
      };
      /**
       * Clone an AABB
       * @method clone
       */


      AABB.prototype.clone = function () {
        return new AABB().copy(this);
      };
      /**
       * Extend this AABB so that it covers the given AABB too.
       * @method extend
       * @param  {AABB} aabb
       */


      AABB.prototype.extend = function (aabb) {
        this.lowerBound.x = Math.min(this.lowerBound.x, aabb.lowerBound.x);
        this.upperBound.x = Math.max(this.upperBound.x, aabb.upperBound.x);
        this.lowerBound.y = Math.min(this.lowerBound.y, aabb.lowerBound.y);
        this.upperBound.y = Math.max(this.upperBound.y, aabb.upperBound.y);
        this.lowerBound.z = Math.min(this.lowerBound.z, aabb.lowerBound.z);
        this.upperBound.z = Math.max(this.upperBound.z, aabb.upperBound.z);
      };
      /**
       * Returns true if the given AABB overlaps this AABB.
       * @method overlaps
       * @param  {AABB} aabb
       * @return {Boolean}
       */


      AABB.prototype.overlaps = function (aabb) {
        var l1 = this.lowerBound,
            u1 = this.upperBound,
            l2 = aabb.lowerBound,
            u2 = aabb.upperBound; //      l2        u2
        //      |---------|
        // |--------|
        // l1       u1
        // no consider contain case
        // let overlapsX = ((l2.x <= u1.x && u1.x <= u2.x) || (l1.x <= u2.x && u2.x <= u1.x));
        // let overlapsY = ((l2.y <= u1.y && u1.y <= u2.y) || (l1.y <= u2.y && u2.y <= u1.y));
        // let overlapsZ = ((l2.z <= u1.z && u1.z <= u2.z) || (l1.z <= u2.z && u2.z <= u1.z));
        // overlaps must consider contain case
        // or ray cast may miss

        var overlapsX = l2.x <= u1.x && l1.x <= u2.x;
        var overlapsY = l2.y <= u1.y && l1.y <= u2.y;
        var overlapsZ = l2.z <= u1.z && l1.z <= u2.z;
        return overlapsX && overlapsY && overlapsZ;
      }; // Mostly for debugging


      AABB.prototype.volume = function () {
        var l = this.lowerBound,
            u = this.upperBound;
        return (u.x - l.x) * (u.y - l.y) * (u.z - l.z);
      };
      /**
       * Returns true if the given AABB is fully contained in this AABB.
       * @method contains
       * @param {AABB} aabb
       * @return {Boolean}
       */


      AABB.prototype.contains = function (aabb) {
        var l1 = this.lowerBound,
            u1 = this.upperBound,
            l2 = aabb.lowerBound,
            u2 = aabb.upperBound; //      l2        u2
        //      |---------|
        // |---------------|
        // l1              u1

        return l1.x <= l2.x && u1.x >= u2.x && l1.y <= l2.y && u1.y >= u2.y && l1.z <= l2.z && u1.z >= u2.z;
      };
      /**
       * @method getCorners
       * @param {Vec3} a
       * @param {Vec3} b
       * @param {Vec3} c
       * @param {Vec3} d
       * @param {Vec3} e
       * @param {Vec3} f
       * @param {Vec3} g
       * @param {Vec3} h
       */


      AABB.prototype.getCorners = function (a, b, c, d, e, f, g, h) {
        var l = this.lowerBound,
            u = this.upperBound;
        a.copy(l);
        b.set(u.x, l.y, l.z);
        c.set(u.x, u.y, l.z);
        d.set(l.x, u.y, u.z);
        e.set(u.x, l.y, u.z);
        f.set(l.x, u.y, l.z);
        g.set(l.x, l.y, u.z);
        h.copy(u);
      };

      var transformIntoFrame_corners = [new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3()];
      /**
       * Get the representation of an AABB in another frame.
       * @method toLocalFrame
       * @param  {Transform} frame
       * @param  {AABB} target
       * @return {AABB} The "target" AABB object.
       */

      AABB.prototype.toLocalFrame = function (frame, target) {
        var corners = transformIntoFrame_corners;
        var a = corners[0];
        var b = corners[1];
        var c = corners[2];
        var d = corners[3];
        var e = corners[4];
        var f = corners[5];
        var g = corners[6];
        var h = corners[7]; // Get corners in current frame

        this.getCorners(a, b, c, d, e, f, g, h); // Transform them to new local frame

        for (var i = 0; i !== 8; i++) {
          var corner = corners[i];
          frame.pointToLocal(corner, corner);
        }

        return target.setFromPoints(corners);
      };
      /**
       * Get the representation of an AABB in the global frame.
       * @method toWorldFrame
       * @param  {Transform} frame
       * @param  {AABB} target
       * @return {AABB} The "target" AABB object.
       */


      AABB.prototype.toWorldFrame = function (frame, target) {
        var corners = transformIntoFrame_corners;
        var a = corners[0];
        var b = corners[1];
        var c = corners[2];
        var d = corners[3];
        var e = corners[4];
        var f = corners[5];
        var g = corners[6];
        var h = corners[7]; // Get corners in current frame

        this.getCorners(a, b, c, d, e, f, g, h); // Transform them to new local frame

        for (var i = 0; i !== 8; i++) {
          var corner = corners[i];
          frame.pointToWorld(corner, corner);
        }

        return target.setFromPoints(corners);
      };
      /**
       * Check if the AABB is hit by a ray.
       * @param  {Ray} ray
       * @return {number}
       */


      AABB.prototype.overlapsRay = function (ray) {
        var t = 0; // ray.direction is unit direction vector of ray

        var dirFracX = 1 / ray._direction.x;
        var dirFracY = 1 / ray._direction.y;
        var dirFracZ = 1 / ray._direction.z; // this.lowerBound is the corner of AABB with minimal coordinates - left bottom, rt is maximal corner

        var t1 = (this.lowerBound.x - ray.from.x) * dirFracX;
        var t2 = (this.upperBound.x - ray.from.x) * dirFracX;
        var t3 = (this.lowerBound.y - ray.from.y) * dirFracY;
        var t4 = (this.upperBound.y - ray.from.y) * dirFracY;
        var t5 = (this.lowerBound.z - ray.from.z) * dirFracZ;
        var t6 = (this.upperBound.z - ray.from.z) * dirFracZ; // var tmin = Math.max(Math.max(Math.min(t1, t2), Math.min(t3, t4)));
        // var tmax = Math.min(Math.min(Math.max(t1, t2), Math.max(t3, t4)));

        var tmin = Math.max(Math.max(Math.min(t1, t2), Math.min(t3, t4)), Math.min(t5, t6));
        var tmax = Math.min(Math.min(Math.max(t1, t2), Math.max(t3, t4)), Math.max(t5, t6)); // if tmax < 0, ray (line) is intersecting AABB, but whole AABB is behing us

        if (tmax < 0) {
          //t = tmax;
          return false;
        } // if tmin > tmax, ray doesn't intersect AABB


        if (tmin > tmax) {
          //t = tmax;
          return false;
        }

        return true;
      };
    }, {
      "../math/Vec3": 31,
      "../utils/Utils": 54
    }],
    4: [function (_dereq_, module, exports) {
      module.exports = ArrayCollisionMatrix;
      /**
       * Collision "matrix". It's actually a triangular-shaped array of whether two bodies are touching this step, for reference next step
       * @class ArrayCollisionMatrix
       * @constructor
       */

      function ArrayCollisionMatrix() {
        /**
         * The matrix storage
         * @property matrix
         * @type {Array}
         */
        this.matrix = [];
      }
      /**
       * Get an element
       * @method get
       * @param  {Number} i
       * @param  {Number} j
       * @return {Number}
       */


      ArrayCollisionMatrix.prototype.get = function (i, j) {
        i = i.index;
        j = j.index;

        if (j > i) {
          var temp = j;
          j = i;
          i = temp;
        }

        return this.matrix[(i * (i + 1) >> 1) + j - 1];
      };
      /**
       * Set an element
       * @method set
       * @param {Number} i
       * @param {Number} j
       * @param {Number} value
       */


      ArrayCollisionMatrix.prototype.set = function (i, j, value) {
        i = i.index;
        j = j.index;

        if (j > i) {
          var temp = j;
          j = i;
          i = temp;
        }

        this.matrix[(i * (i + 1) >> 1) + j - 1] = value ? 1 : 0;
      };
      /**
       * Sets all elements to zero
       * @method reset
       */


      ArrayCollisionMatrix.prototype.reset = function () {
        for (var i = 0, l = this.matrix.length; i !== l; i++) {
          this.matrix[i] = 0;
        }
      };
      /**
       * Sets the max number of objects
       * @method setNumObjects
       * @param {Number} n
       */


      ArrayCollisionMatrix.prototype.setNumObjects = function (n) {
        this.matrix.length = n * (n - 1) >> 1;
      };
    }, {}],
    5: [function (_dereq_, module, exports) {
      var Body = _dereq_('../objects/Body');

      var Vec3 = _dereq_('../math/Vec3');

      var Quaternion = _dereq_('../math/Quaternion');

      var Shape = _dereq_('../shapes/Shape');

      var Plane = _dereq_('../shapes/Plane');

      module.exports = Broadphase;
      /**
       * Base class for broadphase implementations
       * @class Broadphase
       * @constructor
       * @author schteppe
       */

      function Broadphase() {
        /**
        * The world to search for collisions in.
        * @property world
        * @type {World}
        */
        this.world = null;
        /**
         * If set to true, the broadphase uses bounding boxes for intersection test, else it uses bounding spheres.
         * @property useBoundingBoxes
         * @type {Boolean}
         */

        this.useBoundingBoxes = false;
        /**
         * Set to true if the objects in the world moved.
         * @property {Boolean} dirty
         */

        this.dirty = true;
      }
      /**
       * Get the collision pairs from the world
       * @method collisionPairs
       * @param {World} world The world to search in
       * @param {Array} p1 Empty array to be filled with body objects
       * @param {Array} p2 Empty array to be filled with body objects
       */


      Broadphase.prototype.collisionPairs = function (world, p1, p2) {
        throw new Error("collisionPairs not implemented for this BroadPhase class!");
      };
      /**
       * Check if a body pair needs to be intersection tested at all.
       * @method needBroadphaseCollision
       * @param {Body} bodyA
       * @param {Body} bodyB
       * @return {bool}
       */


      Broadphase.prototype.needBroadphaseCollision = function (bodyA, bodyB) {
        // Check collision filter masks
        if ((bodyA.collisionFilterGroup & bodyB.collisionFilterMask) === 0 || (bodyB.collisionFilterGroup & bodyA.collisionFilterMask) === 0) {
          return false;
        } // Check has trigger


        if (bodyA.hasTrigger || bodyB.hasTrigger) {
          return true;
        } // Check types


        if (((bodyA.type & Body.STATIC) !== 0 || bodyA.sleepState === Body.SLEEPING) && ((bodyB.type & Body.STATIC) !== 0 || bodyB.sleepState === Body.SLEEPING)) {
          // Both bodies are static or sleeping. Skip.
          return false;
        }

        return true;
      };
      /**
       * Check if the bounding volumes of two bodies intersect.
       * @method intersectionTest
       * @param {Body} bodyA
       * @param {Body} bodyB
       * @param {array} pairs1
       * @param {array} pairs2
        */


      Broadphase.prototype.intersectionTest = function (bodyA, bodyB, pairs1, pairs2) {
        if (this.useBoundingBoxes) {
          this.doBoundingBoxBroadphase(bodyA, bodyB, pairs1, pairs2);
        } else {
          this.doBoundingSphereBroadphase(bodyA, bodyB, pairs1, pairs2);
        }
      };
      /**
       * Check if the bounding spheres of two bodies are intersecting.
       * @method doBoundingSphereBroadphase
       * @param {Body} bodyA
       * @param {Body} bodyB
       * @param {Array} pairs1 bodyA is appended to this array if intersection
       * @param {Array} pairs2 bodyB is appended to this array if intersection
       */


      var Broadphase_collisionPairs_r = new Vec3(),
          // Temp objects
      Broadphase_collisionPairs_normal = new Vec3(),
          Broadphase_collisionPairs_quat = new Quaternion(),
          Broadphase_collisionPairs_relpos = new Vec3();

      Broadphase.prototype.doBoundingSphereBroadphase = function (bodyA, bodyB, pairs1, pairs2) {
        var r = Broadphase_collisionPairs_r;
        bodyB.position.vsub(bodyA.position, r);
        var boundingRadiusSum2 = Math.pow(bodyA.boundingRadius + bodyB.boundingRadius, 2);
        var norm2 = r.norm2();

        if (norm2 < boundingRadiusSum2) {
          pairs1.push(bodyA);
          pairs2.push(bodyB);
        }
      };
      /**
       * Check if the bounding boxes of two bodies are intersecting.
       * @method doBoundingBoxBroadphase
       * @param {Body} bodyA
       * @param {Body} bodyB
       * @param {Array} pairs1
       * @param {Array} pairs2
       */


      Broadphase.prototype.doBoundingBoxBroadphase = function (bodyA, bodyB, pairs1, pairs2) {
        if (bodyA.aabbNeedsUpdate) {
          bodyA.computeAABB();
        }

        if (bodyB.aabbNeedsUpdate) {
          bodyB.computeAABB();
        } // Check AABB / AABB


        if (bodyA.aabb.overlaps(bodyB.aabb)) {
          pairs1.push(bodyA);
          pairs2.push(bodyB);
        }
      };
      /**
       * Removes duplicate pairs from the pair arrays.
       * @method makePairsUnique
       * @param {Array} pairs1
       * @param {Array} pairs2
       */


      var Broadphase_makePairsUnique_temp = {
        keys: []
      },
          Broadphase_makePairsUnique_p1 = [],
          Broadphase_makePairsUnique_p2 = [];

      Broadphase.prototype.makePairsUnique = function (pairs1, pairs2) {
        var t = Broadphase_makePairsUnique_temp,
            p1 = Broadphase_makePairsUnique_p1,
            p2 = Broadphase_makePairsUnique_p2,
            N = pairs1.length;

        for (var i = 0; i !== N; i++) {
          p1[i] = pairs1[i];
          p2[i] = pairs2[i];
        }

        pairs1.length = 0;
        pairs2.length = 0;

        for (var i = 0; i !== N; i++) {
          var id1 = p1[i].id,
              id2 = p2[i].id;
          var key = id1 < id2 ? id1 + "," + id2 : id2 + "," + id1;
          t[key] = i;
          t.keys.push(key);
        }

        for (var i = 0; i !== t.keys.length; i++) {
          var key = t.keys.pop(),
              pairIndex = t[key];
          pairs1.push(p1[pairIndex]);
          pairs2.push(p2[pairIndex]);
          delete t[key];
        }
      };
      /**
       * To be implemented by subcasses
       * @method setWorld
       * @param {World} world
       */


      Broadphase.prototype.setWorld = function (world) {};
      /**
       * Check if the bounding spheres of two bodies overlap.
       * @method boundingSphereCheck
       * @param {Body} bodyA
       * @param {Body} bodyB
       * @return {boolean}
       */


      var bsc_dist = new Vec3();

      Broadphase.boundingSphereCheck = function (bodyA, bodyB) {
        var dist = bsc_dist;
        bodyA.position.vsub(bodyB.position, dist);
        return Math.pow(bodyA.shape.boundingSphereRadius + bodyB.shape.boundingSphereRadius, 2) > dist.norm2();
      };
      /**
       * Returns all the bodies within the AABB.
       * @method aabbQuery
       * @param  {World} world
       * @param  {AABB} aabb
       * @param  {array} result An array to store resulting bodies in.
       * @return {array}
       */


      Broadphase.prototype.aabbQuery = function (world, aabb, result) {
        console.warn('.aabbQuery is not implemented in this Broadphase subclass.');
        return [];
      };
    }, {
      "../math/Quaternion": 29,
      "../math/Vec3": 31,
      "../objects/Body": 32,
      "../shapes/Plane": 43,
      "../shapes/Shape": 44
    }],
    6: [function (_dereq_, module, exports) {
      module.exports = GridBroadphase;

      var Broadphase = _dereq_('./Broadphase');

      var Vec3 = _dereq_('../math/Vec3');

      var Shape = _dereq_('../shapes/Shape');
      /**
       * Axis aligned uniform grid broadphase.
       * @class GridBroadphase
       * @constructor
       * @extends Broadphase
       * @todo Needs support for more than just planes and spheres.
       * @param {Vec3} aabbMin
       * @param {Vec3} aabbMax
       * @param {Number} nx Number of boxes along x
       * @param {Number} ny Number of boxes along y
       * @param {Number} nz Number of boxes along z
       */


      function GridBroadphase(aabbMin, aabbMax, nx, ny, nz) {
        Broadphase.apply(this);
        this.nx = nx || 10;
        this.ny = ny || 10;
        this.nz = nz || 10;
        this.aabbMin = aabbMin || new Vec3(100, 100, 100);
        this.aabbMax = aabbMax || new Vec3(-100, -100, -100);
        var nbins = this.nx * this.ny * this.nz;

        if (nbins <= 0) {
          throw "GridBroadphase: Each dimension's n must be >0";
        }

        this.bins = [];
        this.binLengths = []; //Rather than continually resizing arrays (thrashing the memory), just record length and allow them to grow

        this.bins.length = nbins;
        this.binLengths.length = nbins;

        for (var i = 0; i < nbins; i++) {
          this.bins[i] = [];
          this.binLengths[i] = 0;
        }
      }

      GridBroadphase.prototype = new Broadphase();
      GridBroadphase.prototype.constructor = GridBroadphase;
      /**
       * Get all the collision pairs in the physics world
       * @method collisionPairs
       * @param {World} world
       * @param {Array} pairs1
       * @param {Array} pairs2
       */

      var GridBroadphase_collisionPairs_d = new Vec3();
      var GridBroadphase_collisionPairs_binPos = new Vec3();

      GridBroadphase.prototype.collisionPairs = function (world, pairs1, pairs2) {
        var N = world.numObjects(),
            bodies = world.bodies;
        var max = this.aabbMax,
            min = this.aabbMin,
            nx = this.nx,
            ny = this.ny,
            nz = this.nz;
        var xstep = ny * nz;
        var ystep = nz;
        var zstep = 1;
        var xmax = max.x,
            ymax = max.y,
            zmax = max.z,
            xmin = min.x,
            ymin = min.y,
            zmin = min.z;
        var xmult = nx / (xmax - xmin),
            ymult = ny / (ymax - ymin),
            zmult = nz / (zmax - zmin);
        var binsizeX = (xmax - xmin) / nx,
            binsizeY = (ymax - ymin) / ny,
            binsizeZ = (zmax - zmin) / nz;
        var binRadius = Math.sqrt(binsizeX * binsizeX + binsizeY * binsizeY + binsizeZ * binsizeZ) * 0.5;
        var types = Shape.types;
        var SPHERE = types.SPHERE,
            PLANE = types.PLANE,
            BOX = types.BOX,
            COMPOUND = types.COMPOUND,
            CONVEXPOLYHEDRON = types.CONVEXPOLYHEDRON;
        var bins = this.bins,
            binLengths = this.binLengths,
            Nbins = this.bins.length; // Reset bins

        for (var i = 0; i !== Nbins; i++) {
          binLengths[i] = 0;
        }

        var ceil = Math.ceil;
        var min = Math.min;
        var max = Math.max;

        function addBoxToBins(x0, y0, z0, x1, y1, z1, bi) {
          var xoff0 = (x0 - xmin) * xmult | 0,
              yoff0 = (y0 - ymin) * ymult | 0,
              zoff0 = (z0 - zmin) * zmult | 0,
              xoff1 = ceil((x1 - xmin) * xmult),
              yoff1 = ceil((y1 - ymin) * ymult),
              zoff1 = ceil((z1 - zmin) * zmult);

          if (xoff0 < 0) {
            xoff0 = 0;
          } else if (xoff0 >= nx) {
            xoff0 = nx - 1;
          }

          if (yoff0 < 0) {
            yoff0 = 0;
          } else if (yoff0 >= ny) {
            yoff0 = ny - 1;
          }

          if (zoff0 < 0) {
            zoff0 = 0;
          } else if (zoff0 >= nz) {
            zoff0 = nz - 1;
          }

          if (xoff1 < 0) {
            xoff1 = 0;
          } else if (xoff1 >= nx) {
            xoff1 = nx - 1;
          }

          if (yoff1 < 0) {
            yoff1 = 0;
          } else if (yoff1 >= ny) {
            yoff1 = ny - 1;
          }

          if (zoff1 < 0) {
            zoff1 = 0;
          } else if (zoff1 >= nz) {
            zoff1 = nz - 1;
          }

          xoff0 *= xstep;
          yoff0 *= ystep;
          zoff0 *= zstep;
          xoff1 *= xstep;
          yoff1 *= ystep;
          zoff1 *= zstep;

          for (var xoff = xoff0; xoff <= xoff1; xoff += xstep) {
            for (var yoff = yoff0; yoff <= yoff1; yoff += ystep) {
              for (var zoff = zoff0; zoff <= zoff1; zoff += zstep) {
                var idx = xoff + yoff + zoff;
                bins[idx][binLengths[idx]++] = bi;
              }
            }
          }
        } // Put all bodies into the bins


        for (var i = 0; i !== N; i++) {
          var bi = bodies[i];
          var si = bi.shape;

          switch (si.type) {
            case SPHERE:
              // Put in bin
              // check if overlap with other bins
              var x = bi.position.x,
                  y = bi.position.y,
                  z = bi.position.z;
              var r = si.radius;
              addBoxToBins(x - r, y - r, z - r, x + r, y + r, z + r, bi);
              break;

            case PLANE:
              if (si.worldNormalNeedsUpdate) {
                si.computeWorldNormal(bi.quaternion);
              }

              var planeNormal = si.worldNormal; //Relative position from origin of plane object to the first bin
              //Incremented as we iterate through the bins

              var xreset = xmin + binsizeX * 0.5 - bi.position.x,
                  yreset = ymin + binsizeY * 0.5 - bi.position.y,
                  zreset = zmin + binsizeZ * 0.5 - bi.position.z;
              var d = GridBroadphase_collisionPairs_d;
              d.set(xreset, yreset, zreset);

              for (var xi = 0, xoff = 0; xi !== nx; xi++, xoff += xstep, d.y = yreset, d.x += binsizeX) {
                for (var yi = 0, yoff = 0; yi !== ny; yi++, yoff += ystep, d.z = zreset, d.y += binsizeY) {
                  for (var zi = 0, zoff = 0; zi !== nz; zi++, zoff += zstep, d.z += binsizeZ) {
                    if (d.dot(planeNormal) < binRadius) {
                      var idx = xoff + yoff + zoff;
                      bins[idx][binLengths[idx]++] = bi;
                    }
                  }
                }
              }

              break;

            default:
              if (bi.aabbNeedsUpdate) {
                bi.computeAABB();
              }

              addBoxToBins(bi.aabb.lowerBound.x, bi.aabb.lowerBound.y, bi.aabb.lowerBound.z, bi.aabb.upperBound.x, bi.aabb.upperBound.y, bi.aabb.upperBound.z, bi);
              break;
          }
        } // Check each bin


        for (var i = 0; i !== Nbins; i++) {
          var binLength = binLengths[i]; //Skip bins with no potential collisions

          if (binLength > 1) {
            var bin = bins[i]; // Do N^2 broadphase inside

            for (var xi = 0; xi !== binLength; xi++) {
              var bi = bin[xi];

              for (var yi = 0; yi !== xi; yi++) {
                var bj = bin[yi];

                if (this.needBroadphaseCollision(bi, bj)) {
                  this.intersectionTest(bi, bj, pairs1, pairs2);
                }
              }
            }
          }
        } //	for (var zi = 0, zoff=0; zi < nz; zi++, zoff+= zstep) {
        //		console.log("layer "+zi);
        //		for (var yi = 0, yoff=0; yi < ny; yi++, yoff += ystep) {
        //			var row = '';
        //			for (var xi = 0, xoff=0; xi < nx; xi++, xoff += xstep) {
        //				var idx = xoff + yoff + zoff;
        //				row += ' ' + binLengths[idx];
        //			}
        //			console.log(row);
        //		}
        //	}


        this.makePairsUnique(pairs1, pairs2);
      };
    }, {
      "../math/Vec3": 31,
      "../shapes/Shape": 44,
      "./Broadphase": 5
    }],
    7: [function (_dereq_, module, exports) {
      module.exports = NaiveBroadphase;

      var Broadphase = _dereq_('./Broadphase');

      var AABB = _dereq_('./AABB');
      /**
       * Naive broadphase implementation, used in lack of better ones.
       * @class NaiveBroadphase
       * @constructor
       * @description The naive broadphase looks at all possible pairs without restriction, therefore it has complexity N^2 (which is bad)
       * @extends Broadphase
       */


      function NaiveBroadphase() {
        Broadphase.apply(this);
      }

      NaiveBroadphase.prototype = new Broadphase();
      NaiveBroadphase.prototype.constructor = NaiveBroadphase;
      /**
       * Get all the collision pairs in the physics world
       * @method collisionPairs
       * @param {World} world
       * @param {Array} pairs1
       * @param {Array} pairs2
       */

      NaiveBroadphase.prototype.collisionPairs = function (world, pairs1, pairs2) {
        var bodies = world.bodies,
            n = bodies.length,
            i,
            j,
            bi,
            bj; // Naive N^2 ftw!

        for (i = 0; i !== n; i++) {
          for (j = 0; j !== i; j++) {
            bi = bodies[i];
            bj = bodies[j];

            if (!this.needBroadphaseCollision(bi, bj)) {
              continue;
            }

            this.intersectionTest(bi, bj, pairs1, pairs2);
          }
        }
      };

      var tmpAABB = new AABB();
      /**
       * Returns all the bodies within an AABB.
       * @method aabbQuery
       * @param  {World} world
       * @param  {AABB} aabb
       * @param {array} result An array to store resulting bodies in.
       * @return {array}
       */

      NaiveBroadphase.prototype.aabbQuery = function (world, aabb, result) {
        result = result || [];

        for (var i = 0; i < world.bodies.length; i++) {
          var b = world.bodies[i];

          if (b.aabbNeedsUpdate) {
            b.computeAABB();
          } // Ugly hack until Body gets aabb


          if (b.aabb.overlaps(aabb)) {
            result.push(b);
          }
        }

        return result;
      };
    }, {
      "./AABB": 3,
      "./Broadphase": 5
    }],
    8: [function (_dereq_, module, exports) {
      module.exports = ObjectCollisionMatrix;
      /**
       * Records what objects are colliding with each other
       * @class ObjectCollisionMatrix
       * @constructor
       */

      function ObjectCollisionMatrix() {
        /**
         * The matrix storage
         * @property matrix
         * @type {Object}
         */
        this.matrix = {};
      }
      /**
       * @method get
       * @param  {Number} i
       * @param  {Number} j
       * @return {Number}
       */


      ObjectCollisionMatrix.prototype.get = function (i, j) {
        i = i.id;
        j = j.id;

        if (j > i) {
          var temp = j;
          j = i;
          i = temp;
        }

        return i + '-' + j in this.matrix;
      };
      /**
       * @method set
       * @param  {Number} i
       * @param  {Number} j
       * @param {Number} value
       */


      ObjectCollisionMatrix.prototype.set = function (i, j, value) {
        i = i.id;
        j = j.id;

        if (j > i) {
          var temp = j;
          j = i;
          i = temp;
        }

        if (value) {
          this.matrix[i + '-' + j] = true;
        } else {
          delete this.matrix[i + '-' + j];
        }
      };
      /**
       * Empty the matrix
       * @method reset
       */


      ObjectCollisionMatrix.prototype.reset = function () {
        this.matrix = {};
      };
      /**
       * Set max number of objects
       * @method setNumObjects
       * @param {Number} n
       */


      ObjectCollisionMatrix.prototype.setNumObjects = function (n) {};
    }, {}],
    9: [function (_dereq_, module, exports) {
      module.exports = OverlapKeeper;
      /**
       * @class OverlapKeeper
       * @constructor
       */

      function OverlapKeeper() {
        this.current = [];
        this.previous = [];
      }

      OverlapKeeper.prototype.getKey = function (i, j) {
        if (j < i) {
          var temp = j;
          j = i;
          i = temp;
        }

        return i << 16 | j;
      };
      /**
       * @method set
       * @param {Number} i
       * @param {Number} j
       */


      OverlapKeeper.prototype.set = function (i, j) {
        // Insertion sort. This way the diff will have linear complexity.
        var key = this.getKey(i, j);
        var current = this.current;
        var index = 0;

        while (key > current[index]) {
          index++;
        }

        if (key === current[index]) {
          return; // Pair was already added
        }

        for (var j = current.length - 1; j >= index; j--) {
          current[j + 1] = current[j];
        }

        current[index] = key;
      };
      /**
       * @method tick
       */


      OverlapKeeper.prototype.tick = function () {
        var tmp = this.current;
        this.current = this.previous;
        this.previous = tmp;
        this.current.length = 0;
      };
      /**
       * @method reset
       */


      OverlapKeeper.prototype.reset = function () {
        this.previous.length = 0;
        this.current.length = 0;
      };

      function unpackAndPush(array, key) {
        array.push((key & 0xFFFF0000) >> 16, key & 0x0000FFFF);
      }
      /**
       * @method getDiff
       * @param  {array} additions
       * @param  {array} removals
       */


      OverlapKeeper.prototype.getDiff = function (additions, removals) {
        var a = this.current;
        var b = this.previous;
        var al = a.length;
        var bl = b.length;
        var j = 0;

        for (var i = 0; i < al; i++) {
          var found = false;
          var keyA = a[i];

          while (keyA > b[j]) {
            j++;
          }

          found = keyA === b[j];

          if (!found) {
            unpackAndPush(additions, keyA);
          }
        }

        j = 0;

        for (var i = 0; i < bl; i++) {
          var found = false;
          var keyB = b[i];

          while (keyB > a[j]) {
            j++;
          }

          found = a[j] === keyB;

          if (!found) {
            unpackAndPush(removals, keyB);
          }
        }
      };

      OverlapKeeper.prototype.copy = function (overlapKeeper) {
        this.current.length = 0;
        this.previous.length = 0;
        this.current = overlapKeeper.current.slice();
        this.previous = overlapKeeper.previous.slice();
      };
    }, {}],
    10: [function (_dereq_, module, exports) {
      module.exports = Ray;

      var Vec3 = _dereq_('../math/Vec3');

      var Quaternion = _dereq_('../math/Quaternion');

      var Transform = _dereq_('../math/Transform');

      var ConvexPolyhedron = _dereq_('../shapes/ConvexPolyhedron');

      var Box = _dereq_('../shapes/Box');

      var RaycastResult = _dereq_('../collision/RaycastResult');

      var Shape = _dereq_('../shapes/Shape');

      var AABB = _dereq_('../collision/AABB');
      /**
       * A line in 3D space that intersects bodies and return points.
       * @class Ray
       * @constructor
       * @param {Vec3} from
       * @param {Vec3} to
       */


      function Ray(from, to) {
        /**
         * @property {Vec3} from
         */
        this.from = from ? from.clone() : new Vec3();
        /**
         * @property {Vec3} to
         */

        this.to = to ? to.clone() : new Vec3();
        /**
         * @private
         * @property {Vec3} _direction
         */

        this._direction = new Vec3();
        /**
         * The precision of the ray. Used when checking parallelity etc.
         * @property {Number} precision
         */

        this.precision = 0.0001;
        /**
         * Set to true if you want the Ray to take .collisionResponse flags into account on bodies and shapes.
         * @property {Boolean} checkCollisionResponse
         */

        this.checkCollisionResponse = true;
        /**
         * If set to true, the ray skips any hits with normal.dot(rayDirection) < 0.
         * @property {Boolean} skipBackfaces
         */

        this.skipBackfaces = false;
        /**
         * @property {number} collisionFilterMask
         * @default -1
         */

        this.collisionFilterMask = -1;
        /**
         * @property {number} collisionFilterGroup
         * @default -1
         */

        this.collisionFilterGroup = -1;
        /**
         * The intersection mode. Should be Ray.ANY, Ray.ALL or Ray.CLOSEST.
         * @property {number} mode
         */

        this.mode = Ray.ANY;
        /**
         * Current result object.
         * @property {RaycastResult} result
         */

        this.result = new RaycastResult();
        /**
         * Will be set to true during intersectWorld() if the ray hit anything.
         * @property {Boolean} hasHit
         */

        this.hasHit = false;
        /**
         * Current, user-provided result callback. Will be used if mode is Ray.ALL.
         * @property {Function} callback
         */

        this.callback = function (result) {};
      }

      Ray.prototype.constructor = Ray;
      Ray.CLOSEST = 1;
      Ray.ANY = 2;
      Ray.ALL = 4;
      var tmpAABB = new AABB();
      var tmpArray = [];
      /**
       * Do itersection against all bodies in the given World.
       * @method intersectWorld
       * @param  {World} world
       * @param  {object} options
       * @return {Boolean} True if the ray hit anything, otherwise false.
       */

      Ray.prototype.intersectWorld = function (world, options) {
        this.mode = options.mode || Ray.ANY;
        this.result = options.result || new RaycastResult();
        this.skipBackfaces = !!options.skipBackfaces;
        this.collisionFilterMask = typeof options.collisionFilterMask !== 'undefined' ? options.collisionFilterMask : -1;
        this.collisionFilterGroup = typeof options.collisionFilterGroup !== 'undefined' ? options.collisionFilterGroup : -1;

        if (options.from) {
          this.from.copy(options.from);
        }

        if (options.to) {
          this.to.copy(options.to);
        }

        this.callback = options.callback || function () {};

        this.hasHit = false;
        this.result.reset();

        this._updateDirection();

        this.getAABB(tmpAABB);
        tmpArray.length = 0;
        world.broadphase.aabbQuery(world, tmpAABB, tmpArray);
        this.intersectBodies(tmpArray);
        return this.hasHit;
      };

      var v1 = new Vec3(),
          v2 = new Vec3();
      /*
       * As per "Barycentric Technique" as named here http://www.blackpawn.com/texts/pointinpoly/default.html But without the division
       */

      Ray.pointInTriangle = pointInTriangle;

      function pointInTriangle(p, a, b, c) {
        c.vsub(a, v0);
        b.vsub(a, v1);
        p.vsub(a, v2);
        var dot00 = v0.dot(v0);
        var dot01 = v0.dot(v1);
        var dot02 = v0.dot(v2);
        var dot11 = v1.dot(v1);
        var dot12 = v1.dot(v2);
        var u, v;
        return (u = dot11 * dot02 - dot01 * dot12) >= 0 && (v = dot00 * dot12 - dot01 * dot02) >= 0 && u + v < dot00 * dot11 - dot01 * dot01;
      }
      /**
       * Shoot a ray at a body, get back information about the hit.
       * @method intersectBody
       * @private
       * @param {Body} body
       * @param {RaycastResult} [result] Deprecated - set the result property of the Ray instead.
       */


      var intersectBody_xi = new Vec3();
      var intersectBody_qi = new Quaternion();

      Ray.prototype.intersectBody = function (body, result) {
        if (result) {
          this.result = result;

          this._updateDirection();
        }

        var checkCollisionResponse = this.checkCollisionResponse;

        if (checkCollisionResponse && !body.collisionResponse) {
          return;
        }

        if ((this.collisionFilterGroup & body.collisionFilterMask) === 0 || (body.collisionFilterGroup & this.collisionFilterMask) === 0) {
          return;
        }

        var xi = intersectBody_xi;
        var qi = intersectBody_qi;

        for (var i = 0, N = body.shapes.length; i < N; i++) {
          var shape = body.shapes[i];

          if (checkCollisionResponse && !shape.collisionResponse) {
            continue; // Skip
          }

          body.quaternion.mult(body.shapeOrientations[i], qi);
          body.quaternion.vmult(body.shapeOffsets[i], xi);
          xi.vadd(body.position, xi);
          this.intersectShape(shape, qi, xi, body);

          if (this.result._shouldStop) {
            break;
          }
        }
      };
      /**
       * @method intersectBodies
       * @param {Array} bodies An array of Body objects.
       * @param {RaycastResult} [result] Deprecated
       */


      Ray.prototype.intersectBodies = function (bodies, result) {
        if (result) {
          this.result = result;

          this._updateDirection();
        }

        for (var i = 0, l = bodies.length; !this.result._shouldStop && i < l; i++) {
          this.intersectBody(bodies[i]);
        }
      };
      /**
       * Updates the _direction vector.
       * @private
       * @method _updateDirection
       */


      Ray.prototype._updateDirection = function () {
        this.to.vsub(this.from, this._direction);

        this._direction.normalize();
      };
      /**
       * @method intersectShape
       * @private
       * @param {Shape} shape
       * @param {Quaternion} quat
       * @param {Vec3} position
       * @param {Body} body
       */


      Ray.prototype.intersectShape = function (shape, quat, position, body) {
        var from = this.from; // Checking boundingSphere

        var distance = distanceFromIntersection(from, this._direction, position);

        if (distance > shape.boundingSphereRadius) {
          return;
        }

        var intersectMethod = this[shape.type];

        if (intersectMethod) {
          intersectMethod.call(this, shape, quat, position, body, shape);
        }
      };

      var vector = new Vec3();
      var normal = new Vec3();
      var intersectPoint = new Vec3();
      var a = new Vec3();
      var b = new Vec3();
      var c = new Vec3();
      var d = new Vec3();
      var tmpRaycastResult = new RaycastResult();
      /**
       * @method intersectBox
       * @private
       * @param  {Shape} shape
       * @param  {Quaternion} quat
       * @param  {Vec3} position
       * @param  {Body} body
       */

      Ray.prototype.intersectBox = function (shape, quat, position, body, reportedShape) {
        return this.intersectConvex(shape.convexPolyhedronRepresentation, quat, position, body, reportedShape);
      };

      Ray.prototype[Shape.types.BOX] = Ray.prototype.intersectBox;
      /**
       * @method intersectPlane
       * @private
       * @param  {Shape} shape
       * @param  {Quaternion} quat
       * @param  {Vec3} position
       * @param  {Body} body
       */

      Ray.prototype.intersectPlane = function (shape, quat, position, body, reportedShape) {
        var from = this.from;
        var to = this.to;
        var direction = this._direction; // Get plane normal

        var worldNormal = new Vec3(0, 0, 1);
        quat.vmult(worldNormal, worldNormal);
        var len = new Vec3();
        from.vsub(position, len);
        var planeToFrom = len.dot(worldNormal);
        to.vsub(position, len);
        var planeToTo = len.dot(worldNormal);

        if (planeToFrom * planeToTo > 0) {
          // "from" and "to" are on the same side of the plane... bail out
          return;
        }

        if (from.distanceTo(to) < planeToFrom) {
          return;
        }

        var n_dot_dir = worldNormal.dot(direction);

        if (Math.abs(n_dot_dir) < this.precision) {
          // No intersection
          return;
        }

        var planePointToFrom = new Vec3();
        var dir_scaled_with_t = new Vec3();
        var hitPointWorld = new Vec3();
        from.vsub(position, planePointToFrom);
        var t = -worldNormal.dot(planePointToFrom) / n_dot_dir;
        direction.scale(t, dir_scaled_with_t);
        from.vadd(dir_scaled_with_t, hitPointWorld);
        this.reportIntersection(worldNormal, hitPointWorld, reportedShape, body, -1);
      };

      Ray.prototype[Shape.types.PLANE] = Ray.prototype.intersectPlane;
      /**
       * Get the world AABB of the ray.
       * @method getAABB
       * @param  {AABB} aabb
       */

      Ray.prototype.getAABB = function (result) {
        var to = this.to;
        var from = this.from;
        result.lowerBound.x = Math.min(to.x, from.x);
        result.lowerBound.y = Math.min(to.y, from.y);
        result.lowerBound.z = Math.min(to.z, from.z);
        result.upperBound.x = Math.max(to.x, from.x);
        result.upperBound.y = Math.max(to.y, from.y);
        result.upperBound.z = Math.max(to.z, from.z);
      };

      var intersectConvexOptions = {
        faceList: [0]
      };
      var worldPillarOffset = new Vec3();
      var intersectHeightfield_localRay = new Ray();
      var intersectHeightfield_index = [];
      var intersectHeightfield_minMax = [];
      /**
       * @method intersectHeightfield
       * @private
       * @param  {Shape} shape
       * @param  {Quaternion} quat
       * @param  {Vec3} position
       * @param  {Body} body
       */

      Ray.prototype.intersectHeightfield = function (shape, quat, position, body, reportedShape) {
        var data = shape.data,
            w = shape.elementSize; // Convert the ray to local heightfield coordinates

        var localRay = intersectHeightfield_localRay; //new Ray(this.from, this.to);

        localRay.from.copy(this.from);
        localRay.to.copy(this.to);
        Transform.pointToLocalFrame(position, quat, localRay.from, localRay.from);
        Transform.pointToLocalFrame(position, quat, localRay.to, localRay.to);

        localRay._updateDirection(); // Get the index of the data points to test against


        var index = intersectHeightfield_index;
        var iMinX, iMinY, iMaxX, iMaxY; // Set to max

        iMinX = iMinY = 0;
        iMaxX = iMaxY = shape.data.length - 1;
        var aabb = new AABB();
        localRay.getAABB(aabb);
        shape.getIndexOfPosition(aabb.lowerBound.x, aabb.lowerBound.y, index, true);
        iMinX = Math.max(iMinX, index[0]);
        iMinY = Math.max(iMinY, index[1]);
        shape.getIndexOfPosition(aabb.upperBound.x, aabb.upperBound.y, index, true);
        iMaxX = Math.min(iMaxX, index[0] + 1);
        iMaxY = Math.min(iMaxY, index[1] + 1);

        for (var i = iMinX; i < iMaxX; i++) {
          for (var j = iMinY; j < iMaxY; j++) {
            if (this.result._shouldStop) {
              return;
            }

            shape.getAabbAtIndex(i, j, aabb);

            if (!aabb.overlapsRay(localRay)) {
              continue;
            } // Lower triangle


            shape.getConvexTrianglePillar(i, j, false);
            Transform.pointToWorldFrame(position, quat, shape.pillarOffset, worldPillarOffset);
            this.intersectConvex(shape.pillarConvex, quat, worldPillarOffset, body, reportedShape, intersectConvexOptions);

            if (this.result._shouldStop) {
              return;
            } // Upper triangle


            shape.getConvexTrianglePillar(i, j, true);
            Transform.pointToWorldFrame(position, quat, shape.pillarOffset, worldPillarOffset);
            this.intersectConvex(shape.pillarConvex, quat, worldPillarOffset, body, reportedShape, intersectConvexOptions);
          }
        }
      };

      Ray.prototype[Shape.types.HEIGHTFIELD] = Ray.prototype.intersectHeightfield;
      var Ray_intersectSphere_intersectionPoint = new Vec3();
      var Ray_intersectSphere_normal = new Vec3();
      /**
       * @method intersectSphere
       * @private
       * @param  {Shape} shape
       * @param  {Quaternion} quat
       * @param  {Vec3} position
       * @param  {Body} body
       */

      Ray.prototype.intersectSphere = function (shape, quat, position, body, reportedShape) {
        var from = this.from,
            to = this.to,
            r = shape.radius;
        var a = Math.pow(to.x - from.x, 2) + Math.pow(to.y - from.y, 2) + Math.pow(to.z - from.z, 2);
        var b = 2 * ((to.x - from.x) * (from.x - position.x) + (to.y - from.y) * (from.y - position.y) + (to.z - from.z) * (from.z - position.z));
        var c = Math.pow(from.x - position.x, 2) + Math.pow(from.y - position.y, 2) + Math.pow(from.z - position.z, 2) - Math.pow(r, 2);
        var delta = Math.pow(b, 2) - 4 * a * c;
        var intersectionPoint = Ray_intersectSphere_intersectionPoint;
        var normal = Ray_intersectSphere_normal;

        if (delta < 0) {
          // No intersection
          return;
        } else if (delta === 0) {
          // single intersection point
          from.lerp(to, delta, intersectionPoint);
          intersectionPoint.vsub(position, normal);
          normal.normalize();
          this.reportIntersection(normal, intersectionPoint, reportedShape, body, -1);
        } else {
          var d1 = (-b - Math.sqrt(delta)) / (2 * a);
          var d2 = (-b + Math.sqrt(delta)) / (2 * a);

          if (d1 >= 0 && d1 <= 1) {
            from.lerp(to, d1, intersectionPoint);
            intersectionPoint.vsub(position, normal);
            normal.normalize();
            this.reportIntersection(normal, intersectionPoint, reportedShape, body, -1);
          }

          if (this.result._shouldStop) {
            return;
          }

          if (d2 >= 0 && d2 <= 1) {
            from.lerp(to, d2, intersectionPoint);
            intersectionPoint.vsub(position, normal);
            normal.normalize();
            this.reportIntersection(normal, intersectionPoint, reportedShape, body, -1);
          }
        }
      };

      Ray.prototype[Shape.types.SPHERE] = Ray.prototype.intersectSphere;
      var intersectConvex_normal = new Vec3();
      var intersectConvex_minDistNormal = new Vec3();
      var intersectConvex_minDistIntersect = new Vec3();
      var intersectConvex_vector = new Vec3();
      /**
       * @method intersectConvex
       * @private
       * @param  {Shape} shape
       * @param  {Quaternion} quat
       * @param  {Vec3} position
       * @param  {Body} body
       * @param {object} [options]
       * @param {array} [options.faceList]
       */

      Ray.prototype.intersectConvex = function intersectConvex(shape, quat, position, body, reportedShape, options) {
        var minDistNormal = intersectConvex_minDistNormal;
        var normal = intersectConvex_normal;
        var vector = intersectConvex_vector;
        var minDistIntersect = intersectConvex_minDistIntersect;
        var faceList = options && options.faceList || null; // Checking faces

        var faces = shape.faces,
            vertices = shape.vertices,
            normals = shape.faceNormals;
        var direction = this._direction;
        var from = this.from;
        var to = this.to;
        var fromToDistance = from.distanceTo(to);
        var minDist = -1;
        var Nfaces = faceList ? faceList.length : faces.length;
        var result = this.result;

        for (var j = 0; !result._shouldStop && j < Nfaces; j++) {
          var fi = faceList ? faceList[j] : j;
          var face = faces[fi];
          var faceNormal = normals[fi];
          var q = quat;
          var x = position; // determine if ray intersects the plane of the face
          // note: this works regardless of the direction of the face normal
          // Get plane point in world coordinates...

          vector.copy(vertices[face[0]]);
          q.vmult(vector, vector);
          vector.vadd(x, vector); // ...but make it relative to the ray from. We'll fix this later.

          vector.vsub(from, vector); // Get plane normal

          q.vmult(faceNormal, normal); // If this dot product is negative, we have something interesting

          var dot = direction.dot(normal); // Bail out if ray and plane are parallel

          if (Math.abs(dot) < this.precision) {
            continue;
          } // calc distance to plane


          var scalar = normal.dot(vector) / dot; // if negative distance, then plane is behind ray

          if (scalar < 0) {
            continue;
          } // if (dot < 0) {
          // Intersection point is from + direction * scalar


          direction.mult(scalar, intersectPoint);
          intersectPoint.vadd(from, intersectPoint); // a is the point we compare points b and c with.

          a.copy(vertices[face[0]]);
          q.vmult(a, a);
          x.vadd(a, a);

          for (var i = 1; !result._shouldStop && i < face.length - 1; i++) {
            // Transform 3 vertices to world coords
            b.copy(vertices[face[i]]);
            c.copy(vertices[face[i + 1]]);
            q.vmult(b, b);
            q.vmult(c, c);
            x.vadd(b, b);
            x.vadd(c, c);
            var distance = intersectPoint.distanceTo(from);

            if (!(pointInTriangle(intersectPoint, a, b, c) || pointInTriangle(intersectPoint, b, a, c)) || distance > fromToDistance) {
              continue;
            }

            this.reportIntersection(normal, intersectPoint, reportedShape, body, fi);
          } // }

        }
      };

      Ray.prototype[Shape.types.CONVEXPOLYHEDRON] = Ray.prototype.intersectConvex;
      var intersectTrimesh_normal = new Vec3();
      var intersectTrimesh_localDirection = new Vec3();
      var intersectTrimesh_localFrom = new Vec3();
      var intersectTrimesh_localTo = new Vec3();
      var intersectTrimesh_worldNormal = new Vec3();
      var intersectTrimesh_worldIntersectPoint = new Vec3();
      var intersectTrimesh_localAABB = new AABB();
      var intersectTrimesh_triangles = [];
      var intersectTrimesh_treeTransform = new Transform();
      /**
       * @method intersectTrimesh
       * @private
       * @param  {Shape} shape
       * @param  {Quaternion} quat
       * @param  {Vec3} position
       * @param  {Body} body
       * @param {object} [options]
       * @todo Optimize by transforming the world to local space first.
       * @todo Use Octree lookup
       */

      Ray.prototype.intersectTrimesh = function intersectTrimesh(mesh, quat, position, body, reportedShape, options) {
        var normal = intersectTrimesh_normal;
        var triangles = intersectTrimesh_triangles;
        var treeTransform = intersectTrimesh_treeTransform;
        var minDistNormal = intersectConvex_minDistNormal;
        var vector = intersectConvex_vector;
        var minDistIntersect = intersectConvex_minDistIntersect;
        var localAABB = intersectTrimesh_localAABB;
        var localDirection = intersectTrimesh_localDirection;
        var localFrom = intersectTrimesh_localFrom;
        var localTo = intersectTrimesh_localTo;
        var worldIntersectPoint = intersectTrimesh_worldIntersectPoint;
        var worldNormal = intersectTrimesh_worldNormal;
        var faceList = options && options.faceList || null; // Checking faces

        var indices = mesh.indices,
            vertices = mesh.vertices,
            normals = mesh.faceNormals;
        var from = this.from;
        var to = this.to;
        var direction = this._direction;
        var minDist = -1;
        treeTransform.position.copy(position);
        treeTransform.quaternion.copy(quat); // Transform ray to local space!

        Transform.vectorToLocalFrame(position, quat, direction, localDirection);
        Transform.pointToLocalFrame(position, quat, from, localFrom);
        Transform.pointToLocalFrame(position, quat, to, localTo);
        localTo.x *= mesh.scale.x;
        localTo.y *= mesh.scale.y;
        localTo.z *= mesh.scale.z;
        localFrom.x *= mesh.scale.x;
        localFrom.y *= mesh.scale.y;
        localFrom.z *= mesh.scale.z;
        localTo.vsub(localFrom, localDirection);
        localDirection.normalize();
        var fromToDistanceSquared = localFrom.distanceSquared(localTo);
        mesh.tree.rayQuery(this, treeTransform, triangles);

        for (var i = 0, N = triangles.length; !this.result._shouldStop && i !== N; i++) {
          var trianglesIndex = triangles[i];
          mesh.getNormal(trianglesIndex, normal); // determine if ray intersects the plane of the face
          // note: this works regardless of the direction of the face normal
          // Get plane point in world coordinates...

          mesh.getVertex(indices[trianglesIndex * 3], a); // ...but make it relative to the ray from. We'll fix this later.

          a.vsub(localFrom, vector); // If this dot product is negative, we have something interesting

          var dot = localDirection.dot(normal); // Bail out if ray and plane are parallel
          // if (Math.abs( dot ) < this.precision){
          //     continue;
          // }
          // calc distance to plane

          var scalar = normal.dot(vector) / dot; // if negative distance, then plane is behind ray

          if (scalar < 0) {
            continue;
          } // Intersection point is from + direction * scalar


          localDirection.scale(scalar, intersectPoint);
          intersectPoint.vadd(localFrom, intersectPoint); // Get triangle vertices

          mesh.getVertex(indices[trianglesIndex * 3 + 1], b);
          mesh.getVertex(indices[trianglesIndex * 3 + 2], c);
          var squaredDistance = intersectPoint.distanceSquared(localFrom);

          if (!(pointInTriangle(intersectPoint, b, a, c) || pointInTriangle(intersectPoint, a, b, c)) || squaredDistance > fromToDistanceSquared) {
            continue;
          } // transform intersectpoint and normal to world


          Transform.vectorToWorldFrame(quat, normal, worldNormal);
          Transform.pointToWorldFrame(position, quat, intersectPoint, worldIntersectPoint);
          this.reportIntersection(worldNormal, worldIntersectPoint, reportedShape, body, trianglesIndex);
        }

        triangles.length = 0;
      };

      Ray.prototype[Shape.types.TRIMESH] = Ray.prototype.intersectTrimesh;
      /**
       * @method reportIntersection
       * @private
       * @param  {Vec3} normal
       * @param  {Vec3} hitPointWorld
       * @param  {Shape} shape
       * @param  {Body} body
       * @return {boolean} True if the intersections should continue
       */

      Ray.prototype.reportIntersection = function (normal, hitPointWorld, shape, body, hitFaceIndex) {
        var from = this.from;
        var to = this.to;
        var distance = from.distanceTo(hitPointWorld);
        var result = this.result; // Skip back faces?

        if (this.skipBackfaces && normal.dot(this._direction) > 0) {
          return;
        }

        result.hitFaceIndex = typeof hitFaceIndex !== 'undefined' ? hitFaceIndex : -1;

        switch (this.mode) {
          case Ray.ALL:
            this.hasHit = true;
            result.set(from, to, normal, hitPointWorld, shape, body, distance);
            result.hasHit = true;
            this.callback(result);
            break;

          case Ray.CLOSEST:
            // Store if closer than current closest
            if (distance < result.distance || !result.hasHit) {
              this.hasHit = true;
              result.hasHit = true;
              result.set(from, to, normal, hitPointWorld, shape, body, distance);
            }

            break;

          case Ray.ANY:
            // Report and stop.
            this.hasHit = true;
            result.hasHit = true;
            result.set(from, to, normal, hitPointWorld, shape, body, distance);
            result._shouldStop = true;
            break;
        }
      };

      var v0 = new Vec3(),
          intersect = new Vec3();

      function distanceFromIntersection(from, direction, position) {
        // v0 is vector from from to position
        position.vsub(from, v0);
        var dot = v0.dot(direction); // intersect = direction*dot + from

        direction.mult(dot, intersect);
        intersect.vadd(from, intersect);
        var distance = position.distanceTo(intersect);
        return distance;
      }
    }, {
      "../collision/AABB": 3,
      "../collision/RaycastResult": 11,
      "../math/Quaternion": 29,
      "../math/Transform": 30,
      "../math/Vec3": 31,
      "../shapes/Box": 38,
      "../shapes/ConvexPolyhedron": 39,
      "../shapes/Shape": 44
    }],
    11: [function (_dereq_, module, exports) {
      var Vec3 = _dereq_('../math/Vec3');

      module.exports = RaycastResult;
      /**
       * Storage for Ray casting data.
       * @class RaycastResult
       * @constructor
       */

      function RaycastResult() {
        /**
         * @property {Vec3} rayFromWorld
         */
        this.rayFromWorld = new Vec3();
        /**
         * @property {Vec3} rayToWorld
         */

        this.rayToWorld = new Vec3();
        /**
         * @property {Vec3} hitNormalWorld
         */

        this.hitNormalWorld = new Vec3();
        /**
         * @property {Vec3} hitPointWorld
         */

        this.hitPointWorld = new Vec3();
        /**
         * @property {boolean} hasHit
         */

        this.hasHit = false;
        /**
         * The hit shape, or null.
         * @property {Shape} shape
         */

        this.shape = null;
        /**
         * The hit body, or null.
         * @property {Body} body
         */

        this.body = null;
        /**
         * The index of the hit triangle, if the hit shape was a trimesh.
         * @property {number} hitFaceIndex
         * @default -1
         */

        this.hitFaceIndex = -1;
        /**
         * Distance to the hit. Will be set to -1 if there was no hit.
         * @property {number} distance
         * @default -1
         */

        this.distance = -1;
        /**
         * If the ray should stop traversing the bodies.
         * @private
         * @property {Boolean} _shouldStop
         * @default false
         */

        this._shouldStop = false;
      }
      /**
       * Reset all result data.
       * @method reset
       */


      RaycastResult.prototype.reset = function () {
        this.rayFromWorld.setZero();
        this.rayToWorld.setZero();
        this.hitNormalWorld.setZero();
        this.hitPointWorld.setZero();
        this.hasHit = false;
        this.shape = null;
        this.body = null;
        this.hitFaceIndex = -1;
        this.distance = -1;
        this._shouldStop = false;
      };
      /**
       * @method abort
       */


      RaycastResult.prototype.abort = function () {
        this._shouldStop = true;
      };
      /**
       * @method set
       * @param {Vec3} rayFromWorld
       * @param {Vec3} rayToWorld
       * @param {Vec3} hitNormalWorld
       * @param {Vec3} hitPointWorld
       * @param {Shape} shape
       * @param {Body} body
       * @param {number} distance
       */


      RaycastResult.prototype.set = function (rayFromWorld, rayToWorld, hitNormalWorld, hitPointWorld, shape, body, distance) {
        this.rayFromWorld.copy(rayFromWorld);
        this.rayToWorld.copy(rayToWorld);
        this.hitNormalWorld.copy(hitNormalWorld);
        this.hitPointWorld.copy(hitPointWorld);
        this.shape = shape;
        this.body = body;
        this.distance = distance;
      };
    }, {
      "../math/Vec3": 31
    }],
    12: [function (_dereq_, module, exports) {
      var Shape = _dereq_('../shapes/Shape');

      var Broadphase = _dereq_('../collision/Broadphase');

      module.exports = SAPBroadphase;
      /**
       * Sweep and prune broadphase along one axis.
       *
       * @class SAPBroadphase
       * @constructor
       * @param {World} [world]
       * @extends Broadphase
       */

      function SAPBroadphase(world) {
        Broadphase.apply(this);
        /**
         * List of bodies currently in the broadphase.
         * @property axisList
         * @type {Array}
         */

        this.axisList = [];
        /**
         * The world to search in.
         * @property world
         * @type {World}
         */

        this.world = null;
        /**
         * Axis to sort the bodies along. Set to 0 for x axis, and 1 for y axis. For best performance, choose an axis that the bodies are spread out more on.
         * @property axisIndex
         * @type {Number}
         */

        this.axisIndex = 0;
        var axisList = this.axisList;

        this._addBodyHandler = function (e) {
          axisList.push(e.body);
        };

        this._removeBodyHandler = function (e) {
          var idx = axisList.indexOf(e.body);

          if (idx !== -1) {
            axisList.splice(idx, 1);
          }
        };

        if (world) {
          this.setWorld(world);
        }
      }

      SAPBroadphase.prototype = new Broadphase();
      /**
       * Change the world
       * @method setWorld
       * @param  {World} world
       */

      SAPBroadphase.prototype.setWorld = function (world) {
        // Clear the old axis array
        this.axisList.length = 0; // Add all bodies from the new world

        for (var i = 0; i < world.bodies.length; i++) {
          this.axisList.push(world.bodies[i]);
        } // Remove old handlers, if any


        world.removeEventListener("addBody", this._addBodyHandler);
        world.removeEventListener("removeBody", this._removeBodyHandler); // Add handlers to update the list of bodies.

        world.addEventListener("addBody", this._addBodyHandler);
        world.addEventListener("removeBody", this._removeBodyHandler);
        this.world = world;
        this.dirty = true;
      };
      /**
       * @static
       * @method insertionSortX
       * @param  {Array} a
       * @return {Array}
       */


      SAPBroadphase.insertionSortX = function (a) {
        for (var i = 1, l = a.length; i < l; i++) {
          var v = a[i];

          for (var j = i - 1; j >= 0; j--) {
            if (a[j].aabb.lowerBound.x <= v.aabb.lowerBound.x) {
              break;
            }

            a[j + 1] = a[j];
          }

          a[j + 1] = v;
        }

        return a;
      };
      /**
       * @static
       * @method insertionSortY
       * @param  {Array} a
       * @return {Array}
       */


      SAPBroadphase.insertionSortY = function (a) {
        for (var i = 1, l = a.length; i < l; i++) {
          var v = a[i];

          for (var j = i - 1; j >= 0; j--) {
            if (a[j].aabb.lowerBound.y <= v.aabb.lowerBound.y) {
              break;
            }

            a[j + 1] = a[j];
          }

          a[j + 1] = v;
        }

        return a;
      };
      /**
       * @static
       * @method insertionSortZ
       * @param  {Array} a
       * @return {Array}
       */


      SAPBroadphase.insertionSortZ = function (a) {
        for (var i = 1, l = a.length; i < l; i++) {
          var v = a[i];

          for (var j = i - 1; j >= 0; j--) {
            if (a[j].aabb.lowerBound.z <= v.aabb.lowerBound.z) {
              break;
            }

            a[j + 1] = a[j];
          }

          a[j + 1] = v;
        }

        return a;
      };
      /**
       * Collect all collision pairs
       * @method collisionPairs
       * @param  {World} world
       * @param  {Array} p1
       * @param  {Array} p2
       */


      SAPBroadphase.prototype.collisionPairs = function (world, p1, p2) {
        var bodies = this.axisList,
            N = bodies.length,
            axisIndex = this.axisIndex,
            i,
            j;

        if (this.dirty) {
          this.sortList();
          this.dirty = false;
        } // Look through the list


        for (i = 0; i !== N; i++) {
          var bi = bodies[i];

          for (j = i + 1; j < N; j++) {
            var bj = bodies[j];

            if (!this.needBroadphaseCollision(bi, bj)) {
              continue;
            }

            if (!SAPBroadphase.checkBounds(bi, bj, axisIndex)) {
              break;
            }

            this.intersectionTest(bi, bj, p1, p2);
          }
        }
      };

      SAPBroadphase.prototype.sortList = function () {
        var axisList = this.axisList;
        var axisIndex = this.axisIndex;
        var N = axisList.length; // Update AABBs

        for (var i = 0; i !== N; i++) {
          var bi = axisList[i];

          if (bi.aabbNeedsUpdate) {
            bi.computeAABB();
          }
        } // Sort the list


        if (axisIndex === 0) {
          SAPBroadphase.insertionSortX(axisList);
        } else if (axisIndex === 1) {
          SAPBroadphase.insertionSortY(axisList);
        } else if (axisIndex === 2) {
          SAPBroadphase.insertionSortZ(axisList);
        }
      };
      /**
       * Check if the bounds of two bodies overlap, along the given SAP axis.
       * @static
       * @method checkBounds
       * @param  {Body} bi
       * @param  {Body} bj
       * @param  {Number} axisIndex
       * @return {Boolean}
       */


      SAPBroadphase.checkBounds = function (bi, bj, axisIndex) {
        var biPos;
        var bjPos;

        if (axisIndex === 0) {
          biPos = bi.position.x;
          bjPos = bj.position.x;
        } else if (axisIndex === 1) {
          biPos = bi.position.y;
          bjPos = bj.position.y;
        } else if (axisIndex === 2) {
          biPos = bi.position.z;
          bjPos = bj.position.z;
        }

        var ri = bi.boundingRadius,
            rj = bj.boundingRadius,
            boundA1 = biPos - ri,
            boundA2 = biPos + ri,
            boundB1 = bjPos - rj,
            boundB2 = bjPos + rj;
        return boundB1 < boundA2;
      };
      /**
       * Computes the variance of the body positions and estimates the best
       * axis to use. Will automatically set property .axisIndex.
       * @method autoDetectAxis
       */


      SAPBroadphase.prototype.autoDetectAxis = function () {
        var sumX = 0,
            sumX2 = 0,
            sumY = 0,
            sumY2 = 0,
            sumZ = 0,
            sumZ2 = 0,
            bodies = this.axisList,
            N = bodies.length,
            invN = 1 / N;

        for (var i = 0; i !== N; i++) {
          var b = bodies[i];
          var centerX = b.position.x;
          sumX += centerX;
          sumX2 += centerX * centerX;
          var centerY = b.position.y;
          sumY += centerY;
          sumY2 += centerY * centerY;
          var centerZ = b.position.z;
          sumZ += centerZ;
          sumZ2 += centerZ * centerZ;
        }

        var varianceX = sumX2 - sumX * sumX * invN,
            varianceY = sumY2 - sumY * sumY * invN,
            varianceZ = sumZ2 - sumZ * sumZ * invN;

        if (varianceX > varianceY) {
          if (varianceX > varianceZ) {
            this.axisIndex = 0;
          } else {
            this.axisIndex = 2;
          }
        } else if (varianceY > varianceZ) {
          this.axisIndex = 1;
        } else {
          this.axisIndex = 2;
        }
      };
      /**
       * Returns all the bodies within an AABB.
       * @method aabbQuery
       * @param  {World} world
       * @param  {AABB} aabb
       * @param {array} result An array to store resulting bodies in.
       * @return {array}
       */


      SAPBroadphase.prototype.aabbQuery = function (world, aabb, result) {
        result = result || [];

        if (this.dirty) {
          this.sortList();
          this.dirty = false;
        }

        var axisIndex = this.axisIndex,
            axis = 'x';

        if (axisIndex === 1) {
          axis = 'y';
        }

        if (axisIndex === 2) {
          axis = 'z';
        }

        var axisList = this.axisList;
        var lower = aabb.lowerBound[axis];
        var upper = aabb.upperBound[axis];

        for (var i = 0; i < axisList.length; i++) {
          var b = axisList[i];

          if (b.aabbNeedsUpdate) {
            b.computeAABB();
          }

          if (b.aabb.overlaps(aabb)) {
            result.push(b);
          }
        }

        return result;
      };
    }, {
      "../collision/Broadphase": 5,
      "../shapes/Shape": 44
    }],
    13: [function (_dereq_, module, exports) {
      module.exports = ConeTwistConstraint;

      var Constraint = _dereq_('./Constraint');

      var PointToPointConstraint = _dereq_('./PointToPointConstraint');

      var ConeEquation = _dereq_('../equations/ConeEquation');

      var RotationalEquation = _dereq_('../equations/RotationalEquation');

      var ContactEquation = _dereq_('../equations/ContactEquation');

      var Vec3 = _dereq_('../math/Vec3');
      /**
       * @class ConeTwistConstraint
       * @constructor
       * @author schteppe
       * @param {Body} bodyA
       * @param {Body} bodyB
       * @param {object} [options]
       * @param {Vec3} [options.pivotA]
       * @param {Vec3} [options.pivotB]
       * @param {Vec3} [options.axisA]
       * @param {Vec3} [options.axisB]
       * @param {Number} [options.maxForce=1e6]
       * @extends PointToPointConstraint
       */


      function ConeTwistConstraint(bodyA, bodyB, options) {
        options = options || {};
        var maxForce = typeof options.maxForce !== 'undefined' ? options.maxForce : 1e6; // Set pivot point in between

        var pivotA = options.pivotA ? options.pivotA.clone() : new Vec3();
        var pivotB = options.pivotB ? options.pivotB.clone() : new Vec3();
        this.axisA = options.axisA ? options.axisA.clone() : new Vec3();
        this.axisB = options.axisB ? options.axisB.clone() : new Vec3();
        PointToPointConstraint.call(this, bodyA, pivotA, bodyB, pivotB, maxForce);
        this.collideConnected = !!options.collideConnected;
        this.angle = typeof options.angle !== 'undefined' ? options.angle : 0;
        /**
         * @property {ConeEquation} coneEquation
         */

        var c = this.coneEquation = new ConeEquation(bodyA, bodyB, options);
        /**
         * @property {RotationalEquation} twistEquation
         */

        var t = this.twistEquation = new RotationalEquation(bodyA, bodyB, options);
        this.twistAngle = typeof options.twistAngle !== 'undefined' ? options.twistAngle : 0; // Make the cone equation push the bodies toward the cone axis, not outward

        c.maxForce = 0;
        c.minForce = -maxForce; // Make the twist equation add torque toward the initial position

        t.maxForce = 0;
        t.minForce = -maxForce;
        this.equations.push(c, t);
      }

      ConeTwistConstraint.prototype = new PointToPointConstraint();
      ConeTwistConstraint.constructor = ConeTwistConstraint;
      var ConeTwistConstraint_update_tmpVec1 = new Vec3();
      var ConeTwistConstraint_update_tmpVec2 = new Vec3();

      ConeTwistConstraint.prototype.update = function () {
        var bodyA = this.bodyA,
            bodyB = this.bodyB,
            cone = this.coneEquation,
            twist = this.twistEquation;
        PointToPointConstraint.prototype.update.call(this); // Update the axes to the cone constraint

        bodyA.vectorToWorldFrame(this.axisA, cone.axisA);
        bodyB.vectorToWorldFrame(this.axisB, cone.axisB); // Update the world axes in the twist constraint

        this.axisA.tangents(twist.axisA, twist.axisA);
        bodyA.vectorToWorldFrame(twist.axisA, twist.axisA);
        this.axisB.tangents(twist.axisB, twist.axisB);
        bodyB.vectorToWorldFrame(twist.axisB, twist.axisB);
        cone.angle = this.angle;
        twist.maxAngle = this.twistAngle;
      };
    }, {
      "../equations/ConeEquation": 19,
      "../equations/ContactEquation": 20,
      "../equations/RotationalEquation": 23,
      "../math/Vec3": 31,
      "./Constraint": 14,
      "./PointToPointConstraint": 18
    }],
    14: [function (_dereq_, module, exports) {
      module.exports = Constraint;

      var Utils = _dereq_('../utils/Utils');
      /**
       * Constraint base class
       * @class Constraint
       * @author schteppe
       * @constructor
       * @param {Body} bodyA
       * @param {Body} bodyB
       * @param {object} [options]
       * @param {boolean} [options.collideConnected=true]
       * @param {boolean} [options.wakeUpBodies=true]
       */


      function Constraint(bodyA, bodyB, options) {
        options = Utils.defaults(options, {
          collideConnected: true,
          wakeUpBodies: true
        });
        /**
         * Equations to be solved in this constraint
         * @property equations
         * @type {Array}
         */

        this.equations = [];
        /**
         * @property {Body} bodyA
         */

        this.bodyA = bodyA;
        /**
         * @property {Body} bodyB
         */

        this.bodyB = bodyB;
        /**
         * @property {Number} id
         */

        this.id = Constraint.idCounter++;
        /**
         * Set to true if you want the bodies to collide when they are connected.
         * @property collideConnected
         * @type {boolean}
         */

        this.collideConnected = options.collideConnected;

        if (options.wakeUpBodies) {
          if (bodyA) {
            bodyA.wakeUp();
          }

          if (bodyB) {
            bodyB.wakeUp();
          }
        }
      }
      /**
       * Update all the equations with data.
       * @method update
       */


      Constraint.prototype.update = function () {
        throw new Error("method update() not implmemented in this Constraint subclass!");
      };
      /**
       * Enables all equations in the constraint.
       * @method enable
       */


      Constraint.prototype.enable = function () {
        var eqs = this.equations;

        for (var i = 0; i < eqs.length; i++) {
          eqs[i].enabled = true;
        }
      };
      /**
       * Disables all equations in the constraint.
       * @method disable
       */


      Constraint.prototype.disable = function () {
        var eqs = this.equations;

        for (var i = 0; i < eqs.length; i++) {
          eqs[i].enabled = false;
        }
      };

      Constraint.idCounter = 0;
    }, {
      "../utils/Utils": 54
    }],
    15: [function (_dereq_, module, exports) {
      module.exports = DistanceConstraint;

      var Constraint = _dereq_('./Constraint');

      var ContactEquation = _dereq_('../equations/ContactEquation');
      /**
       * Constrains two bodies to be at a constant distance from each others center of mass.
       * @class DistanceConstraint
       * @constructor
       * @author schteppe
       * @param {Body} bodyA
       * @param {Body} bodyB
       * @param {Number} [distance] The distance to keep. If undefined, it will be set to the current distance between bodyA and bodyB
       * @param {Number} [maxForce=1e6]
       * @extends Constraint
       */


      function DistanceConstraint(bodyA, bodyB, distance, maxForce) {
        Constraint.call(this, bodyA, bodyB);

        if (typeof distance === "undefined") {
          distance = bodyA.position.distanceTo(bodyB.position);
        }

        if (typeof maxForce === "undefined") {
          maxForce = 1e6;
        }
        /**
         * @property {number} distance
         */


        this.distance = distance;
        /**
         * @property {ContactEquation} distanceEquation
         */

        var eq = this.distanceEquation = new ContactEquation(bodyA, bodyB);
        this.equations.push(eq); // Make it bidirectional

        eq.minForce = -maxForce;
        eq.maxForce = maxForce;
      }

      DistanceConstraint.prototype = new Constraint();

      DistanceConstraint.prototype.update = function () {
        var bodyA = this.bodyA;
        var bodyB = this.bodyB;
        var eq = this.distanceEquation;
        var halfDist = this.distance * 0.5;
        var normal = eq.ni;
        bodyB.position.vsub(bodyA.position, normal);
        normal.normalize();
        normal.mult(halfDist, eq.ri);
        normal.mult(-halfDist, eq.rj);
      };
    }, {
      "../equations/ContactEquation": 20,
      "./Constraint": 14
    }],
    16: [function (_dereq_, module, exports) {
      module.exports = HingeConstraint;

      var Constraint = _dereq_('./Constraint');

      var PointToPointConstraint = _dereq_('./PointToPointConstraint');

      var RotationalEquation = _dereq_('../equations/RotationalEquation');

      var RotationalMotorEquation = _dereq_('../equations/RotationalMotorEquation');

      var ContactEquation = _dereq_('../equations/ContactEquation');

      var Vec3 = _dereq_('../math/Vec3');
      /**
       * Hinge constraint. Think of it as a door hinge. It tries to keep the door in the correct place and with the correct orientation.
       * @class HingeConstraint
       * @constructor
       * @author schteppe
       * @param {Body} bodyA
       * @param {Body} bodyB
       * @param {object} [options]
       * @param {Vec3} [options.pivotA] A point defined locally in bodyA. This defines the offset of axisA.
       * @param {Vec3} [options.axisA] An axis that bodyA can rotate around, defined locally in bodyA.
       * @param {Vec3} [options.pivotB]
       * @param {Vec3} [options.axisB]
       * @param {Number} [options.maxForce=1e6]
       * @extends PointToPointConstraint
       */


      function HingeConstraint(bodyA, bodyB, options) {
        options = options || {};
        var maxForce = typeof options.maxForce !== 'undefined' ? options.maxForce : 1e6;
        var pivotA = options.pivotA ? options.pivotA.clone() : new Vec3();
        var pivotB = options.pivotB ? options.pivotB.clone() : new Vec3();
        PointToPointConstraint.call(this, bodyA, pivotA, bodyB, pivotB, maxForce);
        /**
         * Rotation axis, defined locally in bodyA.
         * @property {Vec3} axisA
         */

        var axisA = this.axisA = options.axisA ? options.axisA.clone() : new Vec3(1, 0, 0);
        axisA.normalize();
        /**
         * Rotation axis, defined locally in bodyB.
         * @property {Vec3} axisB
         */

        var axisB = this.axisB = options.axisB ? options.axisB.clone() : new Vec3(1, 0, 0);
        axisB.normalize();
        /**
         * @property {RotationalEquation} rotationalEquation1
         */

        var r1 = this.rotationalEquation1 = new RotationalEquation(bodyA, bodyB, options);
        /**
         * @property {RotationalEquation} rotationalEquation2
         */

        var r2 = this.rotationalEquation2 = new RotationalEquation(bodyA, bodyB, options);
        /**
         * @property {RotationalMotorEquation} motorEquation
         */

        var motor = this.motorEquation = new RotationalMotorEquation(bodyA, bodyB, maxForce);
        motor.enabled = false; // Not enabled by default
        // Equations to be fed to the solver

        this.equations.push(r1, // rotational1
        r2, // rotational2
        motor);
      }

      HingeConstraint.prototype = new PointToPointConstraint();
      HingeConstraint.constructor = HingeConstraint;
      /**
       * @method enableMotor
       */

      HingeConstraint.prototype.enableMotor = function () {
        this.motorEquation.enabled = true;
      };
      /**
       * @method disableMotor
       */


      HingeConstraint.prototype.disableMotor = function () {
        this.motorEquation.enabled = false;
      };
      /**
       * @method setMotorSpeed
       * @param {number} speed
       */


      HingeConstraint.prototype.setMotorSpeed = function (speed) {
        this.motorEquation.targetVelocity = speed;
      };
      /**
       * @method setMotorMaxForce
       * @param {number} maxForce
       */


      HingeConstraint.prototype.setMotorMaxForce = function (maxForce) {
        this.motorEquation.maxForce = maxForce;
        this.motorEquation.minForce = -maxForce;
      };

      var HingeConstraint_update_tmpVec1 = new Vec3();
      var HingeConstraint_update_tmpVec2 = new Vec3();

      HingeConstraint.prototype.update = function () {
        var bodyA = this.bodyA,
            bodyB = this.bodyB,
            motor = this.motorEquation,
            r1 = this.rotationalEquation1,
            r2 = this.rotationalEquation2,
            worldAxisA = HingeConstraint_update_tmpVec1,
            worldAxisB = HingeConstraint_update_tmpVec2;
        var axisA = this.axisA;
        var axisB = this.axisB;
        PointToPointConstraint.prototype.update.call(this); // Get world axes

        bodyA.quaternion.vmult(axisA, worldAxisA);
        bodyB.quaternion.vmult(axisB, worldAxisB);
        worldAxisA.tangents(r1.axisA, r2.axisA);
        r1.axisB.copy(worldAxisB);
        r2.axisB.copy(worldAxisB);

        if (this.motorEquation.enabled) {
          bodyA.quaternion.vmult(this.axisA, motor.axisA);
          bodyB.quaternion.vmult(this.axisB, motor.axisB);
        }
      };
    }, {
      "../equations/ContactEquation": 20,
      "../equations/RotationalEquation": 23,
      "../equations/RotationalMotorEquation": 24,
      "../math/Vec3": 31,
      "./Constraint": 14,
      "./PointToPointConstraint": 18
    }],
    17: [function (_dereq_, module, exports) {
      module.exports = LockConstraint;

      var Constraint = _dereq_('./Constraint');

      var PointToPointConstraint = _dereq_('./PointToPointConstraint');

      var RotationalEquation = _dereq_('../equations/RotationalEquation');

      var RotationalMotorEquation = _dereq_('../equations/RotationalMotorEquation');

      var ContactEquation = _dereq_('../equations/ContactEquation');

      var Vec3 = _dereq_('../math/Vec3');
      /**
       * Lock constraint. Will remove all degrees of freedom between the bodies.
       * @class LockConstraint
       * @constructor
       * @author schteppe
       * @param {Body} bodyA
       * @param {Body} bodyB
       * @param {object} [options]
       * @param {Number} [options.maxForce=1e6]
       * @extends PointToPointConstraint
       */


      function LockConstraint(bodyA, bodyB, options) {
        options = options || {};
        var maxForce = typeof options.maxForce !== 'undefined' ? options.maxForce : 1e6; // Set pivot point in between

        var pivotA = new Vec3();
        var pivotB = new Vec3();
        var halfWay = new Vec3();
        bodyA.position.vadd(bodyB.position, halfWay);
        halfWay.scale(0.5, halfWay);
        bodyB.pointToLocalFrame(halfWay, pivotB);
        bodyA.pointToLocalFrame(halfWay, pivotA); // The point-to-point constraint will keep a point shared between the bodies

        PointToPointConstraint.call(this, bodyA, pivotA, bodyB, pivotB, maxForce); // Store initial rotation of the bodies as unit vectors in the local body spaces

        this.xA = bodyA.vectorToLocalFrame(Vec3.UNIT_X);
        this.xB = bodyB.vectorToLocalFrame(Vec3.UNIT_X);
        this.yA = bodyA.vectorToLocalFrame(Vec3.UNIT_Y);
        this.yB = bodyB.vectorToLocalFrame(Vec3.UNIT_Y);
        this.zA = bodyA.vectorToLocalFrame(Vec3.UNIT_Z);
        this.zB = bodyB.vectorToLocalFrame(Vec3.UNIT_Z); // ...and the following rotational equations will keep all rotational DOF's in place

        /**
         * @property {RotationalEquation} rotationalEquation1
         */

        var r1 = this.rotationalEquation1 = new RotationalEquation(bodyA, bodyB, options);
        /**
         * @property {RotationalEquation} rotationalEquation2
         */

        var r2 = this.rotationalEquation2 = new RotationalEquation(bodyA, bodyB, options);
        /**
         * @property {RotationalEquation} rotationalEquation3
         */

        var r3 = this.rotationalEquation3 = new RotationalEquation(bodyA, bodyB, options);
        this.equations.push(r1, r2, r3);
      }

      LockConstraint.prototype = new PointToPointConstraint();
      LockConstraint.constructor = LockConstraint;
      var LockConstraint_update_tmpVec1 = new Vec3();
      var LockConstraint_update_tmpVec2 = new Vec3();

      LockConstraint.prototype.update = function () {
        var bodyA = this.bodyA,
            bodyB = this.bodyB,
            motor = this.motorEquation,
            r1 = this.rotationalEquation1,
            r2 = this.rotationalEquation2,
            r3 = this.rotationalEquation3,
            worldAxisA = LockConstraint_update_tmpVec1,
            worldAxisB = LockConstraint_update_tmpVec2;
        PointToPointConstraint.prototype.update.call(this); // These vector pairs must be orthogonal

        bodyA.vectorToWorldFrame(this.xA, r1.axisA);
        bodyB.vectorToWorldFrame(this.yB, r1.axisB);
        bodyA.vectorToWorldFrame(this.yA, r2.axisA);
        bodyB.vectorToWorldFrame(this.zB, r2.axisB);
        bodyA.vectorToWorldFrame(this.zA, r3.axisA);
        bodyB.vectorToWorldFrame(this.xB, r3.axisB);
      };
    }, {
      "../equations/ContactEquation": 20,
      "../equations/RotationalEquation": 23,
      "../equations/RotationalMotorEquation": 24,
      "../math/Vec3": 31,
      "./Constraint": 14,
      "./PointToPointConstraint": 18
    }],
    18: [function (_dereq_, module, exports) {
      module.exports = PointToPointConstraint;

      var Constraint = _dereq_('./Constraint');

      var ContactEquation = _dereq_('../equations/ContactEquation');

      var Vec3 = _dereq_('../math/Vec3');
      /**
       * Connects two bodies at given offset points.
       * @class PointToPointConstraint
       * @extends Constraint
       * @constructor
       * @param {Body} bodyA
       * @param {Vec3} pivotA The point relative to the center of mass of bodyA which bodyA is constrained to.
       * @param {Body} bodyB Body that will be constrained in a similar way to the same point as bodyA. We will therefore get a link between bodyA and bodyB. If not specified, bodyA will be constrained to a static point.
       * @param {Vec3} pivotB See pivotA.
       * @param {Number} maxForce The maximum force that should be applied to constrain the bodies.
       *
       * @example
       *     var bodyA = new Body({ mass: 1 });
       *     var bodyB = new Body({ mass: 1 });
       *     bodyA.position.set(-1, 0, 0);
       *     bodyB.position.set(1, 0, 0);
       *     bodyA.addShape(shapeA);
       *     bodyB.addShape(shapeB);
       *     world.addBody(bodyA);
       *     world.addBody(bodyB);
       *     var localPivotA = new Vec3(1, 0, 0);
       *     var localPivotB = new Vec3(-1, 0, 0);
       *     var constraint = new PointToPointConstraint(bodyA, localPivotA, bodyB, localPivotB);
       *     world.addConstraint(constraint);
       */


      function PointToPointConstraint(bodyA, pivotA, bodyB, pivotB, maxForce) {
        Constraint.call(this, bodyA, bodyB);
        maxForce = typeof maxForce !== 'undefined' ? maxForce : 1e6;
        /**
         * Pivot, defined locally in bodyA.
         * @property {Vec3} pivotA
         */

        this.pivotA = pivotA ? pivotA.clone() : new Vec3();
        /**
         * Pivot, defined locally in bodyB.
         * @property {Vec3} pivotB
         */

        this.pivotB = pivotB ? pivotB.clone() : new Vec3();
        /**
         * @property {ContactEquation} equationX
         */

        var x = this.equationX = new ContactEquation(bodyA, bodyB);
        /**
         * @property {ContactEquation} equationY
         */

        var y = this.equationY = new ContactEquation(bodyA, bodyB);
        /**
         * @property {ContactEquation} equationZ
         */

        var z = this.equationZ = new ContactEquation(bodyA, bodyB); // Equations to be fed to the solver

        this.equations.push(x, y, z); // Make the equations bidirectional

        x.minForce = y.minForce = z.minForce = -maxForce;
        x.maxForce = y.maxForce = z.maxForce = maxForce;
        x.ni.set(1, 0, 0);
        y.ni.set(0, 1, 0);
        z.ni.set(0, 0, 1);
      }

      PointToPointConstraint.prototype = new Constraint();

      PointToPointConstraint.prototype.update = function () {
        var bodyA = this.bodyA;
        var bodyB = this.bodyB;
        var x = this.equationX;
        var y = this.equationY;
        var z = this.equationZ; // Rotate the pivots to world space

        bodyA.quaternion.vmult(this.pivotA, x.ri);
        bodyB.quaternion.vmult(this.pivotB, x.rj);
        y.ri.copy(x.ri);
        y.rj.copy(x.rj);
        z.ri.copy(x.ri);
        z.rj.copy(x.rj);
      };
    }, {
      "../equations/ContactEquation": 20,
      "../math/Vec3": 31,
      "./Constraint": 14
    }],
    19: [function (_dereq_, module, exports) {
      module.exports = ConeEquation;

      var Vec3 = _dereq_('../math/Vec3');

      var Mat3 = _dereq_('../math/Mat3');

      var Equation = _dereq_('./Equation');
      /**
       * Cone equation. Works to keep the given body world vectors aligned, or tilted within a given angle from each other.
       * @class ConeEquation
       * @constructor
       * @author schteppe
       * @param {Body} bodyA
       * @param {Body} bodyB
       * @param {Vec3} [options.axisA] Local axis in A
       * @param {Vec3} [options.axisB] Local axis in B
       * @param {Vec3} [options.angle] The "cone angle" to keep
       * @param {number} [options.maxForce=1e6]
       * @extends Equation
       */


      function ConeEquation(bodyA, bodyB, options) {
        options = options || {};
        var maxForce = typeof options.maxForce !== 'undefined' ? options.maxForce : 1e6;
        Equation.call(this, bodyA, bodyB, -maxForce, maxForce);
        this.axisA = options.axisA ? options.axisA.clone() : new Vec3(1, 0, 0);
        this.axisB = options.axisB ? options.axisB.clone() : new Vec3(0, 1, 0);
        /**
         * The cone angle to keep
         * @property {number} angle
         */

        this.angle = typeof options.angle !== 'undefined' ? options.angle : 0;
      }

      ConeEquation.prototype = new Equation();
      ConeEquation.prototype.constructor = ConeEquation;
      var tmpVec1 = new Vec3();
      var tmpVec2 = new Vec3();

      ConeEquation.prototype.computeB = function (h) {
        var a = this.a,
            b = this.b,
            ni = this.axisA,
            nj = this.axisB,
            nixnj = tmpVec1,
            njxni = tmpVec2,
            GA = this.jacobianElementA,
            GB = this.jacobianElementB; // Caluclate cross products

        ni.cross(nj, nixnj);
        nj.cross(ni, njxni); // The angle between two vector is:
        // cos(theta) = a * b / (length(a) * length(b) = { len(a) = len(b) = 1 } = a * b
        // g = a * b
        // gdot = (b x a) * wi + (a x b) * wj
        // G = [0 bxa 0 axb]
        // W = [vi wi vj wj]

        GA.rotational.copy(njxni);
        GB.rotational.copy(nixnj);
        var g = Math.cos(this.angle) - ni.dot(nj),
            GW = this.computeGW(),
            GiMf = this.computeGiMf();
        var B = -g * a - GW * b - h * GiMf;
        return B;
      };
    }, {
      "../math/Mat3": 28,
      "../math/Vec3": 31,
      "./Equation": 21
    }],
    20: [function (_dereq_, module, exports) {
      module.exports = ContactEquation;

      var Equation = _dereq_('./Equation');

      var Vec3 = _dereq_('../math/Vec3');

      var Mat3 = _dereq_('../math/Mat3');
      /**
       * Contact/non-penetration constraint equation
       * @class ContactEquation
       * @constructor
       * @author schteppe
       * @param {Body} bodyA
       * @param {Body} bodyB
       * @extends Equation
       */


      function ContactEquation(bodyA, bodyB, maxForce) {
        maxForce = typeof maxForce !== 'undefined' ? maxForce : 1e6;
        Equation.call(this, bodyA, bodyB, 0, maxForce);
        /**
         * @property si
         * @type {Shape}
         */

        this.si = null;
        /**
         * @property sj
         * @type {Shape}
         */

        this.sj = null;
        /**
         * @property restitution
         * @type {Number}
         */

        this.restitution = 0.0; // "bounciness": u1 = -e*u0

        /**
         * World-oriented vector that goes from the center of bi to the contact point.
         * @property {Vec3} ri
         */

        this.ri = new Vec3();
        /**
         * World-oriented vector that starts in body j position and goes to the contact point.
         * @property {Vec3} rj
         */

        this.rj = new Vec3();
        /**
         * Contact normal, pointing out of body i.
         * @property {Vec3} ni
         */

        this.ni = new Vec3();
      }

      ContactEquation.prototype = new Equation();
      ContactEquation.prototype.constructor = ContactEquation;
      var ContactEquation_computeB_temp1 = new Vec3(); // Temp vectors

      var ContactEquation_computeB_temp2 = new Vec3();
      var ContactEquation_computeB_temp3 = new Vec3();

      ContactEquation.prototype.computeB = function (h) {
        var a = this.a,
            b = this.b,
            bi = this.bi,
            bj = this.bj,
            ri = this.ri,
            rj = this.rj,
            rixn = ContactEquation_computeB_temp1,
            rjxn = ContactEquation_computeB_temp2,
            vi = bi.velocity,
            wi = bi.angularVelocity,
            fi = bi.force,
            taui = bi.torque,
            vj = bj.velocity,
            wj = bj.angularVelocity,
            fj = bj.force,
            tauj = bj.torque,
            penetrationVec = ContactEquation_computeB_temp3,
            GA = this.jacobianElementA,
            GB = this.jacobianElementB,
            n = this.ni; // Caluclate cross products

        ri.cross(n, rixn);
        rj.cross(n, rjxn); // g = xj+rj -(xi+ri)
        // G = [ -ni  -rixn  ni  rjxn ]

        n.negate(GA.spatial);
        rixn.negate(GA.rotational);
        GB.spatial.copy(n);
        GB.rotational.copy(rjxn); // Calculate the penetration vector

        penetrationVec.copy(bj.position);
        penetrationVec.vadd(rj, penetrationVec);
        penetrationVec.vsub(bi.position, penetrationVec);
        penetrationVec.vsub(ri, penetrationVec);
        var g = n.dot(penetrationVec); // Compute iteration

        var ePlusOne = this.restitution + 1;
        var GW = ePlusOne * vj.dot(n) - ePlusOne * vi.dot(n) + wj.dot(rjxn) - wi.dot(rixn);
        var GiMf = this.computeGiMf();
        var B = -g * a - GW * b - h * GiMf;
        return B;
      };

      var ContactEquation_getImpactVelocityAlongNormal_vi = new Vec3();
      var ContactEquation_getImpactVelocityAlongNormal_vj = new Vec3();
      var ContactEquation_getImpactVelocityAlongNormal_xi = new Vec3();
      var ContactEquation_getImpactVelocityAlongNormal_xj = new Vec3();
      var ContactEquation_getImpactVelocityAlongNormal_relVel = new Vec3();
      /**
       * Get the current relative velocity in the contact point.
       * @method getImpactVelocityAlongNormal
       * @return {number}
       */

      ContactEquation.prototype.getImpactVelocityAlongNormal = function () {
        var vi = ContactEquation_getImpactVelocityAlongNormal_vi;
        var vj = ContactEquation_getImpactVelocityAlongNormal_vj;
        var xi = ContactEquation_getImpactVelocityAlongNormal_xi;
        var xj = ContactEquation_getImpactVelocityAlongNormal_xj;
        var relVel = ContactEquation_getImpactVelocityAlongNormal_relVel;
        this.bi.position.vadd(this.ri, xi);
        this.bj.position.vadd(this.rj, xj);
        this.bi.getVelocityAtWorldPoint(xi, vi);
        this.bj.getVelocityAtWorldPoint(xj, vj);
        vi.vsub(vj, relVel);
        return this.ni.dot(relVel);
      };
    }, {
      "../math/Mat3": 28,
      "../math/Vec3": 31,
      "./Equation": 21
    }],
    21: [function (_dereq_, module, exports) {
      module.exports = Equation;

      var JacobianElement = _dereq_('../math/JacobianElement'),
          Vec3 = _dereq_('../math/Vec3');
      /**
       * Equation base class
       * @class Equation
       * @constructor
       * @author schteppe
       * @param {Body} bi
       * @param {Body} bj
       * @param {Number} minForce Minimum (read: negative max) force to be applied by the constraint.
       * @param {Number} maxForce Maximum (read: positive max) force to be applied by the constraint.
       */


      function Equation(bi, bj, minForce, maxForce) {
        this.id = Equation.id++;
        /**
         * @property {number} minForce
         */

        this.minForce = typeof minForce === "undefined" ? -1e6 : minForce;
        /**
         * @property {number} maxForce
         */

        this.maxForce = typeof maxForce === "undefined" ? 1e6 : maxForce;
        /**
         * @property bi
         * @type {Body}
         */

        this.bi = bi;
        /**
         * @property bj
         * @type {Body}
         */

        this.bj = bj;
        /**
         * SPOOK parameter
         * @property {number} a
         */

        this.a = 0.0;
        /**
         * SPOOK parameter
         * @property {number} b
         */

        this.b = 0.0;
        /**
         * SPOOK parameter
         * @property {number} eps
         */

        this.eps = 0.0;
        /**
         * @property {JacobianElement} jacobianElementA
         */

        this.jacobianElementA = new JacobianElement();
        /**
         * @property {JacobianElement} jacobianElementB
         */

        this.jacobianElementB = new JacobianElement();
        /**
         * @property {boolean} enabled
         * @default true
         */

        this.enabled = true;
        /**
         * A number, proportional to the force added to the bodies.
         * @property {number} multiplier
         * @readonly
         */

        this.multiplier = 0; // Set typical spook params

        this.setSpookParams(1e7, 4, 1 / 60);
      }

      Equation.prototype.constructor = Equation;
      Equation.id = 0;
      /**
       * Recalculates a,b,eps.
       * @method setSpookParams
       */

      Equation.prototype.setSpookParams = function (stiffness, relaxation, timeStep) {
        var d = relaxation,
            k = stiffness,
            h = timeStep;
        this.a = 4.0 / (h * (1 + 4 * d));
        this.b = 4.0 * d / (1 + 4 * d);
        this.eps = 4.0 / (h * h * k * (1 + 4 * d));
      };
      /**
       * Computes the RHS of the SPOOK equation
       * @method computeB
       * @return {Number}
       */


      Equation.prototype.computeB = function (a, b, h) {
        var GW = this.computeGW(),
            Gq = this.computeGq(),
            GiMf = this.computeGiMf();
        return -Gq * a - GW * b - GiMf * h;
      };
      /**
       * Computes G*q, where q are the generalized body coordinates
       * @method computeGq
       * @return {Number}
       */


      Equation.prototype.computeGq = function () {
        var GA = this.jacobianElementA,
            GB = this.jacobianElementB,
            bi = this.bi,
            bj = this.bj,
            xi = bi.position,
            xj = bj.position;
        return GA.spatial.dot(xi) + GB.spatial.dot(xj);
      };

      var zero = new Vec3();
      /**
       * Computes G*W, where W are the body velocities
       * @method computeGW
       * @return {Number}
       */

      Equation.prototype.computeGW = function () {
        var GA = this.jacobianElementA,
            GB = this.jacobianElementB,
            bi = this.bi,
            bj = this.bj,
            vi = bi.velocity,
            vj = bj.velocity,
            wi = bi.angularVelocity,
            wj = bj.angularVelocity;
        return GA.multiplyVectors(vi, wi) + GB.multiplyVectors(vj, wj);
      };
      /**
       * Computes G*Wlambda, where W are the body velocities
       * @method computeGWlambda
       * @return {Number}
       */


      Equation.prototype.computeGWlambda = function () {
        var GA = this.jacobianElementA,
            GB = this.jacobianElementB,
            bi = this.bi,
            bj = this.bj,
            vi = bi.vlambda,
            vj = bj.vlambda,
            wi = bi.wlambda,
            wj = bj.wlambda;
        return GA.multiplyVectors(vi, wi) + GB.multiplyVectors(vj, wj);
      };
      /**
       * Computes G*inv(M)*f, where M is the mass matrix with diagonal blocks for each body, and f are the forces on the bodies.
       * @method computeGiMf
       * @return {Number}
       */


      var iMfi = new Vec3(),
          iMfj = new Vec3(),
          invIi_vmult_taui = new Vec3(),
          invIj_vmult_tauj = new Vec3();

      Equation.prototype.computeGiMf = function () {
        var GA = this.jacobianElementA,
            GB = this.jacobianElementB,
            bi = this.bi,
            bj = this.bj,
            fi = bi.force,
            ti = bi.torque,
            fj = bj.force,
            tj = bj.torque,
            invMassi = bi.invMassSolve,
            invMassj = bj.invMassSolve;
        fi.scale(invMassi, iMfi);
        fj.scale(invMassj, iMfj);
        bi.invInertiaWorldSolve.vmult(ti, invIi_vmult_taui);
        bj.invInertiaWorldSolve.vmult(tj, invIj_vmult_tauj);
        return GA.multiplyVectors(iMfi, invIi_vmult_taui) + GB.multiplyVectors(iMfj, invIj_vmult_tauj);
      };
      /**
       * Computes G*inv(M)*G'
       * @method computeGiMGt
       * @return {Number}
       */


      var tmp = new Vec3();

      Equation.prototype.computeGiMGt = function () {
        var GA = this.jacobianElementA,
            GB = this.jacobianElementB,
            bi = this.bi,
            bj = this.bj,
            invMassi = bi.invMassSolve,
            invMassj = bj.invMassSolve,
            invIi = bi.invInertiaWorldSolve,
            invIj = bj.invInertiaWorldSolve,
            result = invMassi + invMassj;
        invIi.vmult(GA.rotational, tmp);
        result += tmp.dot(GA.rotational);
        invIj.vmult(GB.rotational, tmp);
        result += tmp.dot(GB.rotational);
        return result;
      };

      var addToWlambda_temp = new Vec3(),
          addToWlambda_Gi = new Vec3(),
          addToWlambda_Gj = new Vec3(),
          addToWlambda_ri = new Vec3(),
          addToWlambda_rj = new Vec3(),
          addToWlambda_Mdiag = new Vec3();
      /**
       * Add constraint velocity to the bodies.
       * @method addToWlambda
       * @param {Number} deltalambda
       */

      Equation.prototype.addToWlambda = function (deltalambda) {
        var GA = this.jacobianElementA,
            GB = this.jacobianElementB,
            bi = this.bi,
            bj = this.bj,
            temp = addToWlambda_temp; // Add to linear velocity
        // v_lambda += inv(M) * delta_lamba * G

        bi.vlambda.addScaledVector(bi.invMassSolve * deltalambda, GA.spatial, bi.vlambda);
        bj.vlambda.addScaledVector(bj.invMassSolve * deltalambda, GB.spatial, bj.vlambda); // Add to angular velocity

        bi.invInertiaWorldSolve.vmult(GA.rotational, temp);
        bi.wlambda.addScaledVector(deltalambda, temp, bi.wlambda);
        bj.invInertiaWorldSolve.vmult(GB.rotational, temp);
        bj.wlambda.addScaledVector(deltalambda, temp, bj.wlambda);
      };
      /**
       * Compute the denominator part of the SPOOK equation: C = G*inv(M)*G' + eps
       * @method computeInvC
       * @param  {Number} eps
       * @return {Number}
       */


      Equation.prototype.computeC = function () {
        return this.computeGiMGt() + this.eps;
      };
    }, {
      "../math/JacobianElement": 27,
      "../math/Vec3": 31
    }],
    22: [function (_dereq_, module, exports) {
      module.exports = FrictionEquation;

      var Equation = _dereq_('./Equation');

      var Vec3 = _dereq_('../math/Vec3');

      var Mat3 = _dereq_('../math/Mat3');
      /**
       * Constrains the slipping in a contact along a tangent
       * @class FrictionEquation
       * @constructor
       * @author schteppe
       * @param {Body} bodyA
       * @param {Body} bodyB
       * @param {Number} slipForce should be +-F_friction = +-mu * F_normal = +-mu * m * g
       * @extends Equation
       */


      function FrictionEquation(bodyA, bodyB, slipForce) {
        Equation.call(this, bodyA, bodyB, -slipForce, slipForce);
        this.ri = new Vec3();
        this.rj = new Vec3();
        this.t = new Vec3(); // tangent
      }

      FrictionEquation.prototype = new Equation();
      FrictionEquation.prototype.constructor = FrictionEquation;
      var FrictionEquation_computeB_temp1 = new Vec3();
      var FrictionEquation_computeB_temp2 = new Vec3();

      FrictionEquation.prototype.computeB = function (h) {
        var a = this.a,
            b = this.b,
            bi = this.bi,
            bj = this.bj,
            ri = this.ri,
            rj = this.rj,
            rixt = FrictionEquation_computeB_temp1,
            rjxt = FrictionEquation_computeB_temp2,
            t = this.t; // Caluclate cross products

        ri.cross(t, rixt);
        rj.cross(t, rjxt); // G = [-t -rixt t rjxt]
        // And remember, this is a pure velocity constraint, g is always zero!

        var GA = this.jacobianElementA,
            GB = this.jacobianElementB;
        t.negate(GA.spatial);
        rixt.negate(GA.rotational);
        GB.spatial.copy(t);
        GB.rotational.copy(rjxt);
        var GW = this.computeGW();
        var GiMf = this.computeGiMf();
        var B = -GW * b - h * GiMf;
        return B;
      };
    }, {
      "../math/Mat3": 28,
      "../math/Vec3": 31,
      "./Equation": 21
    }],
    23: [function (_dereq_, module, exports) {
      module.exports = RotationalEquation;

      var Vec3 = _dereq_('../math/Vec3');

      var Mat3 = _dereq_('../math/Mat3');

      var Equation = _dereq_('./Equation');
      /**
       * Rotational constraint. Works to keep the local vectors orthogonal to each other in world space.
       * @class RotationalEquation
       * @constructor
       * @author schteppe
       * @param {Body} bodyA
       * @param {Body} bodyB
       * @param {Vec3} [options.axisA]
       * @param {Vec3} [options.axisB]
       * @param {number} [options.maxForce]
       * @extends Equation
       */


      function RotationalEquation(bodyA, bodyB, options) {
        options = options || {};
        var maxForce = typeof options.maxForce !== 'undefined' ? options.maxForce : 1e6;
        Equation.call(this, bodyA, bodyB, -maxForce, maxForce);
        this.axisA = options.axisA ? options.axisA.clone() : new Vec3(1, 0, 0);
        this.axisB = options.axisB ? options.axisB.clone() : new Vec3(0, 1, 0);
        this.maxAngle = Math.PI / 2;
      }

      RotationalEquation.prototype = new Equation();
      RotationalEquation.prototype.constructor = RotationalEquation;
      var tmpVec1 = new Vec3();
      var tmpVec2 = new Vec3();

      RotationalEquation.prototype.computeB = function (h) {
        var a = this.a,
            b = this.b,
            ni = this.axisA,
            nj = this.axisB,
            nixnj = tmpVec1,
            njxni = tmpVec2,
            GA = this.jacobianElementA,
            GB = this.jacobianElementB; // Caluclate cross products

        ni.cross(nj, nixnj);
        nj.cross(ni, njxni); // g = ni * nj
        // gdot = (nj x ni) * wi + (ni x nj) * wj
        // G = [0 njxni 0 nixnj]
        // W = [vi wi vj wj]

        GA.rotational.copy(njxni);
        GB.rotational.copy(nixnj);
        var g = Math.cos(this.maxAngle) - ni.dot(nj),
            GW = this.computeGW(),
            GiMf = this.computeGiMf();
        var B = -g * a - GW * b - h * GiMf;
        return B;
      };
    }, {
      "../math/Mat3": 28,
      "../math/Vec3": 31,
      "./Equation": 21
    }],
    24: [function (_dereq_, module, exports) {
      module.exports = RotationalMotorEquation;

      var Vec3 = _dereq_('../math/Vec3');

      var Mat3 = _dereq_('../math/Mat3');

      var Equation = _dereq_('./Equation');
      /**
       * Rotational motor constraint. Tries to keep the relative angular velocity of the bodies to a given value.
       * @class RotationalMotorEquation
       * @constructor
       * @author schteppe
       * @param {Body} bodyA
       * @param {Body} bodyB
       * @param {Number} maxForce
       * @extends Equation
       */


      function RotationalMotorEquation(bodyA, bodyB, maxForce) {
        maxForce = typeof maxForce !== 'undefined' ? maxForce : 1e6;
        Equation.call(this, bodyA, bodyB, -maxForce, maxForce);
        /**
         * World oriented rotational axis
         * @property {Vec3} axisA
         */

        this.axisA = new Vec3();
        /**
         * World oriented rotational axis
         * @property {Vec3} axisB
         */

        this.axisB = new Vec3(); // World oriented rotational axis

        /**
         * Motor velocity
         * @property {Number} targetVelocity
         */

        this.targetVelocity = 0;
      }

      RotationalMotorEquation.prototype = new Equation();
      RotationalMotorEquation.prototype.constructor = RotationalMotorEquation;

      RotationalMotorEquation.prototype.computeB = function (h) {
        var a = this.a,
            b = this.b,
            bi = this.bi,
            bj = this.bj,
            axisA = this.axisA,
            axisB = this.axisB,
            GA = this.jacobianElementA,
            GB = this.jacobianElementB; // g = 0
        // gdot = axisA * wi - axisB * wj
        // gdot = G * W = G * [vi wi vj wj]
        // =>
        // G = [0 axisA 0 -axisB]

        GA.rotational.copy(axisA);
        axisB.negate(GB.rotational);
        var GW = this.computeGW() - this.targetVelocity,
            GiMf = this.computeGiMf();
        var B = -GW * b - h * GiMf;
        return B;
      };
    }, {
      "../math/Mat3": 28,
      "../math/Vec3": 31,
      "./Equation": 21
    }],
    25: [function (_dereq_, module, exports) {
      var Utils = _dereq_('../utils/Utils');

      module.exports = ContactMaterial;
      /**
       * Defines what happens when two materials meet.
       * @class ContactMaterial
       * @constructor
       * @param {Material} m1
       * @param {Material} m2
       * @param {object} [options]
       * @param {Number} [options.friction=0.3]
       * @param {Number} [options.restitution=0.3]
       * @param {number} [options.contactEquationStiffness=1e7]
       * @param {number} [options.contactEquationRelaxation=3]
       * @param {number} [options.frictionEquationStiffness=1e7]
       * @param {Number} [options.frictionEquationRelaxation=3]
       */

      function ContactMaterial(m1, m2, options) {
        options = Utils.defaults(options, {
          friction: 0.3,
          restitution: 0.3,
          contactEquationStiffness: 1e7,
          contactEquationRelaxation: 3,
          frictionEquationStiffness: 1e7,
          frictionEquationRelaxation: 3
        });
        /**
         * Identifier of this material
         * @property {Number} id
         */

        this.id = ContactMaterial.idCounter++;
        /**
         * Participating materials
         * @property {Array} materials
         * @todo  Should be .materialA and .materialB instead
         */

        this.materials = [m1, m2];
        /**
         * Friction coefficient
         * @property {Number} friction
         */

        this.friction = options.friction;
        /**
         * Restitution coefficient
         * @property {Number} restitution
         */

        this.restitution = options.restitution;
        /**
         * Stiffness of the produced contact equations
         * @property {Number} contactEquationStiffness
         */

        this.contactEquationStiffness = options.contactEquationStiffness;
        /**
         * Relaxation time of the produced contact equations
         * @property {Number} contactEquationRelaxation
         */

        this.contactEquationRelaxation = options.contactEquationRelaxation;
        /**
         * Stiffness of the produced friction equations
         * @property {Number} frictionEquationStiffness
         */

        this.frictionEquationStiffness = options.frictionEquationStiffness;
        /**
         * Relaxation time of the produced friction equations
         * @property {Number} frictionEquationRelaxation
         */

        this.frictionEquationRelaxation = options.frictionEquationRelaxation;
      }

      ContactMaterial.idCounter = 0;
    }, {
      "../utils/Utils": 54
    }],
    26: [function (_dereq_, module, exports) {
      module.exports = Material;
      /**
       * Defines a physics material.
       * @class Material
       * @constructor
       * @param {object} [options]
       * @author schteppe
       */

      function Material(options) {
        var name = '';
        options = options || {}; // Backwards compatibility fix

        if (typeof options === 'string') {
          name = options;
          options = {};
        } else if (typeof options === 'object') {
          name = '';
        }
        /**
         * @property name
         * @type {String}
         */


        this.name = name;
        /**
         * material id.
         * @property id
         * @type {number}
         */

        this.id = Material.idCounter++;
        /**
         * Friction for this material. If non-negative, it will be used instead of the friction given by ContactMaterials. If there's no matching ContactMaterial, the value from .defaultContactMaterial in the World will be used.
         * @property {number} friction
         */

        this.friction = typeof options.friction !== 'undefined' ? options.friction : -1;
        /**
         * Restitution for this material. If non-negative, it will be used instead of the restitution given by ContactMaterials. If there's no matching ContactMaterial, the value from .defaultContactMaterial in the World will be used.
         * @property {number} restitution
         */

        this.restitution = typeof options.restitution !== 'undefined' ? options.restitution : -1;
      }

      Material.idCounter = 0;
    }, {}],
    27: [function (_dereq_, module, exports) {
      module.exports = JacobianElement;

      var Vec3 = _dereq_('./Vec3');
      /**
       * An element containing 6 entries, 3 spatial and 3 rotational degrees of freedom.
       * @class JacobianElement
       * @constructor
       */


      function JacobianElement() {
        /**
         * @property {Vec3} spatial
         */
        this.spatial = new Vec3();
        /**
         * @property {Vec3} rotational
         */

        this.rotational = new Vec3();
      }
      /**
       * Multiply with other JacobianElement
       * @method multiplyElement
       * @param  {JacobianElement} element
       * @return {Number}
       */


      JacobianElement.prototype.multiplyElement = function (element) {
        return element.spatial.dot(this.spatial) + element.rotational.dot(this.rotational);
      };
      /**
       * Multiply with two vectors
       * @method multiplyVectors
       * @param  {Vec3} spatial
       * @param  {Vec3} rotational
       * @return {Number}
       */


      JacobianElement.prototype.multiplyVectors = function (spatial, rotational) {
        return spatial.dot(this.spatial) + rotational.dot(this.rotational);
      };
    }, {
      "./Vec3": 31
    }],
    28: [function (_dereq_, module, exports) {
      module.exports = Mat3;

      var Vec3 = _dereq_('./Vec3');
      /**
       * A 3x3 matrix.
       * @class Mat3
       * @constructor
       * @param array elements Array of nine elements. Optional.
       * @author schteppe / http://github.com/schteppe
       */


      function Mat3(elements) {
        /**
         * A vector of length 9, containing all matrix elements
         * @property {Array} elements
         */
        if (elements) {
          this.elements = elements;
        } else {
          this.elements = [0, 0, 0, 0, 0, 0, 0, 0, 0];
        }
      }
      /**
       * Sets the matrix to identity
       * @method identity
       * @todo Should perhaps be renamed to setIdentity() to be more clear.
       * @todo Create another function that immediately creates an identity matrix eg. eye()
       */


      Mat3.prototype.identity = function () {
        var e = this.elements;
        e[0] = 1;
        e[1] = 0;
        e[2] = 0;
        e[3] = 0;
        e[4] = 1;
        e[5] = 0;
        e[6] = 0;
        e[7] = 0;
        e[8] = 1;
      };
      /**
       * Set all elements to zero
       * @method setZero
       */


      Mat3.prototype.setZero = function () {
        var e = this.elements;
        e[0] = 0;
        e[1] = 0;
        e[2] = 0;
        e[3] = 0;
        e[4] = 0;
        e[5] = 0;
        e[6] = 0;
        e[7] = 0;
        e[8] = 0;
      };
      /**
       * Sets the matrix diagonal elements from a Vec3
       * @method setTrace
       * @param {Vec3} vec3
       */


      Mat3.prototype.setTrace = function (vec3) {
        var e = this.elements;
        e[0] = vec3.x;
        e[4] = vec3.y;
        e[8] = vec3.z;
      };
      /**
       * Gets the matrix diagonal elements
       * @method getTrace
       * @return {Vec3}
       */


      Mat3.prototype.getTrace = function (target) {
        var target = target || new Vec3();
        var e = this.elements;
        target.x = e[0];
        target.y = e[4];
        target.z = e[8];
      };
      /**
       * Matrix-Vector multiplication
       * @method vmult
       * @param {Vec3} v The vector to multiply with
       * @param {Vec3} target Optional, target to save the result in.
       */


      Mat3.prototype.vmult = function (v, target) {
        target = target || new Vec3();
        var e = this.elements,
            x = v.x,
            y = v.y,
            z = v.z;
        target.x = e[0] * x + e[1] * y + e[2] * z;
        target.y = e[3] * x + e[4] * y + e[5] * z;
        target.z = e[6] * x + e[7] * y + e[8] * z;
        return target;
      };
      /**
       * Matrix-scalar multiplication
       * @method smult
       * @param {Number} s
       */


      Mat3.prototype.smult = function (s) {
        for (var i = 0; i < this.elements.length; i++) {
          this.elements[i] *= s;
        }
      };
      /**
       * Matrix multiplication
       * @method mmult
       * @param {Mat3} m Matrix to multiply with from left side.
       * @return {Mat3} The result.
       */


      Mat3.prototype.mmult = function (m, target) {
        var r = target || new Mat3();

        for (var i = 0; i < 3; i++) {
          for (var j = 0; j < 3; j++) {
            var sum = 0.0;

            for (var k = 0; k < 3; k++) {
              sum += m.elements[i + k * 3] * this.elements[k + j * 3];
            }

            r.elements[i + j * 3] = sum;
          }
        }

        return r;
      };
      /**
       * Scale each column of the matrix
       * @method scale
       * @param {Vec3} v
       * @return {Mat3} The result.
       */


      Mat3.prototype.scale = function (v, target) {
        target = target || new Mat3();
        var e = this.elements,
            t = target.elements;

        for (var i = 0; i !== 3; i++) {
          t[3 * i + 0] = v.x * e[3 * i + 0];
          t[3 * i + 1] = v.y * e[3 * i + 1];
          t[3 * i + 2] = v.z * e[3 * i + 2];
        }

        return target;
      };
      /**
       * Solve Ax=b
       * @method solve
       * @param {Vec3} b The right hand side
       * @param {Vec3} target Optional. Target vector to save in.
       * @return {Vec3} The solution x
       * @todo should reuse arrays
       */


      Mat3.prototype.solve = function (b, target) {
        target = target || new Vec3(); // Construct equations

        var nr = 3; // num rows

        var nc = 4; // num cols

        var eqns = [];

        for (var i = 0; i < nr * nc; i++) {
          eqns.push(0);
        }

        var i, j;

        for (i = 0; i < 3; i++) {
          for (j = 0; j < 3; j++) {
            eqns[i + nc * j] = this.elements[i + 3 * j];
          }
        }

        eqns[3 + 4 * 0] = b.x;
        eqns[3 + 4 * 1] = b.y;
        eqns[3 + 4 * 2] = b.z; // Compute right upper triangular version of the matrix - Gauss elimination

        var n = 3,
            k = n,
            np;
        var kp = 4; // num rows

        var p, els;

        do {
          i = k - n;

          if (eqns[i + nc * i] === 0) {
            // the pivot is null, swap lines
            for (j = i + 1; j < k; j++) {
              if (eqns[i + nc * j] !== 0) {
                np = kp;

                do {
                  // do ligne( i ) = ligne( i ) + ligne( k )
                  p = kp - np;
                  eqns[p + nc * i] += eqns[p + nc * j];
                } while (--np);

                break;
              }
            }
          }

          if (eqns[i + nc * i] !== 0) {
            for (j = i + 1; j < k; j++) {
              var multiplier = eqns[i + nc * j] / eqns[i + nc * i];
              np = kp;

              do {
                // do ligne( k ) = ligne( k ) - multiplier * ligne( i )
                p = kp - np;
                eqns[p + nc * j] = p <= i ? 0 : eqns[p + nc * j] - eqns[p + nc * i] * multiplier;
              } while (--np);
            }
          }
        } while (--n); // Get the solution


        target.z = eqns[2 * nc + 3] / eqns[2 * nc + 2];
        target.y = (eqns[1 * nc + 3] - eqns[1 * nc + 2] * target.z) / eqns[1 * nc + 1];
        target.x = (eqns[0 * nc + 3] - eqns[0 * nc + 2] * target.z - eqns[0 * nc + 1] * target.y) / eqns[0 * nc + 0];

        if (isNaN(target.x) || isNaN(target.y) || isNaN(target.z) || target.x === Infinity || target.y === Infinity || target.z === Infinity) {
          throw "Could not solve equation! Got x=[" + target.toString() + "], b=[" + b.toString() + "], A=[" + this.toString() + "]";
        }

        return target;
      };
      /**
       * Get an element in the matrix by index. Index starts at 0, not 1!!!
       * @method e
       * @param {Number} row
       * @param {Number} column
       * @param {Number} value Optional. If provided, the matrix element will be set to this value.
       * @return {Number}
       */


      Mat3.prototype.e = function (row, column, value) {
        if (value === undefined) {
          return this.elements[column + 3 * row];
        } else {
          // Set value
          this.elements[column + 3 * row] = value;
        }
      };
      /**
       * Copy another matrix into this matrix object.
       * @method copy
       * @param {Mat3} source
       * @return {Mat3} this
       */


      Mat3.prototype.copy = function (source) {
        for (var i = 0; i < source.elements.length; i++) {
          this.elements[i] = source.elements[i];
        }

        return this;
      };
      /**
       * Returns a string representation of the matrix.
       * @method toString
       * @return string
       */


      Mat3.prototype.toString = function () {
        var r = "";
        var sep = ",";

        for (var i = 0; i < 9; i++) {
          r += this.elements[i] + sep;
        }

        return r;
      };
      /**
       * reverse the matrix
       * @method reverse
       * @param {Mat3} target Optional. Target matrix to save in.
       * @return {Mat3} The solution x
       */


      Mat3.prototype.reverse = function (target) {
        target = target || new Mat3(); // Construct equations

        var nr = 3; // num rows

        var nc = 6; // num cols

        var eqns = [];

        for (var i = 0; i < nr * nc; i++) {
          eqns.push(0);
        }

        var i, j;

        for (i = 0; i < 3; i++) {
          for (j = 0; j < 3; j++) {
            eqns[i + nc * j] = this.elements[i + 3 * j];
          }
        }

        eqns[3 + 6 * 0] = 1;
        eqns[3 + 6 * 1] = 0;
        eqns[3 + 6 * 2] = 0;
        eqns[4 + 6 * 0] = 0;
        eqns[4 + 6 * 1] = 1;
        eqns[4 + 6 * 2] = 0;
        eqns[5 + 6 * 0] = 0;
        eqns[5 + 6 * 1] = 0;
        eqns[5 + 6 * 2] = 1; // Compute right upper triangular version of the matrix - Gauss elimination

        var n = 3,
            k = n,
            np;
        var kp = nc; // num rows

        var p;

        do {
          i = k - n;

          if (eqns[i + nc * i] === 0) {
            // the pivot is null, swap lines
            for (j = i + 1; j < k; j++) {
              if (eqns[i + nc * j] !== 0) {
                np = kp;

                do {
                  // do line( i ) = line( i ) + line( k )
                  p = kp - np;
                  eqns[p + nc * i] += eqns[p + nc * j];
                } while (--np);

                break;
              }
            }
          }

          if (eqns[i + nc * i] !== 0) {
            for (j = i + 1; j < k; j++) {
              var multiplier = eqns[i + nc * j] / eqns[i + nc * i];
              np = kp;

              do {
                // do line( k ) = line( k ) - multiplier * line( i )
                p = kp - np;
                eqns[p + nc * j] = p <= i ? 0 : eqns[p + nc * j] - eqns[p + nc * i] * multiplier;
              } while (--np);
            }
          }
        } while (--n); // eliminate the upper left triangle of the matrix


        i = 2;

        do {
          j = i - 1;

          do {
            var multiplier = eqns[i + nc * j] / eqns[i + nc * i];
            np = nc;

            do {
              p = nc - np;
              eqns[p + nc * j] = eqns[p + nc * j] - eqns[p + nc * i] * multiplier;
            } while (--np);
          } while (j--);
        } while (--i); // operations on the diagonal


        i = 2;

        do {
          var multiplier = 1 / eqns[i + nc * i];
          np = nc;

          do {
            p = nc - np;
            eqns[p + nc * i] = eqns[p + nc * i] * multiplier;
          } while (--np);
        } while (i--);

        i = 2;

        do {
          j = 2;

          do {
            p = eqns[nr + j + nc * i];

            if (isNaN(p) || p === Infinity) {
              throw "Could not reverse! A=[" + this.toString() + "]";
            }

            target.e(i, j, p);
          } while (j--);
        } while (i--);

        return target;
      };
      /**
       * Set the matrix from a quaterion
       * @method setRotationFromQuaternion
       * @param {Quaternion} q
       */


      Mat3.prototype.setRotationFromQuaternion = function (q) {
        var x = q.x,
            y = q.y,
            z = q.z,
            w = q.w,
            x2 = x + x,
            y2 = y + y,
            z2 = z + z,
            xx = x * x2,
            xy = x * y2,
            xz = x * z2,
            yy = y * y2,
            yz = y * z2,
            zz = z * z2,
            wx = w * x2,
            wy = w * y2,
            wz = w * z2,
            e = this.elements;
        e[3 * 0 + 0] = 1 - (yy + zz);
        e[3 * 0 + 1] = xy - wz;
        e[3 * 0 + 2] = xz + wy;
        e[3 * 1 + 0] = xy + wz;
        e[3 * 1 + 1] = 1 - (xx + zz);
        e[3 * 1 + 2] = yz - wx;
        e[3 * 2 + 0] = xz - wy;
        e[3 * 2 + 1] = yz + wx;
        e[3 * 2 + 2] = 1 - (xx + yy);
        return this;
      };
      /**
       * Transpose the matrix
       * @method transpose
       * @param  {Mat3} target Where to store the result.
       * @return {Mat3} The target Mat3, or a new Mat3 if target was omitted.
       */


      Mat3.prototype.transpose = function (target) {
        target = target || new Mat3();
        var Mt = target.elements,
            M = this.elements;

        for (var i = 0; i !== 3; i++) {
          for (var j = 0; j !== 3; j++) {
            Mt[3 * i + j] = M[3 * j + i];
          }
        }

        return target;
      };
    }, {
      "./Vec3": 31
    }],
    29: [function (_dereq_, module, exports) {
      module.exports = Quaternion;

      var Vec3 = _dereq_('./Vec3');
      /**
       * A Quaternion describes a rotation in 3D space. The Quaternion is mathematically defined as Q = x*i + y*j + z*k + w, where (i,j,k) are imaginary basis vectors. (x,y,z) can be seen as a vector related to the axis of rotation, while the real multiplier, w, is related to the amount of rotation.
       * @class Quaternion
       * @constructor
       * @param {Number} x Multiplier of the imaginary basis vector i.
       * @param {Number} y Multiplier of the imaginary basis vector j.
       * @param {Number} z Multiplier of the imaginary basis vector k.
       * @param {Number} w Multiplier of the real part.
       * @see http://en.wikipedia.org/wiki/Quaternion
       */


      function Quaternion(x, y, z, w) {
        /**
         * @property {Number} x
         */
        this.x = x !== undefined ? x : 0;
        /**
         * @property {Number} y
         */

        this.y = y !== undefined ? y : 0;
        /**
         * @property {Number} z
         */

        this.z = z !== undefined ? z : 0;
        /**
         * The multiplier of the real quaternion basis vector.
         * @property {Number} w
         */

        this.w = w !== undefined ? w : 1;
      }
      /**
       * Set the value of the quaternion.
       * @method set
       * @param {Number} x
       * @param {Number} y
       * @param {Number} z
       * @param {Number} w
       */


      Quaternion.prototype.set = function (x, y, z, w) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
        return this;
      };
      /**
       * Convert to a readable format
       * @method toString
       * @return string
       */


      Quaternion.prototype.toString = function () {
        return this.x + "," + this.y + "," + this.z + "," + this.w;
      };
      /**
       * Convert to an Array
       * @method toArray
       * @return Array
       */


      Quaternion.prototype.toArray = function () {
        return [this.x, this.y, this.z, this.w];
      };
      /**
       * Set the quaternion components given an axis and an angle.
       * @method setFromAxisAngle
       * @param {Vec3} axis
       * @param {Number} angle in radians
       */


      Quaternion.prototype.setFromAxisAngle = function (axis, angle) {
        var s = Math.sin(angle * 0.5);
        this.x = axis.x * s;
        this.y = axis.y * s;
        this.z = axis.z * s;
        this.w = Math.cos(angle * 0.5);
        return this;
      };
      /**
       * Converts the quaternion to axis/angle representation.
       * @method toAxisAngle
       * @param {Vec3} [targetAxis] A vector object to reuse for storing the axis.
       * @return {Array} An array, first elemnt is the axis and the second is the angle in radians.
       */


      Quaternion.prototype.toAxisAngle = function (targetAxis) {
        targetAxis = targetAxis || new Vec3();
        this.normalize(); // if w>1 acos and sqrt will produce errors, this cant happen if quaternion is normalised

        var angle = 2 * Math.acos(this.w);
        var s = Math.sqrt(1 - this.w * this.w); // assuming quaternion normalised then w is less than 1, so term always positive.

        if (s < 0.001) {
          // test to avoid divide by zero, s is always positive due to sqrt
          // if s close to zero then direction of axis not important
          targetAxis.x = this.x; // if it is important that axis is normalised then replace with x=1; y=z=0;

          targetAxis.y = this.y;
          targetAxis.z = this.z;
        } else {
          targetAxis.x = this.x / s; // normalise axis

          targetAxis.y = this.y / s;
          targetAxis.z = this.z / s;
        }

        return [targetAxis, angle];
      };

      var sfv_t1 = new Vec3(),
          sfv_t2 = new Vec3();
      /**
       * Set the quaternion value given two vectors. The resulting rotation will be the needed rotation to rotate u to v.
       * @method setFromVectors
       * @param {Vec3} u
       * @param {Vec3} v
       */

      Quaternion.prototype.setFromVectors = function (u, v) {
        if (u.isAntiparallelTo(v)) {
          var t1 = sfv_t1;
          var t2 = sfv_t2;
          u.tangents(t1, t2);
          this.setFromAxisAngle(t1, Math.PI);
        } else {
          var a = u.cross(v);
          this.x = a.x;
          this.y = a.y;
          this.z = a.z;
          this.w = Math.sqrt(Math.pow(u.norm(), 2) * Math.pow(v.norm(), 2)) + u.dot(v);
          this.normalize();
        }

        return this;
      };
      /**
       * Quaternion multiplication
       * @method mult
       * @param {Quaternion} q
       * @param {Quaternion} target Optional.
       * @return {Quaternion}
       */


      var Quaternion_mult_va = new Vec3();
      var Quaternion_mult_vb = new Vec3();
      var Quaternion_mult_vaxvb = new Vec3();

      Quaternion.prototype.mult = function (q, target) {
        target = target || new Quaternion();
        var ax = this.x,
            ay = this.y,
            az = this.z,
            aw = this.w,
            bx = q.x,
            by = q.y,
            bz = q.z,
            bw = q.w;
        target.x = ax * bw + aw * bx + ay * bz - az * by;
        target.y = ay * bw + aw * by + az * bx - ax * bz;
        target.z = az * bw + aw * bz + ax * by - ay * bx;
        target.w = aw * bw - ax * bx - ay * by - az * bz;
        return target;
      };
      /**
       * Get the inverse quaternion rotation.
       * @method inverse
       * @param {Quaternion} target
       * @return {Quaternion}
       */


      Quaternion.prototype.inverse = function (target) {
        var x = this.x,
            y = this.y,
            z = this.z,
            w = this.w;
        target = target || new Quaternion();
        this.conjugate(target);
        var inorm2 = 1 / (x * x + y * y + z * z + w * w);
        target.x *= inorm2;
        target.y *= inorm2;
        target.z *= inorm2;
        target.w *= inorm2;
        return target;
      };
      /**
       * Get the quaternion conjugate
       * @method conjugate
       * @param {Quaternion} target
       * @return {Quaternion}
       */


      Quaternion.prototype.conjugate = function (target) {
        target = target || new Quaternion();
        target.x = -this.x;
        target.y = -this.y;
        target.z = -this.z;
        target.w = this.w;
        return target;
      };
      /**
       * Normalize the quaternion. Note that this changes the values of the quaternion.
       * @method normalize
       */


      Quaternion.prototype.normalize = function () {
        var l = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);

        if (l === 0) {
          this.x = 0;
          this.y = 0;
          this.z = 0;
          this.w = 0;
        } else {
          l = 1 / l;
          this.x *= l;
          this.y *= l;
          this.z *= l;
          this.w *= l;
        }

        return this;
      };
      /**
       * Approximation of quaternion normalization. Works best when quat is already almost-normalized.
       * @method normalizeFast
       * @see http://jsperf.com/fast-quaternion-normalization
       * @author unphased, https://github.com/unphased
       */


      Quaternion.prototype.normalizeFast = function () {
        var f = (3.0 - (this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)) / 2.0;

        if (f === 0) {
          this.x = 0;
          this.y = 0;
          this.z = 0;
          this.w = 0;
        } else {
          this.x *= f;
          this.y *= f;
          this.z *= f;
          this.w *= f;
        }

        return this;
      };
      /**
       * Multiply the quaternion by a vector
       * @method vmult
       * @param {Vec3} v
       * @param {Vec3} target Optional
       * @return {Vec3}
       */


      Quaternion.prototype.vmult = function (v, target) {
        target = target || new Vec3();
        var x = v.x,
            y = v.y,
            z = v.z;
        var qx = this.x,
            qy = this.y,
            qz = this.z,
            qw = this.w; // q*v

        var ix = qw * x + qy * z - qz * y,
            iy = qw * y + qz * x - qx * z,
            iz = qw * z + qx * y - qy * x,
            iw = -qx * x - qy * y - qz * z;
        target.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
        target.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
        target.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
        return target;
      };
      /**
       * Copies value of source to this quaternion.
       * @method copy
       * @param {Quaternion} source
       * @return {Quaternion} this
       */


      Quaternion.prototype.copy = function (source) {
        this.x = source.x;
        this.y = source.y;
        this.z = source.z;
        this.w = source.w;
        return this;
      };
      /**
       * Convert the quaternion to euler angle representation. Order: YZX, as this page describes: http://www.euclideanspace.com/maths/standards/index.htm
       * @method toEuler
       * @param {Vec3} target
       * @param string order Three-character string e.g. "YZX", which also is default.
       */


      Quaternion.prototype.toEuler = function (target, order) {
        order = order || "YZX";
        var heading, attitude, bank;
        var x = this.x,
            y = this.y,
            z = this.z,
            w = this.w;

        switch (order) {
          case "YZX":
            var test = x * y + z * w;

            if (test > 0.499) {
              // singularity at north pole
              heading = 2 * Math.atan2(x, w);
              attitude = Math.PI / 2;
              bank = 0;
            }

            if (test < -0.499) {
              // singularity at south pole
              heading = -2 * Math.atan2(x, w);
              attitude = -Math.PI / 2;
              bank = 0;
            }

            if (isNaN(heading)) {
              var sqx = x * x;
              var sqy = y * y;
              var sqz = z * z;
              heading = Math.atan2(2 * y * w - 2 * x * z, 1 - 2 * sqy - 2 * sqz); // Heading

              attitude = Math.asin(2 * test); // attitude

              bank = Math.atan2(2 * x * w - 2 * y * z, 1 - 2 * sqx - 2 * sqz); // bank
            }

            break;

          default:
            throw new Error("Euler order " + order + " not supported yet.");
        }

        target.y = heading;
        target.z = attitude;
        target.x = bank;
      };
      /**
       * See http://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/content/SpinCalc.m
       * @method setFromEuler
       * @param {Number} x
       * @param {Number} y
       * @param {Number} z
       * @param {String} order The order to apply angles: 'XYZ' or 'YXZ' or any other combination
       */


      Quaternion.prototype.setFromEuler = function (x, y, z, order) {
        order = order || "XYZ";
        var c1 = Math.cos(x / 2);
        var c2 = Math.cos(y / 2);
        var c3 = Math.cos(z / 2);
        var s1 = Math.sin(x / 2);
        var s2 = Math.sin(y / 2);
        var s3 = Math.sin(z / 2);

        if (order === 'XYZ') {
          this.x = s1 * c2 * c3 + c1 * s2 * s3;
          this.y = c1 * s2 * c3 - s1 * c2 * s3;
          this.z = c1 * c2 * s3 + s1 * s2 * c3;
          this.w = c1 * c2 * c3 - s1 * s2 * s3;
        } else if (order === 'YXZ') {
          this.x = s1 * c2 * c3 + c1 * s2 * s3;
          this.y = c1 * s2 * c3 - s1 * c2 * s3;
          this.z = c1 * c2 * s3 - s1 * s2 * c3;
          this.w = c1 * c2 * c3 + s1 * s2 * s3;
        } else if (order === 'ZXY') {
          this.x = s1 * c2 * c3 - c1 * s2 * s3;
          this.y = c1 * s2 * c3 + s1 * c2 * s3;
          this.z = c1 * c2 * s3 + s1 * s2 * c3;
          this.w = c1 * c2 * c3 - s1 * s2 * s3;
        } else if (order === 'ZYX') {
          this.x = s1 * c2 * c3 - c1 * s2 * s3;
          this.y = c1 * s2 * c3 + s1 * c2 * s3;
          this.z = c1 * c2 * s3 - s1 * s2 * c3;
          this.w = c1 * c2 * c3 + s1 * s2 * s3;
        } else if (order === 'YZX') {
          this.x = s1 * c2 * c3 + c1 * s2 * s3;
          this.y = c1 * s2 * c3 + s1 * c2 * s3;
          this.z = c1 * c2 * s3 - s1 * s2 * c3;
          this.w = c1 * c2 * c3 - s1 * s2 * s3;
        } else if (order === 'XZY') {
          this.x = s1 * c2 * c3 - c1 * s2 * s3;
          this.y = c1 * s2 * c3 - s1 * c2 * s3;
          this.z = c1 * c2 * s3 + s1 * s2 * c3;
          this.w = c1 * c2 * c3 + s1 * s2 * s3;
        }

        return this;
      };
      /**
       * @method clone
       * @return {Quaternion}
       */


      Quaternion.prototype.clone = function () {
        return new Quaternion(this.x, this.y, this.z, this.w);
      };
      /**
       * Performs a spherical linear interpolation between two quat
       *
       * @method slerp
       * @param {Quaternion} toQuat second operand
       * @param {Number} t interpolation amount between the self quaternion and toQuat
       * @param {Quaternion} [target] A quaternion to store the result in. If not provided, a new one will be created.
       * @returns {Quaternion} The "target" object
       */


      Quaternion.prototype.slerp = function (toQuat, t, target) {
        target = target || new Quaternion();
        var ax = this.x,
            ay = this.y,
            az = this.z,
            aw = this.w,
            bx = toQuat.x,
            by = toQuat.y,
            bz = toQuat.z,
            bw = toQuat.w;
        var omega, cosom, sinom, scale0, scale1; // calc cosine

        cosom = ax * bx + ay * by + az * bz + aw * bw; // adjust signs (if necessary)

        if (cosom < 0.0) {
          cosom = -cosom;
          bx = -bx;
          by = -by;
          bz = -bz;
          bw = -bw;
        } // calculate coefficients


        if (1.0 - cosom > 0.000001) {
          // standard case (slerp)
          omega = Math.acos(cosom);
          sinom = Math.sin(omega);
          scale0 = Math.sin((1.0 - t) * omega) / sinom;
          scale1 = Math.sin(t * omega) / sinom;
        } else {
          // "from" and "to" quaternions are very close
          //  ... so we can do a linear interpolation
          scale0 = 1.0 - t;
          scale1 = t;
        } // calculate final values


        target.x = scale0 * ax + scale1 * bx;
        target.y = scale0 * ay + scale1 * by;
        target.z = scale0 * az + scale1 * bz;
        target.w = scale0 * aw + scale1 * bw;
        return target;
      };
      /**
       * Rotate an absolute orientation quaternion given an angular velocity and a time step.
       * @param  {Vec3} angularVelocity
       * @param  {number} dt
       * @param  {Vec3} angularFactor
       * @param  {Quaternion} target
       * @return {Quaternion} The "target" object
       */


      Quaternion.prototype.integrate = function (angularVelocity, dt, angularFactor, target) {
        target = target || new Quaternion();
        var ax = angularVelocity.x * angularFactor.x,
            ay = angularVelocity.y * angularFactor.y,
            az = angularVelocity.z * angularFactor.z,
            bx = this.x,
            by = this.y,
            bz = this.z,
            bw = this.w;
        var half_dt = dt * 0.5;
        target.x += half_dt * (ax * bw + ay * bz - az * by);
        target.y += half_dt * (ay * bw + az * bx - ax * bz);
        target.z += half_dt * (az * bw + ax * by - ay * bx);
        target.w += half_dt * (-ax * bx - ay * by - az * bz);
        return target;
      };
    }, {
      "./Vec3": 31
    }],
    30: [function (_dereq_, module, exports) {
      var Vec3 = _dereq_('./Vec3');

      var Quaternion = _dereq_('./Quaternion');

      module.exports = Transform;
      /**
       * @class Transform
       * @constructor
       */

      function Transform(options) {
        options = options || {};
        /**
         * @property {Vec3} position
         */

        this.position = new Vec3();

        if (options.position) {
          this.position.copy(options.position);
        }
        /**
         * @property {Quaternion} quaternion
         */


        this.quaternion = new Quaternion();

        if (options.quaternion) {
          this.quaternion.copy(options.quaternion);
        }
      }

      var tmpQuat = new Quaternion();
      /**
       * @static
       * @method pointToLocaFrame
       * @param {Vec3} position
       * @param {Quaternion} quaternion
       * @param {Vec3} worldPoint
       * @param {Vec3} result
       */

      Transform.pointToLocalFrame = function (position, quaternion, worldPoint, result) {
        var result = result || new Vec3();
        worldPoint.vsub(position, result);
        quaternion.conjugate(tmpQuat);
        tmpQuat.vmult(result, result);
        return result;
      };
      /**
       * Get a global point in local transform coordinates.
       * @method pointToLocal
       * @param  {Vec3} point
       * @param  {Vec3} result
       * @return {Vec3} The "result" vector object
       */


      Transform.prototype.pointToLocal = function (worldPoint, result) {
        return Transform.pointToLocalFrame(this.position, this.quaternion, worldPoint, result);
      };
      /**
       * @static
       * @method pointToWorldFrame
       * @param {Vec3} position
       * @param {Vec3} quaternion
       * @param {Vec3} localPoint
       * @param {Vec3} result
       */


      Transform.pointToWorldFrame = function (position, quaternion, localPoint, result) {
        var result = result || new Vec3();
        quaternion.vmult(localPoint, result);
        result.vadd(position, result);
        return result;
      };
      /**
       * Get a local point in global transform coordinates.
       * @method pointToWorld
       * @param  {Vec3} point
       * @param  {Vec3} result
       * @return {Vec3} The "result" vector object
       */


      Transform.prototype.pointToWorld = function (localPoint, result) {
        return Transform.pointToWorldFrame(this.position, this.quaternion, localPoint, result);
      };

      Transform.prototype.vectorToWorldFrame = function (localVector, result) {
        var result = result || new Vec3();
        this.quaternion.vmult(localVector, result);
        return result;
      };

      Transform.vectorToWorldFrame = function (quaternion, localVector, result) {
        quaternion.vmult(localVector, result);
        return result;
      };

      Transform.vectorToLocalFrame = function (position, quaternion, worldVector, result) {
        var result = result || new Vec3();
        quaternion.w *= -1;
        quaternion.vmult(worldVector, result);
        quaternion.w *= -1;
        return result;
      };
    }, {
      "./Quaternion": 29,
      "./Vec3": 31
    }],
    31: [function (_dereq_, module, exports) {
      module.exports = Vec3;

      var Mat3 = _dereq_('./Mat3');
      /**
       * 3-dimensional vector
       * @class Vec3
       * @constructor
       * @param {Number} x
       * @param {Number} y
       * @param {Number} z
       * @author schteppe
       * @example
       *     var v = new Vec3(1, 2, 3);
       *     console.log('x=' + v.x); // x=1
       */


      function Vec3(x, y, z) {
        /**
         * @property x
         * @type {Number}
         */
        this.x = x || 0.0;
        /**
         * @property y
         * @type {Number}
         */

        this.y = y || 0.0;
        /**
         * @property z
         * @type {Number}
         */

        this.z = z || 0.0;
      }
      /**
       * @static
       * @property {Vec3} ZERO
       */


      Vec3.ZERO = new Vec3(0, 0, 0);
      /**
       * @static
       * @property {Vec3} UNIT_X
       */

      Vec3.UNIT_X = new Vec3(1, 0, 0);
      /**
       * @static
       * @property {Vec3} UNIT_Y
       */

      Vec3.UNIT_Y = new Vec3(0, 1, 0);
      /**
       * @static
       * @property {Vec3} UNIT_Z
       */

      Vec3.UNIT_Z = new Vec3(0, 0, 1);
      /**
       * Vector cross product
       * @method cross
       * @param {Vec3} v
       * @param {Vec3} target Optional. Target to save in.
       * @return {Vec3}
       */

      Vec3.prototype.cross = function (v, target) {
        var vx = v.x,
            vy = v.y,
            vz = v.z,
            x = this.x,
            y = this.y,
            z = this.z;
        target = target || new Vec3();
        target.x = y * vz - z * vy;
        target.y = z * vx - x * vz;
        target.z = x * vy - y * vx;
        return target;
      };
      /**
       * Set the vectors' 3 elements
       * @method set
       * @param {Number} x
       * @param {Number} y
       * @param {Number} z
       * @return Vec3
       */


      Vec3.prototype.set = function (x, y, z) {
        this.x = x;
        this.y = y;
        this.z = z;
        return this;
      };
      /**
       * Set all components of the vector to zero.
       * @method setZero
       */


      Vec3.prototype.setZero = function () {
        this.x = this.y = this.z = 0;
      };
      /**
       * Vector addition
       * @method vadd
       * @param {Vec3} v
       * @param {Vec3} target Optional.
       * @return {Vec3}
       */


      Vec3.prototype.vadd = function (v, target) {
        if (target) {
          target.x = v.x + this.x;
          target.y = v.y + this.y;
          target.z = v.z + this.z;
        } else {
          return new Vec3(this.x + v.x, this.y + v.y, this.z + v.z);
        }
      };
      /**
       * Vector subtraction
       * @method vsub
       * @param {Vec3} v
       * @param {Vec3} target Optional. Target to save in.
       * @return {Vec3}
       */


      Vec3.prototype.vsub = function (v, target) {
        if (target) {
          target.x = this.x - v.x;
          target.y = this.y - v.y;
          target.z = this.z - v.z;
        } else {
          return new Vec3(this.x - v.x, this.y - v.y, this.z - v.z);
        }
      };
      /**
       * Get the cross product matrix a_cross from a vector, such that a x b = a_cross * b = c
       * @method crossmat
       * @see http://www8.cs.umu.se/kurser/TDBD24/VT06/lectures/Lecture6.pdf
       * @return {Mat3}
       */


      Vec3.prototype.crossmat = function () {
        return new Mat3([0, -this.z, this.y, this.z, 0, -this.x, -this.y, this.x, 0]);
      };
      /**
       * Normalize the vector. Note that this changes the values in the vector.
       * @method normalize
       * @return {Number} Returns the norm of the vector
       */


      Vec3.prototype.normalize = function () {
        var x = this.x,
            y = this.y,
            z = this.z;
        var n = Math.sqrt(x * x + y * y + z * z);

        if (n > 0.0) {
          var invN = 1 / n;
          this.x *= invN;
          this.y *= invN;
          this.z *= invN;
        } else {
          // Make something up
          this.x = 0;
          this.y = 0;
          this.z = 0;
        }

        return n;
      };
      /**
       * Get the version of this vector that is of length 1.
       * @method unit
       * @param {Vec3} target Optional target to save in
       * @return {Vec3} Returns the unit vector
       */


      Vec3.prototype.unit = function (target) {
        target = target || new Vec3();
        var x = this.x,
            y = this.y,
            z = this.z;
        var ninv = Math.sqrt(x * x + y * y + z * z);

        if (ninv > 0.0) {
          ninv = 1.0 / ninv;
          target.x = x * ninv;
          target.y = y * ninv;
          target.z = z * ninv;
        } else {
          target.x = 1;
          target.y = 0;
          target.z = 0;
        }

        return target;
      };
      /**
       * Get the length of the vector
       * @method norm
       * @return {Number}
       * @deprecated Use .length() instead
       */


      Vec3.prototype.norm = function () {
        var x = this.x,
            y = this.y,
            z = this.z;
        return Math.sqrt(x * x + y * y + z * z);
      };
      /**
       * Get the length of the vector
       * @method length
       * @return {Number}
       */


      Vec3.prototype.length = Vec3.prototype.norm;
      /**
       * Get the squared length of the vector
       * @method norm2
       * @return {Number}
       * @deprecated Use .lengthSquared() instead.
       */

      Vec3.prototype.norm2 = function () {
        return this.dot(this);
      };
      /**
       * Get the squared length of the vector.
       * @method lengthSquared
       * @return {Number}
       */


      Vec3.prototype.lengthSquared = Vec3.prototype.norm2;
      /**
       * Get distance from this point to another point
       * @method distanceTo
       * @param  {Vec3} p
       * @return {Number}
       */

      Vec3.prototype.distanceTo = function (p) {
        var x = this.x,
            y = this.y,
            z = this.z;
        var px = p.x,
            py = p.y,
            pz = p.z;
        return Math.sqrt((px - x) * (px - x) + (py - y) * (py - y) + (pz - z) * (pz - z));
      };
      /**
       * Get squared distance from this point to another point
       * @method distanceSquared
       * @param  {Vec3} p
       * @return {Number}
       */


      Vec3.prototype.distanceSquared = function (p) {
        var x = this.x,
            y = this.y,
            z = this.z;
        var px = p.x,
            py = p.y,
            pz = p.z;
        return (px - x) * (px - x) + (py - y) * (py - y) + (pz - z) * (pz - z);
      };
      /**
       * Multiply all the components of the vector with a scalar.
       * @deprecated Use .scale instead
       * @method mult
       * @param {Number} scalar
       * @param {Vec3} target The vector to save the result in.
       * @return {Vec3}
       * @deprecated Use .scale() instead
       */


      Vec3.prototype.mult = function (scalar, target) {
        target = target || new Vec3();
        var x = this.x,
            y = this.y,
            z = this.z;
        target.x = scalar * x;
        target.y = scalar * y;
        target.z = scalar * z;
        return target;
      };
      /**
       * Multiply the vector with an other vector, component-wise.
       * @method mult
       * @param {Number} vector
       * @param {Vec3} target The vector to save the result in.
       * @return {Vec3}
       */


      Vec3.prototype.vmul = function (vector, target) {
        target = target || new Vec3();
        target.x = vector.x * this.x;
        target.y = vector.y * this.y;
        target.z = vector.z * this.z;
        return target;
      };
      /**
       * Multiply the vector with a scalar.
       * @method scale
       * @param {Number} scalar
       * @param {Vec3} target
       * @return {Vec3}
       */


      Vec3.prototype.scale = Vec3.prototype.mult;
      /**
       * Scale a vector and add it to this vector. Save the result in "target". (target = this + vector * scalar)
       * @method addScaledVector
       * @param {Number} scalar
       * @param {Vec3} vector
       * @param {Vec3} target The vector to save the result in.
       * @return {Vec3}
       */

      Vec3.prototype.addScaledVector = function (scalar, vector, target) {
        target = target || new Vec3();
        target.x = this.x + scalar * vector.x;
        target.y = this.y + scalar * vector.y;
        target.z = this.z + scalar * vector.z;
        return target;
      };
      /**
       * Calculate dot product
       * @method dot
       * @param {Vec3} v
       * @return {Number}
       */


      Vec3.prototype.dot = function (v) {
        return this.x * v.x + this.y * v.y + this.z * v.z;
      };
      /**
       * @method isZero
       * @return bool
       */


      Vec3.prototype.isZero = function () {
        return this.x === 0 && this.y === 0 && this.z === 0;
      };
      /**
       * Make the vector point in the opposite direction.
       * @method negate
       * @param {Vec3} target Optional target to save in
       * @return {Vec3}
       */


      Vec3.prototype.negate = function (target) {
        target = target || new Vec3();
        target.x = -this.x;
        target.y = -this.y;
        target.z = -this.z;
        return target;
      };
      /**
       * Compute two artificial tangents to the vector
       * @method tangents
       * @param {Vec3} t1 Vector object to save the first tangent in
       * @param {Vec3} t2 Vector object to save the second tangent in
       */


      var Vec3_tangents_n = new Vec3();
      var Vec3_tangents_randVec = new Vec3();

      Vec3.prototype.tangents = function (t1, t2) {
        var norm = this.norm();

        if (norm > 0.0) {
          var n = Vec3_tangents_n;
          var inorm = 1 / norm;
          n.set(this.x * inorm, this.y * inorm, this.z * inorm);
          var randVec = Vec3_tangents_randVec;

          if (Math.abs(n.x) < 0.9) {
            randVec.set(1, 0, 0);
            n.cross(randVec, t1);
          } else {
            randVec.set(0, 1, 0);
            n.cross(randVec, t1);
          }

          n.cross(t1, t2);
        } else {
          // The normal length is zero, make something up
          t1.set(1, 0, 0);
          t2.set(0, 1, 0);
        }
      };
      /**
       * Converts to a more readable format
       * @method toString
       * @return string
       */


      Vec3.prototype.toString = function () {
        return this.x + "," + this.y + "," + this.z;
      };
      /**
       * Converts to an array
       * @method toArray
       * @return Array
       */


      Vec3.prototype.toArray = function () {
        return [this.x, this.y, this.z];
      };
      /**
       * Copies value of source to this vector.
       * @method copy
       * @param {Vec3} source
       * @return {Vec3} this
       */


      Vec3.prototype.copy = function (source) {
        this.x = source.x;
        this.y = source.y;
        this.z = source.z;
        return this;
      };
      /**
       * Do a linear interpolation between two vectors
       * @method lerp
       * @param {Vec3} v
       * @param {Number} t A number between 0 and 1. 0 will make this function return u, and 1 will make it return v. Numbers in between will generate a vector in between them.
       * @param {Vec3} target
       */


      Vec3.prototype.lerp = function (v, t, target) {
        var x = this.x,
            y = this.y,
            z = this.z;
        target.x = x + (v.x - x) * t;
        target.y = y + (v.y - y) * t;
        target.z = z + (v.z - z) * t;
      };
      /**
       * Check if a vector equals is almost equal to another one.
       * @method almostEquals
       * @param {Vec3} v
       * @param {Number} precision
       * @return bool
       */


      Vec3.prototype.almostEquals = function (v, precision) {
        if (precision === undefined) {
          precision = 1e-6;
        }

        if (Math.abs(this.x - v.x) > precision || Math.abs(this.y - v.y) > precision || Math.abs(this.z - v.z) > precision) {
          return false;
        }

        return true;
      };
      /**
       * Check if a vector is almost zero
       * @method almostZero
       * @param {Number} precision
       */


      Vec3.prototype.almostZero = function (precision) {
        if (precision === undefined) {
          precision = 1e-6;
        }

        if (Math.abs(this.x) > precision || Math.abs(this.y) > precision || Math.abs(this.z) > precision) {
          return false;
        }

        return true;
      };

      var antip_neg = new Vec3();
      /**
       * Check if the vector is anti-parallel to another vector.
       * @method isAntiparallelTo
       * @param  {Vec3}  v
       * @param  {Number}  precision Set to zero for exact comparisons
       * @return {Boolean}
       */

      Vec3.prototype.isAntiparallelTo = function (v, precision) {
        this.negate(antip_neg);
        return antip_neg.almostEquals(v, precision);
      };
      /**
       * Clone the vector
       * @method clone
       * @return {Vec3}
       */


      Vec3.prototype.clone = function () {
        return new Vec3(this.x, this.y, this.z);
      };
    }, {
      "./Mat3": 28
    }],
    32: [function (_dereq_, module, exports) {
      module.exports = Body;

      var EventTarget = _dereq_('../utils/EventTarget');

      var Shape = _dereq_('../shapes/Shape');

      var Vec3 = _dereq_('../math/Vec3');

      var Mat3 = _dereq_('../math/Mat3');

      var Quaternion = _dereq_('../math/Quaternion');

      var Material = _dereq_('../material/Material');

      var AABB = _dereq_('../collision/AABB');

      var Box = _dereq_('../shapes/Box');

      var World = _dereq_('../world/World');
      /**
       * Base class for all body types.
       * @class Body
       * @constructor
       * @extends EventTarget
       * @param {object} [options]
       * @param {Vec3} [options.position]
       * @param {Vec3} [options.velocity]
       * @param {Vec3} [options.angularVelocity]
       * @param {Quaternion} [options.quaternion]
       * @param {number} [options.mass]
       * @param {Material} [options.material]
       * @param {number} [options.type]
       * @param {number} [options.linearDamping=0.01]
       * @param {number} [options.angularDamping=0.01]
       * @param {boolean} [options.allowSleep=true]
       * @param {number} [options.sleepSpeedLimit=0.1]
       * @param {number} [options.sleepTimeLimit=1]
       * @param {number} [options.collisionFilterGroup=1]
       * @param {number} [options.collisionFilterMask=-1]
       * @param {boolean} [options.fixedRotation=false]
       * @param {Vec3} [options.linearFactor]
       * @param {Vec3} [options.angularFactor]
       * @param {Shape} [options.shape]
       * @example
       *     var body = new Body({
       *         mass: 1
       *     });
       *     var shape = new Sphere(1);
       *     body.addShape(shape);
       *     world.addBody(body);
       */


      function Body(options) {
        options = options || {};
        EventTarget.apply(this);
        this.id = Body.idCounter++;
        /**
         * Reference to the world the body is living in
         * @property world
         * @type {World}
         */

        this.world = null;
        /**
         * Callback function that is used BEFORE stepping the system. Use it to apply forces, for example. Inside the function, "this" will refer to this Body object.
         * @property preStep
         * @type {Function}
         * @deprecated Use World events instead
         */

        this.preStep = null;
        /**
         * Callback function that is used AFTER stepping the system. Inside the function, "this" will refer to this Body object.
         * @property postStep
         * @type {Function}
         * @deprecated Use World events instead
         */

        this.postStep = null;
        this.vlambda = new Vec3();
        /**
         * @property {Number} collisionFilterGroup
         */

        this.collisionFilterGroup = typeof options.collisionFilterGroup === 'number' ? options.collisionFilterGroup : 1;
        /**
         * @property {Number} collisionFilterMask
         */

        this.collisionFilterMask = typeof options.collisionFilterMask === 'number' ? options.collisionFilterMask : -1;
        /**
         * Whether to produce contact forces when in contact with other bodies. Note that contacts will be generated, but they will be disabled.
         * @property {Number} collisionResponse
         */

        this.collisionResponse = true;
        /**
         * World space position of the body.
         * @property position
         * @type {Vec3}
         */

        this.position = new Vec3();
        /**
         * @property {Vec3} previousPosition
         */

        this.previousPosition = new Vec3();
        /**
         * Interpolated position of the body.
         * @property {Vec3} interpolatedPosition
         */

        this.interpolatedPosition = new Vec3();
        /**
         * Initial position of the body
         * @property initPosition
         * @type {Vec3}
         */

        this.initPosition = new Vec3();

        if (options.position) {
          this.position.copy(options.position);
          this.previousPosition.copy(options.position);
          this.interpolatedPosition.copy(options.position);
          this.initPosition.copy(options.position);
        }
        /**
         * World space velocity of the body.
         * @property velocity
         * @type {Vec3}
         */


        this.velocity = new Vec3();

        if (options.velocity) {
          this.velocity.copy(options.velocity);
        }
        /**
         * @property initVelocity
         * @type {Vec3}
         */


        this.initVelocity = new Vec3();
        /**
         * Linear force on the body in world space.
         * @property force
         * @type {Vec3}
         */

        this.force = new Vec3();
        var mass = typeof options.mass === 'number' ? options.mass : 0;
        /**
         * @property mass
         * @type {Number}
         * @default 0
         */

        this.mass = mass;
        /**
         * @property invMass
         * @type {Number}
         */

        this.invMass = mass > 0 ? 1.0 / mass : 0;
        /**
         * @property material
         * @type {Material}
         */

        this.material = options.material || null;
        /**
         * @property linearDamping
         * @type {Number}
         */

        this.linearDamping = typeof options.linearDamping === 'number' ? options.linearDamping : 0.01;
        /**
         * One of: Body.DYNAMIC, Body.STATIC and Body.KINEMATIC.
         * @property type
         * @type {Number}
         */

        this.type = mass <= 0.0 ? Body.STATIC : Body.DYNAMIC;

        if (typeof options.type === typeof Body.STATIC) {
          this.type = options.type;
        }
        /**
         * If true, the body will automatically fall to sleep.
         * @property allowSleep
         * @type {Boolean}
         * @default true
         */


        this.allowSleep = typeof options.allowSleep !== 'undefined' ? options.allowSleep : true;
        /**
         * Current sleep state.
         * @property sleepState
         * @type {Number}
         */

        this.sleepState = 0;
        /**
         * If the speed (the norm of the velocity) is smaller than this value, the body is considered sleepy.
         * @property sleepSpeedLimit
         * @type {Number}
         * @default 0.1
         */

        this.sleepSpeedLimit = typeof options.sleepSpeedLimit !== 'undefined' ? options.sleepSpeedLimit : 0.1;
        /**
         * If the body has been sleepy for this sleepTimeLimit seconds, it is considered sleeping.
         * @property sleepTimeLimit
         * @type {Number}
         * @default 1
         */

        this.sleepTimeLimit = typeof options.sleepTimeLimit !== 'undefined' ? options.sleepTimeLimit : 1;
        this.timeLastSleepy = 0;
        this._wakeUpAfterNarrowphase = false;
        /**
         * World space rotational force on the body, around center of mass.
         * @property {Vec3} torque
         */

        this.torque = new Vec3();
        /**
         * World space orientation of the body.
         * @property quaternion
         * @type {Quaternion}
         */

        this.quaternion = new Quaternion();
        /**
         * @property initQuaternion
         * @type {Quaternion}
         */

        this.initQuaternion = new Quaternion();
        /**
         * @property {Quaternion} previousQuaternion
         */

        this.previousQuaternion = new Quaternion();
        /**
         * Interpolated orientation of the body.
         * @property {Quaternion} interpolatedQuaternion
         */

        this.interpolatedQuaternion = new Quaternion();

        if (options.quaternion) {
          this.quaternion.copy(options.quaternion);
          this.initQuaternion.copy(options.quaternion);
          this.previousQuaternion.copy(options.quaternion);
          this.interpolatedQuaternion.copy(options.quaternion);
        }
        /**
         * Angular velocity of the body, in world space. Think of the angular velocity as a vector, which the body rotates around. The length of this vector determines how fast (in radians per second) the body rotates.
         * @property angularVelocity
         * @type {Vec3}
         */


        this.angularVelocity = new Vec3();

        if (options.angularVelocity) {
          this.angularVelocity.copy(options.angularVelocity);
        }
        /**
         * @property initAngularVelocity
         * @type {Vec3}
         */


        this.initAngularVelocity = new Vec3();
        /**
         * @property shapes
         * @type {array}
         */

        this.shapes = [];
        /**
         * Position of each Shape in the body, given in local Body space.
         * @property shapeOffsets
         * @type {array}
         */

        this.shapeOffsets = [];
        /**
         * Orientation of each Shape, given in local Body space.
         * @property shapeOrientations
         * @type {array}
         */

        this.shapeOrientations = [];
        /**
         * @property inertia
         * @type {Vec3}
         */

        this.inertia = new Vec3();
        /**
         * @property {Vec3} invInertia
         */

        this.invInertia = new Vec3();
        /**
         * @property {Mat3} invInertiaWorld
         */

        this.invInertiaWorld = new Mat3();
        this.invMassSolve = 0;
        /**
         * @property {Vec3} invInertiaSolve
         */

        this.invInertiaSolve = new Vec3();
        /**
         * @property {Mat3} invInertiaWorldSolve
         */

        this.invInertiaWorldSolve = new Mat3();
        /**
         * Set to true if you don't want the body to rotate. Make sure to run .updateMassProperties() after changing this.
         * @property {Boolean} fixedRotation
         * @default false
         */

        this.fixedRotation = typeof options.fixedRotation !== "undefined" ? options.fixedRotation : false;
        /**
         * use gravity ?
         * @property {Boolean} useGravity
         * @default true
         */

        this.useGravity = true;
        /**
         * @property {Number} angularDamping
         */

        this.angularDamping = typeof options.angularDamping !== 'undefined' ? options.angularDamping : 0.01;
        /**
         * Use this property to limit the motion along any world axis. (1,1,1) will allow motion along all axes while (0,0,0) allows none.
         * @property {Vec3} linearFactor
         */

        this.linearFactor = new Vec3(1, 1, 1);

        if (options.linearFactor) {
          this.linearFactor.copy(options.linearFactor);
        }
        /**
         * Use this property to limit the rotational motion along any world axis. (1,1,1) will allow rotation along all axes while (0,0,0) allows none.
         * @property {Vec3} angularFactor
         */


        this.angularFactor = new Vec3(1, 1, 1);

        if (options.angularFactor) {
          this.angularFactor.copy(options.angularFactor);
        }
        /**
         * World space bounding box of the body and its shapes.
         * @property aabb
         * @type {AABB}
         */


        this.aabb = new AABB();
        /**
         * Indicates if the AABB needs to be updated before use.
         * @property aabbNeedsUpdate
         * @type {Boolean}
         */

        this.aabbNeedsUpdate = true;
        /**
         * Total bounding radius of the Body including its shapes, relative to body.position.
         * @property boundingRadius
         * @type {Number}
         */

        this.boundingRadius = 0;
        this.wlambda = new Vec3();

        if (options.shape) {
          this.addShape(options.shape);
        }
        /**
         * has trigger?
         */


        this.hasTrigger = true;
        this.updateMassProperties();
      }

      Body.prototype = new EventTarget();
      Body.prototype.constructor = Body;
      /**
       * Dispatched after two bodies collide. This event is dispatched on each
       * of the two bodies involved in the collision.
       * @event collide
       * @param {Body} body The body that was involved in the collision.
       * @param {ContactEquation} contact The details of the collision.
       */

      Body.COLLIDE_EVENT_NAME = "collide";
      /**
       * A dynamic body is fully simulated. Can be moved manually by the user, but normally they move according to forces. A dynamic body can collide with all body types. A dynamic body always has finite, non-zero mass.
       * @static
       * @property DYNAMIC
       * @type {Number}
       */

      Body.DYNAMIC = 1;
      /**
       * A static body does not move during simulation and behaves as if it has infinite mass. Static bodies can be moved manually by setting the position of the body. The velocity of a static body is always zero. Static bodies do not collide with other static or kinematic bodies.
       * @static
       * @property STATIC
       * @type {Number}
       */

      Body.STATIC = 2;
      /**
       * A kinematic body moves under simulation according to its velocity. They do not respond to forces. They can be moved manually, but normally a kinematic body is moved by setting its velocity. A kinematic body behaves as if it has infinite mass. Kinematic bodies do not collide with other static or kinematic bodies.
       * @static
       * @property KINEMATIC
       * @type {Number}
       */

      Body.KINEMATIC = 4;
      /**
       * @static
       * @property AWAKE
       * @type {number}
       */

      Body.AWAKE = 0;
      /**
       * @static
       * @property SLEEPY
       * @type {number}
       */

      Body.SLEEPY = 1;
      /**
       * @static
       * @property SLEEPING
       * @type {number}
       */

      Body.SLEEPING = 2;
      Body.idCounter = 0;
      /**
       * Dispatched after a sleeping body has woken up.
       * @event wakeup
       */

      Body.wakeupEvent = {
        type: "wakeup"
      };
      /**
       * Wake the body up.
       * @method wakeUp
       */

      Body.prototype.wakeUp = function () {
        var s = this.sleepState;
        this.sleepState = 0;
        this._wakeUpAfterNarrowphase = false;

        if (s === Body.SLEEPING) {
          this.dispatchEvent(Body.wakeupEvent);
        }
      };
      /**
       * Force body sleep
       * @method sleep
       */


      Body.prototype.sleep = function () {
        this.sleepState = Body.SLEEPING;
        this.velocity.set(0, 0, 0);
        this.angularVelocity.set(0, 0, 0);
        this._wakeUpAfterNarrowphase = false;
      };
      /**
       * Dispatched after a body has gone in to the sleepy state.
       * @event sleepy
       */


      Body.sleepyEvent = {
        type: "sleepy"
      };
      /**
       * Dispatched after a body has fallen asleep.
       * @event sleep
       */

      Body.sleepEvent = {
        type: "sleep"
      };
      /**
       * Called every timestep to update internal sleep timer and change sleep state if needed.
       * @method sleepTick
       * @param {Number} time The world time in seconds
       */

      Body.prototype.sleepTick = function (time) {
        if (this.allowSleep) {
          var sleepState = this.sleepState;
          var speedSquared = this.velocity.norm2() + this.angularVelocity.norm2();
          var speedLimitSquared = Math.pow(this.sleepSpeedLimit, 2);

          if (sleepState === Body.AWAKE && speedSquared < speedLimitSquared) {
            this.sleepState = Body.SLEEPY; // Sleepy

            this.timeLastSleepy = time;
            this.dispatchEvent(Body.sleepyEvent);
          } else if (sleepState === Body.SLEEPY && speedSquared > speedLimitSquared) {
            this.wakeUp(); // Wake up
          } else if (sleepState === Body.SLEEPY && time - this.timeLastSleepy > this.sleepTimeLimit) {
            this.sleep(); // Sleeping

            this.dispatchEvent(Body.sleepEvent);
          }
        }
      };
      /**
       * If the body is sleeping, it should be immovable / have infinite mass during solve. We solve it by having a separate "solve mass".
       * @method updateSolveMassProperties
       */


      Body.prototype.updateSolveMassProperties = function () {
        if (this.sleepState === Body.SLEEPING || this.type === Body.KINEMATIC) {
          this.invMassSolve = 0;
          this.invInertiaSolve.setZero();
          this.invInertiaWorldSolve.setZero();
        } else {
          this.invMassSolve = this.invMass;
          this.invInertiaSolve.copy(this.invInertia);
          this.invInertiaWorldSolve.copy(this.invInertiaWorld);
        }
      };
      /**
       * Convert a world point to local body frame.
       * @method pointToLocalFrame
       * @param  {Vec3} worldPoint
       * @param  {Vec3} result
       * @return {Vec3}
       */


      Body.prototype.pointToLocalFrame = function (worldPoint, result) {
        var result = result || new Vec3();
        worldPoint.vsub(this.position, result);
        this.quaternion.conjugate().vmult(result, result);
        return result;
      };
      /**
       * Convert a world vector to local body frame.
       * @method vectorToLocalFrame
       * @param  {Vec3} worldPoint
       * @param  {Vec3} result
       * @return {Vec3}
       */


      Body.prototype.vectorToLocalFrame = function (worldVector, result) {
        var result = result || new Vec3();
        this.quaternion.conjugate().vmult(worldVector, result);
        return result;
      };
      /**
       * Convert a local body point to world frame.
       * @method pointToWorldFrame
       * @param  {Vec3} localPoint
       * @param  {Vec3} result
       * @return {Vec3}
       */


      Body.prototype.pointToWorldFrame = function (localPoint, result) {
        var result = result || new Vec3();
        this.quaternion.vmult(localPoint, result);
        result.vadd(this.position, result);
        return result;
      };
      /**
       * Convert a local body point to world frame.
       * @method vectorToWorldFrame
       * @param  {Vec3} localVector
       * @param  {Vec3} result
       * @return {Vec3}
       */


      Body.prototype.vectorToWorldFrame = function (localVector, result) {
        var result = result || new Vec3();
        this.quaternion.vmult(localVector, result);
        return result;
      };

      var tmpVec = new Vec3();
      var tmpQuat = new Quaternion();
      /**
       * Add a shape to the body with a local offset and orientation.
       * @method addShape
       * @param {Shape} shape
       * @param {Vec3} [_offset]
       * @param {Quaternion} [_orientation]
       * @return {Body} The body object, for chainability.
       */

      Body.prototype.addShape = function (shape, _offset, _orientation) {
        var offset;
        var orientation;

        if (DEBUG) {
          offset = new Vec3();
          orientation = new Quaternion();

          if (_offset) {
            offset.copy(_offset);
          }

          if (_orientation) {
            orientation.copy(_orientation);
          }
        } else {
          offset = _offset;
          orientation = _orientation;

          if (!offset) {
            offset = new Vec3();
          }

          if (!orientation) {
            orientation = new Quaternion();
          }
        }

        World.idToShapeMap[shape.id] = shape;
        this.shapes.push(shape);
        this.shapeOffsets.push(offset);
        this.shapeOrientations.push(orientation);
        this.updateMassProperties();
        this.updateBoundingRadius();
        this.aabbNeedsUpdate = true;
        this.updateHasTrigger();
        shape.body = this;
        return this;
      };
      /**
       * Remove a shape from the body
       */


      Body.prototype.removeShape = function (shape) {
        var idx = this.shapes.indexOf(shape);

        if (idx === -1) {
          return;
        } // shape.body = null;  needed ?
        // delete World.idToShapeMap[shape.id];  needed ?


        this.shapes.splice(idx, 1);
        this.shapeOffsets.splice(idx, 1);
        this.shapeOrientations.splice(idx, 1);
        this.updateMassProperties();
        this.updateBoundingRadius();
        this.aabbNeedsUpdate = true;
        this.updateHasTrigger();
      };
      /**
       * Update the bounding radius of the body. Should be done if any of the shapes are changed.
       * @method updateBoundingRadius
       */


      Body.prototype.updateBoundingRadius = function () {
        var shapes = this.shapes,
            shapeOffsets = this.shapeOffsets,
            N = shapes.length,
            radius = 0;

        for (var i = 0; i !== N; i++) {
          var shape = shapes[i];
          shape.updateBoundingSphereRadius();
          var offset = shapeOffsets[i].norm(),
              r = shape.boundingSphereRadius;

          if (offset + r > radius) {
            radius = offset + r;
          }
        }

        this.boundingRadius = radius;
      };

      var computeAABB_shapeAABB = new AABB();
      /**
       * Updates the .aabb
       * @method computeAABB
       * @todo rename to updateAABB()
       */

      Body.prototype.computeAABB = function () {
        var shapes = this.shapes,
            shapeOffsets = this.shapeOffsets,
            shapeOrientations = this.shapeOrientations,
            N = shapes.length,
            offset = tmpVec,
            orientation = tmpQuat,
            bodyQuat = this.quaternion,
            aabb = this.aabb,
            shapeAABB = computeAABB_shapeAABB;

        for (var i = 0; i !== N; i++) {
          var shape = shapes[i]; // Get shape world position

          bodyQuat.vmult(shapeOffsets[i], offset);
          offset.vadd(this.position, offset); // Get shape world quaternion

          shapeOrientations[i].mult(bodyQuat, orientation); // Get shape AABB

          shape.calculateWorldAABB(offset, orientation, shapeAABB.lowerBound, shapeAABB.upperBound);

          if (i === 0) {
            aabb.copy(shapeAABB);
          } else {
            aabb.extend(shapeAABB);
          }
        }

        this.aabbNeedsUpdate = false;
      };

      var uiw_m1 = new Mat3(),
          uiw_m2 = new Mat3(),
          uiw_m3 = new Mat3();
      /**
       * Update .inertiaWorld and .invInertiaWorld
       * @method updateInertiaWorld
       */

      Body.prototype.updateInertiaWorld = function (force) {
        var I = this.invInertia;

        if (I.x === I.y && I.y === I.z && !force) {// If inertia M = s*I, where I is identity and s a scalar, then
          //    R*M*R' = R*(s*I)*R' = s*R*I*R' = s*R*R' = s*I = M
          // where R is the rotation matrix.
          // In other words, we don't have to transform the inertia if all
          // inertia diagonal entries are equal.
        } else {
          var m1 = uiw_m1,
              m2 = uiw_m2,
              m3 = uiw_m3;
          m1.setRotationFromQuaternion(this.quaternion);
          m1.transpose(m2);
          m1.scale(I, m1);
          m1.mmult(m2, this.invInertiaWorld);
        }
      };
      /**
       * Apply force to a world point. This could for example be a point on the Body surface. Applying force this way will add to Body.force and Body.torque.
       * @method applyForce
       * @param  {Vec3} force The amount of force to add.
       * @param  {Vec3} relativePoint A point relative to the center of mass to apply the force on.
       */
      // var Body_applyForce_r = new Vec3();


      var Body_applyForce_rotForce = new Vec3();

      Body.prototype.applyForce = function (force, relativePoint) {
        if (this.type !== Body.DYNAMIC) {
          // Needed?
          return;
        } // Compute produced rotational force


        var rotForce = Body_applyForce_rotForce;
        relativePoint.cross(force, rotForce); // Add linear force

        this.force.vadd(force, this.force); // Add rotational force

        this.torque.vadd(rotForce, this.torque);
      };
      /**
       * Apply force to a local point in the body.
       * @method applyLocalForce
       * @param  {Vec3} force The force vector to apply, defined locally in the body frame.
       * @param  {Vec3} localPoint A local point in the body to apply the force on.
       */


      var Body_applyLocalForce_worldForce = new Vec3();
      var Body_applyLocalForce_relativePointWorld = new Vec3();

      Body.prototype.applyLocalForce = function (localForce, localPoint) {
        if (this.type !== Body.DYNAMIC) {
          return;
        }

        var worldForce = Body_applyLocalForce_worldForce;
        var relativePointWorld = Body_applyLocalForce_relativePointWorld; // Transform the force vector to world space

        this.vectorToWorldFrame(localForce, worldForce);
        this.vectorToWorldFrame(localPoint, relativePointWorld);
        this.applyForce(worldForce, relativePointWorld);
      };
      /**
       * Apply impulse to a world point. This could for example be a point on the Body surface. An impulse is a force added to a body during a short period of time (impulse = force * time). Impulses will be added to Body.velocity and Body.angularVelocity.
       * @method applyImpulse
       * @param  {Vec3} impulse The amount of impulse to add.
       * @param  {Vec3} relativePoint A point relative to the center of mass to apply the force on.
       */
      // var Body_applyImpulse_r = new Vec3();


      var Body_applyImpulse_velo = new Vec3();
      var Body_applyImpulse_rotVelo = new Vec3();

      Body.prototype.applyImpulse = function (impulse, relativePoint) {
        if (this.type !== Body.DYNAMIC) {
          return;
        } // Compute point position relative to the body center


        var r = relativePoint; // Compute produced central impulse velocity

        var velo = Body_applyImpulse_velo;
        velo.copy(impulse);
        velo.mult(this.invMass, velo); // Add linear impulse

        this.velocity.vadd(velo, this.velocity); // Compute produced rotational impulse velocity

        var rotVelo = Body_applyImpulse_rotVelo;
        r.cross(impulse, rotVelo);
        /*
        rotVelo.x *= this.invInertia.x;
        rotVelo.y *= this.invInertia.y;
        rotVelo.z *= this.invInertia.z;
        */

        this.invInertiaWorld.vmult(rotVelo, rotVelo); // Add rotational Impulse

        this.angularVelocity.vadd(rotVelo, this.angularVelocity);
      };
      /**
       * Apply locally-defined impulse to a local point in the body.
       * @method applyLocalImpulse
       * @param  {Vec3} force The force vector to apply, defined locally in the body frame.
       * @param  {Vec3} localPoint A local point in the body to apply the force on.
       */


      var Body_applyLocalImpulse_worldImpulse = new Vec3();
      var Body_applyLocalImpulse_relativePoint = new Vec3();

      Body.prototype.applyLocalImpulse = function (localImpulse, localPoint) {
        if (this.type !== Body.DYNAMIC) {
          return;
        }

        var worldImpulse = Body_applyLocalImpulse_worldImpulse;
        var relativePointWorld = Body_applyLocalImpulse_relativePoint; // Transform the force vector to world space

        this.vectorToWorldFrame(localImpulse, worldImpulse);
        this.vectorToWorldFrame(localPoint, relativePointWorld);
        this.applyImpulse(worldImpulse, relativePointWorld);
      };

      var Body_updateMassProperties_halfExtents = new Vec3();
      /**
       * Should be called whenever you change the body shape or mass.
       * @method updateMassProperties
       */

      Body.prototype.updateMassProperties = function () {
        var halfExtents = Body_updateMassProperties_halfExtents;
        this.invMass = this.mass > 0 ? 1.0 / this.mass : 0;
        var I = this.inertia;
        var fixed = this.fixedRotation; // Approximate with AABB box

        this.computeAABB();
        halfExtents.set((this.aabb.upperBound.x - this.aabb.lowerBound.x) / 2, (this.aabb.upperBound.y - this.aabb.lowerBound.y) / 2, (this.aabb.upperBound.z - this.aabb.lowerBound.z) / 2);
        Box.calculateInertia(halfExtents, this.mass, I);
        this.invInertia.set(I.x > 0 && !fixed ? 1.0 / I.x : 0, I.y > 0 && !fixed ? 1.0 / I.y : 0, I.z > 0 && !fixed ? 1.0 / I.z : 0);
        this.updateInertiaWorld(true);
      };
      /**
       * Get world velocity of a point in the body.
       * @method getVelocityAtWorldPoint
       * @param  {Vec3} worldPoint
       * @param  {Vec3} result
       * @return {Vec3} The result vector.
       */


      Body.prototype.getVelocityAtWorldPoint = function (worldPoint, result) {
        var r = new Vec3();
        worldPoint.vsub(this.position, r);
        this.angularVelocity.cross(r, result);
        this.velocity.vadd(result, result);
        return result;
      }; // var torque = new Vec3();
      // var invI_tau_dt = new Vec3();
      // var w = new Quaternion();
      // var wq = new Quaternion();

      /**
       * Move the body forward in time.
       * @param {number} dt Time step
       * @param {boolean} quatNormalize Set to true to normalize the body quaternion
       * @param {boolean} quatNormalizeFast If the quaternion should be normalized using "fast" quaternion normalization
       */


      Body.prototype.integrate = function (dt, quatNormalize, quatNormalizeFast) {
        // Save previous position
        this.previousPosition.copy(this.position);
        this.previousQuaternion.copy(this.quaternion);

        if (!(this.type === Body.DYNAMIC || this.type === Body.KINEMATIC) || this.sleepState === Body.SLEEPING) {
          // Only for dynamic
          return;
        }

        var velo = this.velocity,
            angularVelo = this.angularVelocity,
            pos = this.position,
            force = this.force,
            torque = this.torque,
            quat = this.quaternion,
            invMass = this.invMass,
            invInertia = this.invInertiaWorld,
            linearFactor = this.linearFactor;
        var iMdt = invMass * dt;
        velo.x += force.x * iMdt * linearFactor.x;
        velo.y += force.y * iMdt * linearFactor.y;
        velo.z += force.z * iMdt * linearFactor.z;
        var e = invInertia.elements;
        var angularFactor = this.angularFactor;
        var tx = torque.x * angularFactor.x;
        var ty = torque.y * angularFactor.y;
        var tz = torque.z * angularFactor.z;
        angularVelo.x += dt * (e[0] * tx + e[1] * ty + e[2] * tz);
        angularVelo.y += dt * (e[3] * tx + e[4] * ty + e[5] * tz);
        angularVelo.z += dt * (e[6] * tx + e[7] * ty + e[8] * tz); // Use new velocity  - leap frog

        pos.x += velo.x * dt;
        pos.y += velo.y * dt;
        pos.z += velo.z * dt;
        quat.integrate(this.angularVelocity, dt, this.angularFactor, quat);

        if (quatNormalize) {
          if (quatNormalizeFast) {
            quat.normalizeFast();
          } else {
            quat.normalize();
          }
        }

        this.aabbNeedsUpdate = true; // Update world inertia

        this.updateInertiaWorld();
      };
      /**
       * Is Sleeping
       */


      Body.prototype.isSleeping = function () {
        return this.sleepState === Body.SLEEPING;
      };
      /**
       * Is Sleepy
       */


      Body.prototype.isSleepy = function () {
        return this.sleepState === Body.SLEEPY;
      };
      /**
       * Is Awake
       */


      Body.prototype.isAwake = function () {
        return this.sleepState === Body.AWAKE;
      };
      /**
       * Update hasTrigger
       */


      Body.prototype.updateHasTrigger = function () {
        for (var i = this.shapes.length; i--;) {
          this.hasTrigger = !this.shapes[i].collisionResponse;
          if (this.hasTrigger) break;
        }
      };
    }, {
      "../collision/AABB": 3,
      "../material/Material": 26,
      "../math/Mat3": 28,
      "../math/Quaternion": 29,
      "../math/Vec3": 31,
      "../shapes/Box": 38,
      "../shapes/Shape": 44,
      "../utils/EventTarget": 50,
      "../world/World": 57
    }],
    33: [function (_dereq_, module, exports) {
      var Body = _dereq_('./Body');

      var Vec3 = _dereq_('../math/Vec3');

      var Quaternion = _dereq_('../math/Quaternion');

      var RaycastResult = _dereq_('../collision/RaycastResult');

      var Ray = _dereq_('../collision/Ray');

      var WheelInfo = _dereq_('../objects/WheelInfo');

      module.exports = RaycastVehicle;
      /**
       * Vehicle helper class that casts rays from the wheel positions towards the ground and applies forces.
       * @class RaycastVehicle
       * @constructor
       * @param {object} [options]
       * @param {Body} [options.chassisBody] The car chassis body.
       * @param {integer} [options.indexRightAxis] Axis to use for right. x=0, y=1, z=2
       * @param {integer} [options.indexLeftAxis]
       * @param {integer} [options.indexUpAxis]
       */

      function RaycastVehicle(options) {
        /**
         * @property {Body} chassisBody
         */
        this.chassisBody = options.chassisBody;
        /**
         * An array of WheelInfo objects.
         * @property {array} wheelInfos
         */

        this.wheelInfos = [];
        /**
         * Will be set to true if the car is sliding.
         * @property {boolean} sliding
         */

        this.sliding = false;
        /**
         * @property {World} world
         */

        this.world = null;
        /**
         * Index of the right axis, 0=x, 1=y, 2=z
         * @property {integer} indexRightAxis
         * @default 1
         */

        this.indexRightAxis = typeof options.indexRightAxis !== 'undefined' ? options.indexRightAxis : 1;
        /**
         * Index of the forward axis, 0=x, 1=y, 2=z
         * @property {integer} indexForwardAxis
         * @default 0
         */

        this.indexForwardAxis = typeof options.indexForwardAxis !== 'undefined' ? options.indexForwardAxis : 0;
        /**
         * Index of the up axis, 0=x, 1=y, 2=z
         * @property {integer} indexUpAxis
         * @default 2
         */

        this.indexUpAxis = typeof options.indexUpAxis !== 'undefined' ? options.indexUpAxis : 2;
      }

      var tmpVec1 = new Vec3();
      var tmpVec2 = new Vec3();
      var tmpVec3 = new Vec3();
      var tmpVec4 = new Vec3();
      var tmpVec5 = new Vec3();
      var tmpVec6 = new Vec3();
      var tmpRay = new Ray();
      /**
       * Add a wheel. For information about the options, see WheelInfo.
       * @method addWheel
       * @param {object} [options]
       */

      RaycastVehicle.prototype.addWheel = function (options) {
        options = options || {};
        var info = new WheelInfo(options);
        var index = this.wheelInfos.length;
        this.wheelInfos.push(info);
        return index;
      };
      /**
       * Set the steering value of a wheel.
       * @method setSteeringValue
       * @param {number} value
       * @param {integer} wheelIndex
       */


      RaycastVehicle.prototype.setSteeringValue = function (value, wheelIndex) {
        var wheel = this.wheelInfos[wheelIndex];
        wheel.steering = value;
      };

      var torque = new Vec3();
      /**
       * Set the wheel force to apply on one of the wheels each time step
       * @method applyEngineForce
       * @param  {number} value
       * @param  {integer} wheelIndex
       */

      RaycastVehicle.prototype.applyEngineForce = function (value, wheelIndex) {
        this.wheelInfos[wheelIndex].engineForce = value;
      };
      /**
       * Set the braking force of a wheel
       * @method setBrake
       * @param {number} brake
       * @param {integer} wheelIndex
       */


      RaycastVehicle.prototype.setBrake = function (brake, wheelIndex) {
        this.wheelInfos[wheelIndex].brake = brake;
      };
      /**
       * Add the vehicle including its constraints to the world.
       * @method addToWorld
       * @param {World} world
       */


      RaycastVehicle.prototype.addToWorld = function (world) {
        var constraints = this.constraints;
        world.addBody(this.chassisBody);
        var that = this;

        this.preStepCallback = function () {
          that.updateVehicle(world.dt);
        };

        world.addEventListener('preStep', this.preStepCallback);
        this.world = world;
      };
      /**
       * Get one of the wheel axles, world-oriented.
       * @private
       * @method getVehicleAxisWorld
       * @param  {integer} axisIndex
       * @param  {Vec3} result
       */


      RaycastVehicle.prototype.getVehicleAxisWorld = function (axisIndex, result) {
        result.set(axisIndex === 0 ? 1 : 0, axisIndex === 1 ? 1 : 0, axisIndex === 2 ? 1 : 0);
        this.chassisBody.vectorToWorldFrame(result, result);
      };

      RaycastVehicle.prototype.updateVehicle = function (timeStep) {
        var wheelInfos = this.wheelInfos;
        var numWheels = wheelInfos.length;
        var chassisBody = this.chassisBody;

        for (var i = 0; i < numWheels; i++) {
          this.updateWheelTransform(i);
        }

        this.currentVehicleSpeedKmHour = 3.6 * chassisBody.velocity.norm();
        var forwardWorld = new Vec3();
        this.getVehicleAxisWorld(this.indexForwardAxis, forwardWorld);

        if (forwardWorld.dot(chassisBody.velocity) < 0) {
          this.currentVehicleSpeedKmHour *= -1;
        } // simulate suspension


        for (var i = 0; i < numWheels; i++) {
          this.castRay(wheelInfos[i]);
        }

        this.updateSuspension(timeStep);
        var impulse = new Vec3();
        var relpos = new Vec3();

        for (var i = 0; i < numWheels; i++) {
          //apply suspension force
          var wheel = wheelInfos[i];
          var suspensionForce = wheel.suspensionForce;

          if (suspensionForce > wheel.maxSuspensionForce) {
            suspensionForce = wheel.maxSuspensionForce;
          }

          wheel.raycastResult.hitNormalWorld.scale(suspensionForce * timeStep, impulse);
          wheel.raycastResult.hitPointWorld.vsub(chassisBody.position, relpos);
          chassisBody.applyImpulse(impulse, relpos);
        }

        this.updateFriction(timeStep);
        var hitNormalWorldScaledWithProj = new Vec3();
        var fwd = new Vec3();
        var vel = new Vec3();

        for (i = 0; i < numWheels; i++) {
          var wheel = wheelInfos[i]; //var relpos = new Vec3();
          //wheel.chassisConnectionPointWorld.vsub(chassisBody.position, relpos);

          chassisBody.getVelocityAtWorldPoint(wheel.chassisConnectionPointWorld, vel); // Hack to get the rotation in the correct direction

          var m = 1;

          switch (this.indexUpAxis) {
            case 1:
              m = -1;
              break;
          }

          if (wheel.isInContact) {
            this.getVehicleAxisWorld(this.indexForwardAxis, fwd);
            var proj = fwd.dot(wheel.raycastResult.hitNormalWorld);
            wheel.raycastResult.hitNormalWorld.scale(proj, hitNormalWorldScaledWithProj);
            fwd.vsub(hitNormalWorldScaledWithProj, fwd);
            var proj2 = fwd.dot(vel);
            wheel.deltaRotation = m * proj2 * timeStep / wheel.radius;
          }

          if ((wheel.sliding || !wheel.isInContact) && wheel.engineForce !== 0 && wheel.useCustomSlidingRotationalSpeed) {
            // Apply custom rotation when accelerating and sliding
            wheel.deltaRotation = (wheel.engineForce > 0 ? 1 : -1) * wheel.customSlidingRotationalSpeed * timeStep;
          } // Lock wheels


          if (Math.abs(wheel.brake) > Math.abs(wheel.engineForce)) {
            wheel.deltaRotation = 0;
          }

          wheel.rotation += wheel.deltaRotation; // Use the old value

          wheel.deltaRotation *= 0.99; // damping of rotation when not in contact
        }
      };

      RaycastVehicle.prototype.updateSuspension = function (deltaTime) {
        var chassisBody = this.chassisBody;
        var chassisMass = chassisBody.mass;
        var wheelInfos = this.wheelInfos;
        var numWheels = wheelInfos.length;

        for (var w_it = 0; w_it < numWheels; w_it++) {
          var wheel = wheelInfos[w_it];

          if (wheel.isInContact) {
            var force; // Spring

            var susp_length = wheel.suspensionRestLength;
            var current_length = wheel.suspensionLength;
            var length_diff = susp_length - current_length;
            force = wheel.suspensionStiffness * length_diff * wheel.clippedInvContactDotSuspension; // Damper

            var projected_rel_vel = wheel.suspensionRelativeVelocity;
            var susp_damping;

            if (projected_rel_vel < 0) {
              susp_damping = wheel.dampingCompression;
            } else {
              susp_damping = wheel.dampingRelaxation;
            }

            force -= susp_damping * projected_rel_vel;
            wheel.suspensionForce = force * chassisMass;

            if (wheel.suspensionForce < 0) {
              wheel.suspensionForce = 0;
            }
          } else {
            wheel.suspensionForce = 0;
          }
        }
      };
      /**
       * Remove the vehicle including its constraints from the world.
       * @method removeFromWorld
       * @param {World} world
       */


      RaycastVehicle.prototype.removeFromWorld = function (world) {
        var constraints = this.constraints;
        world.remove(this.chassisBody);
        world.removeEventListener('preStep', this.preStepCallback);
        this.world = null;
      };

      var castRay_rayvector = new Vec3();
      var castRay_target = new Vec3();

      RaycastVehicle.prototype.castRay = function (wheel) {
        var rayvector = castRay_rayvector;
        var target = castRay_target;
        this.updateWheelTransformWorld(wheel);
        var chassisBody = this.chassisBody;
        var depth = -1;
        var raylen = wheel.suspensionRestLength + wheel.radius;
        wheel.directionWorld.scale(raylen, rayvector);
        var source = wheel.chassisConnectionPointWorld;
        source.vadd(rayvector, target);
        var raycastResult = wheel.raycastResult;
        var param = 0;
        raycastResult.reset(); // Turn off ray collision with the chassis temporarily

        var oldState = chassisBody.collisionResponse;
        chassisBody.collisionResponse = false; // Cast ray against world

        this.world.rayTest(source, target, raycastResult);
        chassisBody.collisionResponse = oldState;
        var object = raycastResult.body;
        wheel.raycastResult.groundObject = 0;

        if (object) {
          depth = raycastResult.distance;
          wheel.raycastResult.hitNormalWorld = raycastResult.hitNormalWorld;
          wheel.isInContact = true;
          var hitDistance = raycastResult.distance;
          wheel.suspensionLength = hitDistance - wheel.radius; // clamp on max suspension travel

          var minSuspensionLength = wheel.suspensionRestLength - wheel.maxSuspensionTravel;
          var maxSuspensionLength = wheel.suspensionRestLength + wheel.maxSuspensionTravel;

          if (wheel.suspensionLength < minSuspensionLength) {
            wheel.suspensionLength = minSuspensionLength;
          }

          if (wheel.suspensionLength > maxSuspensionLength) {
            wheel.suspensionLength = maxSuspensionLength;
            wheel.raycastResult.reset();
          }

          var denominator = wheel.raycastResult.hitNormalWorld.dot(wheel.directionWorld);
          var chassis_velocity_at_contactPoint = new Vec3();
          chassisBody.getVelocityAtWorldPoint(wheel.raycastResult.hitPointWorld, chassis_velocity_at_contactPoint);
          var projVel = wheel.raycastResult.hitNormalWorld.dot(chassis_velocity_at_contactPoint);

          if (denominator >= -0.1) {
            wheel.suspensionRelativeVelocity = 0;
            wheel.clippedInvContactDotSuspension = 1 / 0.1;
          } else {
            var inv = -1 / denominator;
            wheel.suspensionRelativeVelocity = projVel * inv;
            wheel.clippedInvContactDotSuspension = inv;
          }
        } else {
          //put wheel info as in rest position
          wheel.suspensionLength = wheel.suspensionRestLength + 0 * wheel.maxSuspensionTravel;
          wheel.suspensionRelativeVelocity = 0.0;
          wheel.directionWorld.scale(-1, wheel.raycastResult.hitNormalWorld);
          wheel.clippedInvContactDotSuspension = 1.0;
        }

        return depth;
      };

      RaycastVehicle.prototype.updateWheelTransformWorld = function (wheel) {
        wheel.isInContact = false;
        var chassisBody = this.chassisBody;
        chassisBody.pointToWorldFrame(wheel.chassisConnectionPointLocal, wheel.chassisConnectionPointWorld);
        chassisBody.vectorToWorldFrame(wheel.directionLocal, wheel.directionWorld);
        chassisBody.vectorToWorldFrame(wheel.axleLocal, wheel.axleWorld);
      };
      /**
       * Update one of the wheel transform.
       * Note when rendering wheels: during each step, wheel transforms are updated BEFORE the chassis; ie. their position becomes invalid after the step. Thus when you render wheels, you must update wheel transforms before rendering them. See raycastVehicle demo for an example.
       * @method updateWheelTransform
       * @param {integer} wheelIndex The wheel index to update.
       */


      RaycastVehicle.prototype.updateWheelTransform = function (wheelIndex) {
        var up = tmpVec4;
        var right = tmpVec5;
        var fwd = tmpVec6;
        var wheel = this.wheelInfos[wheelIndex];
        this.updateWheelTransformWorld(wheel);
        wheel.directionLocal.scale(-1, up);
        right.copy(wheel.axleLocal);
        up.cross(right, fwd);
        fwd.normalize();
        right.normalize(); // Rotate around steering over the wheelAxle

        var steering = wheel.steering;
        var steeringOrn = new Quaternion();
        steeringOrn.setFromAxisAngle(up, steering);
        var rotatingOrn = new Quaternion();
        rotatingOrn.setFromAxisAngle(right, wheel.rotation); // World rotation of the wheel

        var q = wheel.worldTransform.quaternion;
        this.chassisBody.quaternion.mult(steeringOrn, q);
        q.mult(rotatingOrn, q);
        q.normalize(); // world position of the wheel

        var p = wheel.worldTransform.position;
        p.copy(wheel.directionWorld);
        p.scale(wheel.suspensionLength, p);
        p.vadd(wheel.chassisConnectionPointWorld, p);
      };

      var directions = [new Vec3(1, 0, 0), new Vec3(0, 1, 0), new Vec3(0, 0, 1)];
      /**
       * Get the world transform of one of the wheels
       * @method getWheelTransformWorld
       * @param  {integer} wheelIndex
       * @return {Transform}
       */

      RaycastVehicle.prototype.getWheelTransformWorld = function (wheelIndex) {
        return this.wheelInfos[wheelIndex].worldTransform;
      };

      var updateFriction_surfNormalWS_scaled_proj = new Vec3();
      var updateFriction_axle = [];
      var updateFriction_forwardWS = [];
      var sideFrictionStiffness2 = 1;

      RaycastVehicle.prototype.updateFriction = function (timeStep) {
        var surfNormalWS_scaled_proj = updateFriction_surfNormalWS_scaled_proj; //calculate the impulse, so that the wheels don't move sidewards

        var wheelInfos = this.wheelInfos;
        var numWheels = wheelInfos.length;
        var chassisBody = this.chassisBody;
        var forwardWS = updateFriction_forwardWS;
        var axle = updateFriction_axle;
        var numWheelsOnGround = 0;

        for (var i = 0; i < numWheels; i++) {
          var wheel = wheelInfos[i];
          var groundObject = wheel.raycastResult.body;

          if (groundObject) {
            numWheelsOnGround++;
          }

          wheel.sideImpulse = 0;
          wheel.forwardImpulse = 0;

          if (!forwardWS[i]) {
            forwardWS[i] = new Vec3();
          }

          if (!axle[i]) {
            axle[i] = new Vec3();
          }
        }

        for (var i = 0; i < numWheels; i++) {
          var wheel = wheelInfos[i];
          var groundObject = wheel.raycastResult.body;

          if (groundObject) {
            var axlei = axle[i];
            var wheelTrans = this.getWheelTransformWorld(i); // Get world axle

            wheelTrans.vectorToWorldFrame(directions[this.indexRightAxis], axlei);
            var surfNormalWS = wheel.raycastResult.hitNormalWorld;
            var proj = axlei.dot(surfNormalWS);
            surfNormalWS.scale(proj, surfNormalWS_scaled_proj);
            axlei.vsub(surfNormalWS_scaled_proj, axlei);
            axlei.normalize();
            surfNormalWS.cross(axlei, forwardWS[i]);
            forwardWS[i].normalize();
            wheel.sideImpulse = resolveSingleBilateral(chassisBody, wheel.raycastResult.hitPointWorld, groundObject, wheel.raycastResult.hitPointWorld, axlei);
            wheel.sideImpulse *= sideFrictionStiffness2;
          }
        }

        var sideFactor = 1;
        var fwdFactor = 0.5;
        this.sliding = false;

        for (var i = 0; i < numWheels; i++) {
          var wheel = wheelInfos[i];
          var groundObject = wheel.raycastResult.body;
          var rollingFriction = 0;
          wheel.slipInfo = 1;

          if (groundObject) {
            var defaultRollingFrictionImpulse = 0;
            var maxImpulse = wheel.brake ? wheel.brake : defaultRollingFrictionImpulse; // btWheelContactPoint contactPt(chassisBody,groundObject,wheelInfraycastInfo.hitPointWorld,forwardWS[wheel],maxImpulse);
            // rollingFriction = calcRollingFriction(contactPt);

            rollingFriction = calcRollingFriction(chassisBody, groundObject, wheel.raycastResult.hitPointWorld, forwardWS[i], maxImpulse);
            rollingFriction += wheel.engineForce * timeStep; // rollingFriction = 0;

            var factor = maxImpulse / rollingFriction;
            wheel.slipInfo *= factor;
          } //switch between active rolling (throttle), braking and non-active rolling friction (nthrottle/break)


          wheel.forwardImpulse = 0;
          wheel.skidInfo = 1;

          if (groundObject) {
            wheel.skidInfo = 1;
            var maximp = wheel.suspensionForce * timeStep * wheel.frictionSlip;
            var maximpSide = maximp;
            var maximpSquared = maximp * maximpSide;
            wheel.forwardImpulse = rollingFriction; //wheelInfo.engineForce* timeStep;

            var x = wheel.forwardImpulse * fwdFactor;
            var y = wheel.sideImpulse * sideFactor;
            var impulseSquared = x * x + y * y;
            wheel.sliding = false;

            if (impulseSquared > maximpSquared) {
              this.sliding = true;
              wheel.sliding = true;
              var factor = maximp / Math.sqrt(impulseSquared);
              wheel.skidInfo *= factor;
            }
          }
        }

        if (this.sliding) {
          for (var i = 0; i < numWheels; i++) {
            var wheel = wheelInfos[i];

            if (wheel.sideImpulse !== 0) {
              if (wheel.skidInfo < 1) {
                wheel.forwardImpulse *= wheel.skidInfo;
                wheel.sideImpulse *= wheel.skidInfo;
              }
            }
          }
        } // apply the impulses


        for (var i = 0; i < numWheels; i++) {
          var wheel = wheelInfos[i];
          var rel_pos = new Vec3();
          wheel.raycastResult.hitPointWorld.vsub(chassisBody.position, rel_pos); // cannons applyimpulse is using world coord for the position
          //rel_pos.copy(wheel.raycastResult.hitPointWorld);

          if (wheel.forwardImpulse !== 0) {
            var impulse = new Vec3();
            forwardWS[i].scale(wheel.forwardImpulse, impulse);
            chassisBody.applyImpulse(impulse, rel_pos);
          }

          if (wheel.sideImpulse !== 0) {
            var groundObject = wheel.raycastResult.body;
            var rel_pos2 = new Vec3();
            wheel.raycastResult.hitPointWorld.vsub(groundObject.position, rel_pos2); //rel_pos2.copy(wheel.raycastResult.hitPointWorld);

            var sideImp = new Vec3();
            axle[i].scale(wheel.sideImpulse, sideImp); // Scale the relative position in the up direction with rollInfluence.
            // If rollInfluence is 1, the impulse will be applied on the hitPoint (easy to roll over), if it is zero it will be applied in the same plane as the center of mass (not easy to roll over).

            chassisBody.vectorToLocalFrame(rel_pos, rel_pos);
            rel_pos['xyz'[this.indexUpAxis]] *= wheel.rollInfluence;
            chassisBody.vectorToWorldFrame(rel_pos, rel_pos);
            chassisBody.applyImpulse(sideImp, rel_pos); //apply friction impulse on the ground

            sideImp.scale(-1, sideImp);
            groundObject.applyImpulse(sideImp, rel_pos2);
          }
        }
      };

      var calcRollingFriction_vel1 = new Vec3();
      var calcRollingFriction_vel2 = new Vec3();
      var calcRollingFriction_vel = new Vec3();

      function calcRollingFriction(body0, body1, frictionPosWorld, frictionDirectionWorld, maxImpulse) {
        var j1 = 0;
        var contactPosWorld = frictionPosWorld; // var rel_pos1 = new Vec3();
        // var rel_pos2 = new Vec3();

        var vel1 = calcRollingFriction_vel1;
        var vel2 = calcRollingFriction_vel2;
        var vel = calcRollingFriction_vel; // contactPosWorld.vsub(body0.position, rel_pos1);
        // contactPosWorld.vsub(body1.position, rel_pos2);

        body0.getVelocityAtWorldPoint(contactPosWorld, vel1);
        body1.getVelocityAtWorldPoint(contactPosWorld, vel2);
        vel1.vsub(vel2, vel);
        var vrel = frictionDirectionWorld.dot(vel);
        var denom0 = computeImpulseDenominator(body0, frictionPosWorld, frictionDirectionWorld);
        var denom1 = computeImpulseDenominator(body1, frictionPosWorld, frictionDirectionWorld);
        var relaxation = 1;
        var jacDiagABInv = relaxation / (denom0 + denom1); // calculate j that moves us to zero relative velocity

        j1 = -vrel * jacDiagABInv;

        if (maxImpulse < j1) {
          j1 = maxImpulse;
        }

        if (j1 < -maxImpulse) {
          j1 = -maxImpulse;
        }

        return j1;
      }

      var computeImpulseDenominator_r0 = new Vec3();
      var computeImpulseDenominator_c0 = new Vec3();
      var computeImpulseDenominator_vec = new Vec3();
      var computeImpulseDenominator_m = new Vec3();

      function computeImpulseDenominator(body, pos, normal) {
        var r0 = computeImpulseDenominator_r0;
        var c0 = computeImpulseDenominator_c0;
        var vec = computeImpulseDenominator_vec;
        var m = computeImpulseDenominator_m;
        pos.vsub(body.position, r0);
        r0.cross(normal, c0);
        body.invInertiaWorld.vmult(c0, m);
        m.cross(r0, vec);
        return body.invMass + normal.dot(vec);
      }

      var resolveSingleBilateral_vel1 = new Vec3();
      var resolveSingleBilateral_vel2 = new Vec3();
      var resolveSingleBilateral_vel = new Vec3(); //bilateral constraint between two dynamic objects

      function resolveSingleBilateral(body1, pos1, body2, pos2, normal, impulse) {
        var normalLenSqr = normal.norm2();

        if (normalLenSqr > 1.1) {
          return 0; // no impulse
        } // var rel_pos1 = new Vec3();
        // var rel_pos2 = new Vec3();
        // pos1.vsub(body1.position, rel_pos1);
        // pos2.vsub(body2.position, rel_pos2);


        var vel1 = resolveSingleBilateral_vel1;
        var vel2 = resolveSingleBilateral_vel2;
        var vel = resolveSingleBilateral_vel;
        body1.getVelocityAtWorldPoint(pos1, vel1);
        body2.getVelocityAtWorldPoint(pos2, vel2);
        vel1.vsub(vel2, vel);
        var rel_vel = normal.dot(vel);
        var contactDamping = 0.2;
        var massTerm = 1 / (body1.invMass + body2.invMass);
        var impulse = -contactDamping * rel_vel * massTerm;
        return impulse;
      }
    }, {
      "../collision/Ray": 10,
      "../collision/RaycastResult": 11,
      "../math/Quaternion": 29,
      "../math/Vec3": 31,
      "../objects/WheelInfo": 37,
      "./Body": 32
    }],
    34: [function (_dereq_, module, exports) {
      var Body = _dereq_('./Body');

      var Sphere = _dereq_('../shapes/Sphere');

      var Box = _dereq_('../shapes/Box');

      var Vec3 = _dereq_('../math/Vec3');

      var HingeConstraint = _dereq_('../constraints/HingeConstraint');

      module.exports = RigidVehicle;
      /**
       * Simple vehicle helper class with spherical rigid body wheels.
       * @class RigidVehicle
       * @constructor
       * @param {Body} [options.chassisBody]
       */

      function RigidVehicle(options) {
        this.wheelBodies = [];
        /**
         * @property coordinateSystem
         * @type {Vec3}
         */

        this.coordinateSystem = typeof options.coordinateSystem === 'undefined' ? new Vec3(1, 2, 3) : options.coordinateSystem.clone();
        /**
         * @property {Body} chassisBody
         */

        this.chassisBody = options.chassisBody;

        if (!this.chassisBody) {
          // No chassis body given. Create it!
          var chassisShape = new Box(new Vec3(5, 2, 0.5));
          this.chassisBody = new Body(1, chassisShape);
        }
        /**
         * @property constraints
         * @type {Array}
         */


        this.constraints = [];
        this.wheelAxes = [];
        this.wheelForces = [];
      }
      /**
       * Add a wheel
       * @method addWheel
       * @param {object} options
       * @param {boolean} [options.isFrontWheel]
       * @param {Vec3} [options.position] Position of the wheel, locally in the chassis body.
       * @param {Vec3} [options.direction] Slide direction of the wheel along the suspension.
       * @param {Vec3} [options.axis] Axis of rotation of the wheel, locally defined in the chassis.
       * @param {Body} [options.body] The wheel body.
       */


      RigidVehicle.prototype.addWheel = function (options) {
        options = options || {};
        var wheelBody = options.body;

        if (!wheelBody) {
          wheelBody = new Body(1, new Sphere(1.2));
        }

        this.wheelBodies.push(wheelBody);
        this.wheelForces.push(0); // Position constrain wheels

        var zero = new Vec3();
        var position = typeof options.position !== 'undefined' ? options.position.clone() : new Vec3(); // Set position locally to the chassis

        var worldPosition = new Vec3();
        this.chassisBody.pointToWorldFrame(position, worldPosition);
        wheelBody.position.set(worldPosition.x, worldPosition.y, worldPosition.z); // Constrain wheel

        var axis = typeof options.axis !== 'undefined' ? options.axis.clone() : new Vec3(0, 1, 0);
        this.wheelAxes.push(axis);
        var hingeConstraint = new HingeConstraint(this.chassisBody, wheelBody, {
          pivotA: position,
          axisA: axis,
          pivotB: Vec3.ZERO,
          axisB: axis,
          collideConnected: false
        });
        this.constraints.push(hingeConstraint);
        return this.wheelBodies.length - 1;
      };
      /**
       * Set the steering value of a wheel.
       * @method setSteeringValue
       * @param {number} value
       * @param {integer} wheelIndex
       * @todo check coordinateSystem
       */


      RigidVehicle.prototype.setSteeringValue = function (value, wheelIndex) {
        // Set angle of the hinge axis
        var axis = this.wheelAxes[wheelIndex];
        var c = Math.cos(value),
            s = Math.sin(value),
            x = axis.x,
            y = axis.y;
        this.constraints[wheelIndex].axisA.set(c * x - s * y, s * x + c * y, 0);
      };
      /**
       * Set the target rotational speed of the hinge constraint.
       * @method setMotorSpeed
       * @param {number} value
       * @param {integer} wheelIndex
       */


      RigidVehicle.prototype.setMotorSpeed = function (value, wheelIndex) {
        var hingeConstraint = this.constraints[wheelIndex];
        hingeConstraint.enableMotor();
        hingeConstraint.motorTargetVelocity = value;
      };
      /**
       * Set the target rotational speed of the hinge constraint.
       * @method disableMotor
       * @param {number} value
       * @param {integer} wheelIndex
       */


      RigidVehicle.prototype.disableMotor = function (wheelIndex) {
        var hingeConstraint = this.constraints[wheelIndex];
        hingeConstraint.disableMotor();
      };

      var torque = new Vec3();
      /**
       * Set the wheel force to apply on one of the wheels each time step
       * @method setWheelForce
       * @param  {number} value
       * @param  {integer} wheelIndex
       */

      RigidVehicle.prototype.setWheelForce = function (value, wheelIndex) {
        this.wheelForces[wheelIndex] = value;
      };
      /**
       * Apply a torque on one of the wheels.
       * @method applyWheelForce
       * @param  {number} value
       * @param  {integer} wheelIndex
       */


      RigidVehicle.prototype.applyWheelForce = function (value, wheelIndex) {
        var axis = this.wheelAxes[wheelIndex];
        var wheelBody = this.wheelBodies[wheelIndex];
        var bodyTorque = wheelBody.torque;
        axis.scale(value, torque);
        wheelBody.vectorToWorldFrame(torque, torque);
        bodyTorque.vadd(torque, bodyTorque);
      };
      /**
       * Add the vehicle including its constraints to the world.
       * @method addToWorld
       * @param {World} world
       */


      RigidVehicle.prototype.addToWorld = function (world) {
        var constraints = this.constraints;
        var bodies = this.wheelBodies.concat([this.chassisBody]);

        for (var i = 0; i < bodies.length; i++) {
          world.addBody(bodies[i]);
        }

        for (var i = 0; i < constraints.length; i++) {
          world.addConstraint(constraints[i]);
        }

        world.addEventListener('preStep', this._update.bind(this));
      };

      RigidVehicle.prototype._update = function () {
        var wheelForces = this.wheelForces;

        for (var i = 0; i < wheelForces.length; i++) {
          this.applyWheelForce(wheelForces[i], i);
        }
      };
      /**
       * Remove the vehicle including its constraints from the world.
       * @method removeFromWorld
       * @param {World} world
       */


      RigidVehicle.prototype.removeFromWorld = function (world) {
        var constraints = this.constraints;
        var bodies = this.wheelBodies.concat([this.chassisBody]);

        for (var i = 0; i < bodies.length; i++) {
          world.remove(bodies[i]);
        }

        for (var i = 0; i < constraints.length; i++) {
          world.removeConstraint(constraints[i]);
        }
      };

      var worldAxis = new Vec3();
      /**
       * Get current rotational velocity of a wheel
       * @method getWheelSpeed
       * @param {integer} wheelIndex
       */

      RigidVehicle.prototype.getWheelSpeed = function (wheelIndex) {
        var axis = this.wheelAxes[wheelIndex];
        var wheelBody = this.wheelBodies[wheelIndex];
        var w = wheelBody.angularVelocity;
        this.chassisBody.vectorToWorldFrame(axis, worldAxis);
        return w.dot(worldAxis);
      };
    }, {
      "../constraints/HingeConstraint": 16,
      "../math/Vec3": 31,
      "../shapes/Box": 38,
      "../shapes/Sphere": 45,
      "./Body": 32
    }],
    35: [function (_dereq_, module, exports) {
      module.exports = SPHSystem;

      var Shape = _dereq_('../shapes/Shape');

      var Vec3 = _dereq_('../math/Vec3');

      var Quaternion = _dereq_('../math/Quaternion');

      var Particle = _dereq_('../shapes/Particle');

      var Body = _dereq_('../objects/Body');

      var Material = _dereq_('../material/Material');
      /**
       * Smoothed-particle hydrodynamics system
       * @class SPHSystem
       * @constructor
       */


      function SPHSystem() {
        this.particles = [];
        /**
         * Density of the system (kg/m3).
         * @property {number} density
         */

        this.density = 1;
        /**
         * Distance below which two particles are considered to be neighbors.
         * It should be adjusted so there are about 15-20 neighbor particles within this radius.
         * @property {number} smoothingRadius
         */

        this.smoothingRadius = 1;
        this.speedOfSound = 1;
        /**
         * Viscosity of the system.
         * @property {number} viscosity
         */

        this.viscosity = 0.01;
        this.eps = 0.000001; // Stuff Computed per particle

        this.pressures = [];
        this.densities = [];
        this.neighbors = [];
      }
      /**
       * Add a particle to the system.
       * @method add
       * @param {Body} particle
       */


      SPHSystem.prototype.add = function (particle) {
        this.particles.push(particle);

        if (this.neighbors.length < this.particles.length) {
          this.neighbors.push([]);
        }
      };
      /**
       * Remove a particle from the system.
       * @method remove
       * @param {Body} particle
       */


      SPHSystem.prototype.remove = function (particle) {
        var idx = this.particles.indexOf(particle);

        if (idx !== -1) {
          this.particles.splice(idx, 1);

          if (this.neighbors.length > this.particles.length) {
            this.neighbors.pop();
          }
        }
      };
      /**
       * Get neighbors within smoothing volume, save in the array neighbors
       * @method getNeighbors
       * @param {Body} particle
       * @param {Array} neighbors
       */


      var SPHSystem_getNeighbors_dist = new Vec3();

      SPHSystem.prototype.getNeighbors = function (particle, neighbors) {
        var N = this.particles.length,
            id = particle.id,
            R2 = this.smoothingRadius * this.smoothingRadius,
            dist = SPHSystem_getNeighbors_dist;

        for (var i = 0; i !== N; i++) {
          var p = this.particles[i];
          p.position.vsub(particle.position, dist);

          if (id !== p.id && dist.norm2() < R2) {
            neighbors.push(p);
          }
        }
      }; // Temp vectors for calculation


      var SPHSystem_update_dist = new Vec3(),
          SPHSystem_update_a_pressure = new Vec3(),
          SPHSystem_update_a_visc = new Vec3(),
          SPHSystem_update_gradW = new Vec3(),
          SPHSystem_update_r_vec = new Vec3(),
          SPHSystem_update_u = new Vec3(); // Relative velocity

      SPHSystem.prototype.update = function () {
        var N = this.particles.length,
            dist = SPHSystem_update_dist,
            cs = this.speedOfSound,
            eps = this.eps;

        for (var i = 0; i !== N; i++) {
          var p = this.particles[i]; // Current particle

          var neighbors = this.neighbors[i]; // Get neighbors

          neighbors.length = 0;
          this.getNeighbors(p, neighbors);
          neighbors.push(this.particles[i]); // Add current too

          var numNeighbors = neighbors.length; // Accumulate density for the particle

          var sum = 0.0;

          for (var j = 0; j !== numNeighbors; j++) {
            //printf("Current particle has position %f %f %f\n",objects[id].pos.x(),objects[id].pos.y(),objects[id].pos.z());
            p.position.vsub(neighbors[j].position, dist);
            var len = dist.norm();
            var weight = this.w(len);
            sum += neighbors[j].mass * weight;
          } // Save


          this.densities[i] = sum;
          this.pressures[i] = cs * cs * (this.densities[i] - this.density);
        } // Add forces
        // Sum to these accelerations


        var a_pressure = SPHSystem_update_a_pressure;
        var a_visc = SPHSystem_update_a_visc;
        var gradW = SPHSystem_update_gradW;
        var r_vec = SPHSystem_update_r_vec;
        var u = SPHSystem_update_u;

        for (var i = 0; i !== N; i++) {
          var particle = this.particles[i];
          a_pressure.set(0, 0, 0);
          a_visc.set(0, 0, 0); // Init vars

          var Pij;
          var nabla;
          var Vij; // Sum up for all other neighbors

          var neighbors = this.neighbors[i];
          var numNeighbors = neighbors.length; //printf("Neighbors: ");

          for (var j = 0; j !== numNeighbors; j++) {
            var neighbor = neighbors[j]; //printf("%d ",nj);
            // Get r once for all..

            particle.position.vsub(neighbor.position, r_vec);
            var r = r_vec.norm(); // Pressure contribution

            Pij = -neighbor.mass * (this.pressures[i] / (this.densities[i] * this.densities[i] + eps) + this.pressures[j] / (this.densities[j] * this.densities[j] + eps));
            this.gradw(r_vec, gradW); // Add to pressure acceleration

            gradW.mult(Pij, gradW);
            a_pressure.vadd(gradW, a_pressure); // Viscosity contribution

            neighbor.velocity.vsub(particle.velocity, u);
            u.mult(1.0 / (0.0001 + this.densities[i] * this.densities[j]) * this.viscosity * neighbor.mass, u);
            nabla = this.nablaw(r);
            u.mult(nabla, u); // Add to viscosity acceleration

            a_visc.vadd(u, a_visc);
          } // Calculate force


          a_visc.mult(particle.mass, a_visc);
          a_pressure.mult(particle.mass, a_pressure); // Add force to particles

          particle.force.vadd(a_visc, particle.force);
          particle.force.vadd(a_pressure, particle.force);
        }
      }; // Calculate the weight using the W(r) weightfunction


      SPHSystem.prototype.w = function (r) {
        // 315
        var h = this.smoothingRadius;
        return 315.0 / (64.0 * Math.PI * Math.pow(h, 9)) * Math.pow(h * h - r * r, 3);
      }; // calculate gradient of the weight function


      SPHSystem.prototype.gradw = function (rVec, resultVec) {
        var r = rVec.norm(),
            h = this.smoothingRadius;
        rVec.mult(945.0 / (32.0 * Math.PI * Math.pow(h, 9)) * Math.pow(h * h - r * r, 2), resultVec);
      }; // Calculate nabla(W)


      SPHSystem.prototype.nablaw = function (r) {
        var h = this.smoothingRadius;
        var nabla = 945.0 / (32.0 * Math.PI * Math.pow(h, 9)) * (h * h - r * r) * (7 * r * r - 3 * h * h);
        return nabla;
      };
    }, {
      "../material/Material": 26,
      "../math/Quaternion": 29,
      "../math/Vec3": 31,
      "../objects/Body": 32,
      "../shapes/Particle": 42,
      "../shapes/Shape": 44
    }],
    36: [function (_dereq_, module, exports) {
      var Vec3 = _dereq_('../math/Vec3');

      module.exports = Spring;
      /**
       * A spring, connecting two bodies.
       *
       * @class Spring
       * @constructor
       * @param {Body} bodyA
       * @param {Body} bodyB
       * @param {Object} [options]
       * @param {number} [options.restLength]   A number > 0. Default: 1
       * @param {number} [options.stiffness]    A number >= 0. Default: 100
       * @param {number} [options.damping]      A number >= 0. Default: 1
       * @param {Vec3}  [options.worldAnchorA] Where to hook the spring to body A, in world coordinates.
       * @param {Vec3}  [options.worldAnchorB]
       * @param {Vec3}  [options.localAnchorA] Where to hook the spring to body A, in local body coordinates.
       * @param {Vec3}  [options.localAnchorB]
       */

      function Spring(bodyA, bodyB, options) {
        options = options || {};
        /**
         * Rest length of the spring.
         * @property restLength
         * @type {number}
         */

        this.restLength = typeof options.restLength === "number" ? options.restLength : 1;
        /**
         * Stiffness of the spring.
         * @property stiffness
         * @type {number}
         */

        this.stiffness = options.stiffness || 100;
        /**
         * Damping of the spring.
         * @property damping
         * @type {number}
         */

        this.damping = options.damping || 1;
        /**
         * First connected body.
         * @property bodyA
         * @type {Body}
         */

        this.bodyA = bodyA;
        /**
         * Second connected body.
         * @property bodyB
         * @type {Body}
         */

        this.bodyB = bodyB;
        /**
         * Anchor for bodyA in local bodyA coordinates.
         * @property localAnchorA
         * @type {Vec3}
         */

        this.localAnchorA = new Vec3();
        /**
         * Anchor for bodyB in local bodyB coordinates.
         * @property localAnchorB
         * @type {Vec3}
         */

        this.localAnchorB = new Vec3();

        if (options.localAnchorA) {
          this.localAnchorA.copy(options.localAnchorA);
        }

        if (options.localAnchorB) {
          this.localAnchorB.copy(options.localAnchorB);
        }

        if (options.worldAnchorA) {
          this.setWorldAnchorA(options.worldAnchorA);
        }

        if (options.worldAnchorB) {
          this.setWorldAnchorB(options.worldAnchorB);
        }
      }
      /**
       * Set the anchor point on body A, using world coordinates.
       * @method setWorldAnchorA
       * @param {Vec3} worldAnchorA
       */


      Spring.prototype.setWorldAnchorA = function (worldAnchorA) {
        this.bodyA.pointToLocalFrame(worldAnchorA, this.localAnchorA);
      };
      /**
       * Set the anchor point on body B, using world coordinates.
       * @method setWorldAnchorB
       * @param {Vec3} worldAnchorB
       */


      Spring.prototype.setWorldAnchorB = function (worldAnchorB) {
        this.bodyB.pointToLocalFrame(worldAnchorB, this.localAnchorB);
      };
      /**
       * Get the anchor point on body A, in world coordinates.
       * @method getWorldAnchorA
       * @param {Vec3} result The vector to store the result in.
       */


      Spring.prototype.getWorldAnchorA = function (result) {
        this.bodyA.pointToWorldFrame(this.localAnchorA, result);
      };
      /**
       * Get the anchor point on body B, in world coordinates.
       * @method getWorldAnchorB
       * @param {Vec3} result The vector to store the result in.
       */


      Spring.prototype.getWorldAnchorB = function (result) {
        this.bodyB.pointToWorldFrame(this.localAnchorB, result);
      };

      var applyForce_r = new Vec3(),
          applyForce_r_unit = new Vec3(),
          applyForce_u = new Vec3(),
          applyForce_f = new Vec3(),
          applyForce_worldAnchorA = new Vec3(),
          applyForce_worldAnchorB = new Vec3(),
          applyForce_ri = new Vec3(),
          applyForce_rj = new Vec3(),
          applyForce_ri_x_f = new Vec3(),
          applyForce_rj_x_f = new Vec3(),
          applyForce_tmp = new Vec3();
      /**
       * Apply the spring force to the connected bodies.
       * @method applyForce
       */

      Spring.prototype.applyForce = function () {
        var k = this.stiffness,
            d = this.damping,
            l = this.restLength,
            bodyA = this.bodyA,
            bodyB = this.bodyB,
            r = applyForce_r,
            r_unit = applyForce_r_unit,
            u = applyForce_u,
            f = applyForce_f,
            tmp = applyForce_tmp;
        var worldAnchorA = applyForce_worldAnchorA,
            worldAnchorB = applyForce_worldAnchorB,
            ri = applyForce_ri,
            rj = applyForce_rj,
            ri_x_f = applyForce_ri_x_f,
            rj_x_f = applyForce_rj_x_f; // Get world anchors

        this.getWorldAnchorA(worldAnchorA);
        this.getWorldAnchorB(worldAnchorB); // Get offset points

        worldAnchorA.vsub(bodyA.position, ri);
        worldAnchorB.vsub(bodyB.position, rj); // Compute distance vector between world anchor points

        worldAnchorB.vsub(worldAnchorA, r);
        var rlen = r.norm();
        r_unit.copy(r);
        r_unit.normalize(); // Compute relative velocity of the anchor points, u

        bodyB.velocity.vsub(bodyA.velocity, u); // Add rotational velocity

        bodyB.angularVelocity.cross(rj, tmp);
        u.vadd(tmp, u);
        bodyA.angularVelocity.cross(ri, tmp);
        u.vsub(tmp, u); // F = - k * ( x - L ) - D * ( u )

        r_unit.mult(-k * (rlen - l) - d * u.dot(r_unit), f); // Add forces to bodies

        bodyA.force.vsub(f, bodyA.force);
        bodyB.force.vadd(f, bodyB.force); // Angular force

        ri.cross(f, ri_x_f);
        rj.cross(f, rj_x_f);
        bodyA.torque.vsub(ri_x_f, bodyA.torque);
        bodyB.torque.vadd(rj_x_f, bodyB.torque);
      };
    }, {
      "../math/Vec3": 31
    }],
    37: [function (_dereq_, module, exports) {
      var Vec3 = _dereq_('../math/Vec3');

      var Transform = _dereq_('../math/Transform');

      var RaycastResult = _dereq_('../collision/RaycastResult');

      var Utils = _dereq_('../utils/Utils');

      module.exports = WheelInfo;
      /**
       * @class WheelInfo
       * @constructor
       * @param {Object} [options]
       *
       * @param {Vec3} [options.chassisConnectionPointLocal]
       * @param {Vec3} [options.chassisConnectionPointWorld]
       * @param {Vec3} [options.directionLocal]
       * @param {Vec3} [options.directionWorld]
       * @param {Vec3} [options.axleLocal]
       * @param {Vec3} [options.axleWorld]
       * @param {number} [options.suspensionRestLength=1]
       * @param {number} [options.suspensionMaxLength=2]
       * @param {number} [options.radius=1]
       * @param {number} [options.suspensionStiffness=100]
       * @param {number} [options.dampingCompression=10]
       * @param {number} [options.dampingRelaxation=10]
       * @param {number} [options.frictionSlip=10000]
       * @param {number} [options.steering=0]
       * @param {number} [options.rotation=0]
       * @param {number} [options.deltaRotation=0]
       * @param {number} [options.rollInfluence=0.01]
       * @param {number} [options.maxSuspensionForce]
       * @param {boolean} [options.isFrontWheel=true]
       * @param {number} [options.clippedInvContactDotSuspension=1]
       * @param {number} [options.suspensionRelativeVelocity=0]
       * @param {number} [options.suspensionForce=0]
       * @param {number} [options.skidInfo=0]
       * @param {number} [options.suspensionLength=0]
       * @param {number} [options.maxSuspensionTravel=1]
       * @param {boolean} [options.useCustomSlidingRotationalSpeed=false]
       * @param {number} [options.customSlidingRotationalSpeed=-0.1]
       */

      function WheelInfo(options) {
        options = Utils.defaults(options, {
          chassisConnectionPointLocal: new Vec3(),
          chassisConnectionPointWorld: new Vec3(),
          directionLocal: new Vec3(),
          directionWorld: new Vec3(),
          axleLocal: new Vec3(),
          axleWorld: new Vec3(),
          suspensionRestLength: 1,
          suspensionMaxLength: 2,
          radius: 1,
          suspensionStiffness: 100,
          dampingCompression: 10,
          dampingRelaxation: 10,
          frictionSlip: 10000,
          steering: 0,
          rotation: 0,
          deltaRotation: 0,
          rollInfluence: 0.01,
          maxSuspensionForce: Number.MAX_VALUE,
          isFrontWheel: true,
          clippedInvContactDotSuspension: 1,
          suspensionRelativeVelocity: 0,
          suspensionForce: 0,
          skidInfo: 0,
          suspensionLength: 0,
          maxSuspensionTravel: 1,
          useCustomSlidingRotationalSpeed: false,
          customSlidingRotationalSpeed: -0.1
        });
        /**
         * Max travel distance of the suspension, in meters.
         * @property {number} maxSuspensionTravel
         */

        this.maxSuspensionTravel = options.maxSuspensionTravel;
        /**
         * Speed to apply to the wheel rotation when the wheel is sliding.
         * @property {number} customSlidingRotationalSpeed
         */

        this.customSlidingRotationalSpeed = options.customSlidingRotationalSpeed;
        /**
         * If the customSlidingRotationalSpeed should be used.
         * @property {Boolean} useCustomSlidingRotationalSpeed
         */

        this.useCustomSlidingRotationalSpeed = options.useCustomSlidingRotationalSpeed;
        /**
         * @property {Boolean} sliding
         */

        this.sliding = false;
        /**
         * Connection point, defined locally in the chassis body frame.
         * @property {Vec3} chassisConnectionPointLocal
         */

        this.chassisConnectionPointLocal = options.chassisConnectionPointLocal.clone();
        /**
         * @property {Vec3} chassisConnectionPointWorld
         */

        this.chassisConnectionPointWorld = options.chassisConnectionPointWorld.clone();
        /**
         * @property {Vec3} directionLocal
         */

        this.directionLocal = options.directionLocal.clone();
        /**
         * @property {Vec3} directionWorld
         */

        this.directionWorld = options.directionWorld.clone();
        /**
         * @property {Vec3} axleLocal
         */

        this.axleLocal = options.axleLocal.clone();
        /**
         * @property {Vec3} axleWorld
         */

        this.axleWorld = options.axleWorld.clone();
        /**
         * @property {number} suspensionRestLength
         */

        this.suspensionRestLength = options.suspensionRestLength;
        /**
         * @property {number} suspensionMaxLength
         */

        this.suspensionMaxLength = options.suspensionMaxLength;
        /**
         * @property {number} radius
         */

        this.radius = options.radius;
        /**
         * @property {number} suspensionStiffness
         */

        this.suspensionStiffness = options.suspensionStiffness;
        /**
         * @property {number} dampingCompression
         */

        this.dampingCompression = options.dampingCompression;
        /**
         * @property {number} dampingRelaxation
         */

        this.dampingRelaxation = options.dampingRelaxation;
        /**
         * @property {number} frictionSlip
         */

        this.frictionSlip = options.frictionSlip;
        /**
         * @property {number} steering
         */

        this.steering = 0;
        /**
         * Rotation value, in radians.
         * @property {number} rotation
         */

        this.rotation = 0;
        /**
         * @property {number} deltaRotation
         */

        this.deltaRotation = 0;
        /**
         * @property {number} rollInfluence
         */

        this.rollInfluence = options.rollInfluence;
        /**
         * @property {number} maxSuspensionForce
         */

        this.maxSuspensionForce = options.maxSuspensionForce;
        /**
         * @property {number} engineForce
         */

        this.engineForce = 0;
        /**
         * @property {number} brake
         */

        this.brake = 0;
        /**
         * @property {number} isFrontWheel
         */

        this.isFrontWheel = options.isFrontWheel;
        /**
         * @property {number} clippedInvContactDotSuspension
         */

        this.clippedInvContactDotSuspension = 1;
        /**
         * @property {number} suspensionRelativeVelocity
         */

        this.suspensionRelativeVelocity = 0;
        /**
         * @property {number} suspensionForce
         */

        this.suspensionForce = 0;
        /**
         * @property {number} skidInfo
         */

        this.skidInfo = 0;
        /**
         * @property {number} suspensionLength
         */

        this.suspensionLength = 0;
        /**
         * @property {number} sideImpulse
         */

        this.sideImpulse = 0;
        /**
         * @property {number} forwardImpulse
         */

        this.forwardImpulse = 0;
        /**
         * The result from raycasting
         * @property {RaycastResult} raycastResult
         */

        this.raycastResult = new RaycastResult();
        /**
         * Wheel world transform
         * @property {Transform} worldTransform
         */

        this.worldTransform = new Transform();
        /**
         * @property {boolean} isInContact
         */

        this.isInContact = false;
      }

      var chassis_velocity_at_contactPoint = new Vec3();
      var relpos = new Vec3();
      var chassis_velocity_at_contactPoint = new Vec3();

      WheelInfo.prototype.updateWheel = function (chassis) {
        var raycastResult = this.raycastResult;

        if (this.isInContact) {
          var project = raycastResult.hitNormalWorld.dot(raycastResult.directionWorld);
          raycastResult.hitPointWorld.vsub(chassis.position, relpos);
          chassis.getVelocityAtWorldPoint(relpos, chassis_velocity_at_contactPoint);
          var projVel = raycastResult.hitNormalWorld.dot(chassis_velocity_at_contactPoint);

          if (project >= -0.1) {
            this.suspensionRelativeVelocity = 0.0;
            this.clippedInvContactDotSuspension = 1.0 / 0.1;
          } else {
            var inv = -1 / project;
            this.suspensionRelativeVelocity = projVel * inv;
            this.clippedInvContactDotSuspension = inv;
          }
        } else {
          // Not in contact : position wheel in a nice (rest length) position
          raycastResult.suspensionLength = this.suspensionRestLength;
          this.suspensionRelativeVelocity = 0.0;
          raycastResult.directionWorld.scale(-1, raycastResult.hitNormalWorld);
          this.clippedInvContactDotSuspension = 1.0;
        }
      };
    }, {
      "../collision/RaycastResult": 11,
      "../math/Transform": 30,
      "../math/Vec3": 31,
      "../utils/Utils": 54
    }],
    38: [function (_dereq_, module, exports) {
      module.exports = Box;

      var Shape = _dereq_('./Shape');

      var Vec3 = _dereq_('../math/Vec3');

      var ConvexPolyhedron = _dereq_('./ConvexPolyhedron');
      /**
       * A 3d box shape.
       * @class Box
       * @constructor
       * @param {Vec3} halfExtents
       * @author schteppe
       * @extends Shape
       */


      function Box(halfExtents) {
        Shape.call(this, {
          type: Shape.types.BOX
        });
        /**
         * @property halfExtents
         * @type {Vec3}
         */

        this.halfExtents = halfExtents;
        /**
         * Used by the contact generator to make contacts with other convex polyhedra for example
         * @property convexPolyhedronRepresentation
         * @type {ConvexPolyhedron}
         */

        this.convexPolyhedronRepresentation = null;
        this.updateConvexPolyhedronRepresentation();
        this.updateBoundingSphereRadius();
      }

      Box.prototype = new Shape();
      Box.prototype.constructor = Box;
      /**
       * Updates the local convex polyhedron representation used for some collisions.
       * @method updateConvexPolyhedronRepresentation
       */

      Box.prototype.updateConvexPolyhedronRepresentation = function () {
        var sx = this.halfExtents.x;
        var sy = this.halfExtents.y;
        var sz = this.halfExtents.z;
        var V = Vec3;
        var vertices = [new V(-sx, -sy, -sz), new V(sx, -sy, -sz), new V(sx, sy, -sz), new V(-sx, sy, -sz), new V(-sx, -sy, sz), new V(sx, -sy, sz), new V(sx, sy, sz), new V(-sx, sy, sz)];
        var indices = [[3, 2, 1, 0], // -z
        [4, 5, 6, 7], // +z
        [5, 4, 0, 1], // -y
        [2, 3, 7, 6], // +y
        [0, 4, 7, 3], // -x
        [1, 2, 6, 5] // +x
        ];
        var axes = [new V(0, 0, 1), new V(0, 1, 0), new V(1, 0, 0)];
        var h = new ConvexPolyhedron(vertices, indices);
        this.convexPolyhedronRepresentation = h;
        h.material = this.material;
      };
      /**
       * @method calculateLocalInertia
       * @param  {Number} mass
       * @param  {Vec3} target
       * @return {Vec3}
       */


      Box.prototype.calculateLocalInertia = function (mass, target) {
        target = target || new Vec3();
        Box.calculateInertia(this.halfExtents, mass, target);
        return target;
      };

      Box.calculateInertia = function (halfExtents, mass, target) {
        var e = halfExtents;

        if (e.isZero()) {
          target.x = 2.0 / 12.0 * mass;
          target.y = 2.0 / 12.0 * mass;
          target.z = 2.0 / 12.0 * mass;
        } else {
          target.x = 1.0 / 12.0 * mass * (2 * e.y * 2 * e.y + 2 * e.z * 2 * e.z);
          target.y = 1.0 / 12.0 * mass * (2 * e.x * 2 * e.x + 2 * e.z * 2 * e.z);
          target.z = 1.0 / 12.0 * mass * (2 * e.y * 2 * e.y + 2 * e.x * 2 * e.x);
        }
      };
      /**
       * Get the box 6 side normals
       * @method getSideNormals
       * @param {array}      sixTargetVectors An array of 6 vectors, to store the resulting side normals in.
       * @param {Quaternion} quat             Orientation to apply to the normal vectors. If not provided, the vectors will be in respect to the local frame.
       * @return {array}
       */


      Box.prototype.getSideNormals = function (sixTargetVectors, quat) {
        var sides = sixTargetVectors;
        var ex = this.halfExtents;
        sides[0].set(ex.x, 0, 0);
        sides[1].set(0, ex.y, 0);
        sides[2].set(0, 0, ex.z);
        sides[3].set(-ex.x, 0, 0);
        sides[4].set(0, -ex.y, 0);
        sides[5].set(0, 0, -ex.z);

        if (quat !== undefined) {
          for (var i = 0; i !== sides.length; i++) {
            quat.vmult(sides[i], sides[i]);
          }
        }

        return sides;
      };

      Box.prototype.volume = function () {
        return 8.0 * this.halfExtents.x * this.halfExtents.y * this.halfExtents.z;
      };

      Box.prototype.updateBoundingSphereRadius = function () {
        this.boundingSphereRadius = this.halfExtents.norm();
      };

      var worldCornerTempPos = new Vec3();
      var worldCornerTempNeg = new Vec3();

      Box.prototype.forEachWorldCorner = function (pos, quat, callback) {
        var e = this.halfExtents;
        var corners = [[e.x, e.y, e.z], [-e.x, e.y, e.z], [-e.x, -e.y, e.z], [-e.x, -e.y, -e.z], [e.x, -e.y, -e.z], [e.x, e.y, -e.z], [-e.x, e.y, -e.z], [e.x, -e.y, e.z]];

        for (var i = 0; i < corners.length; i++) {
          worldCornerTempPos.set(corners[i][0], corners[i][1], corners[i][2]);
          quat.vmult(worldCornerTempPos, worldCornerTempPos);
          pos.vadd(worldCornerTempPos, worldCornerTempPos);
          callback(worldCornerTempPos.x, worldCornerTempPos.y, worldCornerTempPos.z);
        }
      };

      var worldCornersTemp = [new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3()];

      Box.prototype.calculateWorldAABB = function (pos, quat, min, max) {
        var e = this.halfExtents;
        worldCornersTemp[0].set(e.x, e.y, e.z);
        worldCornersTemp[1].set(-e.x, e.y, e.z);
        worldCornersTemp[2].set(-e.x, -e.y, e.z);
        worldCornersTemp[3].set(-e.x, -e.y, -e.z);
        worldCornersTemp[4].set(e.x, -e.y, -e.z);
        worldCornersTemp[5].set(e.x, e.y, -e.z);
        worldCornersTemp[6].set(-e.x, e.y, -e.z);
        worldCornersTemp[7].set(e.x, -e.y, e.z);
        var wc = worldCornersTemp[0];
        quat.vmult(wc, wc);
        pos.vadd(wc, wc);
        max.copy(wc);
        min.copy(wc);

        for (var i = 1; i < 8; i++) {
          var wc = worldCornersTemp[i];
          quat.vmult(wc, wc);
          pos.vadd(wc, wc);
          var x = wc.x;
          var y = wc.y;
          var z = wc.z;

          if (x > max.x) {
            max.x = x;
          }

          if (y > max.y) {
            max.y = y;
          }

          if (z > max.z) {
            max.z = z;
          }

          if (x < min.x) {
            min.x = x;
          }

          if (y < min.y) {
            min.y = y;
          }

          if (z < min.z) {
            min.z = z;
          }
        } // Get each axis max
        // min.set(Infinity,Infinity,Infinity);
        // max.set(-Infinity,-Infinity,-Infinity);
        // this.forEachWorldCorner(pos,quat,function(x,y,z){
        //     if(x > max.x){
        //         max.x = x;
        //     }
        //     if(y > max.y){
        //         max.y = y;
        //     }
        //     if(z > max.z){
        //         max.z = z;
        //     }
        //     if(x < min.x){
        //         min.x = x;
        //     }
        //     if(y < min.y){
        //         min.y = y;
        //     }
        //     if(z < min.z){
        //         min.z = z;
        //     }
        // });

      };
    }, {
      "../math/Vec3": 31,
      "./ConvexPolyhedron": 39,
      "./Shape": 44
    }],
    39: [function (_dereq_, module, exports) {
      module.exports = ConvexPolyhedron;

      var Shape = _dereq_('./Shape');

      var Vec3 = _dereq_('../math/Vec3');

      var Quaternion = _dereq_('../math/Quaternion');

      var Transform = _dereq_('../math/Transform');
      /**
       * A set of polygons describing a convex shape.
       * @class ConvexPolyhedron
       * @constructor
       * @extends Shape
       * @description The shape MUST be convex for the code to work properly. No polygons may be coplanar (contained
       * in the same 3D plane), instead these should be merged into one polygon.
       *
       * @param {array} points An array of Vec3's
       * @param {array} faces Array of integer arrays, describing which vertices that is included in each face.
       *
       * @author qiao / https://github.com/qiao (original author, see https://github.com/qiao/three.js/commit/85026f0c769e4000148a67d45a9e9b9c5108836f)
       * @author schteppe / https://github.com/schteppe
       * @see http://www.altdevblogaday.com/2011/05/13/contact-generation-between-3d-convex-meshes/
       * @see http://bullet.googlecode.com/svn/trunk/src/BulletCollision/NarrowPhaseCollision/btPolyhedralContactClipping.cpp
       *
       * @todo Move the clipping functions to ContactGenerator?
       * @todo Automatically merge coplanar polygons in constructor.
       */


      function ConvexPolyhedron(points, faces, uniqueAxes) {
        Shape.call(this, {
          type: Shape.types.CONVEXPOLYHEDRON
        });
        /**
         * Array of Vec3
         * @property vertices
         * @type {Array}
         */

        this.vertices = points || [];
        this.worldVertices = []; // World transformed version of .vertices

        this.worldVerticesNeedsUpdate = true;
        /**
         * Array of integer arrays, indicating which vertices each face consists of
         * @property faces
         * @type {Array}
         */

        this.faces = faces || [];
        /**
         * Array of Vec3
         * @property faceNormals
         * @type {Array}
         */

        this.faceNormals = [];
        this.computeNormals();
        this.worldFaceNormalsNeedsUpdate = true;
        this.worldFaceNormals = []; // World transformed version of .faceNormals

        /**
         * Array of Vec3
         * @property uniqueEdges
         * @type {Array}
         */

        this.uniqueEdges = [];
        /**
         * If given, these locally defined, normalized axes are the only ones being checked when doing separating axis check.
         * @property {Array} uniqueAxes
         */

        this.uniqueAxes = uniqueAxes ? uniqueAxes.slice() : null;
        this.computeEdges();
        this.updateBoundingSphereRadius();
      }

      ConvexPolyhedron.prototype = new Shape();
      ConvexPolyhedron.prototype.constructor = ConvexPolyhedron;
      var computeEdges_tmpEdge = new Vec3();
      /**
       * Computes uniqueEdges
       * @method computeEdges
       */

      ConvexPolyhedron.prototype.computeEdges = function () {
        var faces = this.faces;
        var vertices = this.vertices;
        var nv = vertices.length;
        var edges = this.uniqueEdges;
        edges.length = 0;
        var edge = computeEdges_tmpEdge;

        for (var i = 0; i !== faces.length; i++) {
          var face = faces[i];
          var numVertices = face.length;

          for (var j = 0; j !== numVertices; j++) {
            var k = (j + 1) % numVertices;
            vertices[face[j]].vsub(vertices[face[k]], edge);
            edge.normalize();
            var found = false;

            for (var p = 0; p !== edges.length; p++) {
              if (edges[p].almostEquals(edge) || edges[p].almostEquals(edge)) {
                found = true;
                break;
              }
            }

            if (!found) {
              edges.push(edge.clone());
            }
          }
        }
      };
      /**
       * Compute the normals of the faces. Will reuse existing Vec3 objects in the .faceNormals array if they exist.
       * @method computeNormals
       */


      ConvexPolyhedron.prototype.computeNormals = function () {
        this.faceNormals.length = this.faces.length; // Generate normals

        for (var i = 0; i < this.faces.length; i++) {
          // Check so all vertices exists for this face
          for (var j = 0; j < this.faces[i].length; j++) {
            if (!this.vertices[this.faces[i][j]]) {
              throw new Error("Vertex " + this.faces[i][j] + " not found!");
            }
          }

          var n = this.faceNormals[i] || new Vec3();
          this.getFaceNormal(i, n);
          n.negate(n);
          this.faceNormals[i] = n;
          var vertex = this.vertices[this.faces[i][0]];

          if (n.dot(vertex) < 0) {
            console.error(".faceNormals[" + i + "] = Vec3(" + n.toString() + ") looks like it points into the shape? The vertices follow. Make sure they are ordered CCW around the normal, using the right hand rule.");

            for (var j = 0; j < this.faces[i].length; j++) {
              console.warn(".vertices[" + this.faces[i][j] + "] = Vec3(" + this.vertices[this.faces[i][j]].toString() + ")");
            }
          }
        }
      };
      /**
       * Get face normal given 3 vertices
       * @static
       * @method getFaceNormal
       * @param {Vec3} va
       * @param {Vec3} vb
       * @param {Vec3} vc
       * @param {Vec3} target
       */


      var cb = new Vec3();
      var ab = new Vec3();

      ConvexPolyhedron.computeNormal = function (va, vb, vc, target) {
        vb.vsub(va, ab);
        vc.vsub(vb, cb);
        cb.cross(ab, target);

        if (!target.isZero()) {
          target.normalize();
        }
      };
      /**
       * Compute the normal of a face from its vertices
       * @method getFaceNormal
       * @param  {Number} i
       * @param  {Vec3} target
       */


      ConvexPolyhedron.prototype.getFaceNormal = function (i, target) {
        var f = this.faces[i];
        var va = this.vertices[f[0]];
        var vb = this.vertices[f[1]];
        var vc = this.vertices[f[2]];
        return ConvexPolyhedron.computeNormal(va, vb, vc, target);
      };
      /**
       * @method clipAgainstHull
       * @param {Vec3} posA
       * @param {Quaternion} quatA
       * @param {ConvexPolyhedron} hullB
       * @param {Vec3} posB
       * @param {Quaternion} quatB
       * @param {Vec3} separatingNormal
       * @param {Number} minDist Clamp distance
       * @param {Number} maxDist
       * @param {array} result The an array of contact point objects, see clipFaceAgainstHull
       * @see http://bullet.googlecode.com/svn/trunk/src/BulletCollision/NarrowPhaseCollision/btPolyhedralContactClipping.cpp
       */


      var cah_WorldNormal = new Vec3();

      ConvexPolyhedron.prototype.clipAgainstHull = function (posA, quatA, hullB, posB, quatB, separatingNormal, minDist, maxDist, result) {
        var WorldNormal = cah_WorldNormal;
        var hullA = this;
        var curMaxDist = maxDist;
        var closestFaceB = -1;
        var dmax = -Number.MAX_VALUE;

        for (var face = 0; face < hullB.faces.length; face++) {
          WorldNormal.copy(hullB.faceNormals[face]);
          quatB.vmult(WorldNormal, WorldNormal); //posB.vadd(WorldNormal,WorldNormal);

          var d = WorldNormal.dot(separatingNormal);

          if (d > dmax) {
            dmax = d;
            closestFaceB = face;
          }
        }

        var worldVertsB1 = [];
        var polyB = hullB.faces[closestFaceB];
        var numVertices = polyB.length;

        for (var e0 = 0; e0 < numVertices; e0++) {
          var b = hullB.vertices[polyB[e0]];
          var worldb = new Vec3();
          worldb.copy(b);
          quatB.vmult(worldb, worldb);
          posB.vadd(worldb, worldb);
          worldVertsB1.push(worldb);
        }

        if (closestFaceB >= 0) {
          this.clipFaceAgainstHull(separatingNormal, posA, quatA, worldVertsB1, minDist, maxDist, result);
        }
      };
      /**
       * Find the separating axis between this hull and another
       * @method findSeparatingAxis
       * @param {ConvexPolyhedron} hullB
       * @param {Vec3} posA
       * @param {Quaternion} quatA
       * @param {Vec3} posB
       * @param {Quaternion} quatB
       * @param {Vec3} target The target vector to save the axis in
       * @return {bool} Returns false if a separation is found, else true
       */


      var fsa_faceANormalWS3 = new Vec3(),
          fsa_Worldnormal1 = new Vec3(),
          fsa_deltaC = new Vec3(),
          fsa_worldEdge0 = new Vec3(),
          fsa_worldEdge1 = new Vec3(),
          fsa_Cross = new Vec3();

      ConvexPolyhedron.prototype.findSeparatingAxis = function (hullB, posA, quatA, posB, quatB, target, faceListA, faceListB) {
        var faceANormalWS3 = fsa_faceANormalWS3,
            Worldnormal1 = fsa_Worldnormal1,
            deltaC = fsa_deltaC,
            worldEdge0 = fsa_worldEdge0,
            worldEdge1 = fsa_worldEdge1,
            Cross = fsa_Cross;
        var dmin = Number.MAX_VALUE;
        var hullA = this;
        var curPlaneTests = 0;

        if (!hullA.uniqueAxes) {
          var numFacesA = faceListA ? faceListA.length : hullA.faces.length; // Test face normals from hullA

          for (var i = 0; i < numFacesA; i++) {
            var fi = faceListA ? faceListA[i] : i; // Get world face normal

            faceANormalWS3.copy(hullA.faceNormals[fi]);
            quatA.vmult(faceANormalWS3, faceANormalWS3);
            var d = hullA.testSepAxis(faceANormalWS3, hullB, posA, quatA, posB, quatB);

            if (d === false) {
              return false;
            }

            if (d < dmin) {
              dmin = d;
              target.copy(faceANormalWS3);
            }
          }
        } else {
          // Test unique axes
          for (var i = 0; i !== hullA.uniqueAxes.length; i++) {
            // Get world axis
            quatA.vmult(hullA.uniqueAxes[i], faceANormalWS3);
            var d = hullA.testSepAxis(faceANormalWS3, hullB, posA, quatA, posB, quatB);

            if (d === false) {
              return false;
            }

            if (d < dmin) {
              dmin = d;
              target.copy(faceANormalWS3);
            }
          }
        }

        if (!hullB.uniqueAxes) {
          // Test face normals from hullB
          var numFacesB = faceListB ? faceListB.length : hullB.faces.length;

          for (var i = 0; i < numFacesB; i++) {
            var fi = faceListB ? faceListB[i] : i;
            Worldnormal1.copy(hullB.faceNormals[fi]);
            quatB.vmult(Worldnormal1, Worldnormal1);
            curPlaneTests++;
            var d = hullA.testSepAxis(Worldnormal1, hullB, posA, quatA, posB, quatB);

            if (d === false) {
              return false;
            }

            if (d < dmin) {
              dmin = d;
              target.copy(Worldnormal1);
            }
          }
        } else {
          // Test unique axes in B
          for (var i = 0; i !== hullB.uniqueAxes.length; i++) {
            quatB.vmult(hullB.uniqueAxes[i], Worldnormal1);
            curPlaneTests++;
            var d = hullA.testSepAxis(Worldnormal1, hullB, posA, quatA, posB, quatB);

            if (d === false) {
              return false;
            }

            if (d < dmin) {
              dmin = d;
              target.copy(Worldnormal1);
            }
          }
        } // Test edges


        for (var e0 = 0; e0 !== hullA.uniqueEdges.length; e0++) {
          // Get world edge
          quatA.vmult(hullA.uniqueEdges[e0], worldEdge0);

          for (var e1 = 0; e1 !== hullB.uniqueEdges.length; e1++) {
            // Get world edge 2
            quatB.vmult(hullB.uniqueEdges[e1], worldEdge1);
            worldEdge0.cross(worldEdge1, Cross);

            if (!Cross.almostZero()) {
              Cross.normalize();
              var dist = hullA.testSepAxis(Cross, hullB, posA, quatA, posB, quatB);

              if (dist === false) {
                return false;
              }

              if (dist < dmin) {
                dmin = dist;
                target.copy(Cross);
              }
            }
          }
        }

        posB.vsub(posA, deltaC);

        if (deltaC.dot(target) > 0.0) {
          target.negate(target);
        }

        return true;
      };

      var maxminA = [],
          maxminB = [];
      /**
       * Test separating axis against two hulls. Both hulls are projected onto the axis and the overlap size is returned if there is one.
       * @method testSepAxis
       * @param {Vec3} axis
       * @param {ConvexPolyhedron} hullB
       * @param {Vec3} posA
       * @param {Quaternion} quatA
       * @param {Vec3} posB
       * @param {Quaternion} quatB
       * @return {number} The overlap depth, or FALSE if no penetration.
       */

      ConvexPolyhedron.prototype.testSepAxis = function (axis, hullB, posA, quatA, posB, quatB) {
        var hullA = this;
        ConvexPolyhedron.project(hullA, axis, posA, quatA, maxminA);
        ConvexPolyhedron.project(hullB, axis, posB, quatB, maxminB);
        var maxA = maxminA[0];
        var minA = maxminA[1];
        var maxB = maxminB[0];
        var minB = maxminB[1];

        if (maxA < minB || maxB < minA) {
          return false; // Separated
        }

        var d0 = maxA - minB;
        var d1 = maxB - minA;
        var depth = d0 < d1 ? d0 : d1;
        return depth;
      };

      var cli_aabbmin = new Vec3(),
          cli_aabbmax = new Vec3();
      /**
       * @method calculateLocalInertia
       * @param  {Number} mass
       * @param  {Vec3} target
       */

      ConvexPolyhedron.prototype.calculateLocalInertia = function (mass, target) {
        // Approximate with box inertia
        // Exact inertia calculation is overkill, but see http://geometrictools.com/Documentation/PolyhedralMassProperties.pdf for the correct way to do it
        this.computeLocalAABB(cli_aabbmin, cli_aabbmax);
        var x = cli_aabbmax.x - cli_aabbmin.x,
            y = cli_aabbmax.y - cli_aabbmin.y,
            z = cli_aabbmax.z - cli_aabbmin.z;
        target.x = 1.0 / 12.0 * mass * (2 * y * 2 * y + 2 * z * 2 * z);
        target.y = 1.0 / 12.0 * mass * (2 * x * 2 * x + 2 * z * 2 * z);
        target.z = 1.0 / 12.0 * mass * (2 * y * 2 * y + 2 * x * 2 * x);
      };
      /**
       * @method getPlaneConstantOfFace
       * @param  {Number} face_i Index of the face
       * @return {Number}
       */


      ConvexPolyhedron.prototype.getPlaneConstantOfFace = function (face_i) {
        var f = this.faces[face_i];
        var n = this.faceNormals[face_i];
        var v = this.vertices[f[0]];
        var c = -n.dot(v);
        return c;
      };
      /**
       * Clip a face against a hull.
       * @method clipFaceAgainstHull
       * @param {Vec3} separatingNormal
       * @param {Vec3} posA
       * @param {Quaternion} quatA
       * @param {Array} worldVertsB1 An array of Vec3 with vertices in the world frame.
       * @param {Number} minDist Distance clamping
       * @param {Number} maxDist
       * @param Array result Array to store resulting contact points in. Will be objects with properties: point, depth, normal. These are represented in world coordinates.
       */


      var cfah_faceANormalWS = new Vec3(),
          cfah_edge0 = new Vec3(),
          cfah_WorldEdge0 = new Vec3(),
          cfah_worldPlaneAnormal1 = new Vec3(),
          cfah_planeNormalWS1 = new Vec3(),
          cfah_worldA1 = new Vec3(),
          cfah_localPlaneNormal = new Vec3(),
          cfah_planeNormalWS = new Vec3();

      ConvexPolyhedron.prototype.clipFaceAgainstHull = function (separatingNormal, posA, quatA, worldVertsB1, minDist, maxDist, result) {
        var faceANormalWS = cfah_faceANormalWS,
            edge0 = cfah_edge0,
            WorldEdge0 = cfah_WorldEdge0,
            worldPlaneAnormal1 = cfah_worldPlaneAnormal1,
            planeNormalWS1 = cfah_planeNormalWS1,
            worldA1 = cfah_worldA1,
            localPlaneNormal = cfah_localPlaneNormal,
            planeNormalWS = cfah_planeNormalWS;
        var hullA = this;
        var worldVertsB2 = [];
        var pVtxIn = worldVertsB1;
        var pVtxOut = worldVertsB2; // Find the face with normal closest to the separating axis

        var closestFaceA = -1;
        var dmin = Number.MAX_VALUE;

        for (var face = 0; face < hullA.faces.length; face++) {
          faceANormalWS.copy(hullA.faceNormals[face]);
          quatA.vmult(faceANormalWS, faceANormalWS); //posA.vadd(faceANormalWS,faceANormalWS);

          var d = faceANormalWS.dot(separatingNormal);

          if (d < dmin) {
            dmin = d;
            closestFaceA = face;
          }
        }

        if (closestFaceA < 0) {
          // console.log("--- did not find any closest face... ---");
          return;
        } //console.log("closest A: ",closestFaceA);
        // Get the face and construct connected faces


        var polyA = hullA.faces[closestFaceA];
        polyA.connectedFaces = [];

        for (var i = 0; i < hullA.faces.length; i++) {
          for (var j = 0; j < hullA.faces[i].length; j++) {
            if (polyA.indexOf(hullA.faces[i][j]) !== -1
            /* Sharing a vertex*/
            && i !== closestFaceA
            /* Not the one we are looking for connections from */
            && polyA.connectedFaces.indexOf(i) === -1
            /* Not already added */
            ) {
                polyA.connectedFaces.push(i);
              }
          }
        } // Clip the polygon to the back of the planes of all faces of hull A, that are adjacent to the witness face


        var numContacts = pVtxIn.length;
        var numVerticesA = polyA.length;
        var res = [];

        for (var e0 = 0; e0 < numVerticesA; e0++) {
          var a = hullA.vertices[polyA[e0]];
          var b = hullA.vertices[polyA[(e0 + 1) % numVerticesA]];
          a.vsub(b, edge0);
          WorldEdge0.copy(edge0);
          quatA.vmult(WorldEdge0, WorldEdge0);
          posA.vadd(WorldEdge0, WorldEdge0);
          worldPlaneAnormal1.copy(this.faceNormals[closestFaceA]); //transA.getBasis()* btVector3(polyA.m_plane[0],polyA.m_plane[1],polyA.m_plane[2]);

          quatA.vmult(worldPlaneAnormal1, worldPlaneAnormal1);
          posA.vadd(worldPlaneAnormal1, worldPlaneAnormal1);
          WorldEdge0.cross(worldPlaneAnormal1, planeNormalWS1);
          planeNormalWS1.negate(planeNormalWS1);
          worldA1.copy(a);
          quatA.vmult(worldA1, worldA1);
          posA.vadd(worldA1, worldA1);
          var planeEqWS1 = -worldA1.dot(planeNormalWS1);
          var planeEqWS;

          if (true) {
            var otherFace = polyA.connectedFaces[e0];
            localPlaneNormal.copy(this.faceNormals[otherFace]);
            var localPlaneEq = this.getPlaneConstantOfFace(otherFace);
            planeNormalWS.copy(localPlaneNormal);
            quatA.vmult(planeNormalWS, planeNormalWS); //posA.vadd(planeNormalWS,planeNormalWS);

            var planeEqWS = localPlaneEq - planeNormalWS.dot(posA);
          } else {
            planeNormalWS.copy(planeNormalWS1);
            planeEqWS = planeEqWS1;
          } // Clip face against our constructed plane


          this.clipFaceAgainstPlane(pVtxIn, pVtxOut, planeNormalWS, planeEqWS); // Throw away all clipped points, but save the reamining until next clip

          while (pVtxIn.length) {
            pVtxIn.shift();
          }

          while (pVtxOut.length) {
            pVtxIn.push(pVtxOut.shift());
          }
        } //console.log("Resulting points after clip:",pVtxIn);
        // only keep contact points that are behind the witness face


        localPlaneNormal.copy(this.faceNormals[closestFaceA]);
        var localPlaneEq = this.getPlaneConstantOfFace(closestFaceA);
        planeNormalWS.copy(localPlaneNormal);
        quatA.vmult(planeNormalWS, planeNormalWS);
        var planeEqWS = localPlaneEq - planeNormalWS.dot(posA);

        for (var i = 0; i < pVtxIn.length; i++) {
          var depth = planeNormalWS.dot(pVtxIn[i]) + planeEqWS; //???

          /*console.log("depth calc from normal=",planeNormalWS.toString()," and constant "+planeEqWS+" and vertex ",pVtxIn[i].toString()," gives "+depth);*/

          if (depth <= minDist) {
            // console.log("clamped: depth="+depth+" to minDist="+(minDist+""));
            depth = minDist;
          }

          if (depth <= maxDist) {
            var point = pVtxIn[i];

            if (depth <= 0) {
              /*console.log("Got contact point ",point.toString(),
                ", depth=",depth,
                "contact normal=",separatingNormal.toString(),
                "plane",planeNormalWS.toString(),
                "planeConstant",planeEqWS);*/
              var p = {
                point: point,
                normal: planeNormalWS,
                depth: depth
              };
              result.push(p);
            }
          }
        }
      };
      /**
       * Clip a face in a hull against the back of a plane.
       * @method clipFaceAgainstPlane
       * @param {Array} inVertices
       * @param {Array} outVertices
       * @param {Vec3} planeNormal
       * @param {Number} planeConstant The constant in the mathematical plane equation
       */


      ConvexPolyhedron.prototype.clipFaceAgainstPlane = function (inVertices, outVertices, planeNormal, planeConstant) {
        var n_dot_first, n_dot_last;
        var numVerts = inVertices.length;

        if (numVerts < 2) {
          return outVertices;
        }

        var firstVertex = inVertices[inVertices.length - 1],
            lastVertex = inVertices[0];
        n_dot_first = planeNormal.dot(firstVertex) + planeConstant;

        for (var vi = 0; vi < numVerts; vi++) {
          lastVertex = inVertices[vi];
          n_dot_last = planeNormal.dot(lastVertex) + planeConstant;

          if (n_dot_first < 0) {
            if (n_dot_last < 0) {
              // Start < 0, end < 0, so output lastVertex
              var newv = new Vec3();
              newv.copy(lastVertex);
              outVertices.push(newv);
            } else {
              // Start < 0, end >= 0, so output intersection
              var newv = new Vec3();
              firstVertex.lerp(lastVertex, n_dot_first / (n_dot_first - n_dot_last), newv);
              outVertices.push(newv);
            }
          } else {
            if (n_dot_last < 0) {
              // Start >= 0, end < 0 so output intersection and end
              var newv = new Vec3();
              firstVertex.lerp(lastVertex, n_dot_first / (n_dot_first - n_dot_last), newv);
              outVertices.push(newv);
              outVertices.push(lastVertex);
            }
          }

          firstVertex = lastVertex;
          n_dot_first = n_dot_last;
        }

        return outVertices;
      }; // Updates .worldVertices and sets .worldVerticesNeedsUpdate to false.


      ConvexPolyhedron.prototype.computeWorldVertices = function (position, quat) {
        var N = this.vertices.length;

        while (this.worldVertices.length < N) {
          this.worldVertices.push(new Vec3());
        }

        var verts = this.vertices,
            worldVerts = this.worldVertices;

        for (var i = 0; i !== N; i++) {
          quat.vmult(verts[i], worldVerts[i]);
          position.vadd(worldVerts[i], worldVerts[i]);
        }

        this.worldVerticesNeedsUpdate = false;
      };

      var computeLocalAABB_worldVert = new Vec3();

      ConvexPolyhedron.prototype.computeLocalAABB = function (aabbmin, aabbmax) {
        var n = this.vertices.length,
            vertices = this.vertices,
            worldVert = computeLocalAABB_worldVert;
        aabbmin.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
        aabbmax.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);

        for (var i = 0; i < n; i++) {
          var v = vertices[i];

          if (v.x < aabbmin.x) {
            aabbmin.x = v.x;
          } else if (v.x > aabbmax.x) {
            aabbmax.x = v.x;
          }

          if (v.y < aabbmin.y) {
            aabbmin.y = v.y;
          } else if (v.y > aabbmax.y) {
            aabbmax.y = v.y;
          }

          if (v.z < aabbmin.z) {
            aabbmin.z = v.z;
          } else if (v.z > aabbmax.z) {
            aabbmax.z = v.z;
          }
        }
      };
      /**
       * Updates .worldVertices and sets .worldVerticesNeedsUpdate to false.
       * @method computeWorldFaceNormals
       * @param  {Quaternion} quat
       */


      ConvexPolyhedron.prototype.computeWorldFaceNormals = function (quat) {
        var N = this.faceNormals.length;

        while (this.worldFaceNormals.length < N) {
          this.worldFaceNormals.push(new Vec3());
        }

        var normals = this.faceNormals,
            worldNormals = this.worldFaceNormals;

        for (var i = 0; i !== N; i++) {
          quat.vmult(normals[i], worldNormals[i]);
        }

        this.worldFaceNormalsNeedsUpdate = false;
      };
      /**
       * @method updateBoundingSphereRadius
       */


      ConvexPolyhedron.prototype.updateBoundingSphereRadius = function () {
        // Assume points are distributed with local (0,0,0) as center
        var max2 = 0;
        var verts = this.vertices;

        for (var i = 0, N = verts.length; i !== N; i++) {
          var norm2 = verts[i].norm2();

          if (norm2 > max2) {
            max2 = norm2;
          }
        }

        this.boundingSphereRadius = Math.sqrt(max2);
      };

      var tempWorldVertex = new Vec3();
      /**
       * @method calculateWorldAABB
       * @param {Vec3}        pos
       * @param {Quaternion}  quat
       * @param {Vec3}        min
       * @param {Vec3}        max
       */

      ConvexPolyhedron.prototype.calculateWorldAABB = function (pos, quat, min, max) {
        var n = this.vertices.length,
            verts = this.vertices;
        var minx, miny, minz, maxx, maxy, maxz;

        for (var i = 0; i < n; i++) {
          tempWorldVertex.copy(verts[i]);
          quat.vmult(tempWorldVertex, tempWorldVertex);
          pos.vadd(tempWorldVertex, tempWorldVertex);
          var v = tempWorldVertex;

          if (v.x < minx || minx === undefined) {
            minx = v.x;
          }

          if (v.x > maxx || maxx === undefined) {
            maxx = v.x;
          }

          if (v.y < miny || miny === undefined) {
            miny = v.y;
          }

          if (v.y > maxy || maxy === undefined) {
            maxy = v.y;
          }

          if (v.z < minz || minz === undefined) {
            minz = v.z;
          }

          if (v.z > maxz || maxz === undefined) {
            maxz = v.z;
          }
        }

        min.set(minx, miny, minz);
        max.set(maxx, maxy, maxz);
      };
      /**
       * Get approximate convex volume
       * @method volume
       * @return {Number}
       */


      ConvexPolyhedron.prototype.volume = function () {
        return 4.0 * Math.PI * this.boundingSphereRadius / 3.0;
      };
      /**
       * Get an average of all the vertices positions
       * @method getAveragePointLocal
       * @param  {Vec3} target
       * @return {Vec3}
       */


      ConvexPolyhedron.prototype.getAveragePointLocal = function (target) {
        target = target || new Vec3();
        var n = this.vertices.length,
            verts = this.vertices;

        for (var i = 0; i < n; i++) {
          target.vadd(verts[i], target);
        }

        target.mult(1 / n, target);
        return target;
      };
      /**
       * Transform all local points. Will change the .vertices
       * @method transformAllPoints
       * @param  {Vec3} offset
       * @param  {Quaternion} quat
       */


      ConvexPolyhedron.prototype.transformAllPoints = function (offset, quat) {
        var n = this.vertices.length,
            verts = this.vertices; // Apply rotation

        if (quat) {
          // Rotate vertices
          for (var i = 0; i < n; i++) {
            var v = verts[i];
            quat.vmult(v, v);
          } // Rotate face normals


          for (var i = 0; i < this.faceNormals.length; i++) {
            var v = this.faceNormals[i];
            quat.vmult(v, v);
          }
          /*
          // Rotate edges
          for(var i=0; i<this.uniqueEdges.length; i++){
              var v = this.uniqueEdges[i];
              quat.vmult(v,v);
          }*/

        } // Apply offset


        if (offset) {
          for (var i = 0; i < n; i++) {
            var v = verts[i];
            v.vadd(offset, v);
          }
        }
      };
      /**
       * Checks whether p is inside the polyhedra. Must be in local coords. The point lies outside of the convex hull of the other points if and only if the direction of all the vectors from it to those other points are on less than one half of a sphere around it.
       * @method pointIsInside
       * @param  {Vec3} p      A point given in local coordinates
       * @return {Boolean}
       */


      var ConvexPolyhedron_pointIsInside = new Vec3();
      var ConvexPolyhedron_vToP = new Vec3();
      var ConvexPolyhedron_vToPointInside = new Vec3();

      ConvexPolyhedron.prototype.pointIsInside = function (p) {
        var n = this.vertices.length,
            verts = this.vertices,
            faces = this.faces,
            normals = this.faceNormals;
        var positiveResult = null;
        var N = this.faces.length;
        var pointInside = ConvexPolyhedron_pointIsInside;
        this.getAveragePointLocal(pointInside);

        for (var i = 0; i < N; i++) {
          var numVertices = this.faces[i].length;
          var n = normals[i];
          var v = verts[faces[i][0]]; // We only need one point in the face
          // This dot product determines which side of the edge the point is

          var vToP = ConvexPolyhedron_vToP;
          p.vsub(v, vToP);
          var r1 = n.dot(vToP);
          var vToPointInside = ConvexPolyhedron_vToPointInside;
          pointInside.vsub(v, vToPointInside);
          var r2 = n.dot(vToPointInside);

          if (r1 < 0 && r2 > 0 || r1 > 0 && r2 < 0) {
            return false; // Encountered some other sign. Exit.
          } else {}
        } // If we got here, all dot products were of the same sign.


        return positiveResult ? 1 : -1;
      };
      /**
       * Get max and min dot product of a convex hull at position (pos,quat) projected onto an axis. Results are saved in the array maxmin.
       * @static
       * @method project
       * @param {ConvexPolyhedron} hull
       * @param {Vec3} axis
       * @param {Vec3} pos
       * @param {Quaternion} quat
       * @param {array} result result[0] and result[1] will be set to maximum and minimum, respectively.
       */


      var project_worldVertex = new Vec3();
      var project_localAxis = new Vec3();
      var project_localOrigin = new Vec3();

      ConvexPolyhedron.project = function (hull, axis, pos, quat, result) {
        var n = hull.vertices.length,
            worldVertex = project_worldVertex,
            localAxis = project_localAxis,
            max = 0,
            min = 0,
            localOrigin = project_localOrigin,
            vs = hull.vertices;
        localOrigin.setZero(); // Transform the axis to local

        Transform.vectorToLocalFrame(pos, quat, axis, localAxis);
        Transform.pointToLocalFrame(pos, quat, localOrigin, localOrigin);
        var add = localOrigin.dot(localAxis);
        min = max = vs[0].dot(localAxis);

        for (var i = 1; i < n; i++) {
          var val = vs[i].dot(localAxis);

          if (val > max) {
            max = val;
          }

          if (val < min) {
            min = val;
          }
        }

        min -= add;
        max -= add;

        if (min > max) {
          // Inconsistent - swap
          var temp = min;
          min = max;
          max = temp;
        } // Output


        result[0] = max;
        result[1] = min;
      };
    }, {
      "../math/Quaternion": 29,
      "../math/Transform": 30,
      "../math/Vec3": 31,
      "./Shape": 44
    }],
    40: [function (_dereq_, module, exports) {
      module.exports = Cylinder;

      var Shape = _dereq_('./Shape');

      var Vec3 = _dereq_('../math/Vec3');

      var Quaternion = _dereq_('../math/Quaternion');

      var ConvexPolyhedron = _dereq_('./ConvexPolyhedron');
      /**
       * @class Cylinder
       * @constructor
       * @extends ConvexPolyhedron
       * @author schteppe / https://github.com/schteppe
       * @param {Number} radiusTop
       * @param {Number} radiusBottom
       * @param {Number} height
       * @param {Number} numSegments The number of segments to build the cylinder out of
       */


      function Cylinder(radiusTop, radiusBottom, height, numSegments) {
        var N = numSegments,
            verts = [],
            axes = [],
            faces = [],
            bottomface = [],
            topface = [],
            cos = Math.cos,
            sin = Math.sin; // First bottom point

        verts.push(new Vec3(radiusBottom * cos(0), radiusBottom * sin(0), -height * 0.5));
        bottomface.push(0); // First top point

        verts.push(new Vec3(radiusTop * cos(0), radiusTop * sin(0), height * 0.5));
        topface.push(1);

        for (var i = 0; i < N; i++) {
          var theta = 2 * Math.PI / N * (i + 1);
          var thetaN = 2 * Math.PI / N * (i + 0.5);

          if (i < N - 1) {
            // Bottom
            verts.push(new Vec3(radiusBottom * cos(theta), radiusBottom * sin(theta), -height * 0.5));
            bottomface.push(2 * i + 2); // Top

            verts.push(new Vec3(radiusTop * cos(theta), radiusTop * sin(theta), height * 0.5));
            topface.push(2 * i + 3); // Face

            faces.push([2 * i + 2, 2 * i + 3, 2 * i + 1, 2 * i]);
          } else {
            faces.push([0, 1, 2 * i + 1, 2 * i]); // Connect
          } // Axis: we can cut off half of them if we have even number of segments


          if (N % 2 === 1 || i < N / 2) {
            axes.push(new Vec3(cos(thetaN), sin(thetaN), 0));
          }
        }

        faces.push(topface);
        axes.push(new Vec3(0, 0, 1)); // Reorder bottom face

        var temp = [];

        for (var i = 0; i < bottomface.length; i++) {
          temp.push(bottomface[bottomface.length - i - 1]);
        }

        faces.push(temp);
        ConvexPolyhedron.call(this, verts, faces, axes);
      }

      Cylinder.prototype = new ConvexPolyhedron();
    }, {
      "../math/Quaternion": 29,
      "../math/Vec3": 31,
      "./ConvexPolyhedron": 39,
      "./Shape": 44
    }],
    41: [function (_dereq_, module, exports) {
      var Shape = _dereq_('./Shape');

      var ConvexPolyhedron = _dereq_('./ConvexPolyhedron');

      var Vec3 = _dereq_('../math/Vec3');

      var Utils = _dereq_('../utils/Utils');

      module.exports = Heightfield;
      /**
       * Heightfield shape class. Height data is given as an array. These data points are spread out evenly with a given distance.
       * @class Heightfield
       * @extends Shape
       * @constructor
       * @param {Array} data An array of Y values that will be used to construct the terrain.
       * @param {object} options
       * @param {Number} [options.minValue] Minimum value of the data points in the data array. Will be computed automatically if not given.
       * @param {Number} [options.maxValue] Maximum value.
       * @param {Number} [options.elementSize=0.1] World spacing between the data points in X direction.
       * @todo Should be possible to use along all axes, not just y
       * @todo should be possible to scale along all axes
       *
       * @example
       *     // Generate some height data (y-values).
       *     var data = [];
       *     for(var i = 0; i < 1000; i++){
       *         var y = 0.5 * Math.cos(0.2 * i);
       *         data.push(y);
       *     }
       *
       *     // Create the heightfield shape
       *     var heightfieldShape = new Heightfield(data, {
       *         elementSize: 1 // Distance between the data points in X and Y directions
       *     });
       *     var heightfieldBody = new Body();
       *     heightfieldBody.addShape(heightfieldShape);
       *     world.addBody(heightfieldBody);
       */

      function Heightfield(data, options) {
        options = Utils.defaults(options, {
          maxValue: null,
          minValue: null,
          elementSize: 1
        });
        /**
         * An array of numbers, or height values, that are spread out along the x axis.
         * @property {array} data
         */

        this.data = data;
        /**
         * Max value of the data
         * @property {number} maxValue
         */

        this.maxValue = options.maxValue;
        /**
         * Max value of the data
         * @property {number} minValue
         */

        this.minValue = options.minValue;
        /**
         * The width of each element
         * @property {number} elementSize
         * @todo elementSizeX and Y
         */

        this.elementSize = options.elementSize;

        if (options.minValue === null) {
          this.updateMinValue();
        }

        if (options.maxValue === null) {
          this.updateMaxValue();
        }

        this.cacheEnabled = true;
        Shape.call(this, {
          type: Shape.types.HEIGHTFIELD
        });
        this.pillarConvex = new ConvexPolyhedron();
        this.pillarOffset = new Vec3();
        this.updateBoundingSphereRadius(); // "i_j_isUpper" => { convex: ..., offset: ... }
        // for example:
        // _cachedPillars["0_2_1"]

        this._cachedPillars = {};
      }

      Heightfield.prototype = new Shape();
      /**
       * Call whenever you change the data array.
       * @method update
       */

      Heightfield.prototype.update = function () {
        this._cachedPillars = {};
      };
      /**
       * Update the .minValue property
       * @method updateMinValue
       */


      Heightfield.prototype.updateMinValue = function () {
        var data = this.data;
        var minValue = data[0][0];

        for (var i = 0; i !== data.length; i++) {
          for (var j = 0; j !== data[i].length; j++) {
            var v = data[i][j];

            if (v < minValue) {
              minValue = v;
            }
          }
        }

        this.minValue = minValue;
      };
      /**
       * Update the .maxValue property
       * @method updateMaxValue
       */


      Heightfield.prototype.updateMaxValue = function () {
        var data = this.data;
        var maxValue = data[0][0];

        for (var i = 0; i !== data.length; i++) {
          for (var j = 0; j !== data[i].length; j++) {
            var v = data[i][j];

            if (v > maxValue) {
              maxValue = v;
            }
          }
        }

        this.maxValue = maxValue;
      };
      /**
       * Set the height value at an index. Don't forget to update maxValue and minValue after you're done.
       * @method setHeightValueAtIndex
       * @param {integer} xi
       * @param {integer} yi
       * @param {number} value
       */


      Heightfield.prototype.setHeightValueAtIndex = function (xi, yi, value) {
        var data = this.data;
        data[xi][yi] = value; // Invalidate cache

        this.clearCachedConvexTrianglePillar(xi, yi, false);

        if (xi > 0) {
          this.clearCachedConvexTrianglePillar(xi - 1, yi, true);
          this.clearCachedConvexTrianglePillar(xi - 1, yi, false);
        }

        if (yi > 0) {
          this.clearCachedConvexTrianglePillar(xi, yi - 1, true);
          this.clearCachedConvexTrianglePillar(xi, yi - 1, false);
        }

        if (yi > 0 && xi > 0) {
          this.clearCachedConvexTrianglePillar(xi - 1, yi - 1, true);
        }
      };
      /**
       * Get max/min in a rectangle in the matrix data
       * @method getRectMinMax
       * @param  {integer} iMinX
       * @param  {integer} iMinY
       * @param  {integer} iMaxX
       * @param  {integer} iMaxY
       * @param  {array} [result] An array to store the results in.
       * @return {array} The result array, if it was passed in. Minimum will be at position 0 and max at 1.
       */


      Heightfield.prototype.getRectMinMax = function (iMinX, iMinY, iMaxX, iMaxY, result) {
        result = result || []; // Get max and min of the data

        var data = this.data,
            max = this.minValue; // Set first value

        for (var i = iMinX; i <= iMaxX; i++) {
          for (var j = iMinY; j <= iMaxY; j++) {
            var height = data[i][j];

            if (height > max) {
              max = height;
            }
          }
        }

        result[0] = this.minValue;
        result[1] = max;
      };
      /**
       * Get the index of a local position on the heightfield. The indexes indicate the rectangles, so if your terrain is made of N x N height data points, you will have rectangle indexes ranging from 0 to N-1.
       * @method getIndexOfPosition
       * @param  {number} x
       * @param  {number} y
       * @param  {array} result Two-element array
       * @param  {boolean} clamp If the position should be clamped to the heightfield edge.
       * @return {boolean}
       */


      Heightfield.prototype.getIndexOfPosition = function (x, y, result, clamp) {
        // Get the index of the data points to test against
        var w = this.elementSize;
        var data = this.data;
        var xi = Math.floor(x / w);
        var yi = Math.floor(y / w);
        result[0] = xi;
        result[1] = yi;

        if (clamp) {
          // Clamp index to edges
          if (xi < 0) {
            xi = 0;
          }

          if (yi < 0) {
            yi = 0;
          }

          if (xi >= data.length - 1) {
            xi = data.length - 1;
          }

          if (yi >= data[0].length - 1) {
            yi = data[0].length - 1;
          }
        } // Bail out if we are out of the terrain


        if (xi < 0 || yi < 0 || xi >= data.length - 1 || yi >= data[0].length - 1) {
          return false;
        }

        return true;
      };

      var getHeightAt_idx = [];
      var getHeightAt_weights = new Vec3();
      var getHeightAt_a = new Vec3();
      var getHeightAt_b = new Vec3();
      var getHeightAt_c = new Vec3();

      Heightfield.prototype.getTriangleAt = function (x, y, edgeClamp, a, b, c) {
        var idx = getHeightAt_idx;
        this.getIndexOfPosition(x, y, idx, edgeClamp);
        var xi = idx[0];
        var yi = idx[1];
        var data = this.data;

        if (edgeClamp) {
          xi = Math.min(data.length - 2, Math.max(0, xi));
          yi = Math.min(data[0].length - 2, Math.max(0, yi));
        }

        var elementSize = this.elementSize;
        var lowerDist2 = Math.pow(x / elementSize - xi, 2) + Math.pow(y / elementSize - yi, 2);
        var upperDist2 = Math.pow(x / elementSize - (xi + 1), 2) + Math.pow(y / elementSize - (yi + 1), 2);
        var upper = lowerDist2 > upperDist2;
        this.getTriangle(xi, yi, upper, a, b, c);
        return upper;
      };

      var getNormalAt_a = new Vec3();
      var getNormalAt_b = new Vec3();
      var getNormalAt_c = new Vec3();
      var getNormalAt_e0 = new Vec3();
      var getNormalAt_e1 = new Vec3();

      Heightfield.prototype.getNormalAt = function (x, y, edgeClamp, result) {
        var a = getNormalAt_a;
        var b = getNormalAt_b;
        var c = getNormalAt_c;
        var e0 = getNormalAt_e0;
        var e1 = getNormalAt_e1;
        this.getTriangleAt(x, y, edgeClamp, a, b, c);
        b.vsub(a, e0);
        c.vsub(a, e1);
        e0.cross(e1, result);
        result.normalize();
      };
      /**
       * Get an AABB of a square in the heightfield
       * @param  {number} xi
       * @param  {number} yi
       * @param  {AABB} result
       */


      Heightfield.prototype.getAabbAtIndex = function (xi, yi, result) {
        var data = this.data;
        var elementSize = this.elementSize;
        result.lowerBound.set(xi * elementSize, yi * elementSize, data[xi][yi]);
        result.upperBound.set((xi + 1) * elementSize, (yi + 1) * elementSize, data[xi + 1][yi + 1]);
      };
      /**
       * Get the height in the heightfield at a given position
       * @param  {number} x
       * @param  {number} y
       * @param  {boolean} edgeClamp
       * @return {number}
       */


      Heightfield.prototype.getHeightAt = function (x, y, edgeClamp) {
        var data = this.data;
        var a = getHeightAt_a;
        var b = getHeightAt_b;
        var c = getHeightAt_c;
        var idx = getHeightAt_idx;
        this.getIndexOfPosition(x, y, idx, edgeClamp);
        var xi = idx[0];
        var yi = idx[1];

        if (edgeClamp) {
          xi = Math.min(data.length - 2, Math.max(0, xi));
          yi = Math.min(data[0].length - 2, Math.max(0, yi));
        }

        var upper = this.getTriangleAt(x, y, edgeClamp, a, b, c);
        barycentricWeights(x, y, a.x, a.y, b.x, b.y, c.x, c.y, getHeightAt_weights);
        var w = getHeightAt_weights;

        if (upper) {
          // Top triangle verts
          return data[xi + 1][yi + 1] * w.x + data[xi][yi + 1] * w.y + data[xi + 1][yi] * w.z;
        } else {
          // Top triangle verts
          return data[xi][yi] * w.x + data[xi + 1][yi] * w.y + data[xi][yi + 1] * w.z;
        }
      }; // from https://en.wikipedia.org/wiki/Barycentric_coordinate_system


      function barycentricWeights(x, y, ax, ay, bx, by, cx, cy, result) {
        result.x = ((by - cy) * (x - cx) + (cx - bx) * (y - cy)) / ((by - cy) * (ax - cx) + (cx - bx) * (ay - cy));
        result.y = ((cy - ay) * (x - cx) + (ax - cx) * (y - cy)) / ((by - cy) * (ax - cx) + (cx - bx) * (ay - cy));
        result.z = 1 - result.x - result.y;
      }

      Heightfield.prototype.getCacheConvexTrianglePillarKey = function (xi, yi, getUpperTriangle) {
        return xi + '_' + yi + '_' + (getUpperTriangle ? 1 : 0);
      };

      Heightfield.prototype.getCachedConvexTrianglePillar = function (xi, yi, getUpperTriangle) {
        return this._cachedPillars[this.getCacheConvexTrianglePillarKey(xi, yi, getUpperTriangle)];
      };

      Heightfield.prototype.setCachedConvexTrianglePillar = function (xi, yi, getUpperTriangle, convex, offset) {
        this._cachedPillars[this.getCacheConvexTrianglePillarKey(xi, yi, getUpperTriangle)] = {
          convex: convex,
          offset: offset
        };
      };

      Heightfield.prototype.clearCachedConvexTrianglePillar = function (xi, yi, getUpperTriangle) {
        delete this._cachedPillars[this.getCacheConvexTrianglePillarKey(xi, yi, getUpperTriangle)];
      };
      /**
       * Get a triangle from the heightfield
       * @param  {number} xi
       * @param  {number} yi
       * @param  {boolean} upper
       * @param  {Vec3} a
       * @param  {Vec3} b
       * @param  {Vec3} c
       */


      Heightfield.prototype.getTriangle = function (xi, yi, upper, a, b, c) {
        var data = this.data;
        var elementSize = this.elementSize;

        if (upper) {
          // Top triangle verts
          a.set((xi + 1) * elementSize, (yi + 1) * elementSize, data[xi + 1][yi + 1]);
          b.set(xi * elementSize, (yi + 1) * elementSize, data[xi][yi + 1]);
          c.set((xi + 1) * elementSize, yi * elementSize, data[xi + 1][yi]);
        } else {
          // Top triangle verts
          a.set(xi * elementSize, yi * elementSize, data[xi][yi]);
          b.set((xi + 1) * elementSize, yi * elementSize, data[xi + 1][yi]);
          c.set(xi * elementSize, (yi + 1) * elementSize, data[xi][yi + 1]);
        }
      };
      /**
       * Get a triangle in the terrain in the form of a triangular convex shape.
       * @method getConvexTrianglePillar
       * @param  {integer} i
       * @param  {integer} j
       * @param  {boolean} getUpperTriangle
       */


      Heightfield.prototype.getConvexTrianglePillar = function (xi, yi, getUpperTriangle) {
        var result = this.pillarConvex;
        var offsetResult = this.pillarOffset;

        if (this.cacheEnabled) {
          var data = this.getCachedConvexTrianglePillar(xi, yi, getUpperTriangle);

          if (data) {
            this.pillarConvex = data.convex;
            this.pillarOffset = data.offset;
            return;
          }

          result = new ConvexPolyhedron();
          offsetResult = new Vec3();
          this.pillarConvex = result;
          this.pillarOffset = offsetResult;
        }

        var data = this.data;
        var elementSize = this.elementSize;
        var faces = result.faces; // Reuse verts if possible

        result.vertices.length = 6;

        for (var i = 0; i < 6; i++) {
          if (!result.vertices[i]) {
            result.vertices[i] = new Vec3();
          }
        } // Reuse faces if possible


        faces.length = 5;

        for (var i = 0; i < 5; i++) {
          if (!faces[i]) {
            faces[i] = [];
          }
        }

        var verts = result.vertices;
        var h = (Math.min(data[xi][yi], data[xi + 1][yi], data[xi][yi + 1], data[xi + 1][yi + 1]) - this.minValue) / 2 + this.minValue;

        if (!getUpperTriangle) {
          // Center of the triangle pillar - all polygons are given relative to this one
          offsetResult.set((xi + 0.25) * elementSize, // sort of center of a triangle
          (yi + 0.25) * elementSize, h // vertical center
          ); // Top triangle verts

          verts[0].set(-0.25 * elementSize, -0.25 * elementSize, data[xi][yi] - h);
          verts[1].set(0.75 * elementSize, -0.25 * elementSize, data[xi + 1][yi] - h);
          verts[2].set(-0.25 * elementSize, 0.75 * elementSize, data[xi][yi + 1] - h); // bottom triangle verts

          verts[3].set(-0.25 * elementSize, -0.25 * elementSize, -h - 1);
          verts[4].set(0.75 * elementSize, -0.25 * elementSize, -h - 1);
          verts[5].set(-0.25 * elementSize, 0.75 * elementSize, -h - 1); // top triangle

          faces[0][0] = 0;
          faces[0][1] = 1;
          faces[0][2] = 2; // bottom triangle

          faces[1][0] = 5;
          faces[1][1] = 4;
          faces[1][2] = 3; // -x facing quad

          faces[2][0] = 0;
          faces[2][1] = 2;
          faces[2][2] = 5;
          faces[2][3] = 3; // -y facing quad

          faces[3][0] = 1;
          faces[3][1] = 0;
          faces[3][2] = 3;
          faces[3][3] = 4; // +xy facing quad

          faces[4][0] = 4;
          faces[4][1] = 5;
          faces[4][2] = 2;
          faces[4][3] = 1;
        } else {
          // Center of the triangle pillar - all polygons are given relative to this one
          offsetResult.set((xi + 0.75) * elementSize, // sort of center of a triangle
          (yi + 0.75) * elementSize, h // vertical center
          ); // Top triangle verts

          verts[0].set(0.25 * elementSize, 0.25 * elementSize, data[xi + 1][yi + 1] - h);
          verts[1].set(-0.75 * elementSize, 0.25 * elementSize, data[xi][yi + 1] - h);
          verts[2].set(0.25 * elementSize, -0.75 * elementSize, data[xi + 1][yi] - h); // bottom triangle verts

          verts[3].set(0.25 * elementSize, 0.25 * elementSize, -h - 1);
          verts[4].set(-0.75 * elementSize, 0.25 * elementSize, -h - 1);
          verts[5].set(0.25 * elementSize, -0.75 * elementSize, -h - 1); // Top triangle

          faces[0][0] = 0;
          faces[0][1] = 1;
          faces[0][2] = 2; // bottom triangle

          faces[1][0] = 5;
          faces[1][1] = 4;
          faces[1][2] = 3; // +x facing quad

          faces[2][0] = 2;
          faces[2][1] = 5;
          faces[2][2] = 3;
          faces[2][3] = 0; // +y facing quad

          faces[3][0] = 3;
          faces[3][1] = 4;
          faces[3][2] = 1;
          faces[3][3] = 0; // -xy facing quad

          faces[4][0] = 1;
          faces[4][1] = 4;
          faces[4][2] = 5;
          faces[4][3] = 2;
        }

        result.computeNormals();
        result.computeEdges();
        result.updateBoundingSphereRadius();
        this.setCachedConvexTrianglePillar(xi, yi, getUpperTriangle, result, offsetResult);
      };

      Heightfield.prototype.calculateLocalInertia = function (mass, target) {
        target = target || new Vec3();
        target.set(0, 0, 0);
        return target;
      };

      Heightfield.prototype.volume = function () {
        return Number.MAX_VALUE; // The terrain is infinite
      };

      Heightfield.prototype.calculateWorldAABB = function (pos, quat, min, max) {
        // TODO: do it properly
        min.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
        max.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
      };

      Heightfield.prototype.updateBoundingSphereRadius = function () {
        // Use the bounding box of the min/max values
        var data = this.data,
            s = this.elementSize;
        this.boundingSphereRadius = new Vec3(data.length * s, data[0].length * s, Math.max(Math.abs(this.maxValue), Math.abs(this.minValue))).norm();
      };
      /**
       * Sets the height values from an image. Currently only supported in browser.
       * @method setHeightsFromImage
       * @param {Image} image
       * @param {Vec3} scale
       */


      Heightfield.prototype.setHeightsFromImage = function (image, scale) {
        var canvas = document.createElement('canvas');
        canvas.width = image.width;
        canvas.height = image.height;
        var context = canvas.getContext('2d');
        context.drawImage(image, 0, 0);
        var imageData = context.getImageData(0, 0, image.width, image.height);
        var matrix = this.data;
        matrix.length = 0;
        this.elementSize = Math.abs(scale.x) / imageData.width;

        for (var i = 0; i < imageData.height; i++) {
          var row = [];

          for (var j = 0; j < imageData.width; j++) {
            var a = imageData.data[(i * imageData.height + j) * 4];
            var b = imageData.data[(i * imageData.height + j) * 4 + 1];
            var c = imageData.data[(i * imageData.height + j) * 4 + 2];
            var height = (a + b + c) / 4 / 255 * scale.z;

            if (scale.x < 0) {
              row.push(height);
            } else {
              row.unshift(height);
            }
          }

          if (scale.y < 0) {
            matrix.unshift(row);
          } else {
            matrix.push(row);
          }
        }

        this.updateMaxValue();
        this.updateMinValue();
        this.update();
      };
    }, {
      "../math/Vec3": 31,
      "../utils/Utils": 54,
      "./ConvexPolyhedron": 39,
      "./Shape": 44
    }],
    42: [function (_dereq_, module, exports) {
      module.exports = Particle;

      var Shape = _dereq_('./Shape');

      var Vec3 = _dereq_('../math/Vec3');
      /**
       * Particle shape.
       * @class Particle
       * @constructor
       * @author schteppe
       * @extends Shape
       */


      function Particle() {
        Shape.call(this, {
          type: Shape.types.PARTICLE
        });
      }

      Particle.prototype = new Shape();
      Particle.prototype.constructor = Particle;
      /**
       * @method calculateLocalInertia
       * @param  {Number} mass
       * @param  {Vec3} target
       * @return {Vec3}
       */

      Particle.prototype.calculateLocalInertia = function (mass, target) {
        target = target || new Vec3();
        target.set(0, 0, 0);
        return target;
      };

      Particle.prototype.volume = function () {
        return 0;
      };

      Particle.prototype.updateBoundingSphereRadius = function () {
        this.boundingSphereRadius = 0;
      };

      Particle.prototype.calculateWorldAABB = function (pos, quat, min, max) {
        // Get each axis max
        min.copy(pos);
        max.copy(pos);
      };
    }, {
      "../math/Vec3": 31,
      "./Shape": 44
    }],
    43: [function (_dereq_, module, exports) {
      module.exports = Plane;

      var Shape = _dereq_('./Shape');

      var Vec3 = _dereq_('../math/Vec3');
      /**
       * A plane, facing in the Z direction. The plane has its surface at z=0 and everything below z=0 is assumed to be solid plane. To make the plane face in some other direction than z, you must put it inside a Body and rotate that body. See the demos.
       * @class Plane
       * @constructor
       * @extends Shape
       * @author schteppe
       */


      function Plane() {
        Shape.call(this, {
          type: Shape.types.PLANE
        }); // World oriented normal

        this.worldNormal = new Vec3();
        this.worldNormalNeedsUpdate = true;
        this.boundingSphereRadius = Number.MAX_VALUE;
      }

      Plane.prototype = new Shape();
      Plane.prototype.constructor = Plane;

      Plane.prototype.computeWorldNormal = function (quat) {
        var n = this.worldNormal;
        n.set(0, 0, 1);
        quat.vmult(n, n);
        this.worldNormalNeedsUpdate = false;
      };

      Plane.prototype.calculateLocalInertia = function (mass, target) {
        target = target || new Vec3();
        return target;
      };

      Plane.prototype.volume = function () {
        return Number.MAX_VALUE; // The plane is infinite...
      };

      var tempNormal = new Vec3();

      Plane.prototype.calculateWorldAABB = function (pos, quat, min, max) {
        // The plane AABB is infinite, except if the normal is pointing along any axis
        tempNormal.set(0, 0, 1); // Default plane normal is z

        quat.vmult(tempNormal, tempNormal);
        var maxVal = Number.MAX_VALUE;
        min.set(-maxVal, -maxVal, -maxVal);
        max.set(maxVal, maxVal, maxVal);

        if (tempNormal.x === 1) {
          max.x = pos.x;
        }

        if (tempNormal.y === 1) {
          max.y = pos.y;
        }

        if (tempNormal.z === 1) {
          max.z = pos.z;
        }

        if (tempNormal.x === -1) {
          min.x = pos.x;
        }

        if (tempNormal.y === -1) {
          min.y = pos.y;
        }

        if (tempNormal.z === -1) {
          min.z = pos.z;
        }
      };

      Plane.prototype.updateBoundingSphereRadius = function () {
        this.boundingSphereRadius = Number.MAX_VALUE;
      };
    }, {
      "../math/Vec3": 31,
      "./Shape": 44
    }],
    44: [function (_dereq_, module, exports) {
      module.exports = Shape;

      var EventTarget = _dereq_('../utils/EventTarget');

      var Shape = _dereq_('./Shape');

      var Vec3 = _dereq_('../math/Vec3');

      var Quaternion = _dereq_('../math/Quaternion');

      var Material = _dereq_('../material/Material');
      /**
       * Base class for shapes
       * @class Shape
       * @constructor
       * @param {object} [options]
       * @param {number} [options.collisionFilterGroup=1]
       * @param {number} [options.collisionFilterMask=-1]
       * @param {number} [options.collisionResponse=true]
       * @param {number} [options.material=null]
       * @author schteppe
       */


      function Shape(options) {
        options = options || {};
        EventTarget.apply(this);
        /**
         * Identifyer of the Shape.
         * @property {number} id
         */

        this.id = Shape.idCounter++;
        /**
         * The type of this shape. Must be set to an int > 0 by subclasses.
         * @property type
         * @type {Number}
         * @see Shape.types
         */

        this.type = options.type || 0;
        /**
         * The local bounding sphere radius of this shape.
         * @property {Number} boundingSphereRadius
         */

        this.boundingSphereRadius = 0;
        /**
         * Whether to produce contact forces when in contact with other bodies. Note that contacts will be generated, but they will be disabled.
         * @property {boolean} collisionResponse
         */

        this.collisionResponse = options.collisionResponse ? options.collisionResponse : true;
        /**
         * @property {Number} collisionFilterGroup
         */

        this.collisionFilterGroup = options.collisionFilterGroup !== undefined ? options.collisionFilterGroup : 1;
        /**
         * @property {Number} collisionFilterMask
         */

        this.collisionFilterMask = options.collisionFilterMask !== undefined ? options.collisionFilterMask : -1;
        /**
         * @property {Material} material
         */

        this.material = options.material ? options.material : null;
        /**
         * @property {Body} body
         */

        this.body = null;
      }

      Shape.prototype = new EventTarget();
      Shape.prototype.constructor = Shape;
      /**
       * Computes the bounding sphere radius. The result is stored in the property .boundingSphereRadius
       * @method updateBoundingSphereRadius
       */

      Shape.prototype.updateBoundingSphereRadius = function () {
        throw "computeBoundingSphereRadius() not implemented for shape type " + this.type;
      };
      /**
       * Get the volume of this shape
       * @method volume
       * @return {Number}
       */


      Shape.prototype.volume = function () {
        throw "volume() not implemented for shape type " + this.type;
      };
      /**
       * Calculates the inertia in the local frame for this shape.
       * @method calculateLocalInertia
       * @param {Number} mass
       * @param {Vec3} target
       * @see http://en.wikipedia.org/wiki/List_of_moments_of_inertia
       */


      Shape.prototype.calculateLocalInertia = function (mass, target) {
        throw "calculateLocalInertia() not implemented for shape type " + this.type;
      };

      Shape.idCounter = 0;
      /**
       * The available shape types.
       * @static
       * @property types
       * @type {Object}
       */

      Shape.types = {
        SPHERE: 1,
        PLANE: 2,
        BOX: 4,
        COMPOUND: 8,
        CONVEXPOLYHEDRON: 16,
        HEIGHTFIELD: 32,
        PARTICLE: 64,
        CYLINDER: 128,
        TRIMESH: 256
      };
    }, {
      "../material/Material": 26,
      "../math/Quaternion": 29,
      "../math/Vec3": 31,
      "../utils/EventTarget": 50,
      "./Shape": 44
    }],
    45: [function (_dereq_, module, exports) {
      module.exports = Sphere;

      var Shape = _dereq_('./Shape');

      var Vec3 = _dereq_('../math/Vec3');
      /**
       * Spherical shape
       * @class Sphere
       * @constructor
       * @extends Shape
       * @param {Number} radius The radius of the sphere, a non-negative number.
       * @author schteppe / http://github.com/schteppe
       */


      function Sphere(radius) {
        Shape.call(this, {
          type: Shape.types.SPHERE
        });
        /**
         * @property {Number} radius
         */

        this.radius = radius !== undefined ? radius : 1.0;

        if (this.radius < 0) {
          throw new Error('The sphere radius cannot be negative.');
        }

        this.updateBoundingSphereRadius();
      }

      Sphere.prototype = new Shape();
      Sphere.prototype.constructor = Sphere;

      Sphere.prototype.calculateLocalInertia = function (mass, target) {
        target = target || new Vec3();
        var I = 2.0 * mass * this.radius * this.radius / 5.0;
        target.x = I;
        target.y = I;
        target.z = I;
        return target;
      };

      Sphere.prototype.volume = function () {
        return 4.0 * Math.PI * this.radius / 3.0;
      };

      Sphere.prototype.updateBoundingSphereRadius = function () {
        this.boundingSphereRadius = this.radius;
      };

      Sphere.prototype.calculateWorldAABB = function (pos, quat, min, max) {
        var r = this.radius;
        var axes = ['x', 'y', 'z'];

        for (var i = 0; i < axes.length; i++) {
          var ax = axes[i];
          min[ax] = pos[ax] - r;
          max[ax] = pos[ax] + r;
        }
      };
    }, {
      "../math/Vec3": 31,
      "./Shape": 44
    }],
    46: [function (_dereq_, module, exports) {
      module.exports = Trimesh;

      var Shape = _dereq_('./Shape');

      var Vec3 = _dereq_('../math/Vec3');

      var Quaternion = _dereq_('../math/Quaternion');

      var Transform = _dereq_('../math/Transform');

      var AABB = _dereq_('../collision/AABB');

      var Octree = _dereq_('../utils/Octree');
      /**
       * @class Trimesh
       * @constructor
       * @param {array} vertices
       * @param {array} indices
       * @extends Shape
       * @example
       *     // How to make a mesh with a single triangle
       *     var vertices = [
       *         0, 0, 0, // vertex 0
       *         1, 0, 0, // vertex 1
       *         0, 1, 0  // vertex 2
       *     ];
       *     var indices = [
       *         0, 1, 2  // triangle 0
       *     ];
       *     var trimeshShape = new Trimesh(vertices, indices);
       */


      function Trimesh(vertices, indices) {
        Shape.call(this, {
          type: Shape.types.TRIMESH
        });
        /**
         * @property vertices
         * @type {Array}
         */

        this.vertices = new Float32Array(vertices);
        /**
         * Array of integers, indicating which vertices each triangle consists of. The length of this array is thus 3 times the number of triangles.
         * @property indices
         * @type {Array}
         */

        this.indices = new Int16Array(indices);
        /**
         * The normals data.
         * @property normals
         * @type {Array}
         */

        this.normals = new Float32Array(indices.length);
        /**
         * The local AABB of the mesh.
         * @property aabb
         * @type {Array}
         */

        this.aabb = new AABB();
        /**
         * References to vertex pairs, making up all unique edges in the trimesh.
         * @property {array} edges
         */

        this.edges = null;
        /**
         * Local scaling of the mesh. Use .setScale() to set it.
         * @property {Vec3} scale
         */

        this.scale = new Vec3(1, 1, 1);
        /**
         * The indexed triangles. Use .updateTree() to update it.
         * @property {Octree} tree
         */

        this.tree = new Octree();
        this.updateEdges();
        this.updateNormals();
        this.updateAABB();
        this.updateBoundingSphereRadius();
        this.updateTree();
      }

      Trimesh.prototype = new Shape();
      Trimesh.prototype.constructor = Trimesh;
      var computeNormals_n = new Vec3();
      /**
       * @method updateTree
       */

      Trimesh.prototype.updateTree = function () {
        var tree = this.tree;
        tree.reset();
        tree.aabb.copy(this.aabb);
        var scale = this.scale; // The local mesh AABB is scaled, but the octree AABB should be unscaled

        tree.aabb.lowerBound.x *= 1 / scale.x;
        tree.aabb.lowerBound.y *= 1 / scale.y;
        tree.aabb.lowerBound.z *= 1 / scale.z;
        tree.aabb.upperBound.x *= 1 / scale.x;
        tree.aabb.upperBound.y *= 1 / scale.y;
        tree.aabb.upperBound.z *= 1 / scale.z; // Insert all triangles

        var triangleAABB = new AABB();
        var a = new Vec3();
        var b = new Vec3();
        var c = new Vec3();
        var points = [a, b, c];

        for (var i = 0; i < this.indices.length / 3; i++) {
          //this.getTriangleVertices(i, a, b, c);
          // Get unscaled triangle verts
          var i3 = i * 3;

          this._getUnscaledVertex(this.indices[i3], a);

          this._getUnscaledVertex(this.indices[i3 + 1], b);

          this._getUnscaledVertex(this.indices[i3 + 2], c);

          triangleAABB.setFromPoints(points);
          tree.insert(triangleAABB, i);
        }

        tree.removeEmptyNodes();
      };

      var unscaledAABB = new AABB();
      /**
       * Get triangles in a local AABB from the trimesh.
       * @method getTrianglesInAABB
       * @param  {AABB} aabb
       * @param  {array} result An array of integers, referencing the queried triangles.
       */

      Trimesh.prototype.getTrianglesInAABB = function (aabb, result) {
        unscaledAABB.copy(aabb); // Scale it to local

        var scale = this.scale;
        var isx = scale.x;
        var isy = scale.y;
        var isz = scale.z;
        var l = unscaledAABB.lowerBound;
        var u = unscaledAABB.upperBound;
        l.x /= isx;
        l.y /= isy;
        l.z /= isz;
        u.x /= isx;
        u.y /= isy;
        u.z /= isz;
        return this.tree.aabbQuery(unscaledAABB, result);
      };
      /**
       * @method setScale
       * @param {Vec3} scale
       */


      Trimesh.prototype.setScale = function (scale) {
        var wasUniform = this.scale.x === this.scale.y === this.scale.z;
        var isUniform = scale.x === scale.y === scale.z;

        if (!(wasUniform && isUniform)) {
          // Non-uniform scaling. Need to update normals.
          this.updateNormals();
        }

        this.scale.copy(scale);
        this.updateAABB();
        this.updateBoundingSphereRadius();
      };
      /**
       * Compute the normals of the faces. Will save in the .normals array.
       * @method updateNormals
       */


      Trimesh.prototype.updateNormals = function () {
        var n = computeNormals_n; // Generate normals

        var normals = this.normals;

        for (var i = 0; i < this.indices.length / 3; i++) {
          var i3 = i * 3;
          var a = this.indices[i3],
              b = this.indices[i3 + 1],
              c = this.indices[i3 + 2];
          this.getVertex(a, va);
          this.getVertex(b, vb);
          this.getVertex(c, vc);
          Trimesh.computeNormal(vb, va, vc, n);
          normals[i3] = n.x;
          normals[i3 + 1] = n.y;
          normals[i3 + 2] = n.z;
        }
      };
      /**
       * Update the .edges property
       * @method updateEdges
       */


      Trimesh.prototype.updateEdges = function () {
        var edges = {};

        var add = function add(indexA, indexB) {
          var key = a < b ? a + '_' + b : b + '_' + a;
          edges[key] = true;
        };

        for (var i = 0; i < this.indices.length / 3; i++) {
          var i3 = i * 3;
          var a = this.indices[i3],
              b = this.indices[i3 + 1],
              c = this.indices[i3 + 2];
          add(a, b);
          add(b, c);
          add(c, a);
        }

        var keys = Object.keys(edges);
        this.edges = new Int16Array(keys.length * 2);

        for (var i = 0; i < keys.length; i++) {
          var indices = keys[i].split('_');
          this.edges[2 * i] = parseInt(indices[0], 10);
          this.edges[2 * i + 1] = parseInt(indices[1], 10);
        }
      };
      /**
       * Get an edge vertex
       * @method getEdgeVertex
       * @param  {number} edgeIndex
       * @param  {number} firstOrSecond 0 or 1, depending on which one of the vertices you need.
       * @param  {Vec3} vertexStore Where to store the result
       */


      Trimesh.prototype.getEdgeVertex = function (edgeIndex, firstOrSecond, vertexStore) {
        var vertexIndex = this.edges[edgeIndex * 2 + (firstOrSecond ? 1 : 0)];
        this.getVertex(vertexIndex, vertexStore);
      };

      var getEdgeVector_va = new Vec3();
      var getEdgeVector_vb = new Vec3();
      /**
       * Get a vector along an edge.
       * @method getEdgeVector
       * @param  {number} edgeIndex
       * @param  {Vec3} vectorStore
       */

      Trimesh.prototype.getEdgeVector = function (edgeIndex, vectorStore) {
        var va = getEdgeVector_va;
        var vb = getEdgeVector_vb;
        this.getEdgeVertex(edgeIndex, 0, va);
        this.getEdgeVertex(edgeIndex, 1, vb);
        vb.vsub(va, vectorStore);
      };
      /**
       * Get face normal given 3 vertices
       * @static
       * @method computeNormal
       * @param {Vec3} va
       * @param {Vec3} vb
       * @param {Vec3} vc
       * @param {Vec3} target
       */


      var cb = new Vec3();
      var ab = new Vec3();

      Trimesh.computeNormal = function (va, vb, vc, target) {
        vb.vsub(va, ab);
        vc.vsub(vb, cb);
        cb.cross(ab, target);

        if (!target.isZero()) {
          target.normalize();
        }
      };

      var va = new Vec3();
      var vb = new Vec3();
      var vc = new Vec3();
      /**
       * Get vertex i.
       * @method getVertex
       * @param  {number} i
       * @param  {Vec3} out
       * @return {Vec3} The "out" vector object
       */

      Trimesh.prototype.getVertex = function (i, out) {
        var scale = this.scale;

        this._getUnscaledVertex(i, out);

        out.x *= scale.x;
        out.y *= scale.y;
        out.z *= scale.z;
        return out;
      };
      /**
       * Get raw vertex i
       * @private
       * @method _getUnscaledVertex
       * @param  {number} i
       * @param  {Vec3} out
       * @return {Vec3} The "out" vector object
       */


      Trimesh.prototype._getUnscaledVertex = function (i, out) {
        var i3 = i * 3;
        var vertices = this.vertices;
        return out.set(vertices[i3], vertices[i3 + 1], vertices[i3 + 2]);
      };
      /**
       * Get a vertex from the trimesh,transformed by the given position and quaternion.
       * @method getWorldVertex
       * @param  {number} i
       * @param  {Vec3} pos
       * @param  {Quaternion} quat
       * @param  {Vec3} out
       * @return {Vec3} The "out" vector object
       */


      Trimesh.prototype.getWorldVertex = function (i, pos, quat, out) {
        this.getVertex(i, out);
        Transform.pointToWorldFrame(pos, quat, out, out);
        return out;
      };
      /**
       * Get the three vertices for triangle i.
       * @method getTriangleVertices
       * @param  {number} i
       * @param  {Vec3} a
       * @param  {Vec3} b
       * @param  {Vec3} c
       */


      Trimesh.prototype.getTriangleVertices = function (i, a, b, c) {
        var i3 = i * 3;
        this.getVertex(this.indices[i3], a);
        this.getVertex(this.indices[i3 + 1], b);
        this.getVertex(this.indices[i3 + 2], c);
      };
      /**
       * Compute the normal of triangle i.
       * @method getNormal
       * @param  {Number} i
       * @param  {Vec3} target
       * @return {Vec3} The "target" vector object
       */


      Trimesh.prototype.getNormal = function (i, target) {
        var i3 = i * 3;
        return target.set(this.normals[i3], this.normals[i3 + 1], this.normals[i3 + 2]);
      };

      var cli_aabb = new AABB();
      /**
       * @method calculateLocalInertia
       * @param  {Number} mass
       * @param  {Vec3} target
       * @return {Vec3} The "target" vector object
       */

      Trimesh.prototype.calculateLocalInertia = function (mass, target) {
        // Approximate with box inertia
        // Exact inertia calculation is overkill, but see http://geometrictools.com/Documentation/PolyhedralMassProperties.pdf for the correct way to do it
        this.computeLocalAABB(cli_aabb);
        var x = cli_aabb.upperBound.x - cli_aabb.lowerBound.x,
            y = cli_aabb.upperBound.y - cli_aabb.lowerBound.y,
            z = cli_aabb.upperBound.z - cli_aabb.lowerBound.z;
        return target.set(1.0 / 12.0 * mass * (2 * y * 2 * y + 2 * z * 2 * z), 1.0 / 12.0 * mass * (2 * x * 2 * x + 2 * z * 2 * z), 1.0 / 12.0 * mass * (2 * y * 2 * y + 2 * x * 2 * x));
      };

      var computeLocalAABB_worldVert = new Vec3();
      /**
       * Compute the local AABB for the trimesh
       * @method computeLocalAABB
       * @param  {AABB} aabb
       */

      Trimesh.prototype.computeLocalAABB = function (aabb) {
        var l = aabb.lowerBound,
            u = aabb.upperBound,
            n = this.vertices.length,
            vertices = this.vertices,
            v = computeLocalAABB_worldVert;
        this.getVertex(0, v);
        l.copy(v);
        u.copy(v);

        for (var i = 0; i !== n; i++) {
          this.getVertex(i, v);

          if (v.x < l.x) {
            l.x = v.x;
          } else if (v.x > u.x) {
            u.x = v.x;
          }

          if (v.y < l.y) {
            l.y = v.y;
          } else if (v.y > u.y) {
            u.y = v.y;
          }

          if (v.z < l.z) {
            l.z = v.z;
          } else if (v.z > u.z) {
            u.z = v.z;
          }
        }
      };
      /**
       * Update the .aabb property
       * @method updateAABB
       */


      Trimesh.prototype.updateAABB = function () {
        this.computeLocalAABB(this.aabb);
      };
      /**
       * Will update the .boundingSphereRadius property
       * @method updateBoundingSphereRadius
       */


      Trimesh.prototype.updateBoundingSphereRadius = function () {
        // Assume points are distributed with local (0,0,0) as center
        var max2 = 0;
        var vertices = this.vertices;
        var v = new Vec3();

        for (var i = 0, N = vertices.length / 3; i !== N; i++) {
          this.getVertex(i, v);
          var norm2 = v.norm2();

          if (norm2 > max2) {
            max2 = norm2;
          }
        }

        this.boundingSphereRadius = Math.sqrt(max2);
      };

      var tempWorldVertex = new Vec3();
      var calculateWorldAABB_frame = new Transform();
      var calculateWorldAABB_aabb = new AABB();
      /**
       * @method calculateWorldAABB
       * @param {Vec3}        pos
       * @param {Quaternion}  quat
       * @param {Vec3}        min
       * @param {Vec3}        max
       */

      Trimesh.prototype.calculateWorldAABB = function (pos, quat, min, max) {
        /*
        var n = this.vertices.length / 3,
            verts = this.vertices;
        var minx,miny,minz,maxx,maxy,maxz;
          var v = tempWorldVertex;
        for(var i=0; i<n; i++){
            this.getVertex(i, v);
            quat.vmult(v, v);
            pos.vadd(v, v);
            if (v.x < minx || minx===undefined){
                minx = v.x;
            } else if(v.x > maxx || maxx===undefined){
                maxx = v.x;
            }
              if (v.y < miny || miny===undefined){
                miny = v.y;
            } else if(v.y > maxy || maxy===undefined){
                maxy = v.y;
            }
              if (v.z < minz || minz===undefined){
                minz = v.z;
            } else if(v.z > maxz || maxz===undefined){
                maxz = v.z;
            }
        }
        min.set(minx,miny,minz);
        max.set(maxx,maxy,maxz);
        */
        // Faster approximation using local AABB
        var frame = calculateWorldAABB_frame;
        var result = calculateWorldAABB_aabb;
        frame.position = pos;
        frame.quaternion = quat;
        this.aabb.toWorldFrame(frame, result);
        min.copy(result.lowerBound);
        max.copy(result.upperBound);
      };
      /**
       * Get approximate volume
       * @method volume
       * @return {Number}
       */


      Trimesh.prototype.volume = function () {
        return 4.0 * Math.PI * this.boundingSphereRadius / 3.0;
      };
      /**
       * Create a Trimesh instance, shaped as a torus.
       * @static
       * @method createTorus
       * @param  {number} [radius=1]
       * @param  {number} [tube=0.5]
       * @param  {number} [radialSegments=8]
       * @param  {number} [tubularSegments=6]
       * @param  {number} [arc=6.283185307179586]
       * @return {Trimesh} A torus
       */


      Trimesh.createTorus = function (radius, tube, radialSegments, tubularSegments, arc) {
        radius = radius || 1;
        tube = tube || 0.5;
        radialSegments = radialSegments || 8;
        tubularSegments = tubularSegments || 6;
        arc = arc || Math.PI * 2;
        var vertices = [];
        var indices = [];

        for (var j = 0; j <= radialSegments; j++) {
          for (var i = 0; i <= tubularSegments; i++) {
            var u = i / tubularSegments * arc;
            var v = j / radialSegments * Math.PI * 2;
            var x = (radius + tube * Math.cos(v)) * Math.cos(u);
            var y = (radius + tube * Math.cos(v)) * Math.sin(u);
            var z = tube * Math.sin(v);
            vertices.push(x, y, z);
          }
        }

        for (var j = 1; j <= radialSegments; j++) {
          for (var i = 1; i <= tubularSegments; i++) {
            var a = (tubularSegments + 1) * j + i - 1;
            var b = (tubularSegments + 1) * (j - 1) + i - 1;
            var c = (tubularSegments + 1) * (j - 1) + i;
            var d = (tubularSegments + 1) * j + i;
            indices.push(a, b, d);
            indices.push(b, c, d);
          }
        }

        return new Trimesh(vertices, indices);
      };
    }, {
      "../collision/AABB": 3,
      "../math/Quaternion": 29,
      "../math/Transform": 30,
      "../math/Vec3": 31,
      "../utils/Octree": 51,
      "./Shape": 44
    }],
    47: [function (_dereq_, module, exports) {
      module.exports = GSSolver;

      var Vec3 = _dereq_('../math/Vec3');

      var Quaternion = _dereq_('../math/Quaternion');

      var Solver = _dereq_('./Solver');
      /**
       * Constraint equation Gauss-Seidel solver.
       * @class GSSolver
       * @constructor
       * @todo The spook parameters should be specified for each constraint, not globally.
       * @author schteppe / https://github.com/schteppe
       * @see https://www8.cs.umu.se/kurser/5DV058/VT09/lectures/spooknotes.pdf
       * @extends Solver
       */


      function GSSolver() {
        Solver.call(this);
        /**
         * The number of solver iterations determines quality of the constraints in the world. The more iterations, the more correct simulation. More iterations need more computations though. If you have a large gravity force in your world, you will need more iterations.
         * @property iterations
         * @type {Number}
         * @todo write more about solver and iterations in the wiki
         */

        this.iterations = 10;
        /**
         * When tolerance is reached, the system is assumed to be converged.
         * @property tolerance
         * @type {Number}
         */

        this.tolerance = 1e-7;
      }

      GSSolver.prototype = new Solver();
      var GSSolver_solve_lambda = []; // Just temporary number holders that we want to reuse each solve.

      var GSSolver_solve_invCs = [];
      var GSSolver_solve_Bs = [];

      GSSolver.prototype.solve = function (dt, world) {
        var iter = 0,
            maxIter = this.iterations,
            tolSquared = this.tolerance * this.tolerance,
            equations = this.equations,
            Neq = equations.length,
            bodies = world.bodies,
            Nbodies = bodies.length,
            h = dt,
            q,
            B,
            invC,
            deltalambda,
            deltalambdaTot,
            GWlambda,
            lambdaj; // Update solve mass

        if (Neq !== 0) {
          for (var i = 0; i !== Nbodies; i++) {
            bodies[i].updateSolveMassProperties();
          }
        } // Things that does not change during iteration can be computed once


        var invCs = GSSolver_solve_invCs,
            Bs = GSSolver_solve_Bs,
            lambda = GSSolver_solve_lambda;
        invCs.length = Neq;
        Bs.length = Neq;
        lambda.length = Neq;

        for (var i = 0; i !== Neq; i++) {
          var c = equations[i];
          lambda[i] = 0.0;
          Bs[i] = c.computeB(h);
          invCs[i] = 1.0 / c.computeC();
        }

        if (Neq !== 0) {
          // Reset vlambda
          for (var i = 0; i !== Nbodies; i++) {
            var b = bodies[i],
                vlambda = b.vlambda,
                wlambda = b.wlambda;
            vlambda.set(0, 0, 0);
            wlambda.set(0, 0, 0);
          } // Iterate over equations


          for (iter = 0; iter !== maxIter; iter++) {
            // Accumulate the total error for each iteration.
            deltalambdaTot = 0.0;

            for (var j = 0; j !== Neq; j++) {
              var c = equations[j]; // Compute iteration

              B = Bs[j];
              invC = invCs[j];
              lambdaj = lambda[j];
              GWlambda = c.computeGWlambda();
              deltalambda = invC * (B - GWlambda - c.eps * lambdaj); // Clamp if we are not within the min/max interval

              if (lambdaj + deltalambda < c.minForce) {
                deltalambda = c.minForce - lambdaj;
              } else if (lambdaj + deltalambda > c.maxForce) {
                deltalambda = c.maxForce - lambdaj;
              }

              lambda[j] += deltalambda;
              deltalambdaTot += deltalambda > 0.0 ? deltalambda : -deltalambda; // abs(deltalambda)

              c.addToWlambda(deltalambda);
            } // If the total error is small enough - stop iterate


            if (deltalambdaTot * deltalambdaTot < tolSquared) {
              break;
            }
          } // Add result to velocity


          for (var i = 0; i !== Nbodies; i++) {
            var b = bodies[i],
                v = b.velocity,
                w = b.angularVelocity;
            b.vlambda.vmul(b.linearFactor, b.vlambda);
            v.vadd(b.vlambda, v);
            b.wlambda.vmul(b.angularFactor, b.wlambda);
            w.vadd(b.wlambda, w);
          } // Set the .multiplier property of each equation


          var l = equations.length;
          var invDt = 1 / h;

          while (l--) {
            equations[l].multiplier = lambda[l] * invDt;
          }
        }

        return iter;
      };
    }, {
      "../math/Quaternion": 29,
      "../math/Vec3": 31,
      "./Solver": 48
    }],
    48: [function (_dereq_, module, exports) {
      module.exports = Solver;
      /**
       * Constraint equation solver base class.
       * @class Solver
       * @constructor
       * @author schteppe / https://github.com/schteppe
       */

      function Solver() {
        /**
         * All equations to be solved
         * @property {Array} equations
         */
        this.equations = [];
      }
      /**
       * Should be implemented in subclasses!
       * @method solve
       * @param  {Number} dt
       * @param  {World} world
       */


      Solver.prototype.solve = function (dt, world) {
        // Should return the number of iterations done!
        return 0;
      };
      /**
       * Add an equation
       * @method addEquation
       * @param {Equation} eq
       */


      Solver.prototype.addEquation = function (eq) {
        if (eq.enabled) {
          this.equations.push(eq);
        }
      };
      /**
       * Remove an equation
       * @method removeEquation
       * @param {Equation} eq
       */


      Solver.prototype.removeEquation = function (eq) {
        var eqs = this.equations;
        var i = eqs.indexOf(eq);

        if (i !== -1) {
          eqs.splice(i, 1);
        }
      };
      /**
       * Add all equations
       * @method removeAllEquations
       */


      Solver.prototype.removeAllEquations = function () {
        this.equations.length = 0;
      };
    }, {}],
    49: [function (_dereq_, module, exports) {
      module.exports = SplitSolver;

      var Vec3 = _dereq_('../math/Vec3');

      var Quaternion = _dereq_('../math/Quaternion');

      var Solver = _dereq_('./Solver');

      var Body = _dereq_('../objects/Body');
      /**
       * Splits the equations into islands and solves them independently. Can improve performance.
       * @class SplitSolver
       * @constructor
       * @extends Solver
       * @param {Solver} subsolver
       */


      function SplitSolver(subsolver) {
        Solver.call(this);
        this.iterations = 10;
        this.tolerance = 1e-7;
        this.subsolver = subsolver;
        this.nodes = [];
        this.nodePool = []; // Create needed nodes, reuse if possible

        while (this.nodePool.length < 128) {
          this.nodePool.push(this.createNode());
        }
      }

      SplitSolver.prototype = new Solver(); // Returns the number of subsystems

      var SplitSolver_solve_nodes = []; // All allocated node objects

      var SplitSolver_solve_nodePool = []; // All allocated node objects

      var SplitSolver_solve_eqs = []; // Temp array

      var SplitSolver_solve_bds = []; // Temp array

      var SplitSolver_solve_dummyWorld = {
        bodies: []
      }; // Temp object

      var STATIC = Body.STATIC;

      function getUnvisitedNode(nodes) {
        var Nnodes = nodes.length;

        for (var i = 0; i !== Nnodes; i++) {
          var node = nodes[i];

          if (!node.visited && !(node.body.type & STATIC)) {
            return node;
          }
        }

        return false;
      }

      var queue = [];

      function bfs(root, visitFunc, bds, eqs) {
        queue.push(root);
        root.visited = true;
        visitFunc(root, bds, eqs);

        while (queue.length) {
          var node = queue.pop(); // Loop over unvisited child nodes

          var child;

          while (child = getUnvisitedNode(node.children)) {
            child.visited = true;
            visitFunc(child, bds, eqs);
            queue.push(child);
          }
        }
      }

      function visitFunc(node, bds, eqs) {
        bds.push(node.body);
        var Neqs = node.eqs.length;

        for (var i = 0; i !== Neqs; i++) {
          var eq = node.eqs[i];

          if (eqs.indexOf(eq) === -1) {
            eqs.push(eq);
          }
        }
      }

      SplitSolver.prototype.createNode = function () {
        return {
          body: null,
          children: [],
          eqs: [],
          visited: false
        };
      };
      /**
       * Solve the subsystems
       * @method solve
       * @param  {Number} dt
       * @param  {World} world
       */


      SplitSolver.prototype.solve = function (dt, world) {
        var nodes = SplitSolver_solve_nodes,
            nodePool = this.nodePool,
            bodies = world.bodies,
            equations = this.equations,
            Neq = equations.length,
            Nbodies = bodies.length,
            subsolver = this.subsolver; // Create needed nodes, reuse if possible

        while (nodePool.length < Nbodies) {
          nodePool.push(this.createNode());
        }

        nodes.length = Nbodies;

        for (var i = 0; i < Nbodies; i++) {
          nodes[i] = nodePool[i];
        } // Reset node values


        for (var i = 0; i !== Nbodies; i++) {
          var node = nodes[i];
          node.body = bodies[i];
          node.children.length = 0;
          node.eqs.length = 0;
          node.visited = false;
        }

        for (var k = 0; k !== Neq; k++) {
          var eq = equations[k],
              i = bodies.indexOf(eq.bi),
              j = bodies.indexOf(eq.bj),
              ni = nodes[i],
              nj = nodes[j];
          ni.children.push(nj);
          ni.eqs.push(eq);
          nj.children.push(ni);
          nj.eqs.push(eq);
        }

        var child,
            n = 0,
            eqs = SplitSolver_solve_eqs;
        subsolver.tolerance = this.tolerance;
        subsolver.iterations = this.iterations;
        var dummyWorld = SplitSolver_solve_dummyWorld;

        while (child = getUnvisitedNode(nodes)) {
          eqs.length = 0;
          dummyWorld.bodies.length = 0;
          bfs(child, visitFunc, dummyWorld.bodies, eqs);
          var Neqs = eqs.length;
          eqs = eqs.sort(sortById);

          for (var i = 0; i !== Neqs; i++) {
            subsolver.addEquation(eqs[i]);
          }

          var iter = subsolver.solve(dt, dummyWorld);
          subsolver.removeAllEquations();
          n++;
        }

        return n;
      };

      function sortById(a, b) {
        return b.id - a.id;
      }
    }, {
      "../math/Quaternion": 29,
      "../math/Vec3": 31,
      "../objects/Body": 32,
      "./Solver": 48
    }],
    50: [function (_dereq_, module, exports) {
      /**
       * Base class for objects that dispatches events.
       * @class EventTarget
       * @constructor
       */
      var EventTarget = function EventTarget() {};

      module.exports = EventTarget;
      EventTarget.prototype = {
        constructor: EventTarget,

        /**
         * Add an event listener
         * @method addEventListener
         * @param  {String} type
         * @param  {Function} listener
         * @return {EventTarget} The self object, for chainability.
         */
        addEventListener: function addEventListener(type, listener) {
          if (this._listeners === undefined) {
            this._listeners = {};
          }

          var listeners = this._listeners;

          if (listeners[type] === undefined) {
            listeners[type] = [];
          }

          if (listeners[type].indexOf(listener) === -1) {
            listeners[type].push(listener);
          }

          return this;
        },

        /**
         * Check if an event listener is added
         * @method hasEventListener
         * @param  {String} type
         * @param  {Function} listener
         * @return {Boolean}
         */
        hasEventListener: function hasEventListener(type, listener) {
          if (this._listeners === undefined) {
            return false;
          }

          var listeners = this._listeners;

          if (listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1) {
            return true;
          }

          return false;
        },

        /**
         * Check if any event listener of the given type is added
         * @method hasAnyEventListener
         * @param  {String} type
         * @return {Boolean}
         */
        hasAnyEventListener: function hasAnyEventListener(type) {
          if (this._listeners === undefined) {
            return false;
          }

          var listeners = this._listeners;
          return listeners[type] !== undefined;
        },

        /**
         * Remove an event listener
         * @method removeEventListener
         * @param  {String} type
         * @param  {Function} listener
         * @return {EventTarget} The self object, for chainability.
         */
        removeEventListener: function removeEventListener(type, listener) {
          if (this._listeners === undefined) {
            return this;
          }

          var listeners = this._listeners;

          if (listeners[type] === undefined) {
            return this;
          }

          var index = listeners[type].indexOf(listener);

          if (index !== -1) {
            listeners[type].splice(index, 1);
          }

          return this;
        },

        /**
         * Emit an event.
         * @method dispatchEvent
         * @param  {Object} event
         * @param  {String} event.type
         * @return {EventTarget} The self object, for chainability.
         */
        dispatchEvent: function dispatchEvent(event) {
          if (this._listeners === undefined) {
            return this;
          }

          var listeners = this._listeners;
          var listenerArray = listeners[event.type];

          if (listenerArray !== undefined) {
            event.target = this;

            for (var i = 0, l = listenerArray.length; i < l; i++) {
              listenerArray[i].call(this, event);
            }
          }

          return this;
        }
      };
    }, {}],
    51: [function (_dereq_, module, exports) {
      var AABB = _dereq_('../collision/AABB');

      var Vec3 = _dereq_('../math/Vec3');

      module.exports = Octree;
      /**
       * @class OctreeNode
       * @param {object} [options]
       * @param {Octree} [options.root]
       * @param {AABB} [options.aabb]
       */

      function OctreeNode(options) {
        options = options || {};
        /**
         * The root node
         * @property {OctreeNode} root
         */

        this.root = options.root || null;
        /**
         * Boundary of this node
         * @property {AABB} aabb
         */

        this.aabb = options.aabb ? options.aabb.clone() : new AABB();
        /**
         * Contained data at the current node level.
         * @property {Array} data
         */

        this.data = [];
        /**
         * Children to this node
         * @property {Array} children
         */

        this.children = [];
      }
      /**
       * @class Octree
       * @param {AABB} aabb The total AABB of the tree
       * @param {object} [options]
       * @param {number} [options.maxDepth=8]
       * @extends OctreeNode
       */


      function Octree(aabb, options) {
        options = options || {};
        options.root = null;
        options.aabb = aabb;
        OctreeNode.call(this, options);
        /**
         * Maximum subdivision depth
         * @property {number} maxDepth
         */

        this.maxDepth = typeof options.maxDepth !== 'undefined' ? options.maxDepth : 8;
      }

      Octree.prototype = new OctreeNode();

      OctreeNode.prototype.reset = function (aabb, options) {
        this.children.length = this.data.length = 0;
      };
      /**
       * Insert data into this node
       * @method insert
       * @param  {AABB} aabb
       * @param  {object} elementData
       * @return {boolean} True if successful, otherwise false
       */


      OctreeNode.prototype.insert = function (aabb, elementData, level) {
        var nodeData = this.data;
        level = level || 0; // Ignore objects that do not belong in this node

        if (!this.aabb.contains(aabb)) {
          return false; // object cannot be added
        }

        var children = this.children;

        if (level < (this.maxDepth || this.root.maxDepth)) {
          // Subdivide if there are no children yet
          var subdivided = false;

          if (!children.length) {
            this.subdivide();
            subdivided = true;
          } // add to whichever node will accept it


          for (var i = 0; i !== 8; i++) {
            if (children[i].insert(aabb, elementData, level + 1)) {
              return true;
            }
          }

          if (subdivided) {
            // No children accepted! Might as well just remove em since they contain none
            children.length = 0;
          }
        } // Too deep, or children didnt want it. add it in current node


        nodeData.push(elementData);
        return true;
      };

      var halfDiagonal = new Vec3();
      /**
       * Create 8 equally sized children nodes and put them in the .children array.
       * @method subdivide
       */

      OctreeNode.prototype.subdivide = function () {
        var aabb = this.aabb;
        var l = aabb.lowerBound;
        var u = aabb.upperBound;
        var children = this.children;
        children.push(new OctreeNode({
          aabb: new AABB({
            lowerBound: new Vec3(0, 0, 0)
          })
        }), new OctreeNode({
          aabb: new AABB({
            lowerBound: new Vec3(1, 0, 0)
          })
        }), new OctreeNode({
          aabb: new AABB({
            lowerBound: new Vec3(1, 1, 0)
          })
        }), new OctreeNode({
          aabb: new AABB({
            lowerBound: new Vec3(1, 1, 1)
          })
        }), new OctreeNode({
          aabb: new AABB({
            lowerBound: new Vec3(0, 1, 1)
          })
        }), new OctreeNode({
          aabb: new AABB({
            lowerBound: new Vec3(0, 0, 1)
          })
        }), new OctreeNode({
          aabb: new AABB({
            lowerBound: new Vec3(1, 0, 1)
          })
        }), new OctreeNode({
          aabb: new AABB({
            lowerBound: new Vec3(0, 1, 0)
          })
        }));
        u.vsub(l, halfDiagonal);
        halfDiagonal.scale(0.5, halfDiagonal);
        var root = this.root || this;

        for (var i = 0; i !== 8; i++) {
          var child = children[i]; // Set current node as root

          child.root = root; // Compute bounds

          var lowerBound = child.aabb.lowerBound;
          lowerBound.x *= halfDiagonal.x;
          lowerBound.y *= halfDiagonal.y;
          lowerBound.z *= halfDiagonal.z;
          lowerBound.vadd(l, lowerBound); // Upper bound is always lower bound + halfDiagonal

          lowerBound.vadd(halfDiagonal, child.aabb.upperBound);
        }
      };
      /**
       * Get all data, potentially within an AABB
       * @method aabbQuery
       * @param  {AABB} aabb
       * @param  {array} result
       * @return {array} The "result" object
       */


      OctreeNode.prototype.aabbQuery = function (aabb, result) {
        var nodeData = this.data; // abort if the range does not intersect this node
        // if (!this.aabb.overlaps(aabb)){
        //     return result;
        // }
        // Add objects at this level
        // Array.prototype.push.apply(result, nodeData);
        // Add child data
        // @todo unwrap recursion into a queue / loop, that's faster in JS

        var children = this.children; // for (var i = 0, N = this.children.length; i !== N; i++) {
        //     children[i].aabbQuery(aabb, result);
        // }

        var queue = [this];

        while (queue.length) {
          var node = queue.pop();

          if (node.aabb.overlaps(aabb)) {
            Array.prototype.push.apply(result, node.data);
          }

          Array.prototype.push.apply(queue, node.children);
        }

        return result;
      };

      var tmpAABB = new AABB();
      /**
       * Get all data, potentially intersected by a ray.
       * @method rayQuery
       * @param  {Ray} ray
       * @param  {Transform} treeTransform
       * @param  {array} result
       * @return {array} The "result" object
       */

      OctreeNode.prototype.rayQuery = function (ray, treeTransform, result) {
        // Use aabb query for now.
        // @todo implement real ray query which needs less lookups
        ray.getAABB(tmpAABB);
        tmpAABB.toLocalFrame(treeTransform, tmpAABB);
        this.aabbQuery(tmpAABB, result);
        return result;
      };
      /**
       * @method removeEmptyNodes
       */


      OctreeNode.prototype.removeEmptyNodes = function () {
        for (var i = this.children.length - 1; i >= 0; i--) {
          this.children[i].removeEmptyNodes();

          if (!this.children[i].children.length && !this.children[i].data.length) {
            this.children.splice(i, 1);
          }
        }
      };
    }, {
      "../collision/AABB": 3,
      "../math/Vec3": 31
    }],
    52: [function (_dereq_, module, exports) {
      module.exports = Pool;
      /**
       * For pooling objects that can be reused.
       * @class Pool
       * @constructor
       */

      function Pool() {
        /**
         * The pooled objects
         * @property {Array} objects
         */
        this.objects = [];
        /**
         * Constructor of the objects
         * @property {mixed} type
         */

        this.type = Object;
      }
      /**
       * Release an object after use
       * @method release
       * @param {Object} obj
       */


      Pool.prototype.release = function () {
        var Nargs = arguments.length;

        for (var i = 0; i !== Nargs; i++) {
          this.objects.push(arguments[i]);
        }

        return this;
      };
      /**
       * Get an object
       * @method get
       * @return {mixed}
       */


      Pool.prototype.get = function () {
        if (this.objects.length === 0) {
          return this.constructObject();
        } else {
          return this.objects.pop();
        }
      };
      /**
       * Construct an object. Should be implmented in each subclass.
       * @method constructObject
       * @return {mixed}
       */


      Pool.prototype.constructObject = function () {
        throw new Error("constructObject() not implemented in this Pool subclass yet!");
      };
      /**
       * @method resize
       * @param {number} size
       * @return {Pool} Self, for chaining
       */


      Pool.prototype.resize = function (size) {
        var objects = this.objects;

        while (objects.length > size) {
          objects.pop();
        }

        while (objects.length < size) {
          objects.push(this.constructObject());
        }

        return this;
      };
    }, {}],
    53: [function (_dereq_, module, exports) {
      module.exports = TupleDictionary;
      /**
       * @class TupleDictionary
       * @constructor
       */

      function TupleDictionary() {
        /**
         * The data storage
         * @property data
         * @type {Object}
         */
        this.data = {
          keys: []
        };
      }
      /**
       * @method get
       * @param  {Number} i
       * @param  {Number} j
       * @return {Object}
       */


      TupleDictionary.prototype.get = function (i, j) {
        if (i > j) {
          // swap
          var temp = j;
          j = i;
          i = temp;
        }

        return this.data[i + '-' + j];
      };
      /**
       * @method set
       * @param  {Number} i
       * @param  {Number} j
       * @param {Object} value
       */


      TupleDictionary.prototype.set = function (i, j, value) {
        if (i > j) {
          var temp = j;
          j = i;
          i = temp;
        }

        var key = i + '-' + j; // Check if key already exists

        if (!this.get(i, j)) {
          this.data.keys.push(key);
        }

        this.data[key] = value;
        return this.data[key];
      };
      /**
       * @method reset
       */


      TupleDictionary.prototype.reset = function () {
        var data = this.data,
            keys = data.keys;

        while (keys.length > 0) {
          var key = keys.pop();
          delete data[key];
        }
      };
      /**
       * @method getLength
       */


      TupleDictionary.prototype.getLength = function () {
        return this.data.keys.length;
      };
      /**
       * @method getKeyByIndex
       * @param {Number} index
       */


      TupleDictionary.prototype.getKeyByIndex = function (index) {
        return this.data.keys[index];
      };
      /**
       * @method getDataByKey
       * @param {Number} Key
       */


      TupleDictionary.prototype.getDataByKey = function (Key) {
        return this.data[Key];
      };
    }, {}],
    54: [function (_dereq_, module, exports) {
      function Utils() {}

      module.exports = Utils;
      /**
       * Extend an options object with default values.
       * @static
       * @method defaults
       * @param  {object} options The options object. May be falsy: in this case, a new object is created and returned.
       * @param  {object} defaults An object containing default values.
       * @return {object} The modified options object.
       */

      Utils.defaults = function (options, defaults) {
        options = options || {};

        for (var key in defaults) {
          if (!(key in options)) {
            options[key] = defaults[key];
          }
        }

        return options;
      };
    }, {}],
    55: [function (_dereq_, module, exports) {
      module.exports = Vec3Pool;

      var Vec3 = _dereq_('../math/Vec3');

      var Pool = _dereq_('./Pool');
      /**
       * @class Vec3Pool
       * @constructor
       * @extends Pool
       */


      function Vec3Pool() {
        Pool.call(this);
        this.type = Vec3;
      }

      Vec3Pool.prototype = new Pool();
      /**
       * Construct a vector
       * @method constructObject
       * @return {Vec3}
       */

      Vec3Pool.prototype.constructObject = function () {
        return new Vec3();
      };
    }, {
      "../math/Vec3": 31,
      "./Pool": 52
    }],
    56: [function (_dereq_, module, exports) {
      module.exports = Narrowphase;

      var AABB = _dereq_('../collision/AABB');

      var Body = _dereq_('../objects/Body');

      var Shape = _dereq_('../shapes/Shape');

      var Ray = _dereq_('../collision/Ray');

      var Vec3 = _dereq_('../math/Vec3');

      var Transform = _dereq_('../math/Transform');

      var ConvexPolyhedron = _dereq_('../shapes/ConvexPolyhedron');

      var Quaternion = _dereq_('../math/Quaternion');

      var Solver = _dereq_('../solver/Solver');

      var Vec3Pool = _dereq_('../utils/Vec3Pool');

      var ContactEquation = _dereq_('../equations/ContactEquation');

      var FrictionEquation = _dereq_('../equations/FrictionEquation');
      /**
       * Helper class for the World. Generates ContactEquations.
       * @class Narrowphase
       * @constructor
       * @todo Sphere-ConvexPolyhedron contacts
       * @todo Contact reduction
       * @todo  should move methods to prototype
       */


      function Narrowphase(world) {
        /**
         * Internal storage of pooled contact points.
         * @property {Array} contactPointPool
         */
        this.contactPointPool = [];
        this.frictionEquationPool = [];
        this.result = [];
        this.frictionResult = [];
        /**
         * Pooled vectors.
         * @property {Vec3Pool} v3pool
         */

        this.v3pool = new Vec3Pool();
        this.world = world;
        this.currentContactMaterial = null;
        /**
         * @property {Boolean} enableFrictionReduction
         */

        this.enableFrictionReduction = false;
      }
      /**
       * Make a contact object, by using the internal pool or creating a new one.
       * @method createContactEquation
       * @param {Body} bi
       * @param {Body} bj
       * @param {Shape} si
       * @param {Shape} sj
       * @param {Shape} overrideShapeA
       * @param {Shape} overrideShapeB
       * @return {ContactEquation}
       */


      Narrowphase.prototype.createContactEquation = function (bi, bj, si, sj, overrideShapeA, overrideShapeB) {
        var c;

        if (this.contactPointPool.length) {
          c = this.contactPointPool.pop();
          c.bi = bi;
          c.bj = bj;
        } else {
          c = new ContactEquation(bi, bj);
        } // need ?, trigger is already filter
        // c.enabled = bi.collisionResponse && bj.collisionResponse && si.collisionResponse && sj.collisionResponse;


        var cm = this.currentContactMaterial;
        c.restitution = cm.restitution;
        c.setSpookParams(cm.contactEquationStiffness, cm.contactEquationRelaxation, this.world.dt);
        var matA = si.material || bi.material;
        var matB = sj.material || bj.material;

        if (matA && matB && matA.restitution >= 0 && matB.restitution >= 0) {
          c.restitution = matA.restitution * matB.restitution;
        }

        c.si = overrideShapeA || si;
        c.sj = overrideShapeB || sj;
        return c;
      };

      Narrowphase.prototype.createFrictionEquationsFromContact = function (contactEquation, outArray) {
        var bodyA = contactEquation.bi;
        var bodyB = contactEquation.bj;
        var shapeA = contactEquation.si;
        var shapeB = contactEquation.sj;
        var world = this.world;
        var cm = this.currentContactMaterial; // If friction or restitution were specified in the material, use them

        var friction = cm.friction;
        var matA = shapeA.material || bodyA.material;
        var matB = shapeB.material || bodyB.material;

        if (matA && matB && matA.friction >= 0 && matB.friction >= 0) {
          friction = matA.friction * matB.friction;
        }

        if (friction > 0) {
          // Create 2 tangent equations
          var mug = friction * world.gravity.length();
          var reducedMass = bodyA.invMass + bodyB.invMass;

          if (reducedMass > 0) {
            reducedMass = 1 / reducedMass;
          }

          var pool = this.frictionEquationPool;
          var c1 = pool.length ? pool.pop() : new FrictionEquation(bodyA, bodyB, mug * reducedMass);
          var c2 = pool.length ? pool.pop() : new FrictionEquation(bodyA, bodyB, mug * reducedMass);
          c1.bi = c2.bi = bodyA;
          c1.bj = c2.bj = bodyB;
          c1.minForce = c2.minForce = -mug * reducedMass;
          c1.maxForce = c2.maxForce = mug * reducedMass; // Copy over the relative vectors

          c1.ri.copy(contactEquation.ri);
          c1.rj.copy(contactEquation.rj);
          c2.ri.copy(contactEquation.ri);
          c2.rj.copy(contactEquation.rj); // Construct tangents

          contactEquation.ni.tangents(c1.t, c2.t); // Set spook params

          c1.setSpookParams(cm.frictionEquationStiffness, cm.frictionEquationRelaxation, world.dt);
          c2.setSpookParams(cm.frictionEquationStiffness, cm.frictionEquationRelaxation, world.dt);
          c1.enabled = c2.enabled = contactEquation.enabled;
          outArray.push(c1, c2);
          return true;
        }

        return false;
      };

      var averageNormal = new Vec3();
      var averageContactPointA = new Vec3();
      var averageContactPointB = new Vec3(); // Take the average N latest contact point on the plane.

      Narrowphase.prototype.createFrictionFromAverage = function (numContacts) {
        // The last contactEquation
        var c = this.result[this.result.length - 1]; // Create the result: two "average" friction equations

        if (!this.createFrictionEquationsFromContact(c, this.frictionResult) || numContacts === 1) {
          return;
        }

        var f1 = this.frictionResult[this.frictionResult.length - 2];
        var f2 = this.frictionResult[this.frictionResult.length - 1];
        averageNormal.setZero();
        averageContactPointA.setZero();
        averageContactPointB.setZero();
        var bodyA = c.bi;
        var bodyB = c.bj;

        for (var i = 0; i !== numContacts; i++) {
          c = this.result[this.result.length - 1 - i];

          if (c.bodyA !== bodyA) {
            averageNormal.vadd(c.ni, averageNormal);
            averageContactPointA.vadd(c.ri, averageContactPointA);
            averageContactPointB.vadd(c.rj, averageContactPointB);
          } else {
            averageNormal.vsub(c.ni, averageNormal);
            averageContactPointA.vadd(c.rj, averageContactPointA);
            averageContactPointB.vadd(c.ri, averageContactPointB);
          }
        }

        var invNumContacts = 1 / numContacts;
        averageContactPointA.scale(invNumContacts, f1.ri);
        averageContactPointB.scale(invNumContacts, f1.rj);
        f2.ri.copy(f1.ri); // Should be the same

        f2.rj.copy(f1.rj);
        averageNormal.normalize();
        averageNormal.tangents(f1.t, f2.t); // return eq;
      };

      var tmpVec1 = new Vec3();
      var tmpVec2 = new Vec3();
      var tmpQuat1 = new Quaternion();
      var tmpQuat2 = new Quaternion();
      /**
       * Generate all contacts between a list of body pairs
       * @method getContacts
       * @param {array} p1 Array of body indices
       * @param {array} p2 Array of body indices
       * @param {World} world
       * @param {array} result Array to store generated contacts
       * @param {array} oldcontacts Optional. Array of reusable contact objects
       */

      Narrowphase.prototype.getContacts = function (p1, p2, world, result, oldcontacts, frictionResult, frictionPool) {
        // Save old contact objects
        this.frictionEquationPool = frictionPool;
        this.result = result;
        this.frictionResult = frictionResult;
        var qi = tmpQuat1;
        var qj = tmpQuat2;
        var xi = tmpVec1;
        var xj = tmpVec2;

        for (var k = 0, N = p1.length; k !== N; k++) {
          // Get current collision bodies
          var bi = p1[k],
              bj = p2[k]; // Get contact material

          var bodyContactMaterial = null;

          if (bi.material && bj.material) {
            bodyContactMaterial = world.getContactMaterial(bi.material, bj.material) || null;
          }

          var justTest = bi.collisionResponse == false || bj.collisionResponse == false || bi.type & Body.KINEMATIC && bj.type & Body.STATIC || bi.type & Body.STATIC && bj.type & Body.KINEMATIC || bi.type & Body.KINEMATIC && bj.type & Body.KINEMATIC;

          for (var i = 0; i < bi.shapes.length; i++) {
            bi.quaternion.mult(bi.shapeOrientations[i], qi);
            bi.quaternion.vmult(bi.shapeOffsets[i], xi);
            xi.vadd(bi.position, xi);
            var si = bi.shapes[i];

            for (var j = 0; j < bj.shapes.length; j++) {
              // Compute world transform of shapes
              bj.quaternion.mult(bj.shapeOrientations[j], qj);
              bj.quaternion.vmult(bj.shapeOffsets[j], xj);
              xj.vadd(bj.position, xj);
              var sj = bj.shapes[j];

              if (!(si.collisionFilterMask & sj.collisionFilterGroup && sj.collisionFilterMask & si.collisionFilterGroup)) {
                continue;
              }

              if (xi.distanceTo(xj) > si.boundingSphereRadius + sj.boundingSphereRadius) {
                continue;
              } // is trigger ? ,trigger test just only


              justTest |= si.collisionResponse == false || sj.collisionResponse == false; // Get collision material

              var shapeContactMaterial = null;

              if (si.material && sj.material) {
                shapeContactMaterial = world.getContactMaterial(si.material, sj.material) || null;
              }

              this.currentContactMaterial = shapeContactMaterial || bodyContactMaterial || world.defaultContactMaterial; // Get contacts

              var resolver = this[si.type | sj.type];

              if (resolver) {
                var retval = false;

                if (si.type < sj.type) {
                  retval = resolver.call(this, si, sj, xi, xj, qi, qj, bi, bj, si, sj, justTest);
                } else {
                  retval = resolver.call(this, sj, si, xj, xi, qj, qi, bj, bi, si, sj, justTest);
                }

                if (retval && justTest) {
                  // Register overlap
                  world.shapeOverlapKeeper.set(si.id, sj.id);
                  world.shapeOverlapKeeperExit.set(si.id, sj.id);
                }
              }
            }
          }
        }
      };

      var numWarnings = 0;
      var maxWarnings = 10;

      function warn(msg) {
        if (numWarnings > maxWarnings) {
          return;
        }

        numWarnings++;
        console.warn(msg);
      }

      Narrowphase.prototype[Shape.types.BOX | Shape.types.BOX] = Narrowphase.prototype.boxBox = function (si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
        si.convexPolyhedronRepresentation.material = si.material;
        sj.convexPolyhedronRepresentation.material = sj.material;
        si.convexPolyhedronRepresentation.collisionResponse = si.collisionResponse;
        sj.convexPolyhedronRepresentation.collisionResponse = sj.collisionResponse;
        return this.convexConvex(si.convexPolyhedronRepresentation, sj.convexPolyhedronRepresentation, xi, xj, qi, qj, bi, bj, si, sj, justTest);
      };

      Narrowphase.prototype[Shape.types.BOX | Shape.types.CONVEXPOLYHEDRON] = Narrowphase.prototype.boxConvex = function (si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
        si.convexPolyhedronRepresentation.material = si.material;
        si.convexPolyhedronRepresentation.collisionResponse = si.collisionResponse;
        return this.convexConvex(si.convexPolyhedronRepresentation, sj, xi, xj, qi, qj, bi, bj, si, sj, justTest);
      };

      Narrowphase.prototype[Shape.types.BOX | Shape.types.PARTICLE] = Narrowphase.prototype.boxParticle = function (si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
        si.convexPolyhedronRepresentation.material = si.material;
        si.convexPolyhedronRepresentation.collisionResponse = si.collisionResponse;
        return this.convexParticle(si.convexPolyhedronRepresentation, sj, xi, xj, qi, qj, bi, bj, si, sj, justTest);
      };
      /**
       * @method sphereSphere
       * @param  {Shape}      si
       * @param  {Shape}      sj
       * @param  {Vec3}       xi
       * @param  {Vec3}       xj
       * @param  {Quaternion} qi
       * @param  {Quaternion} qj
       * @param  {Body}       bi
       * @param  {Body}       bj
       */


      Narrowphase.prototype[Shape.types.SPHERE] = Narrowphase.prototype.sphereSphere = function (si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
        if (justTest) {
          return xi.distanceSquared(xj) < Math.pow(si.radius + sj.radius, 2);
        } // We will have only one contact in this case


        var r = this.createContactEquation(bi, bj, si, sj, rsi, rsj); // Contact normal

        xj.vsub(xi, r.ni);
        r.ni.normalize(); // Contact point locations

        r.ri.copy(r.ni);
        r.rj.copy(r.ni);
        r.ri.mult(si.radius, r.ri);
        r.rj.mult(-sj.radius, r.rj);
        r.ri.vadd(xi, r.ri);
        r.ri.vsub(bi.position, r.ri);
        r.rj.vadd(xj, r.rj);
        r.rj.vsub(bj.position, r.rj);
        this.result.push(r);
        this.createFrictionEquationsFromContact(r, this.frictionResult);
      };
      /**
       * @method planeTrimesh
       * @param  {Shape}      si
       * @param  {Shape}      sj
       * @param  {Vec3}       xi
       * @param  {Vec3}       xj
       * @param  {Quaternion} qi
       * @param  {Quaternion} qj
       * @param  {Body}       bi
       * @param  {Body}       bj
       */


      var planeTrimesh_normal = new Vec3();
      var planeTrimesh_relpos = new Vec3();
      var planeTrimesh_projected = new Vec3();

      Narrowphase.prototype[Shape.types.PLANE | Shape.types.TRIMESH] = Narrowphase.prototype.planeTrimesh = function (planeShape, trimeshShape, planePos, trimeshPos, planeQuat, trimeshQuat, planeBody, trimeshBody, rsi, rsj, justTest) {
        // Make contacts!
        var v = new Vec3();
        var normal = planeTrimesh_normal;
        normal.set(0, 0, 1);
        planeQuat.vmult(normal, normal); // Turn normal according to plane

        for (var i = 0; i < trimeshShape.vertices.length / 3; i++) {
          // Get world vertex from trimesh
          trimeshShape.getVertex(i, v); // Safe up

          var v2 = new Vec3();
          v2.copy(v);
          Transform.pointToWorldFrame(trimeshPos, trimeshQuat, v2, v); // Check plane side

          var relpos = planeTrimesh_relpos;
          v.vsub(planePos, relpos);
          var dot = normal.dot(relpos);

          if (dot <= 0.0) {
            if (justTest) {
              return true;
            }

            var r = this.createContactEquation(planeBody, trimeshBody, planeShape, trimeshShape, rsi, rsj);
            r.ni.copy(normal); // Contact normal is the plane normal
            // Get vertex position projected on plane

            var projected = planeTrimesh_projected;
            normal.scale(relpos.dot(normal), projected);
            v.vsub(projected, projected); // ri is the projected world position minus plane position

            r.ri.copy(projected);
            r.ri.vsub(planeBody.position, r.ri);
            r.rj.copy(v);
            r.rj.vsub(trimeshBody.position, r.rj); // Store result

            this.result.push(r);
            this.createFrictionEquationsFromContact(r, this.frictionResult);
          }
        }
      };
      /**
       * @method sphereTrimesh
       * @param  {Shape}      sphereShape
       * @param  {Shape}      trimeshShape
       * @param  {Vec3}       spherePos
       * @param  {Vec3}       trimeshPos
       * @param  {Quaternion} sphereQuat
       * @param  {Quaternion} trimeshQuat
       * @param  {Body}       sphereBody
       * @param  {Body}       trimeshBody
       */


      var sphereTrimesh_normal = new Vec3();
      var sphereTrimesh_relpos = new Vec3();
      var sphereTrimesh_projected = new Vec3();
      var sphereTrimesh_v = new Vec3();
      var sphereTrimesh_v2 = new Vec3();
      var sphereTrimesh_edgeVertexA = new Vec3();
      var sphereTrimesh_edgeVertexB = new Vec3();
      var sphereTrimesh_edgeVector = new Vec3();
      var sphereTrimesh_edgeVectorUnit = new Vec3();
      var sphereTrimesh_localSpherePos = new Vec3();
      var sphereTrimesh_tmp = new Vec3();
      var sphereTrimesh_va = new Vec3();
      var sphereTrimesh_vb = new Vec3();
      var sphereTrimesh_vc = new Vec3();
      var sphereTrimesh_localSphereAABB = new AABB();
      var sphereTrimesh_triangles = [];

      Narrowphase.prototype[Shape.types.SPHERE | Shape.types.TRIMESH] = Narrowphase.prototype.sphereTrimesh = function (sphereShape, trimeshShape, spherePos, trimeshPos, sphereQuat, trimeshQuat, sphereBody, trimeshBody, rsi, rsj, justTest) {
        var edgeVertexA = sphereTrimesh_edgeVertexA;
        var edgeVertexB = sphereTrimesh_edgeVertexB;
        var edgeVector = sphereTrimesh_edgeVector;
        var edgeVectorUnit = sphereTrimesh_edgeVectorUnit;
        var localSpherePos = sphereTrimesh_localSpherePos;
        var tmp = sphereTrimesh_tmp;
        var localSphereAABB = sphereTrimesh_localSphereAABB;
        var v2 = sphereTrimesh_v2;
        var relpos = sphereTrimesh_relpos;
        var triangles = sphereTrimesh_triangles; // Convert sphere position to local in the trimesh

        Transform.pointToLocalFrame(trimeshPos, trimeshQuat, spherePos, localSpherePos); // Get the aabb of the sphere locally in the trimesh

        var sphereRadius = sphereShape.radius;
        localSphereAABB.lowerBound.set(localSpherePos.x - sphereRadius, localSpherePos.y - sphereRadius, localSpherePos.z - sphereRadius);
        localSphereAABB.upperBound.set(localSpherePos.x + sphereRadius, localSpherePos.y + sphereRadius, localSpherePos.z + sphereRadius);
        trimeshShape.getTrianglesInAABB(localSphereAABB, triangles); //for (var i = 0; i < trimeshShape.indices.length / 3; i++) triangles.push(i); // All
        // Vertices

        var v = sphereTrimesh_v;
        var radiusSquared = sphereShape.radius * sphereShape.radius;

        for (var i = 0; i < triangles.length; i++) {
          for (var j = 0; j < 3; j++) {
            trimeshShape.getVertex(trimeshShape.indices[triangles[i] * 3 + j], v); // Check vertex overlap in sphere

            v.vsub(localSpherePos, relpos);

            if (relpos.norm2() <= radiusSquared) {
              // Safe up
              v2.copy(v);
              Transform.pointToWorldFrame(trimeshPos, trimeshQuat, v2, v);
              v.vsub(spherePos, relpos);

              if (justTest) {
                return true;
              }

              var r = this.createContactEquation(sphereBody, trimeshBody, sphereShape, trimeshShape, rsi, rsj);
              r.ni.copy(relpos);
              r.ni.normalize(); // ri is the vector from sphere center to the sphere surface

              r.ri.copy(r.ni);
              r.ri.scale(sphereShape.radius, r.ri);
              r.ri.vadd(spherePos, r.ri);
              r.ri.vsub(sphereBody.position, r.ri);
              r.rj.copy(v);
              r.rj.vsub(trimeshBody.position, r.rj); // Store result

              this.result.push(r);
              this.createFrictionEquationsFromContact(r, this.frictionResult);
            }
          }
        } // Check all edges


        for (var i = 0; i < triangles.length; i++) {
          for (var j = 0; j < 3; j++) {
            trimeshShape.getVertex(trimeshShape.indices[triangles[i] * 3 + j], edgeVertexA);
            trimeshShape.getVertex(trimeshShape.indices[triangles[i] * 3 + (j + 1) % 3], edgeVertexB);
            edgeVertexB.vsub(edgeVertexA, edgeVector); // Project sphere position to the edge

            localSpherePos.vsub(edgeVertexB, tmp);
            var positionAlongEdgeB = tmp.dot(edgeVector);
            localSpherePos.vsub(edgeVertexA, tmp);
            var positionAlongEdgeA = tmp.dot(edgeVector);

            if (positionAlongEdgeA > 0 && positionAlongEdgeB < 0) {
              // Now check the orthogonal distance from edge to sphere center
              localSpherePos.vsub(edgeVertexA, tmp);
              edgeVectorUnit.copy(edgeVector);
              edgeVectorUnit.normalize();
              positionAlongEdgeA = tmp.dot(edgeVectorUnit);
              edgeVectorUnit.scale(positionAlongEdgeA, tmp);
              tmp.vadd(edgeVertexA, tmp); // tmp is now the sphere center position projected to the edge, defined locally in the trimesh frame

              var dist = tmp.distanceTo(localSpherePos);

              if (dist < sphereShape.radius) {
                if (justTest) {
                  return true;
                }

                var r = this.createContactEquation(sphereBody, trimeshBody, sphereShape, trimeshShape, rsi, rsj);
                tmp.vsub(localSpherePos, r.ni);
                r.ni.normalize();
                r.ni.scale(sphereShape.radius, r.ri);
                Transform.pointToWorldFrame(trimeshPos, trimeshQuat, tmp, tmp);
                tmp.vsub(trimeshBody.position, r.rj);
                Transform.vectorToWorldFrame(trimeshQuat, r.ni, r.ni);
                Transform.vectorToWorldFrame(trimeshQuat, r.ri, r.ri);
                this.result.push(r);
                this.createFrictionEquationsFromContact(r, this.frictionResult);
              }
            }
          }
        } // Triangle faces


        var va = sphereTrimesh_va;
        var vb = sphereTrimesh_vb;
        var vc = sphereTrimesh_vc;
        var normal = sphereTrimesh_normal;

        for (var i = 0, N = triangles.length; i !== N; i++) {
          trimeshShape.getTriangleVertices(triangles[i], va, vb, vc);
          trimeshShape.getNormal(triangles[i], normal);
          localSpherePos.vsub(va, tmp);
          var dist = tmp.dot(normal);
          normal.scale(dist, tmp);
          localSpherePos.vsub(tmp, tmp); // tmp is now the sphere position projected to the triangle plane

          dist = tmp.distanceTo(localSpherePos);

          if (Ray.pointInTriangle(tmp, va, vb, vc) && dist < sphereShape.radius) {
            if (justTest) {
              return true;
            }

            var r = this.createContactEquation(sphereBody, trimeshBody, sphereShape, trimeshShape, rsi, rsj);
            tmp.vsub(localSpherePos, r.ni);
            r.ni.normalize();
            r.ni.scale(sphereShape.radius, r.ri);
            Transform.pointToWorldFrame(trimeshPos, trimeshQuat, tmp, tmp);
            tmp.vsub(trimeshBody.position, r.rj);
            Transform.vectorToWorldFrame(trimeshQuat, r.ni, r.ni);
            Transform.vectorToWorldFrame(trimeshQuat, r.ri, r.ri);
            this.result.push(r);
            this.createFrictionEquationsFromContact(r, this.frictionResult);
          }
        }

        triangles.length = 0;
      };

      var point_on_plane_to_sphere = new Vec3();
      var plane_to_sphere_ortho = new Vec3();
      var p_s_ni = new Vec3();
      var p_s_ri = new Vec3();
      var p_s_rj = new Vec3();
      /**
       * @method spherePlane
       * @param  {Shape}      si
       * @param  {Shape}      sj
       * @param  {Vec3}       xi
       * @param  {Vec3}       xj
       * @param  {Quaternion} qi
       * @param  {Quaternion} qj
       * @param  {Body}       bi
       * @param  {Body}       bj
       */

      Narrowphase.prototype[Shape.types.SPHERE | Shape.types.PLANE] = Narrowphase.prototype.spherePlane = function (si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
        // Contact normal
        p_s_ni.set(0, 0, 1);
        qj.vmult(p_s_ni, p_s_ni);
        p_s_ni.negate(p_s_ni); // body i is the sphere, flip normal

        p_s_ni.normalize(); // Needed?
        // Vector from sphere center to contact point

        p_s_ni.mult(si.radius, p_s_ri); // Project down sphere on plane

        xi.vsub(xj, point_on_plane_to_sphere);
        p_s_ni.mult(p_s_ni.dot(point_on_plane_to_sphere), plane_to_sphere_ortho);
        point_on_plane_to_sphere.vsub(plane_to_sphere_ortho, p_s_rj); // The sphere position projected to plane

        if (-point_on_plane_to_sphere.dot(p_s_ni) <= si.radius) {
          if (justTest) {
            return true;
          } // We will have one contact in this case


          var r = this.createContactEquation(bi, bj, si, sj, rsi, rsj); // Make it relative to the body

          r.ni.copy(p_s_ni);
          r.ri.copy(p_s_ri);
          r.rj.copy(p_s_rj);
          var ri = r.ri;
          var rj = r.rj;
          ri.vadd(xi, ri);
          ri.vsub(bi.position, ri);
          rj.vadd(xj, rj);
          rj.vsub(bj.position, rj);
          this.result.push(r);
          this.createFrictionEquationsFromContact(r, this.frictionResult);
        }
      }; // See http://bulletphysics.com/Bullet/BulletFull/SphereTriangleDetector_8cpp_source.html


      var pointInPolygon_edge = new Vec3();
      var pointInPolygon_edge_x_normal = new Vec3();
      var pointInPolygon_vtp = new Vec3();

      function pointInPolygon(verts, normal, p) {
        var positiveResult = null;
        var N = verts.length;

        for (var i = 0; i !== N; i++) {
          var v = verts[i]; // Get edge to the next vertex

          var edge = pointInPolygon_edge;
          verts[(i + 1) % N].vsub(v, edge); // Get cross product between polygon normal and the edge

          var edge_x_normal = pointInPolygon_edge_x_normal; //var edge_x_normal = new Vec3();

          edge.cross(normal, edge_x_normal); // Get vector between point and current vertex

          var vertex_to_p = pointInPolygon_vtp;
          p.vsub(v, vertex_to_p); // This dot product determines which side of the edge the point is

          var r = edge_x_normal.dot(vertex_to_p); // If all such dot products have same sign, we are inside the polygon.

          if (positiveResult === null || r > 0 && positiveResult === true || r <= 0 && positiveResult === false) {
            if (positiveResult === null) {
              positiveResult = r > 0;
            }

            continue;
          } else {
            return false; // Encountered some other sign. Exit.
          }
        } // If we got here, all dot products were of the same sign.


        return true;
      }

      var box_to_sphere = new Vec3();
      var sphereBox_ns = new Vec3();
      var sphereBox_ns1 = new Vec3();
      var sphereBox_ns2 = new Vec3();
      var sphereBox_sides = [new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3()];
      var sphereBox_sphere_to_corner = new Vec3();
      var sphereBox_side_ns = new Vec3();
      var sphereBox_side_ns1 = new Vec3();
      var sphereBox_side_ns2 = new Vec3();
      /**
       * @method sphereBox
       * @param  {Shape}      si
       * @param  {Shape}      sj
       * @param  {Vec3}       xi
       * @param  {Vec3}       xj
       * @param  {Quaternion} qi
       * @param  {Quaternion} qj
       * @param  {Body}       bi
       * @param  {Body}       bj
       */

      Narrowphase.prototype[Shape.types.SPHERE | Shape.types.BOX] = Narrowphase.prototype.sphereBox = function (si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
        var v3pool = this.v3pool; // we refer to the box as body j

        var sides = sphereBox_sides;
        xi.vsub(xj, box_to_sphere);
        sj.getSideNormals(sides, qj);
        var R = si.radius;
        var penetrating_sides = []; // Check side (plane) intersections

        var found = false; // Store the resulting side penetration info

        var side_ns = sphereBox_side_ns;
        var side_ns1 = sphereBox_side_ns1;
        var side_ns2 = sphereBox_side_ns2;
        var side_h = null;
        var side_penetrations = 0;
        var side_dot1 = 0;
        var side_dot2 = 0;
        var side_distance = null;

        for (var idx = 0, nsides = sides.length; idx !== nsides && found === false; idx++) {
          // Get the plane side normal (ns)
          var ns = sphereBox_ns;
          ns.copy(sides[idx]);
          var h = ns.norm();
          ns.normalize(); // The normal/distance dot product tells which side of the plane we are

          var dot = box_to_sphere.dot(ns);

          if (dot < h + R && dot > 0) {
            // Intersects plane. Now check the other two dimensions
            var ns1 = sphereBox_ns1;
            var ns2 = sphereBox_ns2;
            ns1.copy(sides[(idx + 1) % 3]);
            ns2.copy(sides[(idx + 2) % 3]);
            var h1 = ns1.norm();
            var h2 = ns2.norm();
            ns1.normalize();
            ns2.normalize();
            var dot1 = box_to_sphere.dot(ns1);
            var dot2 = box_to_sphere.dot(ns2);

            if (dot1 < h1 && dot1 > -h1 && dot2 < h2 && dot2 > -h2) {
              var dist = Math.abs(dot - h - R);

              if (side_distance === null || dist < side_distance) {
                side_distance = dist;
                side_dot1 = dot1;
                side_dot2 = dot2;
                side_h = h;
                side_ns.copy(ns);
                side_ns1.copy(ns1);
                side_ns2.copy(ns2);
                side_penetrations++;

                if (justTest) {
                  return true;
                }
              }
            }
          }
        }

        if (side_penetrations) {
          found = true;
          var r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
          side_ns.mult(-R, r.ri); // Sphere r

          r.ni.copy(side_ns);
          r.ni.negate(r.ni); // Normal should be out of sphere

          side_ns.mult(side_h, side_ns);
          side_ns1.mult(side_dot1, side_ns1);
          side_ns.vadd(side_ns1, side_ns);
          side_ns2.mult(side_dot2, side_ns2);
          side_ns.vadd(side_ns2, r.rj); // Make relative to bodies

          r.ri.vadd(xi, r.ri);
          r.ri.vsub(bi.position, r.ri);
          r.rj.vadd(xj, r.rj);
          r.rj.vsub(bj.position, r.rj);
          this.result.push(r);
          this.createFrictionEquationsFromContact(r, this.frictionResult);
        } // Check corners


        var rj = v3pool.get();
        var sphere_to_corner = sphereBox_sphere_to_corner;

        for (var j = 0; j !== 2 && !found; j++) {
          for (var k = 0; k !== 2 && !found; k++) {
            for (var l = 0; l !== 2 && !found; l++) {
              rj.set(0, 0, 0);

              if (j) {
                rj.vadd(sides[0], rj);
              } else {
                rj.vsub(sides[0], rj);
              }

              if (k) {
                rj.vadd(sides[1], rj);
              } else {
                rj.vsub(sides[1], rj);
              }

              if (l) {
                rj.vadd(sides[2], rj);
              } else {
                rj.vsub(sides[2], rj);
              } // World position of corner


              xj.vadd(rj, sphere_to_corner);
              sphere_to_corner.vsub(xi, sphere_to_corner);

              if (sphere_to_corner.norm2() < R * R) {
                if (justTest) {
                  return true;
                }

                found = true;
                var r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
                r.ri.copy(sphere_to_corner);
                r.ri.normalize();
                r.ni.copy(r.ri);
                r.ri.mult(R, r.ri);
                r.rj.copy(rj); // Make relative to bodies

                r.ri.vadd(xi, r.ri);
                r.ri.vsub(bi.position, r.ri);
                r.rj.vadd(xj, r.rj);
                r.rj.vsub(bj.position, r.rj);
                this.result.push(r);
                this.createFrictionEquationsFromContact(r, this.frictionResult);
              }
            }
          }
        }

        v3pool.release(rj);
        rj = null; // Check edges

        var edgeTangent = v3pool.get();
        var edgeCenter = v3pool.get();
        var r = v3pool.get(); // r = edge center to sphere center

        var orthogonal = v3pool.get();
        var dist = v3pool.get();
        var Nsides = sides.length;

        for (var j = 0; j !== Nsides && !found; j++) {
          for (var k = 0; k !== Nsides && !found; k++) {
            if (j % 3 !== k % 3) {
              // Get edge tangent
              sides[k].cross(sides[j], edgeTangent);
              edgeTangent.normalize();
              sides[j].vadd(sides[k], edgeCenter);
              r.copy(xi);
              r.vsub(edgeCenter, r);
              r.vsub(xj, r);
              var orthonorm = r.dot(edgeTangent); // distance from edge center to sphere center in the tangent direction

              edgeTangent.mult(orthonorm, orthogonal); // Vector from edge center to sphere center in the tangent direction
              // Find the third side orthogonal to this one

              var l = 0;

              while (l === j % 3 || l === k % 3) {
                l++;
              } // vec from edge center to sphere projected to the plane orthogonal to the edge tangent


              dist.copy(xi);
              dist.vsub(orthogonal, dist);
              dist.vsub(edgeCenter, dist);
              dist.vsub(xj, dist); // Distances in tangent direction and distance in the plane orthogonal to it

              var tdist = Math.abs(orthonorm);
              var ndist = dist.norm();

              if (tdist < sides[l].norm() && ndist < R) {
                if (justTest) {
                  return true;
                }

                found = true;
                var res = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
                edgeCenter.vadd(orthogonal, res.rj); // box rj

                res.rj.copy(res.rj);
                dist.negate(res.ni);
                res.ni.normalize();
                res.ri.copy(res.rj);
                res.ri.vadd(xj, res.ri);
                res.ri.vsub(xi, res.ri);
                res.ri.normalize();
                res.ri.mult(R, res.ri); // Make relative to bodies

                res.ri.vadd(xi, res.ri);
                res.ri.vsub(bi.position, res.ri);
                res.rj.vadd(xj, res.rj);
                res.rj.vsub(bj.position, res.rj);
                this.result.push(res);
                this.createFrictionEquationsFromContact(res, this.frictionResult);
              }
            }
          }
        }

        v3pool.release(edgeTangent, edgeCenter, r, orthogonal, dist);
      };

      var convex_to_sphere = new Vec3();
      var sphereConvex_edge = new Vec3();
      var sphereConvex_edgeUnit = new Vec3();
      var sphereConvex_sphereToCorner = new Vec3();
      var sphereConvex_worldCorner = new Vec3();
      var sphereConvex_worldNormal = new Vec3();
      var sphereConvex_worldPoint = new Vec3();
      var sphereConvex_worldSpherePointClosestToPlane = new Vec3();
      var sphereConvex_penetrationVec = new Vec3();
      var sphereConvex_sphereToWorldPoint = new Vec3();
      /**
       * @method sphereConvex
       * @param  {Shape}      si
       * @param  {Shape}      sj
       * @param  {Vec3}       xi
       * @param  {Vec3}       xj
       * @param  {Quaternion} qi
       * @param  {Quaternion} qj
       * @param  {Body}       bi
       * @param  {Body}       bj
       */

      Narrowphase.prototype[Shape.types.SPHERE | Shape.types.CONVEXPOLYHEDRON] = Narrowphase.prototype.sphereConvex = function (si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
        var v3pool = this.v3pool;
        xi.vsub(xj, convex_to_sphere);
        var normals = sj.faceNormals;
        var faces = sj.faces;
        var verts = sj.vertices;
        var R = si.radius;
        var penetrating_sides = []; // if(convex_to_sphere.norm2() > si.boundingSphereRadius + sj.boundingSphereRadius){
        //     return;
        // }
        // Check corners

        for (var i = 0; i !== verts.length; i++) {
          var v = verts[i]; // World position of corner

          var worldCorner = sphereConvex_worldCorner;
          qj.vmult(v, worldCorner);
          xj.vadd(worldCorner, worldCorner);
          var sphere_to_corner = sphereConvex_sphereToCorner;
          worldCorner.vsub(xi, sphere_to_corner);

          if (sphere_to_corner.norm2() < R * R) {
            if (justTest) {
              return true;
            }

            found = true;
            var r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
            r.ri.copy(sphere_to_corner);
            r.ri.normalize();
            r.ni.copy(r.ri);
            r.ri.mult(R, r.ri);
            worldCorner.vsub(xj, r.rj); // Should be relative to the body.

            r.ri.vadd(xi, r.ri);
            r.ri.vsub(bi.position, r.ri); // Should be relative to the body.

            r.rj.vadd(xj, r.rj);
            r.rj.vsub(bj.position, r.rj);
            this.result.push(r);
            this.createFrictionEquationsFromContact(r, this.frictionResult);
            return;
          }
        } // Check side (plane) intersections


        var found = false;

        for (var i = 0, nfaces = faces.length; i !== nfaces && found === false; i++) {
          var normal = normals[i];
          var face = faces[i]; // Get world-transformed normal of the face

          var worldNormal = sphereConvex_worldNormal;
          qj.vmult(normal, worldNormal); // Get a world vertex from the face

          var worldPoint = sphereConvex_worldPoint;
          qj.vmult(verts[face[0]], worldPoint);
          worldPoint.vadd(xj, worldPoint); // Get a point on the sphere, closest to the face normal

          var worldSpherePointClosestToPlane = sphereConvex_worldSpherePointClosestToPlane;
          worldNormal.mult(-R, worldSpherePointClosestToPlane);
          xi.vadd(worldSpherePointClosestToPlane, worldSpherePointClosestToPlane); // Vector from a face point to the closest point on the sphere

          var penetrationVec = sphereConvex_penetrationVec;
          worldSpherePointClosestToPlane.vsub(worldPoint, penetrationVec); // The penetration. Negative value means overlap.

          var penetration = penetrationVec.dot(worldNormal);
          var worldPointToSphere = sphereConvex_sphereToWorldPoint;
          xi.vsub(worldPoint, worldPointToSphere);

          if (penetration < 0 && worldPointToSphere.dot(worldNormal) > 0) {
            // Intersects plane. Now check if the sphere is inside the face polygon
            var faceVerts = []; // Face vertices, in world coords

            for (var j = 0, Nverts = face.length; j !== Nverts; j++) {
              var worldVertex = v3pool.get();
              qj.vmult(verts[face[j]], worldVertex);
              xj.vadd(worldVertex, worldVertex);
              faceVerts.push(worldVertex);
            }

            if (pointInPolygon(faceVerts, worldNormal, xi)) {
              // Is the sphere center in the face polygon?
              if (justTest) {
                return true;
              }

              found = true;
              var r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
              worldNormal.mult(-R, r.ri); // Contact offset, from sphere center to contact

              worldNormal.negate(r.ni); // Normal pointing out of sphere

              var penetrationVec2 = v3pool.get();
              worldNormal.mult(-penetration, penetrationVec2);
              var penetrationSpherePoint = v3pool.get();
              worldNormal.mult(-R, penetrationSpherePoint); //xi.vsub(xj).vadd(penetrationSpherePoint).vadd(penetrationVec2 , r.rj);

              xi.vsub(xj, r.rj);
              r.rj.vadd(penetrationSpherePoint, r.rj);
              r.rj.vadd(penetrationVec2, r.rj); // Should be relative to the body.

              r.rj.vadd(xj, r.rj);
              r.rj.vsub(bj.position, r.rj); // Should be relative to the body.

              r.ri.vadd(xi, r.ri);
              r.ri.vsub(bi.position, r.ri);
              v3pool.release(penetrationVec2);
              v3pool.release(penetrationSpherePoint);
              this.result.push(r);
              this.createFrictionEquationsFromContact(r, this.frictionResult); // Release world vertices

              for (var j = 0, Nfaceverts = faceVerts.length; j !== Nfaceverts; j++) {
                v3pool.release(faceVerts[j]);
              }

              return; // We only expect *one* face contact
            } else {
              // Edge?
              for (var j = 0; j !== face.length; j++) {
                // Get two world transformed vertices
                var v1 = v3pool.get();
                var v2 = v3pool.get();
                qj.vmult(verts[face[(j + 1) % face.length]], v1);
                qj.vmult(verts[face[(j + 2) % face.length]], v2);
                xj.vadd(v1, v1);
                xj.vadd(v2, v2); // Construct edge vector

                var edge = sphereConvex_edge;
                v2.vsub(v1, edge); // Construct the same vector, but normalized

                var edgeUnit = sphereConvex_edgeUnit;
                edge.unit(edgeUnit); // p is xi projected onto the edge

                var p = v3pool.get();
                var v1_to_xi = v3pool.get();
                xi.vsub(v1, v1_to_xi);
                var dot = v1_to_xi.dot(edgeUnit);
                edgeUnit.mult(dot, p);
                p.vadd(v1, p); // Compute a vector from p to the center of the sphere

                var xi_to_p = v3pool.get();
                p.vsub(xi, xi_to_p); // Collision if the edge-sphere distance is less than the radius
                // AND if p is in between v1 and v2

                if (dot > 0 && dot * dot < edge.norm2() && xi_to_p.norm2() < R * R) {
                  // Collision if the edge-sphere distance is less than the radius
                  // Edge contact!
                  if (justTest) {
                    return true;
                  }

                  var r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
                  p.vsub(xj, r.rj);
                  p.vsub(xi, r.ni);
                  r.ni.normalize();
                  r.ni.mult(R, r.ri); // Should be relative to the body.

                  r.rj.vadd(xj, r.rj);
                  r.rj.vsub(bj.position, r.rj); // Should be relative to the body.

                  r.ri.vadd(xi, r.ri);
                  r.ri.vsub(bi.position, r.ri);
                  this.result.push(r);
                  this.createFrictionEquationsFromContact(r, this.frictionResult); // Release world vertices

                  for (var j = 0, Nfaceverts = faceVerts.length; j !== Nfaceverts; j++) {
                    v3pool.release(faceVerts[j]);
                  }

                  v3pool.release(v1);
                  v3pool.release(v2);
                  v3pool.release(p);
                  v3pool.release(xi_to_p);
                  v3pool.release(v1_to_xi);
                  return;
                }

                v3pool.release(v1);
                v3pool.release(v2);
                v3pool.release(p);
                v3pool.release(xi_to_p);
                v3pool.release(v1_to_xi);
              }
            } // Release world vertices


            for (var j = 0, Nfaceverts = faceVerts.length; j !== Nfaceverts; j++) {
              v3pool.release(faceVerts[j]);
            }
          }
        }
      };

      var planeBox_normal = new Vec3();
      var plane_to_corner = new Vec3();
      /**
       * @method planeBox
       * @param  {Array}      result
       * @param  {Shape}      si
       * @param  {Shape}      sj
       * @param  {Vec3}       xi
       * @param  {Vec3}       xj
       * @param  {Quaternion} qi
       * @param  {Quaternion} qj
       * @param  {Body}       bi
       * @param  {Body}       bj
       */

      Narrowphase.prototype[Shape.types.PLANE | Shape.types.BOX] = Narrowphase.prototype.planeBox = function (si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
        sj.convexPolyhedronRepresentation.material = sj.material;
        sj.convexPolyhedronRepresentation.collisionResponse = sj.collisionResponse;
        sj.convexPolyhedronRepresentation.id = sj.id;
        return this.planeConvex(si, sj.convexPolyhedronRepresentation, xi, xj, qi, qj, bi, bj, si, sj, justTest);
      };

      var planeConvex_v = new Vec3();
      var planeConvex_normal = new Vec3();
      var planeConvex_relpos = new Vec3();
      var planeConvex_projected = new Vec3();
      /**
       * @method planeConvex
       * @param  {Shape}      si
       * @param  {Shape}      sj
       * @param  {Vec3}       xi
       * @param  {Vec3}       xj
       * @param  {Quaternion} qi
       * @param  {Quaternion} qj
       * @param  {Body}       bi
       * @param  {Body}       bj
       */

      Narrowphase.prototype[Shape.types.PLANE | Shape.types.CONVEXPOLYHEDRON] = Narrowphase.prototype.planeConvex = function (planeShape, convexShape, planePosition, convexPosition, planeQuat, convexQuat, planeBody, convexBody, si, sj, justTest) {
        // Simply return the points behind the plane.
        var worldVertex = planeConvex_v,
            worldNormal = planeConvex_normal;
        worldNormal.set(0, 0, 1);
        planeQuat.vmult(worldNormal, worldNormal); // Turn normal according to plane orientation

        var numContacts = 0;
        var relpos = planeConvex_relpos;

        for (var i = 0; i !== convexShape.vertices.length; i++) {
          // Get world convex vertex
          worldVertex.copy(convexShape.vertices[i]);
          convexQuat.vmult(worldVertex, worldVertex);
          convexPosition.vadd(worldVertex, worldVertex);
          worldVertex.vsub(planePosition, relpos);
          var dot = worldNormal.dot(relpos);

          if (dot <= 0.0) {
            if (justTest) {
              return true;
            }

            var r = this.createContactEquation(planeBody, convexBody, planeShape, convexShape, si, sj); // Get vertex position projected on plane

            var projected = planeConvex_projected;
            worldNormal.mult(worldNormal.dot(relpos), projected);
            worldVertex.vsub(projected, projected);
            projected.vsub(planePosition, r.ri); // From plane to vertex projected on plane

            r.ni.copy(worldNormal); // Contact normal is the plane normal out from plane
            // rj is now just the vector from the convex center to the vertex

            worldVertex.vsub(convexPosition, r.rj); // Make it relative to the body

            r.ri.vadd(planePosition, r.ri);
            r.ri.vsub(planeBody.position, r.ri);
            r.rj.vadd(convexPosition, r.rj);
            r.rj.vsub(convexBody.position, r.rj);
            this.result.push(r);
            numContacts++;

            if (!this.enableFrictionReduction) {
              this.createFrictionEquationsFromContact(r, this.frictionResult);
            }
          }
        }

        if (this.enableFrictionReduction && numContacts) {
          this.createFrictionFromAverage(numContacts);
        }
      };

      var convexConvex_sepAxis = new Vec3();
      var convexConvex_q = new Vec3();
      /**
       * @method convexConvex
       * @param  {Shape}      si
       * @param  {Shape}      sj
       * @param  {Vec3}       xi
       * @param  {Vec3}       xj
       * @param  {Quaternion} qi
       * @param  {Quaternion} qj
       * @param  {Body}       bi
       * @param  {Body}       bj
       */

      Narrowphase.prototype[Shape.types.CONVEXPOLYHEDRON] = Narrowphase.prototype.convexConvex = function (si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest, faceListA, faceListB) {
        var sepAxis = convexConvex_sepAxis;

        if (xi.distanceTo(xj) > si.boundingSphereRadius + sj.boundingSphereRadius) {
          return;
        }

        if (si.findSeparatingAxis(sj, xi, qi, xj, qj, sepAxis, faceListA, faceListB)) {
          var res = [];
          var q = convexConvex_q;
          si.clipAgainstHull(xi, qi, sj, xj, qj, sepAxis, -100, 100, res);
          var numContacts = 0;

          for (var j = 0; j !== res.length; j++) {
            if (justTest) {
              return true;
            }

            var r = this.createContactEquation(bi, bj, si, sj, rsi, rsj),
                ri = r.ri,
                rj = r.rj;
            sepAxis.negate(r.ni);
            res[j].normal.negate(q);
            q.mult(res[j].depth, q);
            res[j].point.vadd(q, ri);
            rj.copy(res[j].point); // Contact points are in world coordinates. Transform back to relative

            ri.vsub(xi, ri);
            rj.vsub(xj, rj); // Make relative to bodies

            ri.vadd(xi, ri);
            ri.vsub(bi.position, ri);
            rj.vadd(xj, rj);
            rj.vsub(bj.position, rj);
            this.result.push(r);
            numContacts++;

            if (!this.enableFrictionReduction) {
              this.createFrictionEquationsFromContact(r, this.frictionResult);
            }
          }

          if (this.enableFrictionReduction && numContacts) {
            this.createFrictionFromAverage(numContacts);
          }
        }
      };
      /**
       * @method convexTrimesh
       * @param  {Array}      result
       * @param  {Shape}      si
       * @param  {Shape}      sj
       * @param  {Vec3}       xi
       * @param  {Vec3}       xj
       * @param  {Quaternion} qi
       * @param  {Quaternion} qj
       * @param  {Body}       bi
       * @param  {Body}       bj
       */
      // Narrowphase.prototype[Shape.types.CONVEXPOLYHEDRON | Shape.types.TRIMESH] =
      // Narrowphase.prototype.convexTrimesh = function(si,sj,xi,xj,qi,qj,bi,bj,rsi,rsj,faceListA,faceListB){
      //     var sepAxis = convexConvex_sepAxis;
      //     if(xi.distanceTo(xj) > si.boundingSphereRadius + sj.boundingSphereRadius){
      //         return;
      //     }
      //     // Construct a temp hull for each triangle
      //     var hullB = new ConvexPolyhedron();
      //     hullB.faces = [[0,1,2]];
      //     var va = new Vec3();
      //     var vb = new Vec3();
      //     var vc = new Vec3();
      //     hullB.vertices = [
      //         va,
      //         vb,
      //         vc
      //     ];
      //     for (var i = 0; i < sj.indices.length / 3; i++) {
      //         var triangleNormal = new Vec3();
      //         sj.getNormal(i, triangleNormal);
      //         hullB.faceNormals = [triangleNormal];
      //         sj.getTriangleVertices(i, va, vb, vc);
      //         var d = si.testSepAxis(triangleNormal, hullB, xi, qi, xj, qj);
      //         if(!d){
      //             triangleNormal.scale(-1, triangleNormal);
      //             d = si.testSepAxis(triangleNormal, hullB, xi, qi, xj, qj);
      //             if(!d){
      //                 continue;
      //             }
      //         }
      //         var res = [];
      //         var q = convexConvex_q;
      //         si.clipAgainstHull(xi,qi,hullB,xj,qj,triangleNormal,-100,100,res);
      //         for(var j = 0; j !== res.length; j++){
      //             var r = this.createContactEquation(bi,bj,si,sj,rsi,rsj),
      //                 ri = r.ri,
      //                 rj = r.rj;
      //             r.ni.copy(triangleNormal);
      //             r.ni.negate(r.ni);
      //             res[j].normal.negate(q);
      //             q.mult(res[j].depth, q);
      //             res[j].point.vadd(q, ri);
      //             rj.copy(res[j].point);
      //             // Contact points are in world coordinates. Transform back to relative
      //             ri.vsub(xi,ri);
      //             rj.vsub(xj,rj);
      //             // Make relative to bodies
      //             ri.vadd(xi, ri);
      //             ri.vsub(bi.position, ri);
      //             rj.vadd(xj, rj);
      //             rj.vsub(bj.position, rj);
      //             result.push(r);
      //         }
      //     }
      // };


      var particlePlane_normal = new Vec3();
      var particlePlane_relpos = new Vec3();
      var particlePlane_projected = new Vec3();
      /**
       * @method particlePlane
       * @param  {Array}      result
       * @param  {Shape}      si
       * @param  {Shape}      sj
       * @param  {Vec3}       xi
       * @param  {Vec3}       xj
       * @param  {Quaternion} qi
       * @param  {Quaternion} qj
       * @param  {Body}       bi
       * @param  {Body}       bj
       */

      Narrowphase.prototype[Shape.types.PLANE | Shape.types.PARTICLE] = Narrowphase.prototype.planeParticle = function (sj, si, xj, xi, qj, qi, bj, bi, rsi, rsj, justTest) {
        var normal = particlePlane_normal;
        normal.set(0, 0, 1);
        bj.quaternion.vmult(normal, normal); // Turn normal according to plane orientation

        var relpos = particlePlane_relpos;
        xi.vsub(bj.position, relpos);
        var dot = normal.dot(relpos);

        if (dot <= 0.0) {
          if (justTest) {
            return true;
          }

          var r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
          r.ni.copy(normal); // Contact normal is the plane normal

          r.ni.negate(r.ni);
          r.ri.set(0, 0, 0); // Center of particle
          // Get particle position projected on plane

          var projected = particlePlane_projected;
          normal.mult(normal.dot(xi), projected);
          xi.vsub(projected, projected); //projected.vadd(bj.position,projected);
          // rj is now the projected world position minus plane position

          r.rj.copy(projected);
          this.result.push(r);
          this.createFrictionEquationsFromContact(r, this.frictionResult);
        }
      };

      var particleSphere_normal = new Vec3();
      /**
       * @method particleSphere
       * @param  {Array}      result
       * @param  {Shape}      si
       * @param  {Shape}      sj
       * @param  {Vec3}       xi
       * @param  {Vec3}       xj
       * @param  {Quaternion} qi
       * @param  {Quaternion} qj
       * @param  {Body}       bi
       * @param  {Body}       bj
       */

      Narrowphase.prototype[Shape.types.PARTICLE | Shape.types.SPHERE] = Narrowphase.prototype.sphereParticle = function (sj, si, xj, xi, qj, qi, bj, bi, rsi, rsj, justTest) {
        // The normal is the unit vector from sphere center to particle center
        var normal = particleSphere_normal;
        normal.set(0, 0, 1);
        xi.vsub(xj, normal);
        var lengthSquared = normal.norm2();

        if (lengthSquared <= sj.radius * sj.radius) {
          if (justTest) {
            return true;
          }

          var r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
          normal.normalize();
          r.rj.copy(normal);
          r.rj.mult(sj.radius, r.rj);
          r.ni.copy(normal); // Contact normal

          r.ni.negate(r.ni);
          r.ri.set(0, 0, 0); // Center of particle

          this.result.push(r);
          this.createFrictionEquationsFromContact(r, this.frictionResult);
        }
      }; // WIP


      var cqj = new Quaternion();
      var convexParticle_local = new Vec3();
      var convexParticle_normal = new Vec3();
      var convexParticle_penetratedFaceNormal = new Vec3();
      var convexParticle_vertexToParticle = new Vec3();
      var convexParticle_worldPenetrationVec = new Vec3();
      /**
       * @method convexParticle
       * @param  {Array}      result
       * @param  {Shape}      si
       * @param  {Shape}      sj
       * @param  {Vec3}       xi
       * @param  {Vec3}       xj
       * @param  {Quaternion} qi
       * @param  {Quaternion} qj
       * @param  {Body}       bi
       * @param  {Body}       bj
       */

      Narrowphase.prototype[Shape.types.PARTICLE | Shape.types.CONVEXPOLYHEDRON] = Narrowphase.prototype.convexParticle = function (sj, si, xj, xi, qj, qi, bj, bi, rsi, rsj, justTest) {
        var penetratedFaceIndex = -1;
        var penetratedFaceNormal = convexParticle_penetratedFaceNormal;
        var worldPenetrationVec = convexParticle_worldPenetrationVec;
        var minPenetration = null;
        var numDetectedFaces = 0; // Convert particle position xi to local coords in the convex

        var local = convexParticle_local;
        local.copy(xi);
        local.vsub(xj, local); // Convert position to relative the convex origin

        qj.conjugate(cqj);
        cqj.vmult(local, local);

        if (sj.pointIsInside(local)) {
          if (sj.worldVerticesNeedsUpdate) {
            sj.computeWorldVertices(xj, qj);
          }

          if (sj.worldFaceNormalsNeedsUpdate) {
            sj.computeWorldFaceNormals(qj);
          } // For each world polygon in the polyhedra


          for (var i = 0, nfaces = sj.faces.length; i !== nfaces; i++) {
            // Construct world face vertices
            var verts = [sj.worldVertices[sj.faces[i][0]]];
            var normal = sj.worldFaceNormals[i]; // Check how much the particle penetrates the polygon plane.

            xi.vsub(verts[0], convexParticle_vertexToParticle);
            var penetration = -normal.dot(convexParticle_vertexToParticle);

            if (minPenetration === null || Math.abs(penetration) < Math.abs(minPenetration)) {
              if (justTest) {
                return true;
              }

              minPenetration = penetration;
              penetratedFaceIndex = i;
              penetratedFaceNormal.copy(normal);
              numDetectedFaces++;
            }
          }

          if (penetratedFaceIndex !== -1) {
            // Setup contact
            var r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
            penetratedFaceNormal.mult(minPenetration, worldPenetrationVec); // rj is the particle position projected to the face

            worldPenetrationVec.vadd(xi, worldPenetrationVec);
            worldPenetrationVec.vsub(xj, worldPenetrationVec);
            r.rj.copy(worldPenetrationVec); //var projectedToFace = xi.vsub(xj).vadd(worldPenetrationVec);
            //projectedToFace.copy(r.rj);
            //qj.vmult(r.rj,r.rj);

            penetratedFaceNormal.negate(r.ni); // Contact normal

            r.ri.set(0, 0, 0); // Center of particle

            var ri = r.ri,
                rj = r.rj; // Make relative to bodies

            ri.vadd(xi, ri);
            ri.vsub(bi.position, ri);
            rj.vadd(xj, rj);
            rj.vsub(bj.position, rj);
            this.result.push(r);
            this.createFrictionEquationsFromContact(r, this.frictionResult);
          } else {
            console.warn("Point found inside convex, but did not find penetrating face!");
          }
        }
      };

      Narrowphase.prototype[Shape.types.BOX | Shape.types.HEIGHTFIELD] = Narrowphase.prototype.boxHeightfield = function (si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
        si.convexPolyhedronRepresentation.material = si.material;
        si.convexPolyhedronRepresentation.collisionResponse = si.collisionResponse;
        return this.convexHeightfield(si.convexPolyhedronRepresentation, sj, xi, xj, qi, qj, bi, bj, si, sj, justTest);
      };

      var convexHeightfield_tmp1 = new Vec3();
      var convexHeightfield_tmp2 = new Vec3();
      var convexHeightfield_faceList = [0];
      /**
       * @method convexHeightfield
       */

      Narrowphase.prototype[Shape.types.CONVEXPOLYHEDRON | Shape.types.HEIGHTFIELD] = Narrowphase.prototype.convexHeightfield = function (convexShape, hfShape, convexPos, hfPos, convexQuat, hfQuat, convexBody, hfBody, rsi, rsj, justTest) {
        var data = hfShape.data,
            w = hfShape.elementSize,
            radius = convexShape.boundingSphereRadius,
            worldPillarOffset = convexHeightfield_tmp2,
            faceList = convexHeightfield_faceList; // Get sphere position to heightfield local!

        var localConvexPos = convexHeightfield_tmp1;
        Transform.pointToLocalFrame(hfPos, hfQuat, convexPos, localConvexPos); // Get the index of the data points to test against

        var iMinX = Math.floor((localConvexPos.x - radius) / w) - 1,
            iMaxX = Math.ceil((localConvexPos.x + radius) / w) + 1,
            iMinY = Math.floor((localConvexPos.y - radius) / w) - 1,
            iMaxY = Math.ceil((localConvexPos.y + radius) / w) + 1; // Bail out if we are out of the terrain

        if (iMaxX < 0 || iMaxY < 0 || iMinX > data.length || iMinY > data[0].length) {
          return;
        } // Clamp index to edges


        if (iMinX < 0) {
          iMinX = 0;
        }

        if (iMaxX < 0) {
          iMaxX = 0;
        }

        if (iMinY < 0) {
          iMinY = 0;
        }

        if (iMaxY < 0) {
          iMaxY = 0;
        }

        if (iMinX >= data.length) {
          iMinX = data.length - 1;
        }

        if (iMaxX >= data.length) {
          iMaxX = data.length - 1;
        }

        if (iMaxY >= data[0].length) {
          iMaxY = data[0].length - 1;
        }

        if (iMinY >= data[0].length) {
          iMinY = data[0].length - 1;
        }

        var minMax = [];
        hfShape.getRectMinMax(iMinX, iMinY, iMaxX, iMaxY, minMax);
        var min = minMax[0];
        var max = minMax[1]; // Bail out if we're cant touch the bounding height box

        if (localConvexPos.z - radius > max || localConvexPos.z + radius < min) {
          return;
        }

        for (var i = iMinX; i < iMaxX; i++) {
          for (var j = iMinY; j < iMaxY; j++) {
            var intersecting = false; // Lower triangle

            hfShape.getConvexTrianglePillar(i, j, false);
            Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset);

            if (convexPos.distanceTo(worldPillarOffset) < hfShape.pillarConvex.boundingSphereRadius + convexShape.boundingSphereRadius) {
              intersecting = this.convexConvex(convexShape, hfShape.pillarConvex, convexPos, worldPillarOffset, convexQuat, hfQuat, convexBody, hfBody, null, null, justTest, faceList, null);
            }

            if (justTest && intersecting) {
              return true;
            } // Upper triangle


            hfShape.getConvexTrianglePillar(i, j, true);
            Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset);

            if (convexPos.distanceTo(worldPillarOffset) < hfShape.pillarConvex.boundingSphereRadius + convexShape.boundingSphereRadius) {
              intersecting = this.convexConvex(convexShape, hfShape.pillarConvex, convexPos, worldPillarOffset, convexQuat, hfQuat, convexBody, hfBody, null, null, justTest, faceList, null);
            }

            if (justTest && intersecting) {
              return true;
            }
          }
        }
      };

      var sphereHeightfield_tmp1 = new Vec3();
      var sphereHeightfield_tmp2 = new Vec3();
      /**
       * @method sphereHeightfield
       */

      Narrowphase.prototype[Shape.types.SPHERE | Shape.types.HEIGHTFIELD] = Narrowphase.prototype.sphereHeightfield = function (sphereShape, hfShape, spherePos, hfPos, sphereQuat, hfQuat, sphereBody, hfBody, rsi, rsj, justTest) {
        var data = hfShape.data,
            radius = sphereShape.radius,
            w = hfShape.elementSize,
            worldPillarOffset = sphereHeightfield_tmp2; // Get sphere position to heightfield local!

        var localSpherePos = sphereHeightfield_tmp1;
        Transform.pointToLocalFrame(hfPos, hfQuat, spherePos, localSpherePos); // Get the index of the data points to test against

        var iMinX = Math.floor((localSpherePos.x - radius) / w) - 1,
            iMaxX = Math.ceil((localSpherePos.x + radius) / w) + 1,
            iMinY = Math.floor((localSpherePos.y - radius) / w) - 1,
            iMaxY = Math.ceil((localSpherePos.y + radius) / w) + 1; // Bail out if we are out of the terrain

        if (iMaxX < 0 || iMaxY < 0 || iMinX > data.length || iMinY > data[0].length) {
          return;
        } // Clamp index to edges


        if (iMinX < 0) {
          iMinX = 0;
        }

        if (iMaxX < 0) {
          iMaxX = 0;
        }

        if (iMinY < 0) {
          iMinY = 0;
        }

        if (iMaxY < 0) {
          iMaxY = 0;
        }

        if (iMinX >= data.length) {
          iMinX = data.length - 1;
        }

        if (iMaxX >= data.length) {
          iMaxX = data.length - 1;
        }

        if (iMaxY >= data[0].length) {
          iMaxY = data[0].length - 1;
        }

        if (iMinY >= data[0].length) {
          iMinY = data[0].length - 1;
        }

        var minMax = [];
        hfShape.getRectMinMax(iMinX, iMinY, iMaxX, iMaxY, minMax);
        var min = minMax[0];
        var max = minMax[1]; // Bail out if we're cant touch the bounding height box

        if (localSpherePos.z - radius > max || localSpherePos.z + radius < min) {
          return;
        }

        var result = this.result;

        for (var i = iMinX; i < iMaxX; i++) {
          for (var j = iMinY; j < iMaxY; j++) {
            var numContactsBefore = result.length;
            var intersecting = false; // Lower triangle

            hfShape.getConvexTrianglePillar(i, j, false);
            Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset);

            if (spherePos.distanceTo(worldPillarOffset) < hfShape.pillarConvex.boundingSphereRadius + sphereShape.boundingSphereRadius) {
              intersecting = this.sphereConvex(sphereShape, hfShape.pillarConvex, spherePos, worldPillarOffset, sphereQuat, hfQuat, sphereBody, hfBody, sphereShape, hfShape, justTest);
            }

            if (justTest && intersecting) {
              return true;
            } // Upper triangle


            hfShape.getConvexTrianglePillar(i, j, true);
            Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset);

            if (spherePos.distanceTo(worldPillarOffset) < hfShape.pillarConvex.boundingSphereRadius + sphereShape.boundingSphereRadius) {
              intersecting = this.sphereConvex(sphereShape, hfShape.pillarConvex, spherePos, worldPillarOffset, sphereQuat, hfQuat, sphereBody, hfBody, sphereShape, hfShape, justTest);
            }

            if (justTest && intersecting) {
              return true;
            }

            var numContacts = result.length - numContactsBefore;

            if (numContacts > 2) {
              return;
            }
            /*
            // Skip all but 1
            for (var k = 0; k < numContacts - 1; k++) {
                result.pop();
            }
            */

          }
        }
      };
    }, {
      "../collision/AABB": 3,
      "../collision/Ray": 10,
      "../equations/ContactEquation": 20,
      "../equations/FrictionEquation": 22,
      "../math/Quaternion": 29,
      "../math/Transform": 30,
      "../math/Vec3": 31,
      "../objects/Body": 32,
      "../shapes/ConvexPolyhedron": 39,
      "../shapes/Shape": 44,
      "../solver/Solver": 48,
      "../utils/Vec3Pool": 55
    }],
    57: [function (_dereq_, module, exports) {
      (function (global) {
        /* global performance */
        module.exports = World;

        var Shape = _dereq_('../shapes/Shape');

        var Vec3 = _dereq_('../math/Vec3');

        var Quaternion = _dereq_('../math/Quaternion');

        var GSSolver = _dereq_('../solver/GSSolver');

        var ContactEquation = _dereq_('../equations/ContactEquation');

        var FrictionEquation = _dereq_('../equations/FrictionEquation');

        var Narrowphase = _dereq_('./Narrowphase');

        var EventTarget = _dereq_('../utils/EventTarget');

        var ArrayCollisionMatrix = _dereq_('../collision/ArrayCollisionMatrix');

        var ObjectCollisionMatrix = _dereq_('../collision/ObjectCollisionMatrix');

        var OverlapKeeper = _dereq_('../collision/OverlapKeeper');

        var Material = _dereq_('../material/Material');

        var ContactMaterial = _dereq_('../material/ContactMaterial');

        var Body = _dereq_('../objects/Body');

        var TupleDictionary = _dereq_('../utils/TupleDictionary');

        var RaycastResult = _dereq_('../collision/RaycastResult');

        var AABB = _dereq_('../collision/AABB');

        var Ray = _dereq_('../collision/Ray');

        var NaiveBroadphase = _dereq_('../collision/NaiveBroadphase');

        if (global) {
          global['doProfiling'] = false;
          global['DEBUG'] = true;
        } else if (window) {
          window['doProfiling'] = false;
          window['DEBUG'] = true;
        }
        /**
         * The physics world
         * @class World
         * @constructor
         * @extends EventTarget
         * @param {object} [options]
         * @param {Vec3} [options.gravity]
         * @param {boolean} [options.allowSleep]
         * @param {Broadphase} [options.broadphase]
         * @param {Solver} [options.solver]
         * @param {boolean} [options.quatNormalizeFast]
         * @param {number} [options.quatNormalizeSkip]
         */


        function World(options) {
          options = options || {};
          EventTarget.apply(this);
          /**
           * Currently / last used timestep. Is set to -1 if not available. This value is updated before each internal step, which means that it is "fresh" inside event callbacks.
           * @property {Number} dt
           */

          this.dt = -1;
          /**
           * Makes bodies go to sleep when they've been inactive
           * @property allowSleep
           * @type {Boolean}
           * @default false
           */

          this.allowSleep = !!options.allowSleep;
          /**
           * All the current contacts (instances of ContactEquation) in the world.
           * @property contacts
           * @type {Array}
           */

          this.contacts = [];
          this.frictionEquations = [];
          this.contactsDic = new TupleDictionary();
          this.oldContactsDic = new TupleDictionary();
          /**
           * How often to normalize quaternions. Set to 0 for every step, 1 for every second etc.. A larger value increases performance. If bodies tend to explode, set to a smaller value (zero to be sure nothing can go wrong).
           * @property quatNormalizeSkip
           * @type {Number}
           * @default 0
           */

          this.quatNormalizeSkip = options.quatNormalizeSkip !== undefined ? options.quatNormalizeSkip : 0;
          /**
           * Set to true to use fast quaternion normalization. It is often enough accurate to use. If bodies tend to explode, set to false.
           * @property quatNormalizeFast
           * @type {Boolean}
           * @see Quaternion.normalizeFast
           * @see Quaternion.normalize
           * @default false
           */

          this.quatNormalizeFast = options.quatNormalizeFast !== undefined ? options.quatNormalizeFast : false;
          /**
           * The wall-clock time since simulation start
           * @property time
           * @type {Number}
           */

          this.time = 0.0;
          /**
           * Number of timesteps taken since start
           * @property stepnumber
           * @type {Number}
           */

          this.stepnumber = 0;
          this.substeps = 0; /// Default and last timestep sizes

          this.default_dt = 1 / 60;
          this.nextId = 0;
          /**
           * @property gravity
           * @type {Vec3}
           */

          this.gravity = new Vec3();

          if (options.gravity) {
            this.gravity.copy(options.gravity);
          }
          /**
           * The broadphase algorithm to use. Default is NaiveBroadphase
           * @property broadphase
           * @type {Broadphase}
           */


          this.broadphase = options.broadphase !== undefined ? options.broadphase : new NaiveBroadphase();
          /**
           * @property bodies
           * @type {Array}
           */

          this.bodies = [];
          /**
           * The solver algorithm to use. Default is GSSolver
           * @property solver
           * @type {Solver}
           */

          this.solver = options.solver !== undefined ? options.solver : new GSSolver();
          /**
           * @property constraints
           * @type {Array}
           */

          this.constraints = [];
          /**
           * @property narrowphase
           * @type {Narrowphase}
           */

          this.narrowphase = new Narrowphase(this);
          /**
           * @property {ObjectCollisionMatrix} collisionMatrix
          * @type {ObjectCollisionMatrix}
          */

          this.collisionMatrix = new ObjectCollisionMatrix();
          this.triggerMatrix = new ObjectCollisionMatrix();
          this.shapeOverlapKeeper = new OverlapKeeper();
          this.shapeOverlapKeeperExit = new OverlapKeeper();
          /**
           * All added materials
           * @property materials
           * @type {Array}
           */

          this.materials = [];
          /**
           * @property contactmaterials
           * @type {Array}
           */

          this.contactmaterials = [];
          /**
           * Used to look up a ContactMaterial given two instances of Material.
           * @property {TupleDictionary} contactMaterialTable
           */

          this.contactMaterialTable = new TupleDictionary();
          this.defaultMaterial = new Material("default");
          /**
           * This contact material is used if no suitable contactmaterial is found for a contact.
           * @property defaultContactMaterial
           * @type {ContactMaterial}
           */

          this.defaultContactMaterial = new ContactMaterial(this.defaultMaterial, this.defaultMaterial, {
            friction: 0.3,
            restitution: 0.0
          });
          /**
           * @property profile
           * @type {Object}
           */

          this.profile = {
            solve: 0,
            makeContactConstraints: 0,
            broadphase: 0,
            integrate: 0,
            narrowphase: 0
          };
          /**
           * Time accumulator for interpolation. See http://gafferongames.com/game-physics/fix-your-timestep/
           * @property {Number} accumulator
           */

          this.accumulator = 0;
          /**
           * @property subsystems
           * @type {Array}
           */

          this.subsystems = [];
          /**
           * Dispatched after a body has been added to the world.
           * @event addBody
           * @param {Body} body The body that has been added to the world.
           */

          this.addBodyEvent = {
            type: "addBody",
            body: null
          };
          /**
           * Dispatched after a body has been removed from the world.
           * @event removeBody
           * @param {Body} body The body that has been removed from the world.
           */

          this.removeBodyEvent = {
            type: "removeBody",
            body: null
          };
          this.broadphase.setWorld(this);
        }

        World.idToBodyMap = {};
        World.idToShapeMap = {};
        World.prototype = new EventTarget(); // Temp stuff
        // var tmpAABB1 = new AABB();
        // var tmpArray1 = [];

        var tmpRay = new Ray();
        /**
         * Get the contact material between materials m1 and m2
         * @method getContactMaterial
         * @param {Material} m1
         * @param {Material} m2
         * @return {ContactMaterial} The contact material if it was found.
         */

        World.prototype.getContactMaterial = function (m1, m2) {
          return this.contactMaterialTable.get(m1.id, m2.id); //this.contactmaterials[this.mats2cmat[i+j*this.materials.length]];
        };
        /**
         * Get number of objects in the world.
         * @method numObjects
         * @return {Number}
         * @deprecated
         */


        World.prototype.numObjects = function () {
          return this.bodies.length;
        };
        /**
         * Store old collision state info
         * @method collisionMatrixTick
         */


        World.prototype.collisionMatrixTick = function () {// this.shapeOverlapKeeper.tick();
          // this.shapeOverlapKeeperExit.tick();
        };
        /**
         * Add a rigid body to the simulation.
         * @method add
         * @param {Body} body
         * @todo If the simulation has not yet started, why recrete and copy arrays for each body? Accumulate in dynamic arrays in this case.
         * @todo Adding an array of bodies should be possible. This would save some loops too
         * @deprecated Use .addBody instead
         */


        World.prototype.add = World.prototype.addBody = function (body) {
          if (this.bodies.indexOf(body) !== -1) {
            return;
          }

          body.index = this.bodies.length;
          this.bodies.push(body);
          body.world = this;
          body.initPosition.copy(body.position);
          body.initVelocity.copy(body.velocity);
          body.timeLastSleepy = this.time;

          if (body instanceof Body) {
            body.initAngularVelocity.copy(body.angularVelocity);
            body.initQuaternion.copy(body.quaternion);
          }

          this.collisionMatrix.setNumObjects(this.bodies.length);
          this.addBodyEvent.body = body;
          World.idToBodyMap[body.id] = body;
          this.dispatchEvent(this.addBodyEvent);
        };
        /**
         * Add a constraint to the simulation.
         * @method addConstraint
         * @param {Constraint} c
         */


        World.prototype.addConstraint = function (c) {
          this.constraints.push(c);
        };
        /**
         * Removes a constraint
         * @method removeConstraint
         * @param {Constraint} c
         */


        World.prototype.removeConstraint = function (c) {
          var idx = this.constraints.indexOf(c);

          if (idx !== -1) {
            this.constraints.splice(idx, 1);
          }
        };
        /**
         * Raycast test
         * @method rayTest
         * @param {Vec3} from
         * @param {Vec3} to
         * @param {RaycastResult} result
         * @deprecated Use .raycastAll, .raycastClosest or .raycastAny instead.
         */


        World.prototype.rayTest = function (from, to, result) {
          if (result instanceof RaycastResult) {
            // Do raycastclosest
            this.raycastClosest(from, to, {
              skipBackfaces: true
            }, result);
          } else {
            // Do raycastAll
            this.raycastAll(from, to, {
              skipBackfaces: true
            }, result);
          }
        };
        /**
         * Ray cast against all bodies. The provided callback will be executed for each hit with a RaycastResult as single argument.
         * @method raycastAll
         * @param  {Vec3} from
         * @param  {Vec3} to
         * @param  {Object} options
         * @param  {number} [options.collisionFilterMask=-1]
         * @param  {number} [options.collisionFilterGroup=-1]
         * @param  {boolean} [options.skipBackfaces=false]
         * @param  {boolean} [options.checkCollisionResponse=true]
         * @param  {Function} callback
         * @return {boolean} True if any body was hit.
         */


        World.prototype.raycastAll = function (from, to, options, callback) {
          options.mode = Ray.ALL;
          options.from = from;
          options.to = to;
          options.callback = callback;
          return tmpRay.intersectWorld(this, options);
        };
        /**
         * Ray cast, and stop at the first result. Note that the order is random - but the method is fast.
         * @method raycastAny
         * @param  {Vec3} from
         * @param  {Vec3} to
         * @param  {Object} options
         * @param  {number} [options.collisionFilterMask=-1]
         * @param  {number} [options.collisionFilterGroup=-1]
         * @param  {boolean} [options.skipBackfaces=false]
         * @param  {boolean} [options.checkCollisionResponse=true]
         * @param  {RaycastResult} result
         * @return {boolean} True if any body was hit.
         */


        World.prototype.raycastAny = function (from, to, options, result) {
          options.mode = Ray.ANY;
          options.from = from;
          options.to = to;
          options.result = result;
          return tmpRay.intersectWorld(this, options);
        };
        /**
         * Ray cast, and return information of the closest hit.
         * @method raycastClosest
         * @param  {Vec3} from
         * @param  {Vec3} to
         * @param  {Object} options
         * @param  {number} [options.collisionFilterMask=-1]
         * @param  {number} [options.collisionFilterGroup=-1]
         * @param  {boolean} [options.skipBackfaces=false]
         * @param  {boolean} [options.checkCollisionResponse=true]
         * @param  {RaycastResult} result
         * @return {boolean} True if any body was hit.
         */


        World.prototype.raycastClosest = function (from, to, options, result) {
          options.mode = Ray.CLOSEST;
          options.from = from;
          options.to = to;
          options.result = result;
          return tmpRay.intersectWorld(this, options);
        };
        /**
         * Remove a rigid body from the simulation.
         * @method remove
         * @param {Body} body
         * @deprecated Use .removeBody instead
         */


        World.prototype.remove = function (body) {
          body.world = null;
          var n = this.bodies.length - 1,
              bodies = this.bodies,
              idx = bodies.indexOf(body);

          if (idx !== -1) {
            bodies.splice(idx, 1); // Todo: should use a garbage free method
            // Recompute index

            for (var i = 0; i !== bodies.length; i++) {
              bodies[i].index = i;
            }

            this.collisionMatrix.setNumObjects(n);
            this.removeBodyEvent.body = body;
            delete World.idToBodyMap[body.id];
            this.dispatchEvent(this.removeBodyEvent);
          }
        };
        /**
         * Remove a rigid body from the simulation.
         * @method removeBody
         * @param {Body} body
         */


        World.prototype.removeBody = World.prototype.remove;

        World.prototype.getBodyById = function (id) {
          return World.idToBodyMap[id];
        };

        World.prototype.getShapeById = function (id) {
          return World.idToShapeMap[id];
        };
        /**
         * Adds a material to the World.
         * @method addMaterial
         * @param {Material} m
         * @todo Necessary?
         */


        World.prototype.addMaterial = function (m) {
          this.materials.push(m);
        };
        /**
         * Adds a contact material to the World
         * @method addContactMaterial
         * @param {ContactMaterial} cmat
         */


        World.prototype.addContactMaterial = function (cmat) {
          // Add contact material
          this.contactmaterials.push(cmat); // Add current contact material to the material table

          this.contactMaterialTable.set(cmat.materials[0].id, cmat.materials[1].id, cmat);
        }; // performance.now()


        if (DEBUG) {
          if (typeof performance === 'undefined') {
            performance = {};
          }

          if (!performance.now) {
            var nowOffset = Date.now();

            if (performance.timing && performance.timing.navigationStart) {
              nowOffset = performance.timing.navigationStart;
            }

            performance.now = function () {
              return Date.now() - nowOffset;
            };
          }
        } // var step_tmp1 = new Vec3();

        /**
         * Step the physics world forward in time.
         *
         * There are two modes. The simple mode is fixed timestepping without interpolation. In this case you only use the first argument. The second case uses interpolation. In that you also provide the time since the function was last used, as well as the maximum fixed timesteps to take.
         *
         * @method step
         * @param {Number} dt                       The fixed time step size to use.
         * @param {Number} [timeSinceLastCalled]    The time elapsed since the function was last called.
         * @param {Number} [maxSubSteps=10]         Maximum number of fixed steps to take per function call.
         *
         * @example
         *     // fixed timestepping without interpolation
         *     world.step(1/60);
         *
         * @see http://bulletphysics.org/mediawiki-1.5.8/index.php/Stepping_The_World
         */


        World.prototype.step = function (dt, timeSinceLastCalled, maxSubSteps) {
          maxSubSteps = maxSubSteps || 10;
          timeSinceLastCalled = timeSinceLastCalled || 0;

          if (this.substeps != 0) {
            World_step_oldContacts = this.contacts.slice();
          }

          if (timeSinceLastCalled === 0) {
            // Fixed, simple stepping
            this.internalStep(dt); // Increment time

            this.time += dt;
            this.substeps = 1;
          } else {
            this.accumulator += timeSinceLastCalled;
            this.substeps = 0;

            while (this.accumulator >= dt && this.substeps < maxSubSteps) {
              // Do fixed steps to catch up
              this.internalStep(dt);
              this.accumulator -= dt;
              this.substeps++;
            }

            var t = this.accumulator % dt / dt;

            for (var j = 0; j !== this.bodies.length; j++) {
              var b = this.bodies[j];
              b.previousPosition.lerp(b.position, t, b.interpolatedPosition);
              b.previousQuaternion.slerp(b.quaternion, t, b.interpolatedQuaternion);
              b.previousQuaternion.normalize();
            }

            this.time += timeSinceLastCalled;
          }
        };
        /**
         * Dispatched after the world has stepped forward in time.
         * @event postStep
         */
        // World_step_postStepEvent = {type:"postStep"}, // Reusable event objects to save memory

        /**
         * Dispatched before the world steps forward in time.
         * @event preStep
         */
        // World_step_preStepEvent = {type:"preStep"},


        var World_step_collideEvent = {
          type: "collide",
          event: '',
          body: null,
          selfShape: null,
          otherShape: null,
          contacts: null
        },
            World_step_oldContacts = [],
            // Pools for unused objects
        World_step_frictionEquationPool = [],
            World_step_p1 = [],
            // Reusable arrays for collision pairs
        World_step_p2 = []; // World_step_gvec = new Vec3(), // Temporary vectors and quats
        // World_step_vi = new Vec3(),
        // World_step_vj = new Vec3(),
        // World_step_wi = new Vec3(),
        // World_step_wj = new Vec3(),
        // World_step_t1 = new Vec3(),
        // World_step_t2 = new Vec3(),
        // World_step_rixn = new Vec3(),
        // World_step_rjxn = new Vec3(),
        // World_step_step_q = new Quaternion(),
        // World_step_step_w = new Quaternion(),
        // World_step_step_wq = new Quaternion(),
        // invI_tau_dt = new Vec3()

        World.prototype.internalStep = function (dt) {
          this.dt = dt;
          var world = this,
              that = this,
              contacts = this.contacts,
              p1 = World_step_p1,
              p2 = World_step_p2,
              N = this.numObjects(),
              bodies = this.bodies,
              solver = this.solver,
              gravity = this.gravity,
              profile = this.profile,
              DYNAMIC = Body.DYNAMIC,
              profilingStart,
              constraints = this.constraints,
              frictionEquationPool = World_step_frictionEquationPool,
              // gnorm = gravity.norm(),
          gx = gravity.x,
              gy = gravity.y,
              gz = gravity.z,
              i = 0;

          if (doProfiling) {
            profilingStart = performance.now();
          } // Add gravity to all objects


          for (i = 0; i !== N; i++) {
            var bi = bodies[i];

            if (bi.useGravity && bi.type === DYNAMIC) {
              // Only for dynamic bodies
              var f = bi.force,
                  m = bi.mass;
              f.x += m * gx;
              f.y += m * gy;
              f.z += m * gz;
            }
          } // Update subsystems


          for (var i = 0, Nsubsystems = this.subsystems.length; i !== Nsubsystems; i++) {
            this.subsystems[i].update();
          } // Collision detection


          if (doProfiling) {
            profilingStart = performance.now();
          }

          p1.length = 0; // Clean up pair arrays from last step

          p2.length = 0;
          this.broadphase.collisionPairs(this, p1, p2);

          if (doProfiling) {
            profile.broadphase = performance.now() - profilingStart;
          } // Remove constrained pairs with collideConnected == false


          var Nconstraints = constraints.length;

          for (i = 0; i !== Nconstraints; i++) {
            var c = constraints[i];

            if (!c.collideConnected) {
              for (var j = p1.length - 1; j >= 0; j -= 1) {
                if (c.bodyA === p1[j] && c.bodyB === p2[j] || c.bodyB === p1[j] && c.bodyA === p2[j]) {
                  p1.splice(j, 1);
                  p2.splice(j, 1);
                }
              }
            }
          } // Generate contacts


          if (doProfiling) {
            profilingStart = performance.now();
          }

          contacts.length = 0; // Transfer FrictionEquation from current list to the pool for reuse

          var NoldFrictionEquations = this.frictionEquations.length;

          for (i = 0; i !== NoldFrictionEquations; i++) {
            frictionEquationPool.push(this.frictionEquations[i]);
          }

          this.frictionEquations.length = 0;
          this.narrowphase.getContacts(p1, p2, this, contacts, null, this.frictionEquations, frictionEquationPool);

          if (doProfiling) {
            profile.narrowphase = performance.now() - profilingStart;
          } // Loop over all collisions


          if (doProfiling) {
            profilingStart = performance.now();
          } // Add all friction eqs


          for (i = 0; i < this.frictionEquations.length; i++) {
            solver.addEquation(this.frictionEquations[i]);
          }

          var ncontacts = contacts.length;

          for (i = 0; i !== ncontacts; i++) {
            solver.addEquation(contacts[i]);
          }

          if (doProfiling) {
            profile.makeContactConstraints = performance.now() - profilingStart;
            profilingStart = performance.now();
          } // Add user-added constraints


          var Nconstraints = constraints.length;

          for (i = 0; i !== Nconstraints; i++) {
            var c = constraints[i];
            c.update();

            for (var j = 0, Neq = c.equations.length; j !== Neq; j++) {
              var eq = c.equations[j];
              solver.addEquation(eq);
            }
          } // Solve the constrained system


          solver.solve(dt, this);

          if (doProfiling) {
            profile.solve = performance.now() - profilingStart;
          } // Remove all contacts from solver


          solver.removeAllEquations(); // Apply damping, see http://code.google.com/p/bullet/issues/detail?id=74 for details

          var pow = Math.pow;
          N = this.numObjects();

          for (i = 0; i !== N; i++) {
            var bi = bodies[i];

            if (bi.type & DYNAMIC) {
              // Only for dynamic bodies
              var ld = pow(1.0 - bi.linearDamping, dt);
              var v = bi.velocity;
              v.mult(ld, v);
              var av = bi.angularVelocity;

              if (av) {
                var ad = pow(1.0 - bi.angularDamping, dt);
                av.mult(ad, av);
              }
            }
          } // this.dispatchEvent(World_step_preStepEvent);
          // // Invoke pre-step callbacks
          // for(i=0; i!==N; i++){
          //     var bi = bodies[i];
          //     if(bi.preStep){
          //         bi.preStep.call(bi);
          //     }
          // }
          // Leap frog
          // vnew = v + h*f/m
          // xnew = x + h*vnew


          if (doProfiling) {
            profilingStart = performance.now();
          }

          var stepnumber = this.stepnumber;
          var quatNormalize = stepnumber % (this.quatNormalizeSkip + 1) === 0;
          var quatNormalizeFast = this.quatNormalizeFast;

          for (i = 0; i !== N; i++) {
            bodies[i].integrate(dt, quatNormalize, quatNormalizeFast);
          }

          this.clearForces();
          this.broadphase.dirty = true;

          if (doProfiling) {
            profile.integrate = performance.now() - profilingStart;
          } // Update world time


          this.time += dt;
          this.stepnumber += 1; // this.dispatchEvent(World_step_postStepEvent);
          // // Invoke post-step callbacks
          // for(i=0; i!==N; i++){
          //     var bi = bodies[i];
          //     var postStep = bi.postStep;
          //     if(postStep){
          //         postStep.call(bi);
          //     }
          // }
          // Sleeping update

          if (this.allowSleep) {
            for (i = 0; i !== N; i++) {
              bodies[i].sleepTick(this.time);
            }
          }
        };

        var additions = [];
        var removals = [];
        var triggeredEvent = {
          type: 'triggered',
          event: '',
          selfBody: null,
          // need ?
          otherBody: null,
          // need ?
          selfShape: null,
          otherShape: null
        };

        World.prototype.emitTriggeredEvents = function () {
          if (this.substeps == 0) return;
          var id1;
          var id2;
          additions.length = removals.length = 0;
          this.shapeOverlapKeeperExit.getDiff(additions, removals);

          for (var i = 0, l = removals.length; i < l; i += 2) {
            triggeredEvent.event = 'trigger-exit';
            var shapeA = this.getShapeById(removals[i]);
            var shapeB = this.getShapeById(removals[i + 1]); // if(!shapeA.body.isSleeping || !shapeB.body.isSleeping){

            this.triggerMatrix.set(shapeA, shapeB, false);
            triggeredEvent.selfShape = shapeA;
            triggeredEvent.otherShape = shapeB;
            triggeredEvent.selfBody = shapeA.body;
            triggeredEvent.otherBody = shapeB.body;
            shapeA.dispatchEvent(triggeredEvent);
            triggeredEvent.selfShape = shapeB;
            triggeredEvent.otherShape = shapeA;
            triggeredEvent.selfBody = shapeB.body;
            triggeredEvent.otherBody = shapeA.body;
            shapeB.dispatchEvent(triggeredEvent); // }
          }

          additions.length = removals.length = 0;
          this.shapeOverlapKeeper.getDiff(additions, removals);

          for (var i = 0, l = additions.length; i < l; i += 2) {
            var id1 = additions[i];
            var id2 = additions[i + 1];
            var shapeA = this.getShapeById(id1);
            var shapeB = this.getShapeById(id2);
            if (!shapeA || !shapeB) continue;

            if (this.triggerMatrix.get(shapeA, shapeB)) {
              triggeredEvent.event = 'trigger-stay';
            } else {
              this.triggerMatrix.set(shapeA, shapeB, true);
              triggeredEvent.event = 'trigger-enter';
            }

            triggeredEvent.selfShape = shapeA;
            triggeredEvent.otherShape = shapeB;
            triggeredEvent.selfBody = shapeA.body;
            triggeredEvent.otherBody = shapeB.body;
            shapeA.dispatchEvent(triggeredEvent);
            triggeredEvent.selfShape = shapeB;
            triggeredEvent.otherShape = shapeA;
            triggeredEvent.selfBody = shapeB.body;
            triggeredEvent.otherBody = shapeA.body;
            shapeB.dispatchEvent(triggeredEvent);
          }

          this.shapeOverlapKeeper.reset();
          this.shapeOverlapKeeperExit.tick();
        };

        World.prototype.emitCollisionEvents = function () {
          if (this.substeps == 0) return;
          var contacts = this.contacts;
          var i = this.contacts.length;

          while (i--) {
            // Current contact
            var c = contacts[i]; // Get current collision indeces

            var si = c.si;
            var sj = c.sj;
            var item = this.contactsDic.get(si.id, sj.id);

            if (item == null) {
              item = this.contactsDic.set(si.id, sj.id, []);
            }

            item.push(c);
          }

          var key;
          var data; // is collision enter or stay

          var i = this.contactsDic.getLength();

          while (i--) {
            key = this.contactsDic.getKeyByIndex(i);
            data = this.contactsDic.getDataByKey(key);
            if (data == null) continue;
            var bi = data[0].bi;
            var bj = data[0].bj;
            var si = data[0].si;
            var sj = data[0].sj;

            if (bi.allowSleep && bi.type === Body.DYNAMIC && bi.sleepState === Body.SLEEPING && bj.sleepState === Body.AWAKE && bj.type !== Body.STATIC) {
              var speedSquaredB = bj.velocity.norm2() + bj.angularVelocity.norm2();
              var speedLimitSquaredB = Math.pow(bj.sleepSpeedLimit, 2);

              if (speedSquaredB >= speedLimitSquaredB * 2) {
                // bi._wakeUpAfterNarrowphase = true;
                bi.wakeUp();
              }
            }

            if (bj.allowSleep && bj.type === Body.DYNAMIC && bj.sleepState === Body.SLEEPING && bi.sleepState === Body.AWAKE && bi.type !== Body.STATIC) {
              var speedSquaredA = bi.velocity.norm2() + bi.angularVelocity.norm2();
              var speedLimitSquaredA = Math.pow(bi.sleepSpeedLimit, 2);

              if (speedSquaredA >= speedLimitSquaredA * 2) {
                // bj._wakeUpAfterNarrowphase = true;
                bj.wakeUp();
              }
            } // Now we know that i and j are in contact. Set collision matrix state		


            if (this.collisionMatrix.get(bi, bj)) {
              // collision stay
              World_step_collideEvent.event = 'collision-stay';
            } else {
              this.collisionMatrix.set(bi, bj, true); // collision enter

              World_step_collideEvent.event = 'collision-enter';
            }

            if (DEBUG) {
              World_step_collideEvent.bi = bi;
              World_step_collideEvent.contact = data[0];
            }

            World_step_collideEvent.contacts = data;
            World_step_collideEvent.body = sj.body;
            World_step_collideEvent.selfShape = si;
            World_step_collideEvent.otherShape = sj;
            si.body.dispatchEvent(World_step_collideEvent);
            World_step_collideEvent.body = si.body;
            World_step_collideEvent.selfShape = sj;
            World_step_collideEvent.otherShape = si;
            sj.body.dispatchEvent(World_step_collideEvent);
          }

          var oldcontacts = World_step_oldContacts;

          for (i = oldcontacts.length; i--;) {
            // Current contact
            var c = oldcontacts[i]; // Get current collision indeces

            var si = c.si;
            var sj = c.sj;

            if (this.oldContactsDic.get(si.id, sj.id) == null) {
              this.oldContactsDic.set(si.id, sj.id, c);
            }
          } // is collision exit


          i = this.oldContactsDic.getLength();

          while (i--) {
            key = this.oldContactsDic.getKeyByIndex(i);

            if (this.contactsDic.getDataByKey(key) == null) {
              data = this.oldContactsDic.getDataByKey(key);
              var bi = data.bi;
              var bj = data.bj;
              var si = data.si;
              var sj = data.sj;

              if (this.collisionMatrix.get(bi, bj)) {
                if (!bi.isSleeping() || !bj.isSleeping()) {
                  this.collisionMatrix.set(bi, bj, false);

                  if (DEBUG) {
                    World_step_collideEvent.bi = bi;
                    World_step_collideEvent.contact = data;
                  } // collision exit


                  World_step_collideEvent.event = 'collision-exit';
                  World_step_collideEvent.body = sj.body;
                  World_step_collideEvent.selfShape = si;
                  World_step_collideEvent.otherShape = sj;
                  World_step_collideEvent.contacts.length = 0;
                  World_step_collideEvent.contacts.push(data);
                  si.body.dispatchEvent(World_step_collideEvent);
                  World_step_collideEvent.body = si.body;
                  World_step_collideEvent.selfShape = sj;
                  World_step_collideEvent.otherShape = si;
                  sj.body.dispatchEvent(World_step_collideEvent);
                } else {// not exit, due to sleeping
                }
              }
            }
          }

          this.contactsDic.reset();
          this.oldContactsDic.reset();
        };
        /**
         * Sets all body forces in the world to zero.
         * @method clearForces
         */


        World.prototype.clearForces = function () {
          var bodies = this.bodies;
          var N = bodies.length;

          for (var i = 0; i !== N; i++) {
            var b = bodies[i];
            b.force.set(0, 0, 0);
            b.torque.set(0, 0, 0);
          }
        };
      }).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {
      "../collision/AABB": 3,
      "../collision/ArrayCollisionMatrix": 4,
      "../collision/NaiveBroadphase": 7,
      "../collision/ObjectCollisionMatrix": 8,
      "../collision/OverlapKeeper": 9,
      "../collision/Ray": 10,
      "../collision/RaycastResult": 11,
      "../equations/ContactEquation": 20,
      "../equations/FrictionEquation": 22,
      "../material/ContactMaterial": 25,
      "../material/Material": 26,
      "../math/Quaternion": 29,
      "../math/Vec3": 31,
      "../objects/Body": 32,
      "../shapes/Shape": 44,
      "../solver/GSSolver": 47,
      "../utils/EventTarget": 50,
      "../utils/TupleDictionary": 53,
      "./Narrowphase": 56
    }]
  }, {}, [2])(2);
});
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_engine__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImVuZ2luZS1kZXYvZXh0ZXJuYWwvY2Fubm9uL2Nhbm5vbi5qcyJdLCJuYW1lcyI6WyJlIiwiZXhwb3J0cyIsIm1vZHVsZSIsImRlZmluZSIsImFtZCIsImYiLCJ3aW5kb3ciLCJnbG9iYWwiLCJzZWxmIiwiQ0FOTk9OIiwidCIsIm4iLCJyIiwicyIsIm8iLCJ1IiwiYSIsInJlcXVpcmUiLCJpIiwiRXJyb3IiLCJjYWxsIiwibGVuZ3RoIiwiX2RlcmVxXyIsInZlcnNpb24iLCJBQUJCIiwiQXJyYXlDb2xsaXNpb25NYXRyaXgiLCJCb2R5IiwiQm94IiwiQnJvYWRwaGFzZSIsIkNvbnN0cmFpbnQiLCJDb250YWN0RXF1YXRpb24iLCJOYXJyb3dwaGFzZSIsIkNvbmVUd2lzdENvbnN0cmFpbnQiLCJDb250YWN0TWF0ZXJpYWwiLCJDb252ZXhQb2x5aGVkcm9uIiwiQ3lsaW5kZXIiLCJEaXN0YW5jZUNvbnN0cmFpbnQiLCJFcXVhdGlvbiIsIkV2ZW50VGFyZ2V0IiwiRnJpY3Rpb25FcXVhdGlvbiIsIkdTU29sdmVyIiwiR3JpZEJyb2FkcGhhc2UiLCJIZWlnaHRmaWVsZCIsIkhpbmdlQ29uc3RyYWludCIsIkxvY2tDb25zdHJhaW50IiwiTWF0MyIsIk1hdGVyaWFsIiwiTmFpdmVCcm9hZHBoYXNlIiwiT2JqZWN0Q29sbGlzaW9uTWF0cml4IiwiUG9vbCIsIlBhcnRpY2xlIiwiUGxhbmUiLCJQb2ludFRvUG9pbnRDb25zdHJhaW50IiwiUXVhdGVybmlvbiIsIlJheSIsIlJheWNhc3RWZWhpY2xlIiwiUmF5Y2FzdFJlc3VsdCIsIlJpZ2lkVmVoaWNsZSIsIlJvdGF0aW9uYWxFcXVhdGlvbiIsIlJvdGF0aW9uYWxNb3RvckVxdWF0aW9uIiwiU0FQQnJvYWRwaGFzZSIsIlNQSFN5c3RlbSIsIlNoYXBlIiwiU29sdmVyIiwiU3BoZXJlIiwiU3BsaXRTb2x2ZXIiLCJTcHJpbmciLCJUcmFuc2Zvcm0iLCJUcmltZXNoIiwiVmVjMyIsIlZlYzNQb29sIiwiV29ybGQiLCJVdGlscyIsIm9wdGlvbnMiLCJsb3dlckJvdW5kIiwiY29weSIsInVwcGVyQm91bmQiLCJ0bXAiLCJwcm90b3R5cGUiLCJzZXRGcm9tUG9pbnRzIiwicG9pbnRzIiwicG9zaXRpb24iLCJxdWF0ZXJuaW9uIiwic2tpblNpemUiLCJsIiwicSIsInZtdWx0IiwicCIsIngiLCJ5IiwieiIsInZhZGQiLCJhYWJiIiwiY2xvbmUiLCJleHRlbmQiLCJNYXRoIiwibWluIiwibWF4Iiwib3ZlcmxhcHMiLCJsMSIsInUxIiwibDIiLCJ1MiIsIm92ZXJsYXBzWCIsIm92ZXJsYXBzWSIsIm92ZXJsYXBzWiIsInZvbHVtZSIsImNvbnRhaW5zIiwiZ2V0Q29ybmVycyIsImIiLCJjIiwiZCIsImciLCJoIiwic2V0IiwidHJhbnNmb3JtSW50b0ZyYW1lX2Nvcm5lcnMiLCJ0b0xvY2FsRnJhbWUiLCJmcmFtZSIsInRhcmdldCIsImNvcm5lcnMiLCJjb3JuZXIiLCJwb2ludFRvTG9jYWwiLCJ0b1dvcmxkRnJhbWUiLCJwb2ludFRvV29ybGQiLCJvdmVybGFwc1JheSIsInJheSIsImRpckZyYWNYIiwiX2RpcmVjdGlvbiIsImRpckZyYWNZIiwiZGlyRnJhY1oiLCJ0MSIsImZyb20iLCJ0MiIsInQzIiwidDQiLCJ0NSIsInQ2IiwidG1pbiIsInRtYXgiLCJtYXRyaXgiLCJnZXQiLCJqIiwiaW5kZXgiLCJ0ZW1wIiwidmFsdWUiLCJyZXNldCIsInNldE51bU9iamVjdHMiLCJ3b3JsZCIsInVzZUJvdW5kaW5nQm94ZXMiLCJkaXJ0eSIsImNvbGxpc2lvblBhaXJzIiwicDEiLCJwMiIsIm5lZWRCcm9hZHBoYXNlQ29sbGlzaW9uIiwiYm9keUEiLCJib2R5QiIsImNvbGxpc2lvbkZpbHRlckdyb3VwIiwiY29sbGlzaW9uRmlsdGVyTWFzayIsImhhc1RyaWdnZXIiLCJ0eXBlIiwiU1RBVElDIiwic2xlZXBTdGF0ZSIsIlNMRUVQSU5HIiwiaW50ZXJzZWN0aW9uVGVzdCIsInBhaXJzMSIsInBhaXJzMiIsImRvQm91bmRpbmdCb3hCcm9hZHBoYXNlIiwiZG9Cb3VuZGluZ1NwaGVyZUJyb2FkcGhhc2UiLCJCcm9hZHBoYXNlX2NvbGxpc2lvblBhaXJzX3IiLCJCcm9hZHBoYXNlX2NvbGxpc2lvblBhaXJzX25vcm1hbCIsIkJyb2FkcGhhc2VfY29sbGlzaW9uUGFpcnNfcXVhdCIsIkJyb2FkcGhhc2VfY29sbGlzaW9uUGFpcnNfcmVscG9zIiwidnN1YiIsImJvdW5kaW5nUmFkaXVzU3VtMiIsInBvdyIsImJvdW5kaW5nUmFkaXVzIiwibm9ybTIiLCJwdXNoIiwiYWFiYk5lZWRzVXBkYXRlIiwiY29tcHV0ZUFBQkIiLCJCcm9hZHBoYXNlX21ha2VQYWlyc1VuaXF1ZV90ZW1wIiwia2V5cyIsIkJyb2FkcGhhc2VfbWFrZVBhaXJzVW5pcXVlX3AxIiwiQnJvYWRwaGFzZV9tYWtlUGFpcnNVbmlxdWVfcDIiLCJtYWtlUGFpcnNVbmlxdWUiLCJOIiwiaWQxIiwiaWQiLCJpZDIiLCJrZXkiLCJwb3AiLCJwYWlySW5kZXgiLCJzZXRXb3JsZCIsImJzY19kaXN0IiwiYm91bmRpbmdTcGhlcmVDaGVjayIsImRpc3QiLCJzaGFwZSIsImJvdW5kaW5nU3BoZXJlUmFkaXVzIiwiYWFiYlF1ZXJ5IiwicmVzdWx0IiwiY29uc29sZSIsIndhcm4iLCJhYWJiTWluIiwiYWFiYk1heCIsIm54IiwibnkiLCJueiIsImFwcGx5IiwibmJpbnMiLCJiaW5zIiwiYmluTGVuZ3RocyIsImNvbnN0cnVjdG9yIiwiR3JpZEJyb2FkcGhhc2VfY29sbGlzaW9uUGFpcnNfZCIsIkdyaWRCcm9hZHBoYXNlX2NvbGxpc2lvblBhaXJzX2JpblBvcyIsIm51bU9iamVjdHMiLCJib2RpZXMiLCJ4c3RlcCIsInlzdGVwIiwienN0ZXAiLCJ4bWF4IiwieW1heCIsInptYXgiLCJ4bWluIiwieW1pbiIsInptaW4iLCJ4bXVsdCIsInltdWx0Iiwiem11bHQiLCJiaW5zaXplWCIsImJpbnNpemVZIiwiYmluc2l6ZVoiLCJiaW5SYWRpdXMiLCJzcXJ0IiwidHlwZXMiLCJTUEhFUkUiLCJQTEFORSIsIkJPWCIsIkNPTVBPVU5EIiwiQ09OVkVYUE9MWUhFRFJPTiIsIk5iaW5zIiwiY2VpbCIsImFkZEJveFRvQmlucyIsIngwIiwieTAiLCJ6MCIsIngxIiwieTEiLCJ6MSIsImJpIiwieG9mZjAiLCJ5b2ZmMCIsInpvZmYwIiwieG9mZjEiLCJ5b2ZmMSIsInpvZmYxIiwieG9mZiIsInlvZmYiLCJ6b2ZmIiwiaWR4Iiwic2kiLCJyYWRpdXMiLCJ3b3JsZE5vcm1hbE5lZWRzVXBkYXRlIiwiY29tcHV0ZVdvcmxkTm9ybWFsIiwicGxhbmVOb3JtYWwiLCJ3b3JsZE5vcm1hbCIsInhyZXNldCIsInlyZXNldCIsInpyZXNldCIsInhpIiwieWkiLCJ6aSIsImRvdCIsImJpbkxlbmd0aCIsImJpbiIsImJqIiwidG1wQUFCQiIsIk92ZXJsYXBLZWVwZXIiLCJjdXJyZW50IiwicHJldmlvdXMiLCJnZXRLZXkiLCJ0aWNrIiwidW5wYWNrQW5kUHVzaCIsImFycmF5IiwiZ2V0RGlmZiIsImFkZGl0aW9ucyIsInJlbW92YWxzIiwiYWwiLCJibCIsImZvdW5kIiwia2V5QSIsImtleUIiLCJvdmVybGFwS2VlcGVyIiwic2xpY2UiLCJ0byIsInByZWNpc2lvbiIsImNoZWNrQ29sbGlzaW9uUmVzcG9uc2UiLCJza2lwQmFja2ZhY2VzIiwibW9kZSIsIkFOWSIsImhhc0hpdCIsImNhbGxiYWNrIiwiQ0xPU0VTVCIsIkFMTCIsInRtcEFycmF5IiwiaW50ZXJzZWN0V29ybGQiLCJfdXBkYXRlRGlyZWN0aW9uIiwiZ2V0QUFCQiIsImJyb2FkcGhhc2UiLCJpbnRlcnNlY3RCb2RpZXMiLCJ2MSIsInYyIiwicG9pbnRJblRyaWFuZ2xlIiwidjAiLCJkb3QwMCIsImRvdDAxIiwiZG90MDIiLCJkb3QxMSIsImRvdDEyIiwidiIsImludGVyc2VjdEJvZHlfeGkiLCJpbnRlcnNlY3RCb2R5X3FpIiwiaW50ZXJzZWN0Qm9keSIsImJvZHkiLCJjb2xsaXNpb25SZXNwb25zZSIsInFpIiwic2hhcGVzIiwibXVsdCIsInNoYXBlT3JpZW50YXRpb25zIiwic2hhcGVPZmZzZXRzIiwiaW50ZXJzZWN0U2hhcGUiLCJfc2hvdWxkU3RvcCIsIm5vcm1hbGl6ZSIsInF1YXQiLCJkaXN0YW5jZSIsImRpc3RhbmNlRnJvbUludGVyc2VjdGlvbiIsImludGVyc2VjdE1ldGhvZCIsInZlY3RvciIsIm5vcm1hbCIsImludGVyc2VjdFBvaW50IiwidG1wUmF5Y2FzdFJlc3VsdCIsImludGVyc2VjdEJveCIsInJlcG9ydGVkU2hhcGUiLCJpbnRlcnNlY3RDb252ZXgiLCJjb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24iLCJpbnRlcnNlY3RQbGFuZSIsImRpcmVjdGlvbiIsImxlbiIsInBsYW5lVG9Gcm9tIiwicGxhbmVUb1RvIiwiZGlzdGFuY2VUbyIsIm5fZG90X2RpciIsImFicyIsInBsYW5lUG9pbnRUb0Zyb20iLCJkaXJfc2NhbGVkX3dpdGhfdCIsImhpdFBvaW50V29ybGQiLCJzY2FsZSIsInJlcG9ydEludGVyc2VjdGlvbiIsImludGVyc2VjdENvbnZleE9wdGlvbnMiLCJmYWNlTGlzdCIsIndvcmxkUGlsbGFyT2Zmc2V0IiwiaW50ZXJzZWN0SGVpZ2h0ZmllbGRfbG9jYWxSYXkiLCJpbnRlcnNlY3RIZWlnaHRmaWVsZF9pbmRleCIsImludGVyc2VjdEhlaWdodGZpZWxkX21pbk1heCIsImludGVyc2VjdEhlaWdodGZpZWxkIiwiZGF0YSIsInciLCJlbGVtZW50U2l6ZSIsImxvY2FsUmF5IiwicG9pbnRUb0xvY2FsRnJhbWUiLCJpTWluWCIsImlNaW5ZIiwiaU1heFgiLCJpTWF4WSIsImdldEluZGV4T2ZQb3NpdGlvbiIsImdldEFhYmJBdEluZGV4IiwiZ2V0Q29udmV4VHJpYW5nbGVQaWxsYXIiLCJwb2ludFRvV29ybGRGcmFtZSIsInBpbGxhck9mZnNldCIsInBpbGxhckNvbnZleCIsIkhFSUdIVEZJRUxEIiwiUmF5X2ludGVyc2VjdFNwaGVyZV9pbnRlcnNlY3Rpb25Qb2ludCIsIlJheV9pbnRlcnNlY3RTcGhlcmVfbm9ybWFsIiwiaW50ZXJzZWN0U3BoZXJlIiwiZGVsdGEiLCJpbnRlcnNlY3Rpb25Qb2ludCIsImxlcnAiLCJkMSIsImQyIiwiaW50ZXJzZWN0Q29udmV4X25vcm1hbCIsImludGVyc2VjdENvbnZleF9taW5EaXN0Tm9ybWFsIiwiaW50ZXJzZWN0Q29udmV4X21pbkRpc3RJbnRlcnNlY3QiLCJpbnRlcnNlY3RDb252ZXhfdmVjdG9yIiwibWluRGlzdE5vcm1hbCIsIm1pbkRpc3RJbnRlcnNlY3QiLCJmYWNlcyIsInZlcnRpY2VzIiwibm9ybWFscyIsImZhY2VOb3JtYWxzIiwiZnJvbVRvRGlzdGFuY2UiLCJtaW5EaXN0IiwiTmZhY2VzIiwiZmkiLCJmYWNlIiwiZmFjZU5vcm1hbCIsInNjYWxhciIsImludGVyc2VjdFRyaW1lc2hfbm9ybWFsIiwiaW50ZXJzZWN0VHJpbWVzaF9sb2NhbERpcmVjdGlvbiIsImludGVyc2VjdFRyaW1lc2hfbG9jYWxGcm9tIiwiaW50ZXJzZWN0VHJpbWVzaF9sb2NhbFRvIiwiaW50ZXJzZWN0VHJpbWVzaF93b3JsZE5vcm1hbCIsImludGVyc2VjdFRyaW1lc2hfd29ybGRJbnRlcnNlY3RQb2ludCIsImludGVyc2VjdFRyaW1lc2hfbG9jYWxBQUJCIiwiaW50ZXJzZWN0VHJpbWVzaF90cmlhbmdsZXMiLCJpbnRlcnNlY3RUcmltZXNoX3RyZWVUcmFuc2Zvcm0iLCJpbnRlcnNlY3RUcmltZXNoIiwibWVzaCIsInRyaWFuZ2xlcyIsInRyZWVUcmFuc2Zvcm0iLCJsb2NhbEFBQkIiLCJsb2NhbERpcmVjdGlvbiIsImxvY2FsRnJvbSIsImxvY2FsVG8iLCJ3b3JsZEludGVyc2VjdFBvaW50IiwiaW5kaWNlcyIsInZlY3RvclRvTG9jYWxGcmFtZSIsImZyb21Ub0Rpc3RhbmNlU3F1YXJlZCIsImRpc3RhbmNlU3F1YXJlZCIsInRyZWUiLCJyYXlRdWVyeSIsInRyaWFuZ2xlc0luZGV4IiwiZ2V0Tm9ybWFsIiwiZ2V0VmVydGV4Iiwic3F1YXJlZERpc3RhbmNlIiwidmVjdG9yVG9Xb3JsZEZyYW1lIiwiVFJJTUVTSCIsImhpdEZhY2VJbmRleCIsImludGVyc2VjdCIsInJheUZyb21Xb3JsZCIsInJheVRvV29ybGQiLCJoaXROb3JtYWxXb3JsZCIsInNldFplcm8iLCJhYm9ydCIsImF4aXNMaXN0IiwiYXhpc0luZGV4IiwiX2FkZEJvZHlIYW5kbGVyIiwiX3JlbW92ZUJvZHlIYW5kbGVyIiwiaW5kZXhPZiIsInNwbGljZSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJhZGRFdmVudExpc3RlbmVyIiwiaW5zZXJ0aW9uU29ydFgiLCJpbnNlcnRpb25Tb3J0WSIsImluc2VydGlvblNvcnRaIiwic29ydExpc3QiLCJjaGVja0JvdW5kcyIsImJpUG9zIiwiYmpQb3MiLCJyaSIsInJqIiwiYm91bmRBMSIsImJvdW5kQTIiLCJib3VuZEIxIiwiYm91bmRCMiIsImF1dG9EZXRlY3RBeGlzIiwic3VtWCIsInN1bVgyIiwic3VtWSIsInN1bVkyIiwic3VtWiIsInN1bVoyIiwiaW52TiIsImNlbnRlclgiLCJjZW50ZXJZIiwiY2VudGVyWiIsInZhcmlhbmNlWCIsInZhcmlhbmNlWSIsInZhcmlhbmNlWiIsImF4aXMiLCJsb3dlciIsInVwcGVyIiwiQ29uZUVxdWF0aW9uIiwibWF4Rm9yY2UiLCJwaXZvdEEiLCJwaXZvdEIiLCJheGlzQSIsImF4aXNCIiwiY29sbGlkZUNvbm5lY3RlZCIsImFuZ2xlIiwiY29uZUVxdWF0aW9uIiwidHdpc3RFcXVhdGlvbiIsInR3aXN0QW5nbGUiLCJtaW5Gb3JjZSIsImVxdWF0aW9ucyIsIkNvbmVUd2lzdENvbnN0cmFpbnRfdXBkYXRlX3RtcFZlYzEiLCJDb25lVHdpc3RDb25zdHJhaW50X3VwZGF0ZV90bXBWZWMyIiwidXBkYXRlIiwiY29uZSIsInR3aXN0IiwidGFuZ2VudHMiLCJtYXhBbmdsZSIsImRlZmF1bHRzIiwid2FrZVVwQm9kaWVzIiwiaWRDb3VudGVyIiwid2FrZVVwIiwiZW5hYmxlIiwiZXFzIiwiZW5hYmxlZCIsImRpc2FibGUiLCJlcSIsImRpc3RhbmNlRXF1YXRpb24iLCJoYWxmRGlzdCIsIm5pIiwicjEiLCJyb3RhdGlvbmFsRXF1YXRpb24xIiwicjIiLCJyb3RhdGlvbmFsRXF1YXRpb24yIiwibW90b3IiLCJtb3RvckVxdWF0aW9uIiwiZW5hYmxlTW90b3IiLCJkaXNhYmxlTW90b3IiLCJzZXRNb3RvclNwZWVkIiwic3BlZWQiLCJ0YXJnZXRWZWxvY2l0eSIsInNldE1vdG9yTWF4Rm9yY2UiLCJIaW5nZUNvbnN0cmFpbnRfdXBkYXRlX3RtcFZlYzEiLCJIaW5nZUNvbnN0cmFpbnRfdXBkYXRlX3RtcFZlYzIiLCJ3b3JsZEF4aXNBIiwid29ybGRBeGlzQiIsImhhbGZXYXkiLCJ4QSIsIlVOSVRfWCIsInhCIiwieUEiLCJVTklUX1kiLCJ5QiIsInpBIiwiVU5JVF9aIiwiekIiLCJyMyIsInJvdGF0aW9uYWxFcXVhdGlvbjMiLCJMb2NrQ29uc3RyYWludF91cGRhdGVfdG1wVmVjMSIsIkxvY2tDb25zdHJhaW50X3VwZGF0ZV90bXBWZWMyIiwiZXF1YXRpb25YIiwiZXF1YXRpb25ZIiwiZXF1YXRpb25aIiwidG1wVmVjMSIsInRtcFZlYzIiLCJjb21wdXRlQiIsIm5qIiwibml4bmoiLCJuanhuaSIsIkdBIiwiamFjb2JpYW5FbGVtZW50QSIsIkdCIiwiamFjb2JpYW5FbGVtZW50QiIsImNyb3NzIiwicm90YXRpb25hbCIsImNvcyIsIkdXIiwiY29tcHV0ZUdXIiwiR2lNZiIsImNvbXB1dGVHaU1mIiwiQiIsInNqIiwicmVzdGl0dXRpb24iLCJDb250YWN0RXF1YXRpb25fY29tcHV0ZUJfdGVtcDEiLCJDb250YWN0RXF1YXRpb25fY29tcHV0ZUJfdGVtcDIiLCJDb250YWN0RXF1YXRpb25fY29tcHV0ZUJfdGVtcDMiLCJyaXhuIiwicmp4biIsInZpIiwidmVsb2NpdHkiLCJ3aSIsImFuZ3VsYXJWZWxvY2l0eSIsImZvcmNlIiwidGF1aSIsInRvcnF1ZSIsInZqIiwid2oiLCJmaiIsInRhdWoiLCJwZW5ldHJhdGlvblZlYyIsIm5lZ2F0ZSIsInNwYXRpYWwiLCJlUGx1c09uZSIsIkNvbnRhY3RFcXVhdGlvbl9nZXRJbXBhY3RWZWxvY2l0eUFsb25nTm9ybWFsX3ZpIiwiQ29udGFjdEVxdWF0aW9uX2dldEltcGFjdFZlbG9jaXR5QWxvbmdOb3JtYWxfdmoiLCJDb250YWN0RXF1YXRpb25fZ2V0SW1wYWN0VmVsb2NpdHlBbG9uZ05vcm1hbF94aSIsIkNvbnRhY3RFcXVhdGlvbl9nZXRJbXBhY3RWZWxvY2l0eUFsb25nTm9ybWFsX3hqIiwiQ29udGFjdEVxdWF0aW9uX2dldEltcGFjdFZlbG9jaXR5QWxvbmdOb3JtYWxfcmVsVmVsIiwiZ2V0SW1wYWN0VmVsb2NpdHlBbG9uZ05vcm1hbCIsInhqIiwicmVsVmVsIiwiZ2V0VmVsb2NpdHlBdFdvcmxkUG9pbnQiLCJKYWNvYmlhbkVsZW1lbnQiLCJlcHMiLCJtdWx0aXBsaWVyIiwic2V0U3Bvb2tQYXJhbXMiLCJzdGlmZm5lc3MiLCJyZWxheGF0aW9uIiwidGltZVN0ZXAiLCJrIiwiR3EiLCJjb21wdXRlR3EiLCJ6ZXJvIiwibXVsdGlwbHlWZWN0b3JzIiwiY29tcHV0ZUdXbGFtYmRhIiwidmxhbWJkYSIsIndsYW1iZGEiLCJpTWZpIiwiaU1maiIsImludklpX3ZtdWx0X3RhdWkiLCJpbnZJal92bXVsdF90YXVqIiwidGkiLCJ0aiIsImludk1hc3NpIiwiaW52TWFzc1NvbHZlIiwiaW52TWFzc2oiLCJpbnZJbmVydGlhV29ybGRTb2x2ZSIsImNvbXB1dGVHaU1HdCIsImludklpIiwiaW52SWoiLCJhZGRUb1dsYW1iZGFfdGVtcCIsImFkZFRvV2xhbWJkYV9HaSIsImFkZFRvV2xhbWJkYV9HaiIsImFkZFRvV2xhbWJkYV9yaSIsImFkZFRvV2xhbWJkYV9yaiIsImFkZFRvV2xhbWJkYV9NZGlhZyIsImFkZFRvV2xhbWJkYSIsImRlbHRhbGFtYmRhIiwiYWRkU2NhbGVkVmVjdG9yIiwiY29tcHV0ZUMiLCJzbGlwRm9yY2UiLCJGcmljdGlvbkVxdWF0aW9uX2NvbXB1dGVCX3RlbXAxIiwiRnJpY3Rpb25FcXVhdGlvbl9jb21wdXRlQl90ZW1wMiIsInJpeHQiLCJyanh0IiwiUEkiLCJtMSIsIm0yIiwiZnJpY3Rpb24iLCJjb250YWN0RXF1YXRpb25TdGlmZm5lc3MiLCJjb250YWN0RXF1YXRpb25SZWxheGF0aW9uIiwiZnJpY3Rpb25FcXVhdGlvblN0aWZmbmVzcyIsImZyaWN0aW9uRXF1YXRpb25SZWxheGF0aW9uIiwibWF0ZXJpYWxzIiwibmFtZSIsIm11bHRpcGx5RWxlbWVudCIsImVsZW1lbnQiLCJlbGVtZW50cyIsImlkZW50aXR5Iiwic2V0VHJhY2UiLCJ2ZWMzIiwiZ2V0VHJhY2UiLCJzbXVsdCIsIm1tdWx0IiwibSIsInN1bSIsInNvbHZlIiwibnIiLCJuYyIsImVxbnMiLCJucCIsImtwIiwiZWxzIiwiaXNOYU4iLCJJbmZpbml0eSIsInRvU3RyaW5nIiwicm93IiwiY29sdW1uIiwidW5kZWZpbmVkIiwic291cmNlIiwic2VwIiwicmV2ZXJzZSIsInNldFJvdGF0aW9uRnJvbVF1YXRlcm5pb24iLCJ4MiIsInkyIiwiejIiLCJ4eCIsInh5IiwieHoiLCJ5eSIsInl6IiwienoiLCJ3eCIsInd5Iiwid3oiLCJ0cmFuc3Bvc2UiLCJNdCIsIk0iLCJ0b0FycmF5Iiwic2V0RnJvbUF4aXNBbmdsZSIsInNpbiIsInRvQXhpc0FuZ2xlIiwidGFyZ2V0QXhpcyIsImFjb3MiLCJzZnZfdDEiLCJzZnZfdDIiLCJzZXRGcm9tVmVjdG9ycyIsImlzQW50aXBhcmFsbGVsVG8iLCJub3JtIiwiUXVhdGVybmlvbl9tdWx0X3ZhIiwiUXVhdGVybmlvbl9tdWx0X3ZiIiwiUXVhdGVybmlvbl9tdWx0X3ZheHZiIiwiYXgiLCJheSIsImF6IiwiYXciLCJieCIsImJ5IiwiYnoiLCJidyIsImludmVyc2UiLCJjb25qdWdhdGUiLCJpbm9ybTIiLCJub3JtYWxpemVGYXN0IiwicXgiLCJxeSIsInF6IiwicXciLCJpeCIsIml5IiwiaXoiLCJpdyIsInRvRXVsZXIiLCJvcmRlciIsImhlYWRpbmciLCJhdHRpdHVkZSIsImJhbmsiLCJ0ZXN0IiwiYXRhbjIiLCJzcXgiLCJzcXkiLCJzcXoiLCJhc2luIiwic2V0RnJvbUV1bGVyIiwiYzEiLCJjMiIsImMzIiwiczEiLCJzMiIsInMzIiwic2xlcnAiLCJ0b1F1YXQiLCJvbWVnYSIsImNvc29tIiwic2lub20iLCJzY2FsZTAiLCJzY2FsZTEiLCJpbnRlZ3JhdGUiLCJkdCIsImFuZ3VsYXJGYWN0b3IiLCJoYWxmX2R0IiwidG1wUXVhdCIsIndvcmxkUG9pbnQiLCJsb2NhbFBvaW50IiwibG9jYWxWZWN0b3IiLCJ3b3JsZFZlY3RvciIsIlpFUk8iLCJ2eCIsInZ5IiwidnoiLCJjcm9zc21hdCIsInVuaXQiLCJuaW52IiwibGVuZ3RoU3F1YXJlZCIsInB4IiwicHkiLCJweiIsInZtdWwiLCJpc1plcm8iLCJWZWMzX3RhbmdlbnRzX24iLCJWZWMzX3RhbmdlbnRzX3JhbmRWZWMiLCJpbm9ybSIsInJhbmRWZWMiLCJhbG1vc3RFcXVhbHMiLCJhbG1vc3RaZXJvIiwiYW50aXBfbmVnIiwicHJlU3RlcCIsInBvc3RTdGVwIiwicHJldmlvdXNQb3NpdGlvbiIsImludGVycG9sYXRlZFBvc2l0aW9uIiwiaW5pdFBvc2l0aW9uIiwiaW5pdFZlbG9jaXR5IiwibWFzcyIsImludk1hc3MiLCJtYXRlcmlhbCIsImxpbmVhckRhbXBpbmciLCJEWU5BTUlDIiwiYWxsb3dTbGVlcCIsInNsZWVwU3BlZWRMaW1pdCIsInNsZWVwVGltZUxpbWl0IiwidGltZUxhc3RTbGVlcHkiLCJfd2FrZVVwQWZ0ZXJOYXJyb3dwaGFzZSIsImluaXRRdWF0ZXJuaW9uIiwicHJldmlvdXNRdWF0ZXJuaW9uIiwiaW50ZXJwb2xhdGVkUXVhdGVybmlvbiIsImluaXRBbmd1bGFyVmVsb2NpdHkiLCJpbmVydGlhIiwiaW52SW5lcnRpYSIsImludkluZXJ0aWFXb3JsZCIsImludkluZXJ0aWFTb2x2ZSIsImZpeGVkUm90YXRpb24iLCJ1c2VHcmF2aXR5IiwiYW5ndWxhckRhbXBpbmciLCJsaW5lYXJGYWN0b3IiLCJhZGRTaGFwZSIsInVwZGF0ZU1hc3NQcm9wZXJ0aWVzIiwiQ09MTElERV9FVkVOVF9OQU1FIiwiS0lORU1BVElDIiwiQVdBS0UiLCJTTEVFUFkiLCJ3YWtldXBFdmVudCIsImRpc3BhdGNoRXZlbnQiLCJzbGVlcCIsInNsZWVweUV2ZW50Iiwic2xlZXBFdmVudCIsInNsZWVwVGljayIsInRpbWUiLCJzcGVlZFNxdWFyZWQiLCJzcGVlZExpbWl0U3F1YXJlZCIsInVwZGF0ZVNvbHZlTWFzc1Byb3BlcnRpZXMiLCJ0bXBWZWMiLCJfb2Zmc2V0IiwiX29yaWVudGF0aW9uIiwib2Zmc2V0Iiwib3JpZW50YXRpb24iLCJERUJVRyIsImlkVG9TaGFwZU1hcCIsInVwZGF0ZUJvdW5kaW5nUmFkaXVzIiwidXBkYXRlSGFzVHJpZ2dlciIsInJlbW92ZVNoYXBlIiwidXBkYXRlQm91bmRpbmdTcGhlcmVSYWRpdXMiLCJjb21wdXRlQUFCQl9zaGFwZUFBQkIiLCJib2R5UXVhdCIsInNoYXBlQUFCQiIsImNhbGN1bGF0ZVdvcmxkQUFCQiIsInVpd19tMSIsInVpd19tMiIsInVpd19tMyIsInVwZGF0ZUluZXJ0aWFXb3JsZCIsIkkiLCJtMyIsIkJvZHlfYXBwbHlGb3JjZV9yb3RGb3JjZSIsImFwcGx5Rm9yY2UiLCJyZWxhdGl2ZVBvaW50Iiwicm90Rm9yY2UiLCJCb2R5X2FwcGx5TG9jYWxGb3JjZV93b3JsZEZvcmNlIiwiQm9keV9hcHBseUxvY2FsRm9yY2VfcmVsYXRpdmVQb2ludFdvcmxkIiwiYXBwbHlMb2NhbEZvcmNlIiwibG9jYWxGb3JjZSIsIndvcmxkRm9yY2UiLCJyZWxhdGl2ZVBvaW50V29ybGQiLCJCb2R5X2FwcGx5SW1wdWxzZV92ZWxvIiwiQm9keV9hcHBseUltcHVsc2Vfcm90VmVsbyIsImFwcGx5SW1wdWxzZSIsImltcHVsc2UiLCJ2ZWxvIiwicm90VmVsbyIsIkJvZHlfYXBwbHlMb2NhbEltcHVsc2Vfd29ybGRJbXB1bHNlIiwiQm9keV9hcHBseUxvY2FsSW1wdWxzZV9yZWxhdGl2ZVBvaW50IiwiYXBwbHlMb2NhbEltcHVsc2UiLCJsb2NhbEltcHVsc2UiLCJ3b3JsZEltcHVsc2UiLCJCb2R5X3VwZGF0ZU1hc3NQcm9wZXJ0aWVzX2hhbGZFeHRlbnRzIiwiaGFsZkV4dGVudHMiLCJmaXhlZCIsImNhbGN1bGF0ZUluZXJ0aWEiLCJxdWF0Tm9ybWFsaXplIiwicXVhdE5vcm1hbGl6ZUZhc3QiLCJhbmd1bGFyVmVsbyIsInBvcyIsImlNZHQiLCJ0eCIsInR5IiwidHoiLCJpc1NsZWVwaW5nIiwiaXNTbGVlcHkiLCJpc0F3YWtlIiwiV2hlZWxJbmZvIiwiY2hhc3Npc0JvZHkiLCJ3aGVlbEluZm9zIiwic2xpZGluZyIsImluZGV4UmlnaHRBeGlzIiwiaW5kZXhGb3J3YXJkQXhpcyIsImluZGV4VXBBeGlzIiwidG1wVmVjMyIsInRtcFZlYzQiLCJ0bXBWZWM1IiwidG1wVmVjNiIsInRtcFJheSIsImFkZFdoZWVsIiwiaW5mbyIsInNldFN0ZWVyaW5nVmFsdWUiLCJ3aGVlbEluZGV4Iiwid2hlZWwiLCJzdGVlcmluZyIsImFwcGx5RW5naW5lRm9yY2UiLCJlbmdpbmVGb3JjZSIsInNldEJyYWtlIiwiYnJha2UiLCJhZGRUb1dvcmxkIiwiY29uc3RyYWludHMiLCJhZGRCb2R5IiwidGhhdCIsInByZVN0ZXBDYWxsYmFjayIsInVwZGF0ZVZlaGljbGUiLCJnZXRWZWhpY2xlQXhpc1dvcmxkIiwibnVtV2hlZWxzIiwidXBkYXRlV2hlZWxUcmFuc2Zvcm0iLCJjdXJyZW50VmVoaWNsZVNwZWVkS21Ib3VyIiwiZm9yd2FyZFdvcmxkIiwiY2FzdFJheSIsInVwZGF0ZVN1c3BlbnNpb24iLCJyZWxwb3MiLCJzdXNwZW5zaW9uRm9yY2UiLCJtYXhTdXNwZW5zaW9uRm9yY2UiLCJyYXljYXN0UmVzdWx0IiwidXBkYXRlRnJpY3Rpb24iLCJoaXROb3JtYWxXb3JsZFNjYWxlZFdpdGhQcm9qIiwiZndkIiwidmVsIiwiY2hhc3Npc0Nvbm5lY3Rpb25Qb2ludFdvcmxkIiwiaXNJbkNvbnRhY3QiLCJwcm9qIiwicHJvajIiLCJkZWx0YVJvdGF0aW9uIiwidXNlQ3VzdG9tU2xpZGluZ1JvdGF0aW9uYWxTcGVlZCIsImN1c3RvbVNsaWRpbmdSb3RhdGlvbmFsU3BlZWQiLCJyb3RhdGlvbiIsImRlbHRhVGltZSIsImNoYXNzaXNNYXNzIiwid19pdCIsInN1c3BfbGVuZ3RoIiwic3VzcGVuc2lvblJlc3RMZW5ndGgiLCJjdXJyZW50X2xlbmd0aCIsInN1c3BlbnNpb25MZW5ndGgiLCJsZW5ndGhfZGlmZiIsInN1c3BlbnNpb25TdGlmZm5lc3MiLCJjbGlwcGVkSW52Q29udGFjdERvdFN1c3BlbnNpb24iLCJwcm9qZWN0ZWRfcmVsX3ZlbCIsInN1c3BlbnNpb25SZWxhdGl2ZVZlbG9jaXR5Iiwic3VzcF9kYW1waW5nIiwiZGFtcGluZ0NvbXByZXNzaW9uIiwiZGFtcGluZ1JlbGF4YXRpb24iLCJyZW1vdmVGcm9tV29ybGQiLCJyZW1vdmUiLCJjYXN0UmF5X3JheXZlY3RvciIsImNhc3RSYXlfdGFyZ2V0IiwicmF5dmVjdG9yIiwidXBkYXRlV2hlZWxUcmFuc2Zvcm1Xb3JsZCIsImRlcHRoIiwicmF5bGVuIiwiZGlyZWN0aW9uV29ybGQiLCJwYXJhbSIsIm9sZFN0YXRlIiwicmF5VGVzdCIsIm9iamVjdCIsImdyb3VuZE9iamVjdCIsImhpdERpc3RhbmNlIiwibWluU3VzcGVuc2lvbkxlbmd0aCIsIm1heFN1c3BlbnNpb25UcmF2ZWwiLCJtYXhTdXNwZW5zaW9uTGVuZ3RoIiwiZGVub21pbmF0b3IiLCJjaGFzc2lzX3ZlbG9jaXR5X2F0X2NvbnRhY3RQb2ludCIsInByb2pWZWwiLCJpbnYiLCJjaGFzc2lzQ29ubmVjdGlvblBvaW50TG9jYWwiLCJkaXJlY3Rpb25Mb2NhbCIsImF4bGVMb2NhbCIsImF4bGVXb3JsZCIsInVwIiwicmlnaHQiLCJzdGVlcmluZ09ybiIsInJvdGF0aW5nT3JuIiwid29ybGRUcmFuc2Zvcm0iLCJkaXJlY3Rpb25zIiwiZ2V0V2hlZWxUcmFuc2Zvcm1Xb3JsZCIsInVwZGF0ZUZyaWN0aW9uX3N1cmZOb3JtYWxXU19zY2FsZWRfcHJvaiIsInVwZGF0ZUZyaWN0aW9uX2F4bGUiLCJ1cGRhdGVGcmljdGlvbl9mb3J3YXJkV1MiLCJzaWRlRnJpY3Rpb25TdGlmZm5lc3MyIiwic3VyZk5vcm1hbFdTX3NjYWxlZF9wcm9qIiwiZm9yd2FyZFdTIiwiYXhsZSIsIm51bVdoZWVsc09uR3JvdW5kIiwic2lkZUltcHVsc2UiLCJmb3J3YXJkSW1wdWxzZSIsImF4bGVpIiwid2hlZWxUcmFucyIsInN1cmZOb3JtYWxXUyIsInJlc29sdmVTaW5nbGVCaWxhdGVyYWwiLCJzaWRlRmFjdG9yIiwiZndkRmFjdG9yIiwicm9sbGluZ0ZyaWN0aW9uIiwic2xpcEluZm8iLCJkZWZhdWx0Um9sbGluZ0ZyaWN0aW9uSW1wdWxzZSIsIm1heEltcHVsc2UiLCJjYWxjUm9sbGluZ0ZyaWN0aW9uIiwiZmFjdG9yIiwic2tpZEluZm8iLCJtYXhpbXAiLCJmcmljdGlvblNsaXAiLCJtYXhpbXBTaWRlIiwibWF4aW1wU3F1YXJlZCIsImltcHVsc2VTcXVhcmVkIiwicmVsX3BvcyIsInJlbF9wb3MyIiwic2lkZUltcCIsInJvbGxJbmZsdWVuY2UiLCJjYWxjUm9sbGluZ0ZyaWN0aW9uX3ZlbDEiLCJjYWxjUm9sbGluZ0ZyaWN0aW9uX3ZlbDIiLCJjYWxjUm9sbGluZ0ZyaWN0aW9uX3ZlbCIsImJvZHkwIiwiYm9keTEiLCJmcmljdGlvblBvc1dvcmxkIiwiZnJpY3Rpb25EaXJlY3Rpb25Xb3JsZCIsImoxIiwiY29udGFjdFBvc1dvcmxkIiwidmVsMSIsInZlbDIiLCJ2cmVsIiwiZGVub20wIiwiY29tcHV0ZUltcHVsc2VEZW5vbWluYXRvciIsImRlbm9tMSIsImphY0RpYWdBQkludiIsImNvbXB1dGVJbXB1bHNlRGVub21pbmF0b3JfcjAiLCJjb21wdXRlSW1wdWxzZURlbm9taW5hdG9yX2MwIiwiY29tcHV0ZUltcHVsc2VEZW5vbWluYXRvcl92ZWMiLCJjb21wdXRlSW1wdWxzZURlbm9taW5hdG9yX20iLCJyMCIsImMwIiwidmVjIiwicmVzb2x2ZVNpbmdsZUJpbGF0ZXJhbF92ZWwxIiwicmVzb2x2ZVNpbmdsZUJpbGF0ZXJhbF92ZWwyIiwicmVzb2x2ZVNpbmdsZUJpbGF0ZXJhbF92ZWwiLCJwb3MxIiwiYm9keTIiLCJwb3MyIiwibm9ybWFsTGVuU3FyIiwicmVsX3ZlbCIsImNvbnRhY3REYW1waW5nIiwibWFzc1Rlcm0iLCJ3aGVlbEJvZGllcyIsImNvb3JkaW5hdGVTeXN0ZW0iLCJjaGFzc2lzU2hhcGUiLCJ3aGVlbEF4ZXMiLCJ3aGVlbEZvcmNlcyIsIndoZWVsQm9keSIsIndvcmxkUG9zaXRpb24iLCJoaW5nZUNvbnN0cmFpbnQiLCJtb3RvclRhcmdldFZlbG9jaXR5Iiwic2V0V2hlZWxGb3JjZSIsImFwcGx5V2hlZWxGb3JjZSIsImJvZHlUb3JxdWUiLCJjb25jYXQiLCJhZGRDb25zdHJhaW50IiwiX3VwZGF0ZSIsImJpbmQiLCJyZW1vdmVDb25zdHJhaW50Iiwid29ybGRBeGlzIiwiZ2V0V2hlZWxTcGVlZCIsInBhcnRpY2xlcyIsImRlbnNpdHkiLCJzbW9vdGhpbmdSYWRpdXMiLCJzcGVlZE9mU291bmQiLCJ2aXNjb3NpdHkiLCJwcmVzc3VyZXMiLCJkZW5zaXRpZXMiLCJuZWlnaGJvcnMiLCJhZGQiLCJwYXJ0aWNsZSIsIlNQSFN5c3RlbV9nZXROZWlnaGJvcnNfZGlzdCIsImdldE5laWdoYm9ycyIsIlIyIiwiU1BIU3lzdGVtX3VwZGF0ZV9kaXN0IiwiU1BIU3lzdGVtX3VwZGF0ZV9hX3ByZXNzdXJlIiwiU1BIU3lzdGVtX3VwZGF0ZV9hX3Zpc2MiLCJTUEhTeXN0ZW1fdXBkYXRlX2dyYWRXIiwiU1BIU3lzdGVtX3VwZGF0ZV9yX3ZlYyIsIlNQSFN5c3RlbV91cGRhdGVfdSIsImNzIiwibnVtTmVpZ2hib3JzIiwid2VpZ2h0IiwiYV9wcmVzc3VyZSIsImFfdmlzYyIsImdyYWRXIiwicl92ZWMiLCJQaWoiLCJuYWJsYSIsIlZpaiIsIm5laWdoYm9yIiwiZ3JhZHciLCJuYWJsYXciLCJyVmVjIiwicmVzdWx0VmVjIiwicmVzdExlbmd0aCIsImRhbXBpbmciLCJsb2NhbEFuY2hvckEiLCJsb2NhbEFuY2hvckIiLCJ3b3JsZEFuY2hvckEiLCJzZXRXb3JsZEFuY2hvckEiLCJ3b3JsZEFuY2hvckIiLCJzZXRXb3JsZEFuY2hvckIiLCJnZXRXb3JsZEFuY2hvckEiLCJnZXRXb3JsZEFuY2hvckIiLCJhcHBseUZvcmNlX3IiLCJhcHBseUZvcmNlX3JfdW5pdCIsImFwcGx5Rm9yY2VfdSIsImFwcGx5Rm9yY2VfZiIsImFwcGx5Rm9yY2Vfd29ybGRBbmNob3JBIiwiYXBwbHlGb3JjZV93b3JsZEFuY2hvckIiLCJhcHBseUZvcmNlX3JpIiwiYXBwbHlGb3JjZV9yaiIsImFwcGx5Rm9yY2VfcmlfeF9mIiwiYXBwbHlGb3JjZV9yal94X2YiLCJhcHBseUZvcmNlX3RtcCIsInJfdW5pdCIsInJpX3hfZiIsInJqX3hfZiIsInJsZW4iLCJzdXNwZW5zaW9uTWF4TGVuZ3RoIiwiTnVtYmVyIiwiTUFYX1ZBTFVFIiwiaXNGcm9udFdoZWVsIiwidXBkYXRlV2hlZWwiLCJjaGFzc2lzIiwicHJvamVjdCIsInVwZGF0ZUNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbiIsInN4Iiwic3kiLCJzeiIsIlYiLCJheGVzIiwiY2FsY3VsYXRlTG9jYWxJbmVydGlhIiwiZ2V0U2lkZU5vcm1hbHMiLCJzaXhUYXJnZXRWZWN0b3JzIiwic2lkZXMiLCJleCIsIndvcmxkQ29ybmVyVGVtcFBvcyIsIndvcmxkQ29ybmVyVGVtcE5lZyIsImZvckVhY2hXb3JsZENvcm5lciIsIndvcmxkQ29ybmVyc1RlbXAiLCJ3YyIsInVuaXF1ZUF4ZXMiLCJ3b3JsZFZlcnRpY2VzIiwid29ybGRWZXJ0aWNlc05lZWRzVXBkYXRlIiwiY29tcHV0ZU5vcm1hbHMiLCJ3b3JsZEZhY2VOb3JtYWxzTmVlZHNVcGRhdGUiLCJ3b3JsZEZhY2VOb3JtYWxzIiwidW5pcXVlRWRnZXMiLCJjb21wdXRlRWRnZXMiLCJjb21wdXRlRWRnZXNfdG1wRWRnZSIsIm52IiwiZWRnZXMiLCJlZGdlIiwibnVtVmVydGljZXMiLCJnZXRGYWNlTm9ybWFsIiwidmVydGV4IiwiZXJyb3IiLCJjYiIsImFiIiwiY29tcHV0ZU5vcm1hbCIsInZhIiwidmIiLCJ2YyIsImNhaF9Xb3JsZE5vcm1hbCIsImNsaXBBZ2FpbnN0SHVsbCIsInBvc0EiLCJxdWF0QSIsImh1bGxCIiwicG9zQiIsInF1YXRCIiwic2VwYXJhdGluZ05vcm1hbCIsIm1heERpc3QiLCJXb3JsZE5vcm1hbCIsImh1bGxBIiwiY3VyTWF4RGlzdCIsImNsb3Nlc3RGYWNlQiIsImRtYXgiLCJ3b3JsZFZlcnRzQjEiLCJwb2x5QiIsImUwIiwid29ybGRiIiwiY2xpcEZhY2VBZ2FpbnN0SHVsbCIsImZzYV9mYWNlQU5vcm1hbFdTMyIsImZzYV9Xb3JsZG5vcm1hbDEiLCJmc2FfZGVsdGFDIiwiZnNhX3dvcmxkRWRnZTAiLCJmc2Ffd29ybGRFZGdlMSIsImZzYV9Dcm9zcyIsImZpbmRTZXBhcmF0aW5nQXhpcyIsImZhY2VMaXN0QSIsImZhY2VMaXN0QiIsImZhY2VBTm9ybWFsV1MzIiwiV29ybGRub3JtYWwxIiwiZGVsdGFDIiwid29ybGRFZGdlMCIsIndvcmxkRWRnZTEiLCJDcm9zcyIsImRtaW4iLCJjdXJQbGFuZVRlc3RzIiwibnVtRmFjZXNBIiwidGVzdFNlcEF4aXMiLCJudW1GYWNlc0IiLCJlMSIsIm1heG1pbkEiLCJtYXhtaW5CIiwibWF4QSIsIm1pbkEiLCJtYXhCIiwibWluQiIsImQwIiwiY2xpX2FhYmJtaW4iLCJjbGlfYWFiYm1heCIsImNvbXB1dGVMb2NhbEFBQkIiLCJnZXRQbGFuZUNvbnN0YW50T2ZGYWNlIiwiZmFjZV9pIiwiY2ZhaF9mYWNlQU5vcm1hbFdTIiwiY2ZhaF9lZGdlMCIsImNmYWhfV29ybGRFZGdlMCIsImNmYWhfd29ybGRQbGFuZUFub3JtYWwxIiwiY2ZhaF9wbGFuZU5vcm1hbFdTMSIsImNmYWhfd29ybGRBMSIsImNmYWhfbG9jYWxQbGFuZU5vcm1hbCIsImNmYWhfcGxhbmVOb3JtYWxXUyIsImZhY2VBTm9ybWFsV1MiLCJlZGdlMCIsIldvcmxkRWRnZTAiLCJ3b3JsZFBsYW5lQW5vcm1hbDEiLCJwbGFuZU5vcm1hbFdTMSIsIndvcmxkQTEiLCJsb2NhbFBsYW5lTm9ybWFsIiwicGxhbmVOb3JtYWxXUyIsIndvcmxkVmVydHNCMiIsInBWdHhJbiIsInBWdHhPdXQiLCJjbG9zZXN0RmFjZUEiLCJwb2x5QSIsImNvbm5lY3RlZEZhY2VzIiwibnVtQ29udGFjdHMiLCJudW1WZXJ0aWNlc0EiLCJyZXMiLCJwbGFuZUVxV1MxIiwicGxhbmVFcVdTIiwib3RoZXJGYWNlIiwibG9jYWxQbGFuZUVxIiwiY2xpcEZhY2VBZ2FpbnN0UGxhbmUiLCJzaGlmdCIsInBvaW50IiwiaW5WZXJ0aWNlcyIsIm91dFZlcnRpY2VzIiwicGxhbmVDb25zdGFudCIsIm5fZG90X2ZpcnN0Iiwibl9kb3RfbGFzdCIsIm51bVZlcnRzIiwiZmlyc3RWZXJ0ZXgiLCJsYXN0VmVydGV4IiwibmV3diIsImNvbXB1dGVXb3JsZFZlcnRpY2VzIiwidmVydHMiLCJ3b3JsZFZlcnRzIiwiY29tcHV0ZUxvY2FsQUFCQl93b3JsZFZlcnQiLCJhYWJibWluIiwiYWFiYm1heCIsIndvcmxkVmVydCIsImNvbXB1dGVXb3JsZEZhY2VOb3JtYWxzIiwid29ybGROb3JtYWxzIiwibWF4MiIsInRlbXBXb3JsZFZlcnRleCIsIm1pbngiLCJtaW55IiwibWlueiIsIm1heHgiLCJtYXh5IiwibWF4eiIsImdldEF2ZXJhZ2VQb2ludExvY2FsIiwidHJhbnNmb3JtQWxsUG9pbnRzIiwiQ29udmV4UG9seWhlZHJvbl9wb2ludElzSW5zaWRlIiwiQ29udmV4UG9seWhlZHJvbl92VG9QIiwiQ29udmV4UG9seWhlZHJvbl92VG9Qb2ludEluc2lkZSIsInBvaW50SXNJbnNpZGUiLCJwb3NpdGl2ZVJlc3VsdCIsInBvaW50SW5zaWRlIiwidlRvUCIsInZUb1BvaW50SW5zaWRlIiwicHJvamVjdF93b3JsZFZlcnRleCIsInByb2plY3RfbG9jYWxBeGlzIiwicHJvamVjdF9sb2NhbE9yaWdpbiIsImh1bGwiLCJ3b3JsZFZlcnRleCIsImxvY2FsQXhpcyIsImxvY2FsT3JpZ2luIiwidnMiLCJ2YWwiLCJyYWRpdXNUb3AiLCJyYWRpdXNCb3R0b20iLCJoZWlnaHQiLCJudW1TZWdtZW50cyIsImJvdHRvbWZhY2UiLCJ0b3BmYWNlIiwidGhldGEiLCJ0aGV0YU4iLCJtYXhWYWx1ZSIsIm1pblZhbHVlIiwidXBkYXRlTWluVmFsdWUiLCJ1cGRhdGVNYXhWYWx1ZSIsImNhY2hlRW5hYmxlZCIsIl9jYWNoZWRQaWxsYXJzIiwic2V0SGVpZ2h0VmFsdWVBdEluZGV4IiwiY2xlYXJDYWNoZWRDb252ZXhUcmlhbmdsZVBpbGxhciIsImdldFJlY3RNaW5NYXgiLCJjbGFtcCIsImZsb29yIiwiZ2V0SGVpZ2h0QXRfaWR4IiwiZ2V0SGVpZ2h0QXRfd2VpZ2h0cyIsImdldEhlaWdodEF0X2EiLCJnZXRIZWlnaHRBdF9iIiwiZ2V0SGVpZ2h0QXRfYyIsImdldFRyaWFuZ2xlQXQiLCJlZGdlQ2xhbXAiLCJsb3dlckRpc3QyIiwidXBwZXJEaXN0MiIsImdldFRyaWFuZ2xlIiwiZ2V0Tm9ybWFsQXRfYSIsImdldE5vcm1hbEF0X2IiLCJnZXROb3JtYWxBdF9jIiwiZ2V0Tm9ybWFsQXRfZTAiLCJnZXROb3JtYWxBdF9lMSIsImdldE5vcm1hbEF0IiwiZ2V0SGVpZ2h0QXQiLCJiYXJ5Y2VudHJpY1dlaWdodHMiLCJjeCIsImN5IiwiZ2V0Q2FjaGVDb252ZXhUcmlhbmdsZVBpbGxhcktleSIsImdldFVwcGVyVHJpYW5nbGUiLCJnZXRDYWNoZWRDb252ZXhUcmlhbmdsZVBpbGxhciIsInNldENhY2hlZENvbnZleFRyaWFuZ2xlUGlsbGFyIiwiY29udmV4Iiwib2Zmc2V0UmVzdWx0Iiwic2V0SGVpZ2h0c0Zyb21JbWFnZSIsImltYWdlIiwiY2FudmFzIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50Iiwid2lkdGgiLCJjb250ZXh0IiwiZ2V0Q29udGV4dCIsImRyYXdJbWFnZSIsImltYWdlRGF0YSIsImdldEltYWdlRGF0YSIsInVuc2hpZnQiLCJQQVJUSUNMRSIsInRlbXBOb3JtYWwiLCJtYXhWYWwiLCJDWUxJTkRFUiIsIk9jdHJlZSIsIkZsb2F0MzJBcnJheSIsIkludDE2QXJyYXkiLCJ1cGRhdGVFZGdlcyIsInVwZGF0ZU5vcm1hbHMiLCJ1cGRhdGVBQUJCIiwidXBkYXRlVHJlZSIsImNvbXB1dGVOb3JtYWxzX24iLCJ0cmlhbmdsZUFBQkIiLCJpMyIsIl9nZXRVbnNjYWxlZFZlcnRleCIsImluc2VydCIsInJlbW92ZUVtcHR5Tm9kZXMiLCJ1bnNjYWxlZEFBQkIiLCJnZXRUcmlhbmdsZXNJbkFBQkIiLCJpc3giLCJpc3kiLCJpc3oiLCJzZXRTY2FsZSIsIndhc1VuaWZvcm0iLCJpc1VuaWZvcm0iLCJpbmRleEEiLCJpbmRleEIiLCJPYmplY3QiLCJzcGxpdCIsInBhcnNlSW50IiwiZ2V0RWRnZVZlcnRleCIsImVkZ2VJbmRleCIsImZpcnN0T3JTZWNvbmQiLCJ2ZXJ0ZXhTdG9yZSIsInZlcnRleEluZGV4IiwiZ2V0RWRnZVZlY3Rvcl92YSIsImdldEVkZ2VWZWN0b3JfdmIiLCJnZXRFZGdlVmVjdG9yIiwidmVjdG9yU3RvcmUiLCJvdXQiLCJnZXRXb3JsZFZlcnRleCIsImdldFRyaWFuZ2xlVmVydGljZXMiLCJjbGlfYWFiYiIsImNhbGN1bGF0ZVdvcmxkQUFCQl9mcmFtZSIsImNhbGN1bGF0ZVdvcmxkQUFCQl9hYWJiIiwiY3JlYXRlVG9ydXMiLCJ0dWJlIiwicmFkaWFsU2VnbWVudHMiLCJ0dWJ1bGFyU2VnbWVudHMiLCJhcmMiLCJpdGVyYXRpb25zIiwidG9sZXJhbmNlIiwiR1NTb2x2ZXJfc29sdmVfbGFtYmRhIiwiR1NTb2x2ZXJfc29sdmVfaW52Q3MiLCJHU1NvbHZlcl9zb2x2ZV9CcyIsIml0ZXIiLCJtYXhJdGVyIiwidG9sU3F1YXJlZCIsIk5lcSIsIk5ib2RpZXMiLCJpbnZDIiwiZGVsdGFsYW1iZGFUb3QiLCJHV2xhbWJkYSIsImxhbWJkYWoiLCJpbnZDcyIsIkJzIiwibGFtYmRhIiwiaW52RHQiLCJhZGRFcXVhdGlvbiIsInJlbW92ZUVxdWF0aW9uIiwicmVtb3ZlQWxsRXF1YXRpb25zIiwic3Vic29sdmVyIiwibm9kZXMiLCJub2RlUG9vbCIsImNyZWF0ZU5vZGUiLCJTcGxpdFNvbHZlcl9zb2x2ZV9ub2RlcyIsIlNwbGl0U29sdmVyX3NvbHZlX25vZGVQb29sIiwiU3BsaXRTb2x2ZXJfc29sdmVfZXFzIiwiU3BsaXRTb2x2ZXJfc29sdmVfYmRzIiwiU3BsaXRTb2x2ZXJfc29sdmVfZHVtbXlXb3JsZCIsImdldFVudmlzaXRlZE5vZGUiLCJObm9kZXMiLCJub2RlIiwidmlzaXRlZCIsInF1ZXVlIiwiYmZzIiwicm9vdCIsInZpc2l0RnVuYyIsImJkcyIsImNoaWxkIiwiY2hpbGRyZW4iLCJOZXFzIiwiZHVtbXlXb3JsZCIsInNvcnQiLCJzb3J0QnlJZCIsImxpc3RlbmVyIiwiX2xpc3RlbmVycyIsImxpc3RlbmVycyIsImhhc0V2ZW50TGlzdGVuZXIiLCJoYXNBbnlFdmVudExpc3RlbmVyIiwiZXZlbnQiLCJsaXN0ZW5lckFycmF5IiwiT2N0cmVlTm9kZSIsIm1heERlcHRoIiwiZWxlbWVudERhdGEiLCJsZXZlbCIsIm5vZGVEYXRhIiwic3ViZGl2aWRlZCIsInN1YmRpdmlkZSIsImhhbGZEaWFnb25hbCIsIkFycmF5Iiwib2JqZWN0cyIsInJlbGVhc2UiLCJOYXJncyIsImFyZ3VtZW50cyIsImNvbnN0cnVjdE9iamVjdCIsInJlc2l6ZSIsInNpemUiLCJUdXBsZURpY3Rpb25hcnkiLCJnZXRMZW5ndGgiLCJnZXRLZXlCeUluZGV4IiwiZ2V0RGF0YUJ5S2V5IiwiS2V5IiwiY29udGFjdFBvaW50UG9vbCIsImZyaWN0aW9uRXF1YXRpb25Qb29sIiwiZnJpY3Rpb25SZXN1bHQiLCJ2M3Bvb2wiLCJjdXJyZW50Q29udGFjdE1hdGVyaWFsIiwiZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb24iLCJjcmVhdGVDb250YWN0RXF1YXRpb24iLCJvdmVycmlkZVNoYXBlQSIsIm92ZXJyaWRlU2hhcGVCIiwiY20iLCJtYXRBIiwibWF0QiIsImNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3QiLCJjb250YWN0RXF1YXRpb24iLCJvdXRBcnJheSIsInNoYXBlQSIsInNoYXBlQiIsIm11ZyIsImdyYXZpdHkiLCJyZWR1Y2VkTWFzcyIsInBvb2wiLCJhdmVyYWdlTm9ybWFsIiwiYXZlcmFnZUNvbnRhY3RQb2ludEEiLCJhdmVyYWdlQ29udGFjdFBvaW50QiIsImNyZWF0ZUZyaWN0aW9uRnJvbUF2ZXJhZ2UiLCJmMSIsImYyIiwiaW52TnVtQ29udGFjdHMiLCJ0bXBRdWF0MSIsInRtcFF1YXQyIiwiZ2V0Q29udGFjdHMiLCJvbGRjb250YWN0cyIsImZyaWN0aW9uUG9vbCIsInFqIiwiYm9keUNvbnRhY3RNYXRlcmlhbCIsImdldENvbnRhY3RNYXRlcmlhbCIsImp1c3RUZXN0Iiwic2hhcGVDb250YWN0TWF0ZXJpYWwiLCJkZWZhdWx0Q29udGFjdE1hdGVyaWFsIiwicmVzb2x2ZXIiLCJyZXR2YWwiLCJzaGFwZU92ZXJsYXBLZWVwZXIiLCJzaGFwZU92ZXJsYXBLZWVwZXJFeGl0IiwibnVtV2FybmluZ3MiLCJtYXhXYXJuaW5ncyIsIm1zZyIsImJveEJveCIsInJzaSIsInJzaiIsImNvbnZleENvbnZleCIsImJveENvbnZleCIsImJveFBhcnRpY2xlIiwiY29udmV4UGFydGljbGUiLCJzcGhlcmVTcGhlcmUiLCJwbGFuZVRyaW1lc2hfbm9ybWFsIiwicGxhbmVUcmltZXNoX3JlbHBvcyIsInBsYW5lVHJpbWVzaF9wcm9qZWN0ZWQiLCJwbGFuZVRyaW1lc2giLCJwbGFuZVNoYXBlIiwidHJpbWVzaFNoYXBlIiwicGxhbmVQb3MiLCJ0cmltZXNoUG9zIiwicGxhbmVRdWF0IiwidHJpbWVzaFF1YXQiLCJwbGFuZUJvZHkiLCJ0cmltZXNoQm9keSIsInByb2plY3RlZCIsInNwaGVyZVRyaW1lc2hfbm9ybWFsIiwic3BoZXJlVHJpbWVzaF9yZWxwb3MiLCJzcGhlcmVUcmltZXNoX3Byb2plY3RlZCIsInNwaGVyZVRyaW1lc2hfdiIsInNwaGVyZVRyaW1lc2hfdjIiLCJzcGhlcmVUcmltZXNoX2VkZ2VWZXJ0ZXhBIiwic3BoZXJlVHJpbWVzaF9lZGdlVmVydGV4QiIsInNwaGVyZVRyaW1lc2hfZWRnZVZlY3RvciIsInNwaGVyZVRyaW1lc2hfZWRnZVZlY3RvclVuaXQiLCJzcGhlcmVUcmltZXNoX2xvY2FsU3BoZXJlUG9zIiwic3BoZXJlVHJpbWVzaF90bXAiLCJzcGhlcmVUcmltZXNoX3ZhIiwic3BoZXJlVHJpbWVzaF92YiIsInNwaGVyZVRyaW1lc2hfdmMiLCJzcGhlcmVUcmltZXNoX2xvY2FsU3BoZXJlQUFCQiIsInNwaGVyZVRyaW1lc2hfdHJpYW5nbGVzIiwic3BoZXJlVHJpbWVzaCIsInNwaGVyZVNoYXBlIiwic3BoZXJlUG9zIiwic3BoZXJlUXVhdCIsInNwaGVyZUJvZHkiLCJlZGdlVmVydGV4QSIsImVkZ2VWZXJ0ZXhCIiwiZWRnZVZlY3RvciIsImVkZ2VWZWN0b3JVbml0IiwibG9jYWxTcGhlcmVQb3MiLCJsb2NhbFNwaGVyZUFBQkIiLCJzcGhlcmVSYWRpdXMiLCJyYWRpdXNTcXVhcmVkIiwicG9zaXRpb25BbG9uZ0VkZ2VCIiwicG9zaXRpb25BbG9uZ0VkZ2VBIiwicG9pbnRfb25fcGxhbmVfdG9fc3BoZXJlIiwicGxhbmVfdG9fc3BoZXJlX29ydGhvIiwicF9zX25pIiwicF9zX3JpIiwicF9zX3JqIiwic3BoZXJlUGxhbmUiLCJwb2ludEluUG9seWdvbl9lZGdlIiwicG9pbnRJblBvbHlnb25fZWRnZV94X25vcm1hbCIsInBvaW50SW5Qb2x5Z29uX3Z0cCIsInBvaW50SW5Qb2x5Z29uIiwiZWRnZV94X25vcm1hbCIsInZlcnRleF90b19wIiwiYm94X3RvX3NwaGVyZSIsInNwaGVyZUJveF9ucyIsInNwaGVyZUJveF9uczEiLCJzcGhlcmVCb3hfbnMyIiwic3BoZXJlQm94X3NpZGVzIiwic3BoZXJlQm94X3NwaGVyZV90b19jb3JuZXIiLCJzcGhlcmVCb3hfc2lkZV9ucyIsInNwaGVyZUJveF9zaWRlX25zMSIsInNwaGVyZUJveF9zaWRlX25zMiIsInNwaGVyZUJveCIsIlIiLCJwZW5ldHJhdGluZ19zaWRlcyIsInNpZGVfbnMiLCJzaWRlX25zMSIsInNpZGVfbnMyIiwic2lkZV9oIiwic2lkZV9wZW5ldHJhdGlvbnMiLCJzaWRlX2RvdDEiLCJzaWRlX2RvdDIiLCJzaWRlX2Rpc3RhbmNlIiwibnNpZGVzIiwibnMiLCJuczEiLCJuczIiLCJoMSIsImgyIiwiZG90MSIsImRvdDIiLCJzcGhlcmVfdG9fY29ybmVyIiwiZWRnZVRhbmdlbnQiLCJlZGdlQ2VudGVyIiwib3J0aG9nb25hbCIsIk5zaWRlcyIsIm9ydGhvbm9ybSIsInRkaXN0IiwibmRpc3QiLCJjb252ZXhfdG9fc3BoZXJlIiwic3BoZXJlQ29udmV4X2VkZ2UiLCJzcGhlcmVDb252ZXhfZWRnZVVuaXQiLCJzcGhlcmVDb252ZXhfc3BoZXJlVG9Db3JuZXIiLCJzcGhlcmVDb252ZXhfd29ybGRDb3JuZXIiLCJzcGhlcmVDb252ZXhfd29ybGROb3JtYWwiLCJzcGhlcmVDb252ZXhfd29ybGRQb2ludCIsInNwaGVyZUNvbnZleF93b3JsZFNwaGVyZVBvaW50Q2xvc2VzdFRvUGxhbmUiLCJzcGhlcmVDb252ZXhfcGVuZXRyYXRpb25WZWMiLCJzcGhlcmVDb252ZXhfc3BoZXJlVG9Xb3JsZFBvaW50Iiwic3BoZXJlQ29udmV4Iiwid29ybGRDb3JuZXIiLCJuZmFjZXMiLCJ3b3JsZFNwaGVyZVBvaW50Q2xvc2VzdFRvUGxhbmUiLCJwZW5ldHJhdGlvbiIsIndvcmxkUG9pbnRUb1NwaGVyZSIsImZhY2VWZXJ0cyIsIk52ZXJ0cyIsInBlbmV0cmF0aW9uVmVjMiIsInBlbmV0cmF0aW9uU3BoZXJlUG9pbnQiLCJOZmFjZXZlcnRzIiwiZWRnZVVuaXQiLCJ2MV90b194aSIsInhpX3RvX3AiLCJwbGFuZUJveF9ub3JtYWwiLCJwbGFuZV90b19jb3JuZXIiLCJwbGFuZUJveCIsInBsYW5lQ29udmV4IiwicGxhbmVDb252ZXhfdiIsInBsYW5lQ29udmV4X25vcm1hbCIsInBsYW5lQ29udmV4X3JlbHBvcyIsInBsYW5lQ29udmV4X3Byb2plY3RlZCIsImNvbnZleFNoYXBlIiwicGxhbmVQb3NpdGlvbiIsImNvbnZleFBvc2l0aW9uIiwiY29udmV4UXVhdCIsImNvbnZleEJvZHkiLCJjb252ZXhDb252ZXhfc2VwQXhpcyIsImNvbnZleENvbnZleF9xIiwic2VwQXhpcyIsInBhcnRpY2xlUGxhbmVfbm9ybWFsIiwicGFydGljbGVQbGFuZV9yZWxwb3MiLCJwYXJ0aWNsZVBsYW5lX3Byb2plY3RlZCIsInBsYW5lUGFydGljbGUiLCJwYXJ0aWNsZVNwaGVyZV9ub3JtYWwiLCJzcGhlcmVQYXJ0aWNsZSIsImNxaiIsImNvbnZleFBhcnRpY2xlX2xvY2FsIiwiY29udmV4UGFydGljbGVfbm9ybWFsIiwiY29udmV4UGFydGljbGVfcGVuZXRyYXRlZEZhY2VOb3JtYWwiLCJjb252ZXhQYXJ0aWNsZV92ZXJ0ZXhUb1BhcnRpY2xlIiwiY29udmV4UGFydGljbGVfd29ybGRQZW5ldHJhdGlvblZlYyIsInBlbmV0cmF0ZWRGYWNlSW5kZXgiLCJwZW5ldHJhdGVkRmFjZU5vcm1hbCIsIndvcmxkUGVuZXRyYXRpb25WZWMiLCJtaW5QZW5ldHJhdGlvbiIsIm51bURldGVjdGVkRmFjZXMiLCJsb2NhbCIsImJveEhlaWdodGZpZWxkIiwiY29udmV4SGVpZ2h0ZmllbGQiLCJjb252ZXhIZWlnaHRmaWVsZF90bXAxIiwiY29udmV4SGVpZ2h0ZmllbGRfdG1wMiIsImNvbnZleEhlaWdodGZpZWxkX2ZhY2VMaXN0IiwiaGZTaGFwZSIsImNvbnZleFBvcyIsImhmUG9zIiwiaGZRdWF0IiwiaGZCb2R5IiwibG9jYWxDb252ZXhQb3MiLCJtaW5NYXgiLCJpbnRlcnNlY3RpbmciLCJzcGhlcmVIZWlnaHRmaWVsZF90bXAxIiwic3BoZXJlSGVpZ2h0ZmllbGRfdG1wMiIsInNwaGVyZUhlaWdodGZpZWxkIiwibnVtQ29udGFjdHNCZWZvcmUiLCJjb250YWN0cyIsImZyaWN0aW9uRXF1YXRpb25zIiwiY29udGFjdHNEaWMiLCJvbGRDb250YWN0c0RpYyIsInF1YXROb3JtYWxpemVTa2lwIiwic3RlcG51bWJlciIsInN1YnN0ZXBzIiwiZGVmYXVsdF9kdCIsIm5leHRJZCIsInNvbHZlciIsIm5hcnJvd3BoYXNlIiwiY29sbGlzaW9uTWF0cml4IiwidHJpZ2dlck1hdHJpeCIsImNvbnRhY3RtYXRlcmlhbHMiLCJjb250YWN0TWF0ZXJpYWxUYWJsZSIsImRlZmF1bHRNYXRlcmlhbCIsInByb2ZpbGUiLCJtYWtlQ29udGFjdENvbnN0cmFpbnRzIiwiYWNjdW11bGF0b3IiLCJzdWJzeXN0ZW1zIiwiYWRkQm9keUV2ZW50IiwicmVtb3ZlQm9keUV2ZW50IiwiaWRUb0JvZHlNYXAiLCJjb2xsaXNpb25NYXRyaXhUaWNrIiwicmF5Y2FzdENsb3Nlc3QiLCJyYXljYXN0QWxsIiwicmF5Y2FzdEFueSIsInJlbW92ZUJvZHkiLCJnZXRCb2R5QnlJZCIsImdldFNoYXBlQnlJZCIsImFkZE1hdGVyaWFsIiwiYWRkQ29udGFjdE1hdGVyaWFsIiwiY21hdCIsInBlcmZvcm1hbmNlIiwibm93Iiwibm93T2Zmc2V0IiwiRGF0ZSIsInRpbWluZyIsIm5hdmlnYXRpb25TdGFydCIsInN0ZXAiLCJ0aW1lU2luY2VMYXN0Q2FsbGVkIiwibWF4U3ViU3RlcHMiLCJXb3JsZF9zdGVwX29sZENvbnRhY3RzIiwiaW50ZXJuYWxTdGVwIiwiV29ybGRfc3RlcF9jb2xsaWRlRXZlbnQiLCJzZWxmU2hhcGUiLCJvdGhlclNoYXBlIiwiV29ybGRfc3RlcF9mcmljdGlvbkVxdWF0aW9uUG9vbCIsIldvcmxkX3N0ZXBfcDEiLCJXb3JsZF9zdGVwX3AyIiwicHJvZmlsaW5nU3RhcnQiLCJneCIsImd5IiwiZ3oiLCJkb1Byb2ZpbGluZyIsIk5zdWJzeXN0ZW1zIiwiTmNvbnN0cmFpbnRzIiwiTm9sZEZyaWN0aW9uRXF1YXRpb25zIiwibmNvbnRhY3RzIiwibGQiLCJhdiIsImFkIiwiY2xlYXJGb3JjZXMiLCJ0cmlnZ2VyZWRFdmVudCIsInNlbGZCb2R5Iiwib3RoZXJCb2R5IiwiZW1pdFRyaWdnZXJlZEV2ZW50cyIsImVtaXRDb2xsaXNpb25FdmVudHMiLCJpdGVtIiwic3BlZWRTcXVhcmVkQiIsInNwZWVkTGltaXRTcXVhcmVkQiIsInNwZWVkU3F1YXJlZEEiLCJzcGVlZExpbWl0U3F1YXJlZEEiLCJjb250YWN0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUE7O0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF1QkEsQ0FBQyxVQUFTQSxDQUFULEVBQVc7QUFBQyxNQUFHLFlBQVUsT0FBT0MsT0FBakIsSUFBMEIsZUFBYSxPQUFPQyxNQUFqRCxFQUF3REEsTUFBTSxDQUFDRCxPQUFQLEdBQWVELENBQUMsRUFBaEIsQ0FBeEQsS0FBZ0YsSUFBRyxjQUFZLE9BQU9HLE1BQW5CLElBQTJCQSxNQUFNLENBQUNDLEdBQXJDLEVBQXlDRCxNQUFNLENBQUMsRUFBRCxFQUFJSCxDQUFKLENBQU4sQ0FBekMsS0FBMEQ7QUFBQyxRQUFJSyxDQUFKO0FBQU0sbUJBQWEsT0FBT0MsTUFBcEIsR0FBMkJELENBQUMsR0FBQ0MsTUFBN0IsR0FBb0MsZUFBYSxPQUFPQyxNQUFwQixHQUEyQkYsQ0FBQyxHQUFDRSxNQUE3QixHQUFvQyxlQUFhLE9BQU9DLElBQXBCLEtBQTJCSCxDQUFDLEdBQUNHLElBQTdCLENBQXhFLEVBQTJHSCxDQUFDLENBQUNJLE1BQUYsR0FBU1QsQ0FBQyxFQUFySDtBQUF3SDtBQUFDLENBQXRSLENBQXVSLFlBQVU7QUFBQyxNQUFJRyxNQUFKLEVBQVdELE1BQVgsRUFBa0JELE9BQWxCO0FBQTBCLFNBQVEsU0FBU0QsQ0FBVCxDQUFXVSxDQUFYLEVBQWFDLENBQWIsRUFBZUMsQ0FBZixFQUFpQjtBQUFDLGFBQVNDLENBQVQsQ0FBV0MsQ0FBWCxFQUFhQyxDQUFiLEVBQWU7QUFBQyxVQUFHLENBQUNKLENBQUMsQ0FBQ0csQ0FBRCxDQUFMLEVBQVM7QUFBQyxZQUFHLENBQUNKLENBQUMsQ0FBQ0ksQ0FBRCxDQUFMLEVBQVM7QUFBQyxjQUFJRSxDQUFDLEdBQUMsT0FBT0MsT0FBUCxJQUFn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QUFxZ0NDLEtBdGdDZ1QsRUFzZ0MvUztBQUFDLDJCQUFvQixDQUFyQjtBQUF1QiwyQ0FBb0MsQ0FBM0Q7QUFBNkQsc0NBQStCLENBQTVGO0FBQThGLDRDQUFxQyxDQUFuSTtBQUFxSSxvQ0FBNkIsQ0FBbEs7QUFBb0ssMEJBQW1CLEVBQXZMO0FBQTBMLG9DQUE2QixFQUF2TjtBQUEwTixzQ0FBK0IsRUFBelA7QUFBNFAsdUNBQWdDLEVBQTVSO0FBQStSLHFDQUE4QixFQUE3VDtBQUFnVSw4QkFBdUIsRUFBdlY7QUFBMFYsNEJBQXFCLEVBQS9XO0FBQWtYLHNCQUFlLEVBQWpZO0FBQW9ZLHlCQUFrQixFQUF0WjtBQUF5Wix5QkFBa0IsRUFBM2E7QUFBOGEsNEJBQXFCLEVBQW5jO0FBQXNjLDhCQUF1QixFQUE3ZDtBQUFnZSxrQ0FBMkIsRUFBM2Y7QUFBOGYsdUJBQWdCO0FBQTlnQixLQXRnQytTO0FBajBhNGEsR0FBelosRUF1MGNrTixFQXYwY2xOLEVBdTBjcU4sQ0FBQyxDQUFELENBdjBjck4sRUF3MGNuVSxDQXgwY21VLENBQVA7QUF5MGM1VCxDQXowY0EsQ0FBRCIsInNvdXJjZXNDb250ZW50IjpbIi8vIE1vbiwgMDQgTm92IDIwMTkgMDU6MTQ6MzcgR01UXHJcblxyXG4vKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgY2Fubm9uLmpzIEF1dGhvcnNcclxuICpcclxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cclxuICogb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cclxuICogZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0XHJcbiAqIHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LFxyXG4gKiBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXNcclxuICogb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcclxuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuICpcclxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcclxuICogaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcbiAqXHJcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXHJcbiAqIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxyXG4gKiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxyXG4gKiBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFXHJcbiAqIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT05cclxuICogT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXHJcbiAqIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxyXG4gKi9cclxuXHJcbiFmdW5jdGlvbihlKXtpZihcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG1vZHVsZSltb2R1bGUuZXhwb3J0cz1lKCk7ZWxzZSBpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQpZGVmaW5lKFtdLGUpO2Vsc2V7dmFyIGY7XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz9mPXdpbmRvdzpcInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsP2Y9Z2xvYmFsOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZWxmJiYoZj1zZWxmKSxmLkNBTk5PTj1lKCl9fShmdW5jdGlvbigpe3ZhciBkZWZpbmUsbW9kdWxlLGV4cG9ydHM7cmV0dXJuIChmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKX12YXIgZj1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwoZi5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxmLGYuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pKHsxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcclxubW9kdWxlLmV4cG9ydHM9e1xyXG4gIFwibmFtZVwiOiBcIkBjb2Nvcy9jYW5ub25cIixcclxuICBcInZlcnNpb25cIjogXCIxLjAuM1wiLFxyXG4gIFwiZGVzY3JpcHRpb25cIjogXCJBIGxpZ2h0d2VpZ2h0IDNEIHBoeXNpY3MgZW5naW5lIHdyaXR0ZW4gaW4gSmF2YVNjcmlwdC5cIixcclxuICBcImhvbWVwYWdlXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL2NvY29zLWNyZWF0b3IvY2Fubm9uLmpzXCIsXHJcbiAgXCJhdXRob3JcIjogXCJTdGVmYW4gSGVkbWFuIDxzY2h0ZXBwZUBnbWFpbC5jb20+IChodHRwOi8vc3RlZmZlLnNlKSwgSmF5Y2VMYWlcIixcclxuICBcImtleXdvcmRzXCI6IFtcclxuICAgIFwiY2Fubm9uXCIsXHJcbiAgICBcImNvY29zXCIsXHJcbiAgICBcImNyZWF0b3JcIixcclxuICAgIFwicGh5c2ljc1wiLFxyXG4gICAgXCJlbmdpbmVcIixcclxuICAgIFwiM2RcIlxyXG4gIF0sXHJcbiAgXCJzY3JpcHRzXCI6IHtcclxuICAgIFwiYnVpbGRcIjpcImdydW50ICYmIG5wbSBydW4gcHJlcHJvY2VzcyAmJiBncnVudCBhZGRMaWNlbnNlICYmIGdydW50IGFkZERhdGVcIixcclxuICAgIFwicHJlcHJvY2Vzc1wiOlwibm9kZSBub2RlX21vZHVsZXMvdWdsaWZ5LWpzL2Jpbi91Z2xpZnlqcyBidWlsZC9jYW5ub24uanMgLW8gYnVpbGQvY2Fubm9uLm1pbi5qcyAtZCBkb1Byb2ZpbGluZz1mYWxzZSxERUJVRz1mYWxzZSAtYyAtbVwiXHJcbiAgfSxcclxuICBcIm1haW5cIjogXCIuL2J1aWxkL2Nhbm5vbi5taW4uanNcIixcclxuICBcImVuZ2luZXNcIjoge1xyXG4gICAgXCJub2RlXCI6IFwiKlwiXHJcbiAgfSxcclxuICBcInJlcG9zaXRvcnlcIjoge1xyXG4gICAgXCJ0eXBlXCI6IFwiZ2l0XCIsXHJcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9jb2Nvcy1jcmVhdG9yL2Nhbm5vbi5qcy5naXRcIlxyXG4gIH0sXHJcbiAgXCJidWdzXCI6IHtcclxuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL2NvY29zLWNyZWF0b3IvY2Fubm9uLmpzL2lzc3Vlc1wiXHJcbiAgfSxcclxuICBcImxpY2Vuc2VzXCI6IFtcclxuICAgIHtcclxuICAgICAgXCJ0eXBlXCI6IFwiTUlUXCJcclxuICAgIH1cclxuICBdLFxyXG4gIFwiZGV2RGVwZW5kZW5jaWVzXCI6IHtcclxuICAgIFwianNoaW50XCI6IFwibGF0ZXN0XCIsXHJcbiAgICBcInVnbGlmeS1qc1wiOiBcImxhdGVzdFwiLFxyXG4gICAgXCJub2RldW5pdFwiOiBcIl4wLjkuMFwiLFxyXG4gICAgXCJncnVudFwiOiBcIn4wLjQuMFwiLFxyXG4gICAgXCJncnVudC1jb250cmliLWpzaGludFwiOiBcIn4wLjEuMVwiLFxyXG4gICAgXCJncnVudC1jb250cmliLW5vZGV1bml0XCI6IFwiXjAuNC4xXCIsXHJcbiAgICBcImdydW50LWNvbnRyaWItY29uY2F0XCI6IFwifjAuMS4zXCIsXHJcbiAgICBcImdydW50LWNvbnRyaWItdWdsaWZ5XCI6IFwiXjAuNS4xXCIsXHJcbiAgICBcImdydW50LWJyb3dzZXJpZnlcIjogXCJeMi4xLjRcIixcclxuICAgIFwiZ3J1bnQtY29udHJpYi15dWlkb2NcIjogXCJeMC41LjJcIixcclxuICAgIFwiYnJvd3NlcmlmeVwiOiBcIipcIlxyXG4gIH0sXHJcbiAgXCJkZXBlbmRlbmNpZXNcIjoge31cclxufVxyXG5cclxufSx7fV0sMjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XHJcbi8vIEV4cG9ydCBjbGFzc2VzXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgdmVyc2lvbiA6ICAgICAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uLFxyXG5cclxuICAgIEFBQkIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9jb2xsaXNpb24vQUFCQicpLFxyXG4gICAgQXJyYXlDb2xsaXNpb25NYXRyaXggOiAgICAgICAgICBfZGVyZXFfKCcuL2NvbGxpc2lvbi9BcnJheUNvbGxpc2lvbk1hdHJpeCcpLFxyXG4gICAgQm9keSA6ICAgICAgICAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL29iamVjdHMvQm9keScpLFxyXG4gICAgQm94IDogICAgICAgICAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL3NoYXBlcy9Cb3gnKSxcclxuICAgIEJyb2FkcGhhc2UgOiAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9jb2xsaXNpb24vQnJvYWRwaGFzZScpLFxyXG4gICAgQ29uc3RyYWludCA6ICAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL2NvbnN0cmFpbnRzL0NvbnN0cmFpbnQnKSxcclxuICAgIENvbnRhY3RFcXVhdGlvbiA6ICAgICAgICAgICAgICAgX2RlcmVxXygnLi9lcXVhdGlvbnMvQ29udGFjdEVxdWF0aW9uJyksXHJcbiAgICBOYXJyb3dwaGFzZSA6ICAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vd29ybGQvTmFycm93cGhhc2UnKSxcclxuICAgIENvbmVUd2lzdENvbnN0cmFpbnQgOiAgICAgICAgICAgX2RlcmVxXygnLi9jb25zdHJhaW50cy9Db25lVHdpc3RDb25zdHJhaW50JyksXHJcbiAgICBDb250YWN0TWF0ZXJpYWwgOiAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vbWF0ZXJpYWwvQ29udGFjdE1hdGVyaWFsJyksXHJcbiAgICBDb252ZXhQb2x5aGVkcm9uIDogICAgICAgICAgICAgIF9kZXJlcV8oJy4vc2hhcGVzL0NvbnZleFBvbHloZWRyb24nKSxcclxuICAgIEN5bGluZGVyIDogICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9zaGFwZXMvQ3lsaW5kZXInKSxcclxuICAgIERpc3RhbmNlQ29uc3RyYWludCA6ICAgICAgICAgICAgX2RlcmVxXygnLi9jb25zdHJhaW50cy9EaXN0YW5jZUNvbnN0cmFpbnQnKSxcclxuICAgIEVxdWF0aW9uIDogICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9lcXVhdGlvbnMvRXF1YXRpb24nKSxcclxuICAgIEV2ZW50VGFyZ2V0IDogICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi91dGlscy9FdmVudFRhcmdldCcpLFxyXG4gICAgRnJpY3Rpb25FcXVhdGlvbiA6ICAgICAgICAgICAgICBfZGVyZXFfKCcuL2VxdWF0aW9ucy9GcmljdGlvbkVxdWF0aW9uJyksXHJcbiAgICBHU1NvbHZlciA6ICAgICAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vc29sdmVyL0dTU29sdmVyJyksXHJcbiAgICBHcmlkQnJvYWRwaGFzZSA6ICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vY29sbGlzaW9uL0dyaWRCcm9hZHBoYXNlJyksXHJcbiAgICBIZWlnaHRmaWVsZCA6ICAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vc2hhcGVzL0hlaWdodGZpZWxkJyksXHJcbiAgICBIaW5nZUNvbnN0cmFpbnQgOiAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vY29uc3RyYWludHMvSGluZ2VDb25zdHJhaW50JyksXHJcbiAgICBMb2NrQ29uc3RyYWludCA6ICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vY29uc3RyYWludHMvTG9ja0NvbnN0cmFpbnQnKSxcclxuICAgIE1hdDMgOiAgICAgICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9tYXRoL01hdDMnKSxcclxuICAgIE1hdGVyaWFsIDogICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9tYXRlcmlhbC9NYXRlcmlhbCcpLFxyXG4gICAgTmFpdmVCcm9hZHBoYXNlIDogICAgICAgICAgICAgICBfZGVyZXFfKCcuL2NvbGxpc2lvbi9OYWl2ZUJyb2FkcGhhc2UnKSxcclxuICAgIE9iamVjdENvbGxpc2lvbk1hdHJpeCA6ICAgICAgICAgX2RlcmVxXygnLi9jb2xsaXNpb24vT2JqZWN0Q29sbGlzaW9uTWF0cml4JyksXHJcbiAgICBQb29sIDogICAgICAgICAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vdXRpbHMvUG9vbCcpLFxyXG4gICAgUGFydGljbGUgOiAgICAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL3NoYXBlcy9QYXJ0aWNsZScpLFxyXG4gICAgUGxhbmUgOiAgICAgICAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL3NoYXBlcy9QbGFuZScpLFxyXG4gICAgUG9pbnRUb1BvaW50Q29uc3RyYWludCA6ICAgICAgICBfZGVyZXFfKCcuL2NvbnN0cmFpbnRzL1BvaW50VG9Qb2ludENvbnN0cmFpbnQnKSxcclxuICAgIFF1YXRlcm5pb24gOiAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9tYXRoL1F1YXRlcm5pb24nKSxcclxuICAgIFJheSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9jb2xsaXNpb24vUmF5JyksXHJcbiAgICBSYXljYXN0VmVoaWNsZSA6ICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vb2JqZWN0cy9SYXljYXN0VmVoaWNsZScpLFxyXG4gICAgUmF5Y2FzdFJlc3VsdCA6ICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL2NvbGxpc2lvbi9SYXljYXN0UmVzdWx0JyksXHJcbiAgICBSaWdpZFZlaGljbGUgOiAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vb2JqZWN0cy9SaWdpZFZlaGljbGUnKSxcclxuICAgIFJvdGF0aW9uYWxFcXVhdGlvbiA6ICAgICAgICAgICAgX2RlcmVxXygnLi9lcXVhdGlvbnMvUm90YXRpb25hbEVxdWF0aW9uJyksXHJcbiAgICBSb3RhdGlvbmFsTW90b3JFcXVhdGlvbiA6ICAgICAgIF9kZXJlcV8oJy4vZXF1YXRpb25zL1JvdGF0aW9uYWxNb3RvckVxdWF0aW9uJyksXHJcbiAgICBTQVBCcm9hZHBoYXNlIDogICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vY29sbGlzaW9uL1NBUEJyb2FkcGhhc2UnKSxcclxuICAgIFNQSFN5c3RlbSA6ICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9vYmplY3RzL1NQSFN5c3RlbScpLFxyXG4gICAgU2hhcGUgOiAgICAgICAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL3NoYXBlcy9TaGFwZScpLFxyXG4gICAgU29sdmVyIDogICAgICAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL3NvbHZlci9Tb2x2ZXInKSxcclxuICAgIFNwaGVyZSA6ICAgICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9zaGFwZXMvU3BoZXJlJyksXHJcbiAgICBTcGxpdFNvbHZlciA6ICAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vc29sdmVyL1NwbGl0U29sdmVyJyksXHJcbiAgICBTcHJpbmcgOiAgICAgICAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vb2JqZWN0cy9TcHJpbmcnKSxcclxuICAgIFRyYW5zZm9ybSA6ICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9tYXRoL1RyYW5zZm9ybScpLFxyXG4gICAgVHJpbWVzaCA6ICAgICAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL3NoYXBlcy9UcmltZXNoJyksXHJcbiAgICBWZWMzIDogICAgICAgICAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vbWF0aC9WZWMzJyksXHJcbiAgICBWZWMzUG9vbCA6ICAgICAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vdXRpbHMvVmVjM1Bvb2wnKSxcclxuICAgIFdvcmxkIDogICAgICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi93b3JsZC9Xb3JsZCcpLFxyXG59O1xyXG5cclxufSx7XCIuLi9wYWNrYWdlLmpzb25cIjoxLFwiLi9jb2xsaXNpb24vQUFCQlwiOjMsXCIuL2NvbGxpc2lvbi9BcnJheUNvbGxpc2lvbk1hdHJpeFwiOjQsXCIuL2NvbGxpc2lvbi9Ccm9hZHBoYXNlXCI6NSxcIi4vY29sbGlzaW9uL0dyaWRCcm9hZHBoYXNlXCI6NixcIi4vY29sbGlzaW9uL05haXZlQnJvYWRwaGFzZVwiOjcsXCIuL2NvbGxpc2lvbi9PYmplY3RDb2xsaXNpb25NYXRyaXhcIjo4LFwiLi9jb2xsaXNpb24vUmF5XCI6MTAsXCIuL2NvbGxpc2lvbi9SYXljYXN0UmVzdWx0XCI6MTEsXCIuL2NvbGxpc2lvbi9TQVBCcm9hZHBoYXNlXCI6MTIsXCIuL2NvbnN0cmFpbnRzL0NvbmVUd2lzdENvbnN0cmFpbnRcIjoxMyxcIi4vY29uc3RyYWludHMvQ29uc3RyYWludFwiOjE0LFwiLi9jb25zdHJhaW50cy9EaXN0YW5jZUNvbnN0cmFpbnRcIjoxNSxcIi4vY29uc3RyYWludHMvSGluZ2VDb25zdHJhaW50XCI6MTYsXCIuL2NvbnN0cmFpbnRzL0xvY2tDb25zdHJhaW50XCI6MTcsXCIuL2NvbnN0cmFpbnRzL1BvaW50VG9Qb2ludENvbnN0cmFpbnRcIjoxOCxcIi4vZXF1YXRpb25zL0NvbnRhY3RFcXVhdGlvblwiOjIwLFwiLi9lcXVhdGlvbnMvRXF1YXRpb25cIjoyMSxcIi4vZXF1YXRpb25zL0ZyaWN0aW9uRXF1YXRpb25cIjoyMixcIi4vZXF1YXRpb25zL1JvdGF0aW9uYWxFcXVhdGlvblwiOjIzLFwiLi9lcXVhdGlvbnMvUm90YXRpb25hbE1vdG9yRXF1YXRpb25cIjoyNCxcIi4vbWF0ZXJpYWwvQ29udGFjdE1hdGVyaWFsXCI6MjUsXCIuL21hdGVyaWFsL01hdGVyaWFsXCI6MjYsXCIuL21hdGgvTWF0M1wiOjI4LFwiLi9tYXRoL1F1YXRlcm5pb25cIjoyOSxcIi4vbWF0aC9UcmFuc2Zvcm1cIjozMCxcIi4vbWF0aC9WZWMzXCI6MzEsXCIuL29iamVjdHMvQm9keVwiOjMyLFwiLi9vYmplY3RzL1JheWNhc3RWZWhpY2xlXCI6MzMsXCIuL29iamVjdHMvUmlnaWRWZWhpY2xlXCI6MzQsXCIuL29iamVjdHMvU1BIU3lzdGVtXCI6MzUsXCIuL29iamVjdHMvU3ByaW5nXCI6MzYsXCIuL3NoYXBlcy9Cb3hcIjozOCxcIi4vc2hhcGVzL0NvbnZleFBvbHloZWRyb25cIjozOSxcIi4vc2hhcGVzL0N5bGluZGVyXCI6NDAsXCIuL3NoYXBlcy9IZWlnaHRmaWVsZFwiOjQxLFwiLi9zaGFwZXMvUGFydGljbGVcIjo0MixcIi4vc2hhcGVzL1BsYW5lXCI6NDMsXCIuL3NoYXBlcy9TaGFwZVwiOjQ0LFwiLi9zaGFwZXMvU3BoZXJlXCI6NDUsXCIuL3NoYXBlcy9UcmltZXNoXCI6NDYsXCIuL3NvbHZlci9HU1NvbHZlclwiOjQ3LFwiLi9zb2x2ZXIvU29sdmVyXCI6NDgsXCIuL3NvbHZlci9TcGxpdFNvbHZlclwiOjQ5LFwiLi91dGlscy9FdmVudFRhcmdldFwiOjUwLFwiLi91dGlscy9Qb29sXCI6NTIsXCIuL3V0aWxzL1ZlYzNQb29sXCI6NTUsXCIuL3dvcmxkL05hcnJvd3BoYXNlXCI6NTYsXCIuL3dvcmxkL1dvcmxkXCI6NTd9XSwzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcclxudmFyIFZlYzMgPSBfZGVyZXFfKCcuLi9tYXRoL1ZlYzMnKTtcclxudmFyIFV0aWxzID0gX2RlcmVxXygnLi4vdXRpbHMvVXRpbHMnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQUFCQjtcclxuXHJcbi8qKlxyXG4gKiBBeGlzIGFsaWduZWQgYm91bmRpbmcgYm94IGNsYXNzLlxyXG4gKiBAY2xhc3MgQUFCQlxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxyXG4gKiBAcGFyYW0ge1ZlYzN9ICAgW29wdGlvbnMudXBwZXJCb3VuZF1cclxuICogQHBhcmFtIHtWZWMzfSAgIFtvcHRpb25zLmxvd2VyQm91bmRdXHJcbiAqL1xyXG5mdW5jdGlvbiBBQUJCKG9wdGlvbnMpe1xyXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbG93ZXIgYm91bmQgb2YgdGhlIGJvdW5kaW5nIGJveC5cclxuICAgICAqIEBwcm9wZXJ0eSBsb3dlckJvdW5kXHJcbiAgICAgKiBAdHlwZSB7VmVjM31cclxuICAgICAqL1xyXG4gICAgdGhpcy5sb3dlckJvdW5kID0gbmV3IFZlYzMoKTtcclxuICAgIGlmKG9wdGlvbnMubG93ZXJCb3VuZCl7XHJcbiAgICAgICAgdGhpcy5sb3dlckJvdW5kLmNvcHkob3B0aW9ucy5sb3dlckJvdW5kKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSB1cHBlciBib3VuZCBvZiB0aGUgYm91bmRpbmcgYm94LlxyXG4gICAgICogQHByb3BlcnR5IHVwcGVyQm91bmRcclxuICAgICAqIEB0eXBlIHtWZWMzfVxyXG4gICAgICovXHJcbiAgICB0aGlzLnVwcGVyQm91bmQgPSBuZXcgVmVjMygpO1xyXG4gICAgaWYob3B0aW9ucy51cHBlckJvdW5kKXtcclxuICAgICAgICB0aGlzLnVwcGVyQm91bmQuY29weShvcHRpb25zLnVwcGVyQm91bmQpO1xyXG4gICAgfVxyXG59XHJcblxyXG52YXIgdG1wID0gbmV3IFZlYzMoKTtcclxuXHJcbi8qKlxyXG4gKiBTZXQgdGhlIEFBQkIgYm91bmRzIGZyb20gYSBzZXQgb2YgcG9pbnRzLlxyXG4gKiBAbWV0aG9kIHNldEZyb21Qb2ludHNcclxuICogQHBhcmFtIHtBcnJheX0gcG9pbnRzIEFuIGFycmF5IG9mIFZlYzMncy5cclxuICogQHBhcmFtIHtWZWMzfSBwb3NpdGlvblxyXG4gKiBAcGFyYW0ge1F1YXRlcm5pb259IHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtudW1iZXJ9IHNraW5TaXplXHJcbiAqIEByZXR1cm4ge0FBQkJ9IFRoZSBzZWxmIG9iamVjdFxyXG4gKi9cclxuQUFCQi5wcm90b3R5cGUuc2V0RnJvbVBvaW50cyA9IGZ1bmN0aW9uKHBvaW50cywgcG9zaXRpb24sIHF1YXRlcm5pb24sIHNraW5TaXplKXtcclxuICAgIHZhciBsID0gdGhpcy5sb3dlckJvdW5kLFxyXG4gICAgICAgIHUgPSB0aGlzLnVwcGVyQm91bmQsXHJcbiAgICAgICAgcSA9IHF1YXRlcm5pb247XHJcblxyXG4gICAgLy8gU2V0IHRvIHRoZSBmaXJzdCBwb2ludFxyXG4gICAgbC5jb3B5KHBvaW50c1swXSk7XHJcbiAgICBpZihxKXtcclxuICAgICAgICBxLnZtdWx0KGwsIGwpO1xyXG4gICAgfVxyXG4gICAgdS5jb3B5KGwpO1xyXG5cclxuICAgIGZvcih2YXIgaSA9IDE7IGk8cG9pbnRzLmxlbmd0aDsgaSsrKXtcclxuICAgICAgICB2YXIgcCA9IHBvaW50c1tpXTtcclxuXHJcbiAgICAgICAgaWYocSl7XHJcbiAgICAgICAgICAgIHEudm11bHQocCwgdG1wKTtcclxuICAgICAgICAgICAgcCA9IHRtcDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKHAueCA+IHUueCl7IHUueCA9IHAueDsgfVxyXG4gICAgICAgIGlmKHAueCA8IGwueCl7IGwueCA9IHAueDsgfVxyXG4gICAgICAgIGlmKHAueSA+IHUueSl7IHUueSA9IHAueTsgfVxyXG4gICAgICAgIGlmKHAueSA8IGwueSl7IGwueSA9IHAueTsgfVxyXG4gICAgICAgIGlmKHAueiA+IHUueil7IHUueiA9IHAuejsgfVxyXG4gICAgICAgIGlmKHAueiA8IGwueil7IGwueiA9IHAuejsgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEFkZCBvZmZzZXRcclxuICAgIGlmIChwb3NpdGlvbikge1xyXG4gICAgICAgIHBvc2l0aW9uLnZhZGQobCwgbCk7XHJcbiAgICAgICAgcG9zaXRpb24udmFkZCh1LCB1KTtcclxuICAgIH1cclxuXHJcbiAgICBpZihza2luU2l6ZSl7XHJcbiAgICAgICAgbC54IC09IHNraW5TaXplO1xyXG4gICAgICAgIGwueSAtPSBza2luU2l6ZTtcclxuICAgICAgICBsLnogLT0gc2tpblNpemU7XHJcbiAgICAgICAgdS54ICs9IHNraW5TaXplO1xyXG4gICAgICAgIHUueSArPSBza2luU2l6ZTtcclxuICAgICAgICB1LnogKz0gc2tpblNpemU7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogQ29weSBib3VuZHMgZnJvbSBhbiBBQUJCIHRvIHRoaXMgQUFCQlxyXG4gKiBAbWV0aG9kIGNvcHlcclxuICogQHBhcmFtICB7QUFCQn0gYWFiYiBTb3VyY2UgdG8gY29weSBmcm9tXHJcbiAqIEByZXR1cm4ge0FBQkJ9IFRoZSB0aGlzIG9iamVjdCwgZm9yIGNoYWluYWJpbGl0eVxyXG4gKi9cclxuQUFCQi5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKGFhYmIpe1xyXG4gICAgdGhpcy5sb3dlckJvdW5kLmNvcHkoYWFiYi5sb3dlckJvdW5kKTtcclxuICAgIHRoaXMudXBwZXJCb3VuZC5jb3B5KGFhYmIudXBwZXJCb3VuZCk7XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDbG9uZSBhbiBBQUJCXHJcbiAqIEBtZXRob2QgY2xvbmVcclxuICovXHJcbkFBQkIucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKXtcclxuICAgIHJldHVybiBuZXcgQUFCQigpLmNvcHkodGhpcyk7XHJcbn07XHJcblxyXG4vKipcclxuICogRXh0ZW5kIHRoaXMgQUFCQiBzbyB0aGF0IGl0IGNvdmVycyB0aGUgZ2l2ZW4gQUFCQiB0b28uXHJcbiAqIEBtZXRob2QgZXh0ZW5kXHJcbiAqIEBwYXJhbSAge0FBQkJ9IGFhYmJcclxuICovXHJcbkFBQkIucHJvdG90eXBlLmV4dGVuZCA9IGZ1bmN0aW9uKGFhYmIpe1xyXG4gICAgdGhpcy5sb3dlckJvdW5kLnggPSBNYXRoLm1pbih0aGlzLmxvd2VyQm91bmQueCwgYWFiYi5sb3dlckJvdW5kLngpO1xyXG4gICAgdGhpcy51cHBlckJvdW5kLnggPSBNYXRoLm1heCh0aGlzLnVwcGVyQm91bmQueCwgYWFiYi51cHBlckJvdW5kLngpO1xyXG4gICAgdGhpcy5sb3dlckJvdW5kLnkgPSBNYXRoLm1pbih0aGlzLmxvd2VyQm91bmQueSwgYWFiYi5sb3dlckJvdW5kLnkpO1xyXG4gICAgdGhpcy51cHBlckJvdW5kLnkgPSBNYXRoLm1heCh0aGlzLnVwcGVyQm91bmQueSwgYWFiYi51cHBlckJvdW5kLnkpO1xyXG4gICAgdGhpcy5sb3dlckJvdW5kLnogPSBNYXRoLm1pbih0aGlzLmxvd2VyQm91bmQueiwgYWFiYi5sb3dlckJvdW5kLnopO1xyXG4gICAgdGhpcy51cHBlckJvdW5kLnogPSBNYXRoLm1heCh0aGlzLnVwcGVyQm91bmQueiwgYWFiYi51cHBlckJvdW5kLnopO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gQUFCQiBvdmVybGFwcyB0aGlzIEFBQkIuXHJcbiAqIEBtZXRob2Qgb3ZlcmxhcHNcclxuICogQHBhcmFtICB7QUFCQn0gYWFiYlxyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gKi9cclxuQUFCQi5wcm90b3R5cGUub3ZlcmxhcHMgPSBmdW5jdGlvbihhYWJiKXtcclxuICAgIHZhciBsMSA9IHRoaXMubG93ZXJCb3VuZCxcclxuICAgICAgICB1MSA9IHRoaXMudXBwZXJCb3VuZCxcclxuICAgICAgICBsMiA9IGFhYmIubG93ZXJCb3VuZCxcclxuICAgICAgICB1MiA9IGFhYmIudXBwZXJCb3VuZDtcclxuXHJcbiAgICAvLyAgICAgIGwyICAgICAgICB1MlxyXG4gICAgLy8gICAgICB8LS0tLS0tLS0tfFxyXG4gICAgLy8gfC0tLS0tLS0tfFxyXG4gICAgLy8gbDEgICAgICAgdTFcclxuXHJcbiAgICAvLyBubyBjb25zaWRlciBjb250YWluIGNhc2VcclxuICAgIC8vIGxldCBvdmVybGFwc1ggPSAoKGwyLnggPD0gdTEueCAmJiB1MS54IDw9IHUyLngpIHx8IChsMS54IDw9IHUyLnggJiYgdTIueCA8PSB1MS54KSk7XHJcbiAgICAvLyBsZXQgb3ZlcmxhcHNZID0gKChsMi55IDw9IHUxLnkgJiYgdTEueSA8PSB1Mi55KSB8fCAobDEueSA8PSB1Mi55ICYmIHUyLnkgPD0gdTEueSkpO1xyXG4gICAgLy8gbGV0IG92ZXJsYXBzWiA9ICgobDIueiA8PSB1MS56ICYmIHUxLnogPD0gdTIueikgfHwgKGwxLnogPD0gdTIueiAmJiB1Mi56IDw9IHUxLnopKTtcclxuXHJcbiAgICAvLyBvdmVybGFwcyBtdXN0IGNvbnNpZGVyIGNvbnRhaW4gY2FzZVxyXG4gICAgLy8gb3IgcmF5IGNhc3QgbWF5IG1pc3NcclxuICAgIGxldCBvdmVybGFwc1ggPSBsMi54IDw9IHUxLnggJiYgbDEueCA8PSB1Mi54O1xyXG4gICAgbGV0IG92ZXJsYXBzWSA9IGwyLnkgPD0gdTEueSAmJiBsMS55IDw9IHUyLnk7XHJcbiAgICBsZXQgb3ZlcmxhcHNaID0gbDIueiA8PSB1MS56ICYmIGwxLnogPD0gdTIuejtcclxuXHJcbiAgICByZXR1cm4gb3ZlcmxhcHNYICYmIG92ZXJsYXBzWSAmJiBvdmVybGFwc1o7XHJcbn07XHJcblxyXG4vLyBNb3N0bHkgZm9yIGRlYnVnZ2luZ1xyXG5BQUJCLnByb3RvdHlwZS52b2x1bWUgPSBmdW5jdGlvbigpe1xyXG4gICAgdmFyIGwgPSB0aGlzLmxvd2VyQm91bmQsXHJcbiAgICAgICAgdSA9IHRoaXMudXBwZXJCb3VuZDtcclxuICAgIHJldHVybiAodS54IC0gbC54KSAqICh1LnkgLSBsLnkpICogKHUueiAtIGwueik7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gQUFCQiBpcyBmdWxseSBjb250YWluZWQgaW4gdGhpcyBBQUJCLlxyXG4gKiBAbWV0aG9kIGNvbnRhaW5zXHJcbiAqIEBwYXJhbSB7QUFCQn0gYWFiYlxyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gKi9cclxuQUFCQi5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbihhYWJiKXtcclxuICAgIHZhciBsMSA9IHRoaXMubG93ZXJCb3VuZCxcclxuICAgICAgICB1MSA9IHRoaXMudXBwZXJCb3VuZCxcclxuICAgICAgICBsMiA9IGFhYmIubG93ZXJCb3VuZCxcclxuICAgICAgICB1MiA9IGFhYmIudXBwZXJCb3VuZDtcclxuXHJcbiAgICAvLyAgICAgIGwyICAgICAgICB1MlxyXG4gICAgLy8gICAgICB8LS0tLS0tLS0tfFxyXG4gICAgLy8gfC0tLS0tLS0tLS0tLS0tLXxcclxuICAgIC8vIGwxICAgICAgICAgICAgICB1MVxyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgKGwxLnggPD0gbDIueCAmJiB1MS54ID49IHUyLngpICYmXHJcbiAgICAgICAgKGwxLnkgPD0gbDIueSAmJiB1MS55ID49IHUyLnkpICYmXHJcbiAgICAgICAgKGwxLnogPD0gbDIueiAmJiB1MS56ID49IHUyLnopXHJcbiAgICApO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgZ2V0Q29ybmVyc1xyXG4gKiBAcGFyYW0ge1ZlYzN9IGFcclxuICogQHBhcmFtIHtWZWMzfSBiXHJcbiAqIEBwYXJhbSB7VmVjM30gY1xyXG4gKiBAcGFyYW0ge1ZlYzN9IGRcclxuICogQHBhcmFtIHtWZWMzfSBlXHJcbiAqIEBwYXJhbSB7VmVjM30gZlxyXG4gKiBAcGFyYW0ge1ZlYzN9IGdcclxuICogQHBhcmFtIHtWZWMzfSBoXHJcbiAqL1xyXG5BQUJCLnByb3RvdHlwZS5nZXRDb3JuZXJzID0gZnVuY3Rpb24oYSwgYiwgYywgZCwgZSwgZiwgZywgaCl7XHJcbiAgICB2YXIgbCA9IHRoaXMubG93ZXJCb3VuZCxcclxuICAgICAgICB1ID0gdGhpcy51cHBlckJvdW5kO1xyXG5cclxuICAgIGEuY29weShsKTtcclxuICAgIGIuc2V0KCB1LngsIGwueSwgbC56ICk7XHJcbiAgICBjLnNldCggdS54LCB1LnksIGwueiApO1xyXG4gICAgZC5zZXQoIGwueCwgdS55LCB1LnogKTtcclxuICAgIGUuc2V0KCB1LngsIGwueSwgdS56ICk7XHJcbiAgICBmLnNldCggbC54LCB1LnksIGwueiApO1xyXG4gICAgZy5zZXQoIGwueCwgbC55LCB1LnogKTtcclxuICAgIGguY29weSh1KTtcclxufTtcclxuXHJcbnZhciB0cmFuc2Zvcm1JbnRvRnJhbWVfY29ybmVycyA9IFtcclxuICAgIG5ldyBWZWMzKCksXHJcbiAgICBuZXcgVmVjMygpLFxyXG4gICAgbmV3IFZlYzMoKSxcclxuICAgIG5ldyBWZWMzKCksXHJcbiAgICBuZXcgVmVjMygpLFxyXG4gICAgbmV3IFZlYzMoKSxcclxuICAgIG5ldyBWZWMzKCksXHJcbiAgICBuZXcgVmVjMygpXHJcbl07XHJcblxyXG4vKipcclxuICogR2V0IHRoZSByZXByZXNlbnRhdGlvbiBvZiBhbiBBQUJCIGluIGFub3RoZXIgZnJhbWUuXHJcbiAqIEBtZXRob2QgdG9Mb2NhbEZyYW1lXHJcbiAqIEBwYXJhbSAge1RyYW5zZm9ybX0gZnJhbWVcclxuICogQHBhcmFtICB7QUFCQn0gdGFyZ2V0XHJcbiAqIEByZXR1cm4ge0FBQkJ9IFRoZSBcInRhcmdldFwiIEFBQkIgb2JqZWN0LlxyXG4gKi9cclxuQUFCQi5wcm90b3R5cGUudG9Mb2NhbEZyYW1lID0gZnVuY3Rpb24oZnJhbWUsIHRhcmdldCl7XHJcblxyXG4gICAgdmFyIGNvcm5lcnMgPSB0cmFuc2Zvcm1JbnRvRnJhbWVfY29ybmVycztcclxuICAgIHZhciBhID0gY29ybmVyc1swXTtcclxuICAgIHZhciBiID0gY29ybmVyc1sxXTtcclxuICAgIHZhciBjID0gY29ybmVyc1syXTtcclxuICAgIHZhciBkID0gY29ybmVyc1szXTtcclxuICAgIHZhciBlID0gY29ybmVyc1s0XTtcclxuICAgIHZhciBmID0gY29ybmVyc1s1XTtcclxuICAgIHZhciBnID0gY29ybmVyc1s2XTtcclxuICAgIHZhciBoID0gY29ybmVyc1s3XTtcclxuXHJcbiAgICAvLyBHZXQgY29ybmVycyBpbiBjdXJyZW50IGZyYW1lXHJcbiAgICB0aGlzLmdldENvcm5lcnMoYSwgYiwgYywgZCwgZSwgZiwgZywgaCk7XHJcblxyXG4gICAgLy8gVHJhbnNmb3JtIHRoZW0gdG8gbmV3IGxvY2FsIGZyYW1lXHJcbiAgICBmb3IodmFyIGk9MDsgaSAhPT0gODsgaSsrKXtcclxuICAgICAgICB2YXIgY29ybmVyID0gY29ybmVyc1tpXTtcclxuICAgICAgICBmcmFtZS5wb2ludFRvTG9jYWwoY29ybmVyLCBjb3JuZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0YXJnZXQuc2V0RnJvbVBvaW50cyhjb3JuZXJzKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXQgdGhlIHJlcHJlc2VudGF0aW9uIG9mIGFuIEFBQkIgaW4gdGhlIGdsb2JhbCBmcmFtZS5cclxuICogQG1ldGhvZCB0b1dvcmxkRnJhbWVcclxuICogQHBhcmFtICB7VHJhbnNmb3JtfSBmcmFtZVxyXG4gKiBAcGFyYW0gIHtBQUJCfSB0YXJnZXRcclxuICogQHJldHVybiB7QUFCQn0gVGhlIFwidGFyZ2V0XCIgQUFCQiBvYmplY3QuXHJcbiAqL1xyXG5BQUJCLnByb3RvdHlwZS50b1dvcmxkRnJhbWUgPSBmdW5jdGlvbihmcmFtZSwgdGFyZ2V0KXtcclxuXHJcbiAgICB2YXIgY29ybmVycyA9IHRyYW5zZm9ybUludG9GcmFtZV9jb3JuZXJzO1xyXG4gICAgdmFyIGEgPSBjb3JuZXJzWzBdO1xyXG4gICAgdmFyIGIgPSBjb3JuZXJzWzFdO1xyXG4gICAgdmFyIGMgPSBjb3JuZXJzWzJdO1xyXG4gICAgdmFyIGQgPSBjb3JuZXJzWzNdO1xyXG4gICAgdmFyIGUgPSBjb3JuZXJzWzRdO1xyXG4gICAgdmFyIGYgPSBjb3JuZXJzWzVdO1xyXG4gICAgdmFyIGcgPSBjb3JuZXJzWzZdO1xyXG4gICAgdmFyIGggPSBjb3JuZXJzWzddO1xyXG5cclxuICAgIC8vIEdldCBjb3JuZXJzIGluIGN1cnJlbnQgZnJhbWVcclxuICAgIHRoaXMuZ2V0Q29ybmVycyhhLCBiLCBjLCBkLCBlLCBmLCBnLCBoKTtcclxuXHJcbiAgICAvLyBUcmFuc2Zvcm0gdGhlbSB0byBuZXcgbG9jYWwgZnJhbWVcclxuICAgIGZvcih2YXIgaT0wOyBpICE9PSA4OyBpKyspe1xyXG4gICAgICAgIHZhciBjb3JuZXIgPSBjb3JuZXJzW2ldO1xyXG4gICAgICAgIGZyYW1lLnBvaW50VG9Xb3JsZChjb3JuZXIsIGNvcm5lcik7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRhcmdldC5zZXRGcm9tUG9pbnRzKGNvcm5lcnMpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIHRoZSBBQUJCIGlzIGhpdCBieSBhIHJheS5cclxuICogQHBhcmFtICB7UmF5fSByYXlcclxuICogQHJldHVybiB7bnVtYmVyfVxyXG4gKi9cclxuQUFCQi5wcm90b3R5cGUub3ZlcmxhcHNSYXkgPSBmdW5jdGlvbihyYXkpe1xyXG4gICAgdmFyIHQgPSAwO1xyXG5cclxuICAgIC8vIHJheS5kaXJlY3Rpb24gaXMgdW5pdCBkaXJlY3Rpb24gdmVjdG9yIG9mIHJheVxyXG4gICAgdmFyIGRpckZyYWNYID0gMSAvIHJheS5fZGlyZWN0aW9uLng7XHJcbiAgICB2YXIgZGlyRnJhY1kgPSAxIC8gcmF5Ll9kaXJlY3Rpb24ueTtcclxuICAgIHZhciBkaXJGcmFjWiA9IDEgLyByYXkuX2RpcmVjdGlvbi56O1xyXG5cclxuICAgIC8vIHRoaXMubG93ZXJCb3VuZCBpcyB0aGUgY29ybmVyIG9mIEFBQkIgd2l0aCBtaW5pbWFsIGNvb3JkaW5hdGVzIC0gbGVmdCBib3R0b20sIHJ0IGlzIG1heGltYWwgY29ybmVyXHJcbiAgICB2YXIgdDEgPSAodGhpcy5sb3dlckJvdW5kLnggLSByYXkuZnJvbS54KSAqIGRpckZyYWNYO1xyXG4gICAgdmFyIHQyID0gKHRoaXMudXBwZXJCb3VuZC54IC0gcmF5LmZyb20ueCkgKiBkaXJGcmFjWDtcclxuICAgIHZhciB0MyA9ICh0aGlzLmxvd2VyQm91bmQueSAtIHJheS5mcm9tLnkpICogZGlyRnJhY1k7XHJcbiAgICB2YXIgdDQgPSAodGhpcy51cHBlckJvdW5kLnkgLSByYXkuZnJvbS55KSAqIGRpckZyYWNZO1xyXG4gICAgdmFyIHQ1ID0gKHRoaXMubG93ZXJCb3VuZC56IC0gcmF5LmZyb20ueikgKiBkaXJGcmFjWjtcclxuICAgIHZhciB0NiA9ICh0aGlzLnVwcGVyQm91bmQueiAtIHJheS5mcm9tLnopICogZGlyRnJhY1o7XHJcblxyXG4gICAgLy8gdmFyIHRtaW4gPSBNYXRoLm1heChNYXRoLm1heChNYXRoLm1pbih0MSwgdDIpLCBNYXRoLm1pbih0MywgdDQpKSk7XHJcbiAgICAvLyB2YXIgdG1heCA9IE1hdGgubWluKE1hdGgubWluKE1hdGgubWF4KHQxLCB0MiksIE1hdGgubWF4KHQzLCB0NCkpKTtcclxuICAgIHZhciB0bWluID0gTWF0aC5tYXgoTWF0aC5tYXgoTWF0aC5taW4odDEsIHQyKSwgTWF0aC5taW4odDMsIHQ0KSksIE1hdGgubWluKHQ1LCB0NikpO1xyXG4gICAgdmFyIHRtYXggPSBNYXRoLm1pbihNYXRoLm1pbihNYXRoLm1heCh0MSwgdDIpLCBNYXRoLm1heCh0MywgdDQpKSwgTWF0aC5tYXgodDUsIHQ2KSk7XHJcblxyXG4gICAgLy8gaWYgdG1heCA8IDAsIHJheSAobGluZSkgaXMgaW50ZXJzZWN0aW5nIEFBQkIsIGJ1dCB3aG9sZSBBQUJCIGlzIGJlaGluZyB1c1xyXG4gICAgaWYgKHRtYXggPCAwKXtcclxuICAgICAgICAvL3QgPSB0bWF4O1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBpZiB0bWluID4gdG1heCwgcmF5IGRvZXNuJ3QgaW50ZXJzZWN0IEFBQkJcclxuICAgIGlmICh0bWluID4gdG1heCl7XHJcbiAgICAgICAgLy90ID0gdG1heDtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn07XHJcblxyXG59LHtcIi4uL21hdGgvVmVjM1wiOjMxLFwiLi4vdXRpbHMvVXRpbHNcIjo1NH1dLDQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xyXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5Q29sbGlzaW9uTWF0cml4O1xyXG5cclxuLyoqXHJcbiAqIENvbGxpc2lvbiBcIm1hdHJpeFwiLiBJdCdzIGFjdHVhbGx5IGEgdHJpYW5ndWxhci1zaGFwZWQgYXJyYXkgb2Ygd2hldGhlciB0d28gYm9kaWVzIGFyZSB0b3VjaGluZyB0aGlzIHN0ZXAsIGZvciByZWZlcmVuY2UgbmV4dCBzdGVwXHJcbiAqIEBjbGFzcyBBcnJheUNvbGxpc2lvbk1hdHJpeFxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbmZ1bmN0aW9uIEFycmF5Q29sbGlzaW9uTWF0cml4KCkge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG1hdHJpeCBzdG9yYWdlXHJcbiAgICAgKiBAcHJvcGVydHkgbWF0cml4XHJcbiAgICAgKiBAdHlwZSB7QXJyYXl9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubWF0cml4ID0gW107XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgYW4gZWxlbWVudFxyXG4gKiBAbWV0aG9kIGdldFxyXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGlcclxuICogQHBhcmFtICB7TnVtYmVyfSBqXHJcbiAqIEByZXR1cm4ge051bWJlcn1cclxuICovXHJcbkFycmF5Q29sbGlzaW9uTWF0cml4LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihpLCBqKSB7XHJcbiAgICBpID0gaS5pbmRleDtcclxuICAgIGogPSBqLmluZGV4O1xyXG4gICAgaWYgKGogPiBpKSB7XHJcbiAgICAgICAgdmFyIHRlbXAgPSBqO1xyXG4gICAgICAgIGogPSBpO1xyXG4gICAgICAgIGkgPSB0ZW1wO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMubWF0cml4WyhpKihpICsgMSk+PjEpICsgai0xXTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTZXQgYW4gZWxlbWVudFxyXG4gKiBAbWV0aG9kIHNldFxyXG4gKiBAcGFyYW0ge051bWJlcn0gaVxyXG4gKiBAcGFyYW0ge051bWJlcn0galxyXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcclxuICovXHJcbkFycmF5Q29sbGlzaW9uTWF0cml4LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihpLCBqLCB2YWx1ZSkge1xyXG4gICAgaSA9IGkuaW5kZXg7XHJcbiAgICBqID0gai5pbmRleDtcclxuICAgIGlmIChqID4gaSkge1xyXG4gICAgICAgIHZhciB0ZW1wID0gajtcclxuICAgICAgICBqID0gaTtcclxuICAgICAgICBpID0gdGVtcDtcclxuICAgIH1cclxuICAgIHRoaXMubWF0cml4WyhpKihpICsgMSk+PjEpICsgai0xXSA9IHZhbHVlID8gMSA6IDA7XHJcbn07XHJcblxyXG4vKipcclxuICogU2V0cyBhbGwgZWxlbWVudHMgdG8gemVyb1xyXG4gKiBAbWV0aG9kIHJlc2V0XHJcbiAqL1xyXG5BcnJheUNvbGxpc2lvbk1hdHJpeC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpIHtcclxuICAgIGZvciAodmFyIGk9MCwgbD10aGlzLm1hdHJpeC5sZW5ndGg7IGkhPT1sOyBpKyspIHtcclxuICAgICAgICB0aGlzLm1hdHJpeFtpXT0wO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFNldHMgdGhlIG1heCBudW1iZXIgb2Ygb2JqZWN0c1xyXG4gKiBAbWV0aG9kIHNldE51bU9iamVjdHNcclxuICogQHBhcmFtIHtOdW1iZXJ9IG5cclxuICovXHJcbkFycmF5Q29sbGlzaW9uTWF0cml4LnByb3RvdHlwZS5zZXROdW1PYmplY3RzID0gZnVuY3Rpb24obikge1xyXG4gICAgdGhpcy5tYXRyaXgubGVuZ3RoID0gbioobi0xKT4+MTtcclxufTtcclxuXHJcbn0se31dLDU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xyXG52YXIgQm9keSA9IF9kZXJlcV8oJy4uL29iamVjdHMvQm9keScpO1xyXG52YXIgVmVjMyA9IF9kZXJlcV8oJy4uL21hdGgvVmVjMycpO1xyXG52YXIgUXVhdGVybmlvbiA9IF9kZXJlcV8oJy4uL21hdGgvUXVhdGVybmlvbicpO1xyXG52YXIgU2hhcGUgPSBfZGVyZXFfKCcuLi9zaGFwZXMvU2hhcGUnKTtcclxudmFyIFBsYW5lID0gX2RlcmVxXygnLi4vc2hhcGVzL1BsYW5lJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEJyb2FkcGhhc2U7XHJcblxyXG4vKipcclxuICogQmFzZSBjbGFzcyBmb3IgYnJvYWRwaGFzZSBpbXBsZW1lbnRhdGlvbnNcclxuICogQGNsYXNzIEJyb2FkcGhhc2VcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBhdXRob3Igc2NodGVwcGVcclxuICovXHJcbmZ1bmN0aW9uIEJyb2FkcGhhc2UoKXtcclxuICAgIC8qKlxyXG4gICAgKiBUaGUgd29ybGQgdG8gc2VhcmNoIGZvciBjb2xsaXNpb25zIGluLlxyXG4gICAgKiBAcHJvcGVydHkgd29ybGRcclxuICAgICogQHR5cGUge1dvcmxkfVxyXG4gICAgKi9cclxuICAgIHRoaXMud29ybGQgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSWYgc2V0IHRvIHRydWUsIHRoZSBicm9hZHBoYXNlIHVzZXMgYm91bmRpbmcgYm94ZXMgZm9yIGludGVyc2VjdGlvbiB0ZXN0LCBlbHNlIGl0IHVzZXMgYm91bmRpbmcgc3BoZXJlcy5cclxuICAgICAqIEBwcm9wZXJ0eSB1c2VCb3VuZGluZ0JveGVzXHJcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgdGhpcy51c2VCb3VuZGluZ0JveGVzID0gZmFsc2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdG8gdHJ1ZSBpZiB0aGUgb2JqZWN0cyBpbiB0aGUgd29ybGQgbW92ZWQuXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IGRpcnR5XHJcbiAgICAgKi9cclxuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0IHRoZSBjb2xsaXNpb24gcGFpcnMgZnJvbSB0aGUgd29ybGRcclxuICogQG1ldGhvZCBjb2xsaXNpb25QYWlyc1xyXG4gKiBAcGFyYW0ge1dvcmxkfSB3b3JsZCBUaGUgd29ybGQgdG8gc2VhcmNoIGluXHJcbiAqIEBwYXJhbSB7QXJyYXl9IHAxIEVtcHR5IGFycmF5IHRvIGJlIGZpbGxlZCB3aXRoIGJvZHkgb2JqZWN0c1xyXG4gKiBAcGFyYW0ge0FycmF5fSBwMiBFbXB0eSBhcnJheSB0byBiZSBmaWxsZWQgd2l0aCBib2R5IG9iamVjdHNcclxuICovXHJcbkJyb2FkcGhhc2UucHJvdG90eXBlLmNvbGxpc2lvblBhaXJzID0gZnVuY3Rpb24od29ybGQscDEscDIpe1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiY29sbGlzaW9uUGFpcnMgbm90IGltcGxlbWVudGVkIGZvciB0aGlzIEJyb2FkUGhhc2UgY2xhc3MhXCIpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIGEgYm9keSBwYWlyIG5lZWRzIHRvIGJlIGludGVyc2VjdGlvbiB0ZXN0ZWQgYXQgYWxsLlxyXG4gKiBAbWV0aG9kIG5lZWRCcm9hZHBoYXNlQ29sbGlzaW9uXHJcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUFcclxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxyXG4gKiBAcmV0dXJuIHtib29sfVxyXG4gKi9cclxuQnJvYWRwaGFzZS5wcm90b3R5cGUubmVlZEJyb2FkcGhhc2VDb2xsaXNpb24gPSBmdW5jdGlvbihib2R5QSxib2R5Qil7XHJcblxyXG4gICAgLy8gQ2hlY2sgY29sbGlzaW9uIGZpbHRlciBtYXNrc1xyXG4gICAgaWYoKGJvZHlBLmNvbGxpc2lvbkZpbHRlckdyb3VwICYgYm9keUIuY29sbGlzaW9uRmlsdGVyTWFzayk9PT0wIHx8IChib2R5Qi5jb2xsaXNpb25GaWx0ZXJHcm91cCAmIGJvZHlBLmNvbGxpc2lvbkZpbHRlck1hc2spPT09MCl7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENoZWNrIGhhcyB0cmlnZ2VyXHJcbiAgICBpZihib2R5QS5oYXNUcmlnZ2VyIHx8IGJvZHlCLmhhc1RyaWdnZXIpe1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENoZWNrIHR5cGVzXHJcbiAgICBpZigoKGJvZHlBLnR5cGUgJiBCb2R5LlNUQVRJQykhPT0wIHx8IGJvZHlBLnNsZWVwU3RhdGUgPT09IEJvZHkuU0xFRVBJTkcpICYmXHJcbiAgICAgICAoKGJvZHlCLnR5cGUgJiBCb2R5LlNUQVRJQykhPT0wIHx8IGJvZHlCLnNsZWVwU3RhdGUgPT09IEJvZHkuU0xFRVBJTkcpKSB7XHJcbiAgICAgICAgLy8gQm90aCBib2RpZXMgYXJlIHN0YXRpYyBvciBzbGVlcGluZy4gU2tpcC5cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn07XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgdGhlIGJvdW5kaW5nIHZvbHVtZXMgb2YgdHdvIGJvZGllcyBpbnRlcnNlY3QuXHJcbiAqIEBtZXRob2QgaW50ZXJzZWN0aW9uVGVzdFxyXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXHJcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUJcclxuICogQHBhcmFtIHthcnJheX0gcGFpcnMxXHJcbiAqIEBwYXJhbSB7YXJyYXl9IHBhaXJzMlxyXG4gICovXHJcbkJyb2FkcGhhc2UucHJvdG90eXBlLmludGVyc2VjdGlvblRlc3QgPSBmdW5jdGlvbihib2R5QSwgYm9keUIsIHBhaXJzMSwgcGFpcnMyKXtcclxuICAgIGlmKHRoaXMudXNlQm91bmRpbmdCb3hlcyl7XHJcbiAgICAgICAgdGhpcy5kb0JvdW5kaW5nQm94QnJvYWRwaGFzZShib2R5QSxib2R5QixwYWlyczEscGFpcnMyKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5kb0JvdW5kaW5nU3BoZXJlQnJvYWRwaGFzZShib2R5QSxib2R5QixwYWlyczEscGFpcnMyKTtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiB0aGUgYm91bmRpbmcgc3BoZXJlcyBvZiB0d28gYm9kaWVzIGFyZSBpbnRlcnNlY3RpbmcuXHJcbiAqIEBtZXRob2QgZG9Cb3VuZGluZ1NwaGVyZUJyb2FkcGhhc2VcclxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxyXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXHJcbiAqIEBwYXJhbSB7QXJyYXl9IHBhaXJzMSBib2R5QSBpcyBhcHBlbmRlZCB0byB0aGlzIGFycmF5IGlmIGludGVyc2VjdGlvblxyXG4gKiBAcGFyYW0ge0FycmF5fSBwYWlyczIgYm9keUIgaXMgYXBwZW5kZWQgdG8gdGhpcyBhcnJheSBpZiBpbnRlcnNlY3Rpb25cclxuICovXHJcbnZhciBCcm9hZHBoYXNlX2NvbGxpc2lvblBhaXJzX3IgPSBuZXcgVmVjMygpLCAvLyBUZW1wIG9iamVjdHNcclxuICAgIEJyb2FkcGhhc2VfY29sbGlzaW9uUGFpcnNfbm9ybWFsID0gIG5ldyBWZWMzKCksXHJcbiAgICBCcm9hZHBoYXNlX2NvbGxpc2lvblBhaXJzX3F1YXQgPSAgbmV3IFF1YXRlcm5pb24oKSxcclxuICAgIEJyb2FkcGhhc2VfY29sbGlzaW9uUGFpcnNfcmVscG9zICA9ICBuZXcgVmVjMygpO1xyXG5Ccm9hZHBoYXNlLnByb3RvdHlwZS5kb0JvdW5kaW5nU3BoZXJlQnJvYWRwaGFzZSA9IGZ1bmN0aW9uKGJvZHlBLGJvZHlCLHBhaXJzMSxwYWlyczIpe1xyXG4gICAgdmFyIHIgPSBCcm9hZHBoYXNlX2NvbGxpc2lvblBhaXJzX3I7XHJcbiAgICBib2R5Qi5wb3NpdGlvbi52c3ViKGJvZHlBLnBvc2l0aW9uLHIpO1xyXG4gICAgdmFyIGJvdW5kaW5nUmFkaXVzU3VtMiA9IE1hdGgucG93KGJvZHlBLmJvdW5kaW5nUmFkaXVzICsgYm9keUIuYm91bmRpbmdSYWRpdXMsIDIpO1xyXG4gICAgdmFyIG5vcm0yID0gci5ub3JtMigpO1xyXG4gICAgaWYobm9ybTIgPCBib3VuZGluZ1JhZGl1c1N1bTIpe1xyXG4gICAgICAgIHBhaXJzMS5wdXNoKGJvZHlBKTtcclxuICAgICAgICBwYWlyczIucHVzaChib2R5Qik7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgdGhlIGJvdW5kaW5nIGJveGVzIG9mIHR3byBib2RpZXMgYXJlIGludGVyc2VjdGluZy5cclxuICogQG1ldGhvZCBkb0JvdW5kaW5nQm94QnJvYWRwaGFzZVxyXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXHJcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUJcclxuICogQHBhcmFtIHtBcnJheX0gcGFpcnMxXHJcbiAqIEBwYXJhbSB7QXJyYXl9IHBhaXJzMlxyXG4gKi9cclxuQnJvYWRwaGFzZS5wcm90b3R5cGUuZG9Cb3VuZGluZ0JveEJyb2FkcGhhc2UgPSBmdW5jdGlvbihib2R5QSxib2R5QixwYWlyczEscGFpcnMyKXtcclxuICAgIGlmKGJvZHlBLmFhYmJOZWVkc1VwZGF0ZSl7XHJcbiAgICAgICAgYm9keUEuY29tcHV0ZUFBQkIoKTtcclxuICAgIH1cclxuICAgIGlmKGJvZHlCLmFhYmJOZWVkc1VwZGF0ZSl7XHJcbiAgICAgICAgYm9keUIuY29tcHV0ZUFBQkIoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDaGVjayBBQUJCIC8gQUFCQlxyXG4gICAgaWYoYm9keUEuYWFiYi5vdmVybGFwcyhib2R5Qi5hYWJiKSl7XHJcbiAgICAgICAgcGFpcnMxLnB1c2goYm9keUEpO1xyXG4gICAgICAgIHBhaXJzMi5wdXNoKGJvZHlCKTtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZW1vdmVzIGR1cGxpY2F0ZSBwYWlycyBmcm9tIHRoZSBwYWlyIGFycmF5cy5cclxuICogQG1ldGhvZCBtYWtlUGFpcnNVbmlxdWVcclxuICogQHBhcmFtIHtBcnJheX0gcGFpcnMxXHJcbiAqIEBwYXJhbSB7QXJyYXl9IHBhaXJzMlxyXG4gKi9cclxudmFyIEJyb2FkcGhhc2VfbWFrZVBhaXJzVW5pcXVlX3RlbXAgPSB7IGtleXM6W10gfSxcclxuICAgIEJyb2FkcGhhc2VfbWFrZVBhaXJzVW5pcXVlX3AxID0gW10sXHJcbiAgICBCcm9hZHBoYXNlX21ha2VQYWlyc1VuaXF1ZV9wMiA9IFtdO1xyXG5Ccm9hZHBoYXNlLnByb3RvdHlwZS5tYWtlUGFpcnNVbmlxdWUgPSBmdW5jdGlvbihwYWlyczEscGFpcnMyKXtcclxuICAgIHZhciB0ID0gQnJvYWRwaGFzZV9tYWtlUGFpcnNVbmlxdWVfdGVtcCxcclxuICAgICAgICBwMSA9IEJyb2FkcGhhc2VfbWFrZVBhaXJzVW5pcXVlX3AxLFxyXG4gICAgICAgIHAyID0gQnJvYWRwaGFzZV9tYWtlUGFpcnNVbmlxdWVfcDIsXHJcbiAgICAgICAgTiA9IHBhaXJzMS5sZW5ndGg7XHJcblxyXG4gICAgZm9yKHZhciBpPTA7IGkhPT1OOyBpKyspe1xyXG4gICAgICAgIHAxW2ldID0gcGFpcnMxW2ldO1xyXG4gICAgICAgIHAyW2ldID0gcGFpcnMyW2ldO1xyXG4gICAgfVxyXG5cclxuICAgIHBhaXJzMS5sZW5ndGggPSAwO1xyXG4gICAgcGFpcnMyLmxlbmd0aCA9IDA7XHJcblxyXG4gICAgZm9yKHZhciBpPTA7IGkhPT1OOyBpKyspe1xyXG4gICAgICAgIHZhciBpZDEgPSBwMVtpXS5pZCxcclxuICAgICAgICAgICAgaWQyID0gcDJbaV0uaWQ7XHJcbiAgICAgICAgdmFyIGtleSA9IGlkMSA8IGlkMiA/IGlkMStcIixcIitpZDIgOiAgaWQyK1wiLFwiK2lkMTtcclxuICAgICAgICB0W2tleV0gPSBpO1xyXG4gICAgICAgIHQua2V5cy5wdXNoKGtleSk7XHJcbiAgICB9XHJcblxyXG4gICAgZm9yKHZhciBpPTA7IGkhPT10LmtleXMubGVuZ3RoOyBpKyspe1xyXG4gICAgICAgIHZhciBrZXkgPSB0LmtleXMucG9wKCksXHJcbiAgICAgICAgICAgIHBhaXJJbmRleCA9IHRba2V5XTtcclxuICAgICAgICBwYWlyczEucHVzaChwMVtwYWlySW5kZXhdKTtcclxuICAgICAgICBwYWlyczIucHVzaChwMltwYWlySW5kZXhdKTtcclxuICAgICAgICBkZWxldGUgdFtrZXldO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRvIGJlIGltcGxlbWVudGVkIGJ5IHN1YmNhc3Nlc1xyXG4gKiBAbWV0aG9kIHNldFdvcmxkXHJcbiAqIEBwYXJhbSB7V29ybGR9IHdvcmxkXHJcbiAqL1xyXG5Ccm9hZHBoYXNlLnByb3RvdHlwZS5zZXRXb3JsZCA9IGZ1bmN0aW9uKHdvcmxkKXtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiB0aGUgYm91bmRpbmcgc3BoZXJlcyBvZiB0d28gYm9kaWVzIG92ZXJsYXAuXHJcbiAqIEBtZXRob2QgYm91bmRpbmdTcGhlcmVDaGVja1xyXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXHJcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUJcclxuICogQHJldHVybiB7Ym9vbGVhbn1cclxuICovXHJcbnZhciBic2NfZGlzdCA9IG5ldyBWZWMzKCk7XHJcbkJyb2FkcGhhc2UuYm91bmRpbmdTcGhlcmVDaGVjayA9IGZ1bmN0aW9uKGJvZHlBLGJvZHlCKXtcclxuICAgIHZhciBkaXN0ID0gYnNjX2Rpc3Q7XHJcbiAgICBib2R5QS5wb3NpdGlvbi52c3ViKGJvZHlCLnBvc2l0aW9uLGRpc3QpO1xyXG4gICAgcmV0dXJuIE1hdGgucG93KGJvZHlBLnNoYXBlLmJvdW5kaW5nU3BoZXJlUmFkaXVzICsgYm9keUIuc2hhcGUuYm91bmRpbmdTcGhlcmVSYWRpdXMsMikgPiBkaXN0Lm5vcm0yKCk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyBhbGwgdGhlIGJvZGllcyB3aXRoaW4gdGhlIEFBQkIuXHJcbiAqIEBtZXRob2QgYWFiYlF1ZXJ5XHJcbiAqIEBwYXJhbSAge1dvcmxkfSB3b3JsZFxyXG4gKiBAcGFyYW0gIHtBQUJCfSBhYWJiXHJcbiAqIEBwYXJhbSAge2FycmF5fSByZXN1bHQgQW4gYXJyYXkgdG8gc3RvcmUgcmVzdWx0aW5nIGJvZGllcyBpbi5cclxuICogQHJldHVybiB7YXJyYXl9XHJcbiAqL1xyXG5Ccm9hZHBoYXNlLnByb3RvdHlwZS5hYWJiUXVlcnkgPSBmdW5jdGlvbih3b3JsZCwgYWFiYiwgcmVzdWx0KXtcclxuICAgIGNvbnNvbGUud2FybignLmFhYmJRdWVyeSBpcyBub3QgaW1wbGVtZW50ZWQgaW4gdGhpcyBCcm9hZHBoYXNlIHN1YmNsYXNzLicpO1xyXG4gICAgcmV0dXJuIFtdO1xyXG59O1xyXG59LHtcIi4uL21hdGgvUXVhdGVybmlvblwiOjI5LFwiLi4vbWF0aC9WZWMzXCI6MzEsXCIuLi9vYmplY3RzL0JvZHlcIjozMixcIi4uL3NoYXBlcy9QbGFuZVwiOjQzLFwiLi4vc2hhcGVzL1NoYXBlXCI6NDR9XSw2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcclxubW9kdWxlLmV4cG9ydHMgPSBHcmlkQnJvYWRwaGFzZTtcclxuXHJcbnZhciBCcm9hZHBoYXNlID0gX2RlcmVxXygnLi9Ccm9hZHBoYXNlJyk7XHJcbnZhciBWZWMzID0gX2RlcmVxXygnLi4vbWF0aC9WZWMzJyk7XHJcbnZhciBTaGFwZSA9IF9kZXJlcV8oJy4uL3NoYXBlcy9TaGFwZScpO1xyXG5cclxuLyoqXHJcbiAqIEF4aXMgYWxpZ25lZCB1bmlmb3JtIGdyaWQgYnJvYWRwaGFzZS5cclxuICogQGNsYXNzIEdyaWRCcm9hZHBoYXNlXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAZXh0ZW5kcyBCcm9hZHBoYXNlXHJcbiAqIEB0b2RvIE5lZWRzIHN1cHBvcnQgZm9yIG1vcmUgdGhhbiBqdXN0IHBsYW5lcyBhbmQgc3BoZXJlcy5cclxuICogQHBhcmFtIHtWZWMzfSBhYWJiTWluXHJcbiAqIEBwYXJhbSB7VmVjM30gYWFiYk1heFxyXG4gKiBAcGFyYW0ge051bWJlcn0gbnggTnVtYmVyIG9mIGJveGVzIGFsb25nIHhcclxuICogQHBhcmFtIHtOdW1iZXJ9IG55IE51bWJlciBvZiBib3hlcyBhbG9uZyB5XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBueiBOdW1iZXIgb2YgYm94ZXMgYWxvbmcgelxyXG4gKi9cclxuZnVuY3Rpb24gR3JpZEJyb2FkcGhhc2UoYWFiYk1pbixhYWJiTWF4LG54LG55LG56KXtcclxuICAgIEJyb2FkcGhhc2UuYXBwbHkodGhpcyk7XHJcbiAgICB0aGlzLm54ID0gbnggfHwgMTA7XHJcbiAgICB0aGlzLm55ID0gbnkgfHwgMTA7XHJcbiAgICB0aGlzLm56ID0gbnogfHwgMTA7XHJcbiAgICB0aGlzLmFhYmJNaW4gPSBhYWJiTWluIHx8IG5ldyBWZWMzKDEwMCwxMDAsMTAwKTtcclxuICAgIHRoaXMuYWFiYk1heCA9IGFhYmJNYXggfHwgbmV3IFZlYzMoLTEwMCwtMTAwLC0xMDApO1xyXG5cdHZhciBuYmlucyA9IHRoaXMubnggKiB0aGlzLm55ICogdGhpcy5uejtcclxuXHRpZiAobmJpbnMgPD0gMCkge1xyXG5cdFx0dGhyb3cgXCJHcmlkQnJvYWRwaGFzZTogRWFjaCBkaW1lbnNpb24ncyBuIG11c3QgYmUgPjBcIjtcclxuXHR9XHJcbiAgICB0aGlzLmJpbnMgPSBbXTtcclxuXHR0aGlzLmJpbkxlbmd0aHMgPSBbXTsgLy9SYXRoZXIgdGhhbiBjb250aW51YWxseSByZXNpemluZyBhcnJheXMgKHRocmFzaGluZyB0aGUgbWVtb3J5KSwganVzdCByZWNvcmQgbGVuZ3RoIGFuZCBhbGxvdyB0aGVtIHRvIGdyb3dcclxuXHR0aGlzLmJpbnMubGVuZ3RoID0gbmJpbnM7XHJcblx0dGhpcy5iaW5MZW5ndGhzLmxlbmd0aCA9IG5iaW5zO1xyXG5cdGZvciAodmFyIGk9MDtpPG5iaW5zO2krKykge1xyXG5cdFx0dGhpcy5iaW5zW2ldPVtdO1xyXG5cdFx0dGhpcy5iaW5MZW5ndGhzW2ldPTA7XHJcblx0fVxyXG59XHJcbkdyaWRCcm9hZHBoYXNlLnByb3RvdHlwZSA9IG5ldyBCcm9hZHBoYXNlKCk7XHJcbkdyaWRCcm9hZHBoYXNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdyaWRCcm9hZHBoYXNlO1xyXG5cclxuLyoqXHJcbiAqIEdldCBhbGwgdGhlIGNvbGxpc2lvbiBwYWlycyBpbiB0aGUgcGh5c2ljcyB3b3JsZFxyXG4gKiBAbWV0aG9kIGNvbGxpc2lvblBhaXJzXHJcbiAqIEBwYXJhbSB7V29ybGR9IHdvcmxkXHJcbiAqIEBwYXJhbSB7QXJyYXl9IHBhaXJzMVxyXG4gKiBAcGFyYW0ge0FycmF5fSBwYWlyczJcclxuICovXHJcbnZhciBHcmlkQnJvYWRwaGFzZV9jb2xsaXNpb25QYWlyc19kID0gbmV3IFZlYzMoKTtcclxudmFyIEdyaWRCcm9hZHBoYXNlX2NvbGxpc2lvblBhaXJzX2JpblBvcyA9IG5ldyBWZWMzKCk7XHJcbkdyaWRCcm9hZHBoYXNlLnByb3RvdHlwZS5jb2xsaXNpb25QYWlycyA9IGZ1bmN0aW9uKHdvcmxkLHBhaXJzMSxwYWlyczIpe1xyXG4gICAgdmFyIE4gPSB3b3JsZC5udW1PYmplY3RzKCksXHJcbiAgICAgICAgYm9kaWVzID0gd29ybGQuYm9kaWVzO1xyXG5cclxuICAgIHZhciBtYXggPSB0aGlzLmFhYmJNYXgsXHJcbiAgICAgICAgbWluID0gdGhpcy5hYWJiTWluLFxyXG4gICAgICAgIG54ID0gdGhpcy5ueCxcclxuICAgICAgICBueSA9IHRoaXMubnksXHJcbiAgICAgICAgbnogPSB0aGlzLm56O1xyXG5cclxuXHR2YXIgeHN0ZXAgPSBueSpuejtcclxuXHR2YXIgeXN0ZXAgPSBuejtcclxuXHR2YXIgenN0ZXAgPSAxO1xyXG5cclxuICAgIHZhciB4bWF4ID0gbWF4LngsXHJcbiAgICAgICAgeW1heCA9IG1heC55LFxyXG4gICAgICAgIHptYXggPSBtYXgueixcclxuICAgICAgICB4bWluID0gbWluLngsXHJcbiAgICAgICAgeW1pbiA9IG1pbi55LFxyXG4gICAgICAgIHptaW4gPSBtaW4uejtcclxuXHJcbiAgICB2YXIgeG11bHQgPSBueCAvICh4bWF4LXhtaW4pLFxyXG4gICAgICAgIHltdWx0ID0gbnkgLyAoeW1heC15bWluKSxcclxuICAgICAgICB6bXVsdCA9IG56IC8gKHptYXgtem1pbik7XHJcblxyXG4gICAgdmFyIGJpbnNpemVYID0gKHhtYXggLSB4bWluKSAvIG54LFxyXG4gICAgICAgIGJpbnNpemVZID0gKHltYXggLSB5bWluKSAvIG55LFxyXG4gICAgICAgIGJpbnNpemVaID0gKHptYXggLSB6bWluKSAvIG56O1xyXG5cclxuXHR2YXIgYmluUmFkaXVzID0gTWF0aC5zcXJ0KGJpbnNpemVYKmJpbnNpemVYICsgYmluc2l6ZVkqYmluc2l6ZVkgKyBiaW5zaXplWipiaW5zaXplWikgKiAwLjU7XHJcblxyXG4gICAgdmFyIHR5cGVzID0gU2hhcGUudHlwZXM7XHJcbiAgICB2YXIgU1BIRVJFID0gICAgICAgICAgICB0eXBlcy5TUEhFUkUsXHJcbiAgICAgICAgUExBTkUgPSAgICAgICAgICAgICB0eXBlcy5QTEFORSxcclxuICAgICAgICBCT1ggPSAgICAgICAgICAgICAgIHR5cGVzLkJPWCxcclxuICAgICAgICBDT01QT1VORCA9ICAgICAgICAgIHR5cGVzLkNPTVBPVU5ELFxyXG4gICAgICAgIENPTlZFWFBPTFlIRURST04gPSAgdHlwZXMuQ09OVkVYUE9MWUhFRFJPTjtcclxuXHJcbiAgICB2YXIgYmlucz10aGlzLmJpbnMsXHJcblx0XHRiaW5MZW5ndGhzPXRoaXMuYmluTGVuZ3RocyxcclxuICAgICAgICBOYmlucz10aGlzLmJpbnMubGVuZ3RoO1xyXG5cclxuICAgIC8vIFJlc2V0IGJpbnNcclxuICAgIGZvcih2YXIgaT0wOyBpIT09TmJpbnM7IGkrKyl7XHJcbiAgICAgICAgYmluTGVuZ3Roc1tpXSA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGNlaWwgPSBNYXRoLmNlaWw7XHJcblx0dmFyIG1pbiA9IE1hdGgubWluO1xyXG5cdHZhciBtYXggPSBNYXRoLm1heDtcclxuXHJcblx0ZnVuY3Rpb24gYWRkQm94VG9CaW5zKHgwLHkwLHowLHgxLHkxLHoxLGJpKSB7XHJcblx0XHR2YXIgeG9mZjAgPSAoKHgwIC0geG1pbikgKiB4bXVsdCl8MCxcclxuXHRcdFx0eW9mZjAgPSAoKHkwIC0geW1pbikgKiB5bXVsdCl8MCxcclxuXHRcdFx0em9mZjAgPSAoKHowIC0gem1pbikgKiB6bXVsdCl8MCxcclxuXHRcdFx0eG9mZjEgPSBjZWlsKCh4MSAtIHhtaW4pICogeG11bHQpLFxyXG5cdFx0XHR5b2ZmMSA9IGNlaWwoKHkxIC0geW1pbikgKiB5bXVsdCksXHJcblx0XHRcdHpvZmYxID0gY2VpbCgoejEgLSB6bWluKSAqIHptdWx0KTtcclxuXHJcblx0XHRpZiAoeG9mZjAgPCAwKSB7IHhvZmYwID0gMDsgfSBlbHNlIGlmICh4b2ZmMCA+PSBueCkgeyB4b2ZmMCA9IG54IC0gMTsgfVxyXG5cdFx0aWYgKHlvZmYwIDwgMCkgeyB5b2ZmMCA9IDA7IH0gZWxzZSBpZiAoeW9mZjAgPj0gbnkpIHsgeW9mZjAgPSBueSAtIDE7IH1cclxuXHRcdGlmICh6b2ZmMCA8IDApIHsgem9mZjAgPSAwOyB9IGVsc2UgaWYgKHpvZmYwID49IG56KSB7IHpvZmYwID0gbnogLSAxOyB9XHJcblx0XHRpZiAoeG9mZjEgPCAwKSB7IHhvZmYxID0gMDsgfSBlbHNlIGlmICh4b2ZmMSA+PSBueCkgeyB4b2ZmMSA9IG54IC0gMTsgfVxyXG5cdFx0aWYgKHlvZmYxIDwgMCkgeyB5b2ZmMSA9IDA7IH0gZWxzZSBpZiAoeW9mZjEgPj0gbnkpIHsgeW9mZjEgPSBueSAtIDE7IH1cclxuXHRcdGlmICh6b2ZmMSA8IDApIHsgem9mZjEgPSAwOyB9IGVsc2UgaWYgKHpvZmYxID49IG56KSB7IHpvZmYxID0gbnogLSAxOyB9XHJcblxyXG5cdFx0eG9mZjAgKj0geHN0ZXA7XHJcblx0XHR5b2ZmMCAqPSB5c3RlcDtcclxuXHRcdHpvZmYwICo9IHpzdGVwO1xyXG5cdFx0eG9mZjEgKj0geHN0ZXA7XHJcblx0XHR5b2ZmMSAqPSB5c3RlcDtcclxuXHRcdHpvZmYxICo9IHpzdGVwO1xyXG5cclxuXHRcdGZvciAodmFyIHhvZmYgPSB4b2ZmMDsgeG9mZiA8PSB4b2ZmMTsgeG9mZiArPSB4c3RlcCkge1xyXG5cdFx0XHRmb3IgKHZhciB5b2ZmID0geW9mZjA7IHlvZmYgPD0geW9mZjE7IHlvZmYgKz0geXN0ZXApIHtcclxuXHRcdFx0XHRmb3IgKHZhciB6b2ZmID0gem9mZjA7IHpvZmYgPD0gem9mZjE7IHpvZmYgKz0genN0ZXApIHtcclxuXHRcdFx0XHRcdHZhciBpZHggPSB4b2ZmK3lvZmYrem9mZjtcclxuXHRcdFx0XHRcdGJpbnNbaWR4XVtiaW5MZW5ndGhzW2lkeF0rK10gPSBiaTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG4gICAgLy8gUHV0IGFsbCBib2RpZXMgaW50byB0aGUgYmluc1xyXG4gICAgZm9yKHZhciBpPTA7IGkhPT1OOyBpKyspe1xyXG4gICAgICAgIHZhciBiaSA9IGJvZGllc1tpXTtcclxuICAgICAgICB2YXIgc2kgPSBiaS5zaGFwZTtcclxuXHJcbiAgICAgICAgc3dpdGNoKHNpLnR5cGUpe1xyXG4gICAgICAgIGNhc2UgU1BIRVJFOlxyXG4gICAgICAgICAgICAvLyBQdXQgaW4gYmluXHJcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIG92ZXJsYXAgd2l0aCBvdGhlciBiaW5zXHJcbiAgICAgICAgICAgIHZhciB4ID0gYmkucG9zaXRpb24ueCxcclxuICAgICAgICAgICAgICAgIHkgPSBiaS5wb3NpdGlvbi55LFxyXG4gICAgICAgICAgICAgICAgeiA9IGJpLnBvc2l0aW9uLno7XHJcbiAgICAgICAgICAgIHZhciByID0gc2kucmFkaXVzO1xyXG5cclxuXHRcdFx0YWRkQm94VG9CaW5zKHgtciwgeS1yLCB6LXIsIHgrciwgeStyLCB6K3IsIGJpKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIGNhc2UgUExBTkU6XHJcbiAgICAgICAgICAgIGlmKHNpLndvcmxkTm9ybWFsTmVlZHNVcGRhdGUpe1xyXG4gICAgICAgICAgICAgICAgc2kuY29tcHV0ZVdvcmxkTm9ybWFsKGJpLnF1YXRlcm5pb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBwbGFuZU5vcm1hbCA9IHNpLndvcmxkTm9ybWFsO1xyXG5cclxuXHRcdFx0Ly9SZWxhdGl2ZSBwb3NpdGlvbiBmcm9tIG9yaWdpbiBvZiBwbGFuZSBvYmplY3QgdG8gdGhlIGZpcnN0IGJpblxyXG5cdFx0XHQvL0luY3JlbWVudGVkIGFzIHdlIGl0ZXJhdGUgdGhyb3VnaCB0aGUgYmluc1xyXG5cdFx0XHR2YXIgeHJlc2V0ID0geG1pbiArIGJpbnNpemVYKjAuNSAtIGJpLnBvc2l0aW9uLngsXHJcblx0XHRcdFx0eXJlc2V0ID0geW1pbiArIGJpbnNpemVZKjAuNSAtIGJpLnBvc2l0aW9uLnksXHJcblx0XHRcdFx0enJlc2V0ID0gem1pbiArIGJpbnNpemVaKjAuNSAtIGJpLnBvc2l0aW9uLno7XHJcblxyXG4gICAgICAgICAgICB2YXIgZCA9IEdyaWRCcm9hZHBoYXNlX2NvbGxpc2lvblBhaXJzX2Q7XHJcblx0XHRcdGQuc2V0KHhyZXNldCwgeXJlc2V0LCB6cmVzZXQpO1xyXG5cclxuXHRcdFx0Zm9yICh2YXIgeGkgPSAwLCB4b2ZmID0gMDsgeGkgIT09IG54OyB4aSsrLCB4b2ZmICs9IHhzdGVwLCBkLnkgPSB5cmVzZXQsIGQueCArPSBiaW5zaXplWCkge1xyXG5cdFx0XHRcdGZvciAodmFyIHlpID0gMCwgeW9mZiA9IDA7IHlpICE9PSBueTsgeWkrKywgeW9mZiArPSB5c3RlcCwgZC56ID0genJlc2V0LCBkLnkgKz0gYmluc2l6ZVkpIHtcclxuXHRcdFx0XHRcdGZvciAodmFyIHppID0gMCwgem9mZiA9IDA7IHppICE9PSBuejsgemkrKywgem9mZiArPSB6c3RlcCwgZC56ICs9IGJpbnNpemVaKSB7XHJcblx0XHRcdFx0XHRcdGlmIChkLmRvdChwbGFuZU5vcm1hbCkgPCBiaW5SYWRpdXMpIHtcclxuXHRcdFx0XHRcdFx0XHR2YXIgaWR4ID0geG9mZiArIHlvZmYgKyB6b2ZmO1xyXG5cdFx0XHRcdFx0XHRcdGJpbnNbaWR4XVtiaW5MZW5ndGhzW2lkeF0rK10gPSBiaTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgZGVmYXVsdDpcclxuXHRcdFx0aWYgKGJpLmFhYmJOZWVkc1VwZGF0ZSkge1xyXG5cdFx0XHRcdGJpLmNvbXB1dGVBQUJCKCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGFkZEJveFRvQmlucyhcclxuXHRcdFx0XHRiaS5hYWJiLmxvd2VyQm91bmQueCxcclxuXHRcdFx0XHRiaS5hYWJiLmxvd2VyQm91bmQueSxcclxuXHRcdFx0XHRiaS5hYWJiLmxvd2VyQm91bmQueixcclxuXHRcdFx0XHRiaS5hYWJiLnVwcGVyQm91bmQueCxcclxuXHRcdFx0XHRiaS5hYWJiLnVwcGVyQm91bmQueSxcclxuXHRcdFx0XHRiaS5hYWJiLnVwcGVyQm91bmQueixcclxuXHRcdFx0XHRiaSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBDaGVjayBlYWNoIGJpblxyXG4gICAgZm9yKHZhciBpPTA7IGkhPT1OYmluczsgaSsrKXtcclxuXHRcdHZhciBiaW5MZW5ndGggPSBiaW5MZW5ndGhzW2ldO1xyXG5cdFx0Ly9Ta2lwIGJpbnMgd2l0aCBubyBwb3RlbnRpYWwgY29sbGlzaW9uc1xyXG5cdFx0aWYgKGJpbkxlbmd0aCA+IDEpIHtcclxuXHRcdFx0dmFyIGJpbiA9IGJpbnNbaV07XHJcblxyXG5cdFx0XHQvLyBEbyBOXjIgYnJvYWRwaGFzZSBpbnNpZGVcclxuXHRcdFx0Zm9yKHZhciB4aT0wOyB4aSE9PWJpbkxlbmd0aDsgeGkrKyl7XHJcblx0XHRcdFx0dmFyIGJpID0gYmluW3hpXTtcclxuXHRcdFx0XHRmb3IodmFyIHlpPTA7IHlpIT09eGk7IHlpKyspe1xyXG5cdFx0XHRcdFx0dmFyIGJqID0gYmluW3lpXTtcclxuXHRcdFx0XHRcdGlmKHRoaXMubmVlZEJyb2FkcGhhc2VDb2xsaXNpb24oYmksYmopKXtcclxuXHRcdFx0XHRcdFx0dGhpcy5pbnRlcnNlY3Rpb25UZXN0KGJpLGJqLHBhaXJzMSxwYWlyczIpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG4gICAgfVxyXG5cclxuLy9cdGZvciAodmFyIHppID0gMCwgem9mZj0wOyB6aSA8IG56OyB6aSsrLCB6b2ZmKz0genN0ZXApIHtcclxuLy9cdFx0Y29uc29sZS5sb2coXCJsYXllciBcIit6aSk7XHJcbi8vXHRcdGZvciAodmFyIHlpID0gMCwgeW9mZj0wOyB5aSA8IG55OyB5aSsrLCB5b2ZmICs9IHlzdGVwKSB7XHJcbi8vXHRcdFx0dmFyIHJvdyA9ICcnO1xyXG4vL1x0XHRcdGZvciAodmFyIHhpID0gMCwgeG9mZj0wOyB4aSA8IG54OyB4aSsrLCB4b2ZmICs9IHhzdGVwKSB7XHJcbi8vXHRcdFx0XHR2YXIgaWR4ID0geG9mZiArIHlvZmYgKyB6b2ZmO1xyXG4vL1x0XHRcdFx0cm93ICs9ICcgJyArIGJpbkxlbmd0aHNbaWR4XTtcclxuLy9cdFx0XHR9XHJcbi8vXHRcdFx0Y29uc29sZS5sb2cocm93KTtcclxuLy9cdFx0fVxyXG4vL1x0fVxyXG5cclxuICAgIHRoaXMubWFrZVBhaXJzVW5pcXVlKHBhaXJzMSxwYWlyczIpO1xyXG59O1xyXG5cclxufSx7XCIuLi9tYXRoL1ZlYzNcIjozMSxcIi4uL3NoYXBlcy9TaGFwZVwiOjQ0LFwiLi9Ccm9hZHBoYXNlXCI6NX1dLDc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xyXG5tb2R1bGUuZXhwb3J0cyA9IE5haXZlQnJvYWRwaGFzZTtcclxuXHJcbnZhciBCcm9hZHBoYXNlID0gX2RlcmVxXygnLi9Ccm9hZHBoYXNlJyk7XHJcbnZhciBBQUJCID0gX2RlcmVxXygnLi9BQUJCJyk7XHJcblxyXG4vKipcclxuICogTmFpdmUgYnJvYWRwaGFzZSBpbXBsZW1lbnRhdGlvbiwgdXNlZCBpbiBsYWNrIG9mIGJldHRlciBvbmVzLlxyXG4gKiBAY2xhc3MgTmFpdmVCcm9hZHBoYXNlXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAZGVzY3JpcHRpb24gVGhlIG5haXZlIGJyb2FkcGhhc2UgbG9va3MgYXQgYWxsIHBvc3NpYmxlIHBhaXJzIHdpdGhvdXQgcmVzdHJpY3Rpb24sIHRoZXJlZm9yZSBpdCBoYXMgY29tcGxleGl0eSBOXjIgKHdoaWNoIGlzIGJhZClcclxuICogQGV4dGVuZHMgQnJvYWRwaGFzZVxyXG4gKi9cclxuZnVuY3Rpb24gTmFpdmVCcm9hZHBoYXNlKCl7XHJcbiAgICBCcm9hZHBoYXNlLmFwcGx5KHRoaXMpO1xyXG59XHJcbk5haXZlQnJvYWRwaGFzZS5wcm90b3R5cGUgPSBuZXcgQnJvYWRwaGFzZSgpO1xyXG5OYWl2ZUJyb2FkcGhhc2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTmFpdmVCcm9hZHBoYXNlO1xyXG5cclxuLyoqXHJcbiAqIEdldCBhbGwgdGhlIGNvbGxpc2lvbiBwYWlycyBpbiB0aGUgcGh5c2ljcyB3b3JsZFxyXG4gKiBAbWV0aG9kIGNvbGxpc2lvblBhaXJzXHJcbiAqIEBwYXJhbSB7V29ybGR9IHdvcmxkXHJcbiAqIEBwYXJhbSB7QXJyYXl9IHBhaXJzMVxyXG4gKiBAcGFyYW0ge0FycmF5fSBwYWlyczJcclxuICovXHJcbk5haXZlQnJvYWRwaGFzZS5wcm90b3R5cGUuY29sbGlzaW9uUGFpcnMgPSBmdW5jdGlvbih3b3JsZCxwYWlyczEscGFpcnMyKXtcclxuICAgIHZhciBib2RpZXMgPSB3b3JsZC5ib2RpZXMsXHJcbiAgICAgICAgbiA9IGJvZGllcy5sZW5ndGgsXHJcbiAgICAgICAgaSxqLGJpLGJqO1xyXG5cclxuICAgIC8vIE5haXZlIE5eMiBmdHchXHJcbiAgICBmb3IoaT0wOyBpIT09bjsgaSsrKXtcclxuICAgICAgICBmb3Ioaj0wOyBqIT09aTsgaisrKXtcclxuXHJcbiAgICAgICAgICAgIGJpID0gYm9kaWVzW2ldO1xyXG4gICAgICAgICAgICBiaiA9IGJvZGllc1tqXTtcclxuXHJcbiAgICAgICAgICAgIGlmKCF0aGlzLm5lZWRCcm9hZHBoYXNlQ29sbGlzaW9uKGJpLGJqKSl7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5pbnRlcnNlY3Rpb25UZXN0KGJpLGJqLHBhaXJzMSxwYWlyczIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbnZhciB0bXBBQUJCID0gbmV3IEFBQkIoKTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGFsbCB0aGUgYm9kaWVzIHdpdGhpbiBhbiBBQUJCLlxyXG4gKiBAbWV0aG9kIGFhYmJRdWVyeVxyXG4gKiBAcGFyYW0gIHtXb3JsZH0gd29ybGRcclxuICogQHBhcmFtICB7QUFCQn0gYWFiYlxyXG4gKiBAcGFyYW0ge2FycmF5fSByZXN1bHQgQW4gYXJyYXkgdG8gc3RvcmUgcmVzdWx0aW5nIGJvZGllcyBpbi5cclxuICogQHJldHVybiB7YXJyYXl9XHJcbiAqL1xyXG5OYWl2ZUJyb2FkcGhhc2UucHJvdG90eXBlLmFhYmJRdWVyeSA9IGZ1bmN0aW9uKHdvcmxkLCBhYWJiLCByZXN1bHQpe1xyXG4gICAgcmVzdWx0ID0gcmVzdWx0IHx8IFtdO1xyXG5cclxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCB3b3JsZC5ib2RpZXMubGVuZ3RoOyBpKyspe1xyXG4gICAgICAgIHZhciBiID0gd29ybGQuYm9kaWVzW2ldO1xyXG5cclxuICAgICAgICBpZihiLmFhYmJOZWVkc1VwZGF0ZSl7XHJcbiAgICAgICAgICAgIGIuY29tcHV0ZUFBQkIoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFVnbHkgaGFjayB1bnRpbCBCb2R5IGdldHMgYWFiYlxyXG4gICAgICAgIGlmKGIuYWFiYi5vdmVybGFwcyhhYWJiKSl7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG59LHtcIi4vQUFCQlwiOjMsXCIuL0Jyb2FkcGhhc2VcIjo1fV0sODpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XHJcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0Q29sbGlzaW9uTWF0cml4O1xyXG5cclxuLyoqXHJcbiAqIFJlY29yZHMgd2hhdCBvYmplY3RzIGFyZSBjb2xsaWRpbmcgd2l0aCBlYWNoIG90aGVyXHJcbiAqIEBjbGFzcyBPYmplY3RDb2xsaXNpb25NYXRyaXhcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5mdW5jdGlvbiBPYmplY3RDb2xsaXNpb25NYXRyaXgoKSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbWF0cml4IHN0b3JhZ2VcclxuICAgICAqIEBwcm9wZXJ0eSBtYXRyaXhcclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKi9cclxuXHR0aGlzLm1hdHJpeCA9IHt9O1xyXG59XHJcblxyXG4vKipcclxuICogQG1ldGhvZCBnZXRcclxuICogQHBhcmFtICB7TnVtYmVyfSBpXHJcbiAqIEBwYXJhbSAge051bWJlcn0galxyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XHJcbiAqL1xyXG5PYmplY3RDb2xsaXNpb25NYXRyaXgucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGksIGopIHtcclxuXHRpID0gaS5pZDtcclxuXHRqID0gai5pZDtcclxuICAgIGlmIChqID4gaSkge1xyXG4gICAgICAgIHZhciB0ZW1wID0gajtcclxuICAgICAgICBqID0gaTtcclxuICAgICAgICBpID0gdGVtcDtcclxuICAgIH1cclxuXHRyZXR1cm4gaSsnLScraiBpbiB0aGlzLm1hdHJpeDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kIHNldFxyXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGlcclxuICogQHBhcmFtICB7TnVtYmVyfSBqXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxyXG4gKi9cclxuT2JqZWN0Q29sbGlzaW9uTWF0cml4LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihpLCBqLCB2YWx1ZSkge1xyXG5cdGkgPSBpLmlkO1xyXG5cdGogPSBqLmlkO1xyXG4gICAgaWYgKGogPiBpKSB7XHJcbiAgICAgICAgdmFyIHRlbXAgPSBqO1xyXG4gICAgICAgIGogPSBpO1xyXG4gICAgICAgIGkgPSB0ZW1wO1xyXG5cdH1cclxuXHRpZiAodmFsdWUpIHtcclxuXHRcdHRoaXMubWF0cml4W2krJy0nK2pdID0gdHJ1ZTtcclxuXHR9XHJcblx0ZWxzZSB7XHJcblx0XHRkZWxldGUgdGhpcy5tYXRyaXhbaSsnLScral07XHJcblx0fVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEVtcHR5IHRoZSBtYXRyaXhcclxuICogQG1ldGhvZCByZXNldFxyXG4gKi9cclxuT2JqZWN0Q29sbGlzaW9uTWF0cml4LnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCkge1xyXG5cdHRoaXMubWF0cml4ID0ge307XHJcbn07XHJcblxyXG4vKipcclxuICogU2V0IG1heCBudW1iZXIgb2Ygb2JqZWN0c1xyXG4gKiBAbWV0aG9kIHNldE51bU9iamVjdHNcclxuICogQHBhcmFtIHtOdW1iZXJ9IG5cclxuICovXHJcbk9iamVjdENvbGxpc2lvbk1hdHJpeC5wcm90b3R5cGUuc2V0TnVtT2JqZWN0cyA9IGZ1bmN0aW9uKG4pIHtcclxufTtcclxuXHJcbn0se31dLDk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xyXG5tb2R1bGUuZXhwb3J0cyA9IE92ZXJsYXBLZWVwZXI7XHJcblxyXG4vKipcclxuICogQGNsYXNzIE92ZXJsYXBLZWVwZXJcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5mdW5jdGlvbiBPdmVybGFwS2VlcGVyKCkge1xyXG4gICAgdGhpcy5jdXJyZW50ID0gW107XHJcbiAgICB0aGlzLnByZXZpb3VzID0gW107XHJcbn1cclxuXHJcbk92ZXJsYXBLZWVwZXIucHJvdG90eXBlLmdldEtleSA9IGZ1bmN0aW9uKGksIGopIHtcclxuICAgIGlmIChqIDwgaSkge1xyXG4gICAgICAgIHZhciB0ZW1wID0gajtcclxuICAgICAgICBqID0gaTtcclxuICAgICAgICBpID0gdGVtcDtcclxuICAgIH1cclxuICAgIHJldHVybiAoaSA8PCAxNikgfCBqO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kIHNldFxyXG4gKiBAcGFyYW0ge051bWJlcn0gaVxyXG4gKiBAcGFyYW0ge051bWJlcn0galxyXG4gKi9cclxuT3ZlcmxhcEtlZXBlci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oaSwgaikge1xyXG4gICAgLy8gSW5zZXJ0aW9uIHNvcnQuIFRoaXMgd2F5IHRoZSBkaWZmIHdpbGwgaGF2ZSBsaW5lYXIgY29tcGxleGl0eS5cclxuICAgIHZhciBrZXkgPSB0aGlzLmdldEtleShpLCBqKTtcclxuICAgIHZhciBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xyXG4gICAgdmFyIGluZGV4ID0gMDtcclxuICAgIHdoaWxlKGtleSA+IGN1cnJlbnRbaW5kZXhdKXtcclxuICAgICAgICBpbmRleCsrO1xyXG4gICAgfVxyXG4gICAgaWYoa2V5ID09PSBjdXJyZW50W2luZGV4XSl7XHJcbiAgICAgICAgcmV0dXJuOyAvLyBQYWlyIHdhcyBhbHJlYWR5IGFkZGVkXHJcbiAgICB9XHJcbiAgICBmb3IodmFyIGo9Y3VycmVudC5sZW5ndGgtMTsgaj49aW5kZXg7IGotLSl7XHJcbiAgICAgICAgY3VycmVudFtqICsgMV0gPSBjdXJyZW50W2pdO1xyXG4gICAgfVxyXG4gICAgY3VycmVudFtpbmRleF0gPSBrZXk7XHJcbn07XHJcblxyXG4vKipcclxuICogQG1ldGhvZCB0aWNrXHJcbiAqL1xyXG5PdmVybGFwS2VlcGVyLnByb3RvdHlwZS50aWNrID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgdG1wID0gdGhpcy5jdXJyZW50O1xyXG4gICAgdGhpcy5jdXJyZW50ID0gdGhpcy5wcmV2aW91cztcclxuICAgIHRoaXMucHJldmlvdXMgPSB0bXA7XHJcbiAgICB0aGlzLmN1cnJlbnQubGVuZ3RoID0gMDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kIHJlc2V0XHJcbiAqL1xyXG5PdmVybGFwS2VlcGVyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5wcmV2aW91cy5sZW5ndGggPSAwO1xyXG4gICAgdGhpcy5jdXJyZW50Lmxlbmd0aCA9IDA7XHJcbn07XHJcblxyXG5mdW5jdGlvbiB1bnBhY2tBbmRQdXNoKGFycmF5LCBrZXkpe1xyXG4gICAgYXJyYXkucHVzaCgoa2V5ICYgMHhGRkZGMDAwMCkgPj4gMTYsIGtleSAmIDB4MDAwMEZGRkYpO1xyXG59XHJcblxyXG4vKipcclxuICogQG1ldGhvZCBnZXREaWZmXHJcbiAqIEBwYXJhbSAge2FycmF5fSBhZGRpdGlvbnNcclxuICogQHBhcmFtICB7YXJyYXl9IHJlbW92YWxzXHJcbiAqL1xyXG5PdmVybGFwS2VlcGVyLnByb3RvdHlwZS5nZXREaWZmID0gZnVuY3Rpb24oYWRkaXRpb25zLCByZW1vdmFscykge1xyXG4gICAgdmFyIGEgPSB0aGlzLmN1cnJlbnQ7XHJcbiAgICB2YXIgYiA9IHRoaXMucHJldmlvdXM7XHJcbiAgICB2YXIgYWwgPSBhLmxlbmd0aDtcclxuICAgIHZhciBibCA9IGIubGVuZ3RoO1xyXG5cclxuICAgIHZhciBqPTA7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsOyBpKyspIHtcclxuICAgICAgICB2YXIgZm91bmQgPSBmYWxzZTtcclxuICAgICAgICB2YXIga2V5QSA9IGFbaV07XHJcbiAgICAgICAgd2hpbGUoa2V5QSA+IGJbal0pe1xyXG4gICAgICAgICAgICBqKys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvdW5kID0ga2V5QSA9PT0gYltqXTtcclxuXHJcbiAgICAgICAgaWYoIWZvdW5kKXtcclxuICAgICAgICAgICAgdW5wYWNrQW5kUHVzaChhZGRpdGlvbnMsIGtleUEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGogPSAwO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBibDsgaSsrKSB7XHJcbiAgICAgICAgdmFyIGZvdW5kID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIGtleUIgPSBiW2ldO1xyXG4gICAgICAgIHdoaWxlKGtleUIgPiBhW2pdKXtcclxuICAgICAgICAgICAgaisrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3VuZCA9IGFbal0gPT09IGtleUI7XHJcblxyXG4gICAgICAgIGlmKCFmb3VuZCl7XHJcbiAgICAgICAgICAgIHVucGFja0FuZFB1c2gocmVtb3ZhbHMsIGtleUIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbk92ZXJsYXBLZWVwZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbihvdmVybGFwS2VlcGVyKSB7XHJcbiAgICB0aGlzLmN1cnJlbnQubGVuZ3RoID0gMDtcclxuICAgIHRoaXMucHJldmlvdXMubGVuZ3RoID0gMDtcclxuICAgIHRoaXMuY3VycmVudCA9IG92ZXJsYXBLZWVwZXIuY3VycmVudC5zbGljZSgpO1xyXG4gICAgdGhpcy5wcmV2aW91cyA9IG92ZXJsYXBLZWVwZXIucHJldmlvdXMuc2xpY2UoKTtcclxufTtcclxufSx7fV0sMTA6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xyXG5tb2R1bGUuZXhwb3J0cyA9IFJheTtcclxuXHJcbnZhciBWZWMzID0gX2RlcmVxXygnLi4vbWF0aC9WZWMzJyk7XHJcbnZhciBRdWF0ZXJuaW9uID0gX2RlcmVxXygnLi4vbWF0aC9RdWF0ZXJuaW9uJyk7XHJcbnZhciBUcmFuc2Zvcm0gPSBfZGVyZXFfKCcuLi9tYXRoL1RyYW5zZm9ybScpO1xyXG52YXIgQ29udmV4UG9seWhlZHJvbiA9IF9kZXJlcV8oJy4uL3NoYXBlcy9Db252ZXhQb2x5aGVkcm9uJyk7XHJcbnZhciBCb3ggPSBfZGVyZXFfKCcuLi9zaGFwZXMvQm94Jyk7XHJcbnZhciBSYXljYXN0UmVzdWx0ID0gX2RlcmVxXygnLi4vY29sbGlzaW9uL1JheWNhc3RSZXN1bHQnKTtcclxudmFyIFNoYXBlID0gX2RlcmVxXygnLi4vc2hhcGVzL1NoYXBlJyk7XHJcbnZhciBBQUJCID0gX2RlcmVxXygnLi4vY29sbGlzaW9uL0FBQkInKTtcclxuXHJcbi8qKlxyXG4gKiBBIGxpbmUgaW4gM0Qgc3BhY2UgdGhhdCBpbnRlcnNlY3RzIGJvZGllcyBhbmQgcmV0dXJuIHBvaW50cy5cclxuICogQGNsYXNzIFJheVxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtWZWMzfSBmcm9tXHJcbiAqIEBwYXJhbSB7VmVjM30gdG9cclxuICovXHJcbmZ1bmN0aW9uIFJheShmcm9tLCB0byl7XHJcbiAgICAvKipcclxuICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gZnJvbVxyXG4gICAgICovXHJcbiAgICB0aGlzLmZyb20gPSBmcm9tID8gZnJvbS5jbG9uZSgpIDogbmV3IFZlYzMoKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gdG9cclxuICAgICAqL1xyXG4gICAgdGhpcy50byA9IHRvID8gdG8uY2xvbmUoKSA6IG5ldyBWZWMzKCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHByb3BlcnR5IHtWZWMzfSBfZGlyZWN0aW9uXHJcbiAgICAgKi9cclxuICAgIHRoaXMuX2RpcmVjdGlvbiA9IG5ldyBWZWMzKCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgcHJlY2lzaW9uIG9mIHRoZSByYXkuIFVzZWQgd2hlbiBjaGVja2luZyBwYXJhbGxlbGl0eSBldGMuXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gcHJlY2lzaW9uXHJcbiAgICAgKi9cclxuICAgIHRoaXMucHJlY2lzaW9uID0gMC4wMDAxO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRvIHRydWUgaWYgeW91IHdhbnQgdGhlIFJheSB0byB0YWtlIC5jb2xsaXNpb25SZXNwb25zZSBmbGFncyBpbnRvIGFjY291bnQgb24gYm9kaWVzIGFuZCBzaGFwZXMuXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IGNoZWNrQ29sbGlzaW9uUmVzcG9uc2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5jaGVja0NvbGxpc2lvblJlc3BvbnNlID0gdHJ1ZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIElmIHNldCB0byB0cnVlLCB0aGUgcmF5IHNraXBzIGFueSBoaXRzIHdpdGggbm9ybWFsLmRvdChyYXlEaXJlY3Rpb24pIDwgMC5cclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gc2tpcEJhY2tmYWNlc1xyXG4gICAgICovXHJcbiAgICB0aGlzLnNraXBCYWNrZmFjZXMgPSBmYWxzZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb2xsaXNpb25GaWx0ZXJNYXNrXHJcbiAgICAgKiBAZGVmYXVsdCAtMVxyXG4gICAgICovXHJcbiAgICB0aGlzLmNvbGxpc2lvbkZpbHRlck1hc2sgPSAtMTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb2xsaXNpb25GaWx0ZXJHcm91cFxyXG4gICAgICogQGRlZmF1bHQgLTFcclxuICAgICAqL1xyXG4gICAgdGhpcy5jb2xsaXNpb25GaWx0ZXJHcm91cCA9IC0xO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGludGVyc2VjdGlvbiBtb2RlLiBTaG91bGQgYmUgUmF5LkFOWSwgUmF5LkFMTCBvciBSYXkuQ0xPU0VTVC5cclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtb2RlXHJcbiAgICAgKi9cclxuICAgIHRoaXMubW9kZSA9IFJheS5BTlk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDdXJyZW50IHJlc3VsdCBvYmplY3QuXHJcbiAgICAgKiBAcHJvcGVydHkge1JheWNhc3RSZXN1bHR9IHJlc3VsdFxyXG4gICAgICovXHJcbiAgICB0aGlzLnJlc3VsdCA9IG5ldyBSYXljYXN0UmVzdWx0KCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXaWxsIGJlIHNldCB0byB0cnVlIGR1cmluZyBpbnRlcnNlY3RXb3JsZCgpIGlmIHRoZSByYXkgaGl0IGFueXRoaW5nLlxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBoYXNIaXRcclxuICAgICAqL1xyXG4gICAgdGhpcy5oYXNIaXQgPSBmYWxzZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEN1cnJlbnQsIHVzZXItcHJvdmlkZWQgcmVzdWx0IGNhbGxiYWNrLiBXaWxsIGJlIHVzZWQgaWYgbW9kZSBpcyBSYXkuQUxMLlxyXG4gICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gY2FsbGJhY2tcclxuICAgICAqL1xyXG4gICAgdGhpcy5jYWxsYmFjayA9IGZ1bmN0aW9uKHJlc3VsdCl7fTtcclxufVxyXG5SYXkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmF5O1xyXG5cclxuUmF5LkNMT1NFU1QgPSAxO1xyXG5SYXkuQU5ZID0gMjtcclxuUmF5LkFMTCA9IDQ7XHJcblxyXG52YXIgdG1wQUFCQiA9IG5ldyBBQUJCKCk7XHJcbnZhciB0bXBBcnJheSA9IFtdO1xyXG5cclxuLyoqXHJcbiAqIERvIGl0ZXJzZWN0aW9uIGFnYWluc3QgYWxsIGJvZGllcyBpbiB0aGUgZ2l2ZW4gV29ybGQuXHJcbiAqIEBtZXRob2QgaW50ZXJzZWN0V29ybGRcclxuICogQHBhcmFtICB7V29ybGR9IHdvcmxkXHJcbiAqIEBwYXJhbSAge29iamVjdH0gb3B0aW9uc1xyXG4gKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHRoZSByYXkgaGl0IGFueXRoaW5nLCBvdGhlcndpc2UgZmFsc2UuXHJcbiAqL1xyXG5SYXkucHJvdG90eXBlLmludGVyc2VjdFdvcmxkID0gZnVuY3Rpb24gKHdvcmxkLCBvcHRpb25zKSB7XHJcbiAgICB0aGlzLm1vZGUgPSBvcHRpb25zLm1vZGUgfHwgUmF5LkFOWTtcclxuICAgIHRoaXMucmVzdWx0ID0gb3B0aW9ucy5yZXN1bHQgfHwgbmV3IFJheWNhc3RSZXN1bHQoKTtcclxuICAgIHRoaXMuc2tpcEJhY2tmYWNlcyA9ICEhb3B0aW9ucy5za2lwQmFja2ZhY2VzO1xyXG4gICAgdGhpcy5jb2xsaXNpb25GaWx0ZXJNYXNrID0gdHlwZW9mKG9wdGlvbnMuY29sbGlzaW9uRmlsdGVyTWFzaykgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5jb2xsaXNpb25GaWx0ZXJNYXNrIDogLTE7XHJcbiAgICB0aGlzLmNvbGxpc2lvbkZpbHRlckdyb3VwID0gdHlwZW9mKG9wdGlvbnMuY29sbGlzaW9uRmlsdGVyR3JvdXApICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMuY29sbGlzaW9uRmlsdGVyR3JvdXAgOiAtMTtcclxuICAgIGlmKG9wdGlvbnMuZnJvbSl7XHJcbiAgICAgICAgdGhpcy5mcm9tLmNvcHkob3B0aW9ucy5mcm9tKTtcclxuICAgIH1cclxuICAgIGlmKG9wdGlvbnMudG8pe1xyXG4gICAgICAgIHRoaXMudG8uY29weShvcHRpb25zLnRvKTtcclxuICAgIH1cclxuICAgIHRoaXMuY2FsbGJhY2sgPSBvcHRpb25zLmNhbGxiYWNrIHx8IGZ1bmN0aW9uKCl7fTtcclxuICAgIHRoaXMuaGFzSGl0ID0gZmFsc2U7XHJcblxyXG4gICAgdGhpcy5yZXN1bHQucmVzZXQoKTtcclxuICAgIHRoaXMuX3VwZGF0ZURpcmVjdGlvbigpO1xyXG5cclxuICAgIHRoaXMuZ2V0QUFCQih0bXBBQUJCKTtcclxuICAgIHRtcEFycmF5Lmxlbmd0aCA9IDA7XHJcbiAgICB3b3JsZC5icm9hZHBoYXNlLmFhYmJRdWVyeSh3b3JsZCwgdG1wQUFCQiwgdG1wQXJyYXkpO1xyXG4gICAgdGhpcy5pbnRlcnNlY3RCb2RpZXModG1wQXJyYXkpO1xyXG5cclxuICAgIHJldHVybiB0aGlzLmhhc0hpdDtcclxufTtcclxuXHJcbnZhciB2MSA9IG5ldyBWZWMzKCksXHJcbiAgICB2MiA9IG5ldyBWZWMzKCk7XHJcblxyXG4vKlxyXG4gKiBBcyBwZXIgXCJCYXJ5Y2VudHJpYyBUZWNobmlxdWVcIiBhcyBuYW1lZCBoZXJlIGh0dHA6Ly93d3cuYmxhY2twYXduLmNvbS90ZXh0cy9wb2ludGlucG9seS9kZWZhdWx0Lmh0bWwgQnV0IHdpdGhvdXQgdGhlIGRpdmlzaW9uXHJcbiAqL1xyXG5SYXkucG9pbnRJblRyaWFuZ2xlID0gcG9pbnRJblRyaWFuZ2xlO1xyXG5mdW5jdGlvbiBwb2ludEluVHJpYW5nbGUocCwgYSwgYiwgYykge1xyXG4gICAgYy52c3ViKGEsdjApO1xyXG4gICAgYi52c3ViKGEsdjEpO1xyXG4gICAgcC52c3ViKGEsdjIpO1xyXG5cclxuICAgIHZhciBkb3QwMCA9IHYwLmRvdCggdjAgKTtcclxuICAgIHZhciBkb3QwMSA9IHYwLmRvdCggdjEgKTtcclxuICAgIHZhciBkb3QwMiA9IHYwLmRvdCggdjIgKTtcclxuICAgIHZhciBkb3QxMSA9IHYxLmRvdCggdjEgKTtcclxuICAgIHZhciBkb3QxMiA9IHYxLmRvdCggdjIgKTtcclxuXHJcbiAgICB2YXIgdSx2O1xyXG5cclxuICAgIHJldHVybiAgKCAodSA9IGRvdDExICogZG90MDIgLSBkb3QwMSAqIGRvdDEyKSA+PSAwICkgJiZcclxuICAgICAgICAgICAgKCAodiA9IGRvdDAwICogZG90MTIgLSBkb3QwMSAqIGRvdDAyKSA+PSAwICkgJiZcclxuICAgICAgICAgICAgKCB1ICsgdiA8ICggZG90MDAgKiBkb3QxMSAtIGRvdDAxICogZG90MDEgKSApO1xyXG59XHJcblxyXG4vKipcclxuICogU2hvb3QgYSByYXkgYXQgYSBib2R5LCBnZXQgYmFjayBpbmZvcm1hdGlvbiBhYm91dCB0aGUgaGl0LlxyXG4gKiBAbWV0aG9kIGludGVyc2VjdEJvZHlcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtCb2R5fSBib2R5XHJcbiAqIEBwYXJhbSB7UmF5Y2FzdFJlc3VsdH0gW3Jlc3VsdF0gRGVwcmVjYXRlZCAtIHNldCB0aGUgcmVzdWx0IHByb3BlcnR5IG9mIHRoZSBSYXkgaW5zdGVhZC5cclxuICovXHJcbnZhciBpbnRlcnNlY3RCb2R5X3hpID0gbmV3IFZlYzMoKTtcclxudmFyIGludGVyc2VjdEJvZHlfcWkgPSBuZXcgUXVhdGVybmlvbigpO1xyXG5SYXkucHJvdG90eXBlLmludGVyc2VjdEJvZHkgPSBmdW5jdGlvbiAoYm9keSwgcmVzdWx0KSB7XHJcbiAgICBpZihyZXN1bHQpe1xyXG4gICAgICAgIHRoaXMucmVzdWx0ID0gcmVzdWx0O1xyXG4gICAgICAgIHRoaXMuX3VwZGF0ZURpcmVjdGlvbigpO1xyXG4gICAgfVxyXG4gICAgdmFyIGNoZWNrQ29sbGlzaW9uUmVzcG9uc2UgPSB0aGlzLmNoZWNrQ29sbGlzaW9uUmVzcG9uc2U7XHJcblxyXG4gICAgaWYoY2hlY2tDb2xsaXNpb25SZXNwb25zZSAmJiAhYm9keS5jb2xsaXNpb25SZXNwb25zZSl7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmKCh0aGlzLmNvbGxpc2lvbkZpbHRlckdyb3VwICYgYm9keS5jb2xsaXNpb25GaWx0ZXJNYXNrKT09PTAgfHwgKGJvZHkuY29sbGlzaW9uRmlsdGVyR3JvdXAgJiB0aGlzLmNvbGxpc2lvbkZpbHRlck1hc2spPT09MCl7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciB4aSA9IGludGVyc2VjdEJvZHlfeGk7XHJcbiAgICB2YXIgcWkgPSBpbnRlcnNlY3RCb2R5X3FpO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwLCBOID0gYm9keS5zaGFwZXMubGVuZ3RoOyBpIDwgTjsgaSsrKSB7XHJcbiAgICAgICAgdmFyIHNoYXBlID0gYm9keS5zaGFwZXNbaV07XHJcblxyXG4gICAgICAgIGlmKGNoZWNrQ29sbGlzaW9uUmVzcG9uc2UgJiYgIXNoYXBlLmNvbGxpc2lvblJlc3BvbnNlKXtcclxuICAgICAgICAgICAgY29udGludWU7IC8vIFNraXBcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGJvZHkucXVhdGVybmlvbi5tdWx0KGJvZHkuc2hhcGVPcmllbnRhdGlvbnNbaV0sIHFpKTtcclxuICAgICAgICBib2R5LnF1YXRlcm5pb24udm11bHQoYm9keS5zaGFwZU9mZnNldHNbaV0sIHhpKTtcclxuICAgICAgICB4aS52YWRkKGJvZHkucG9zaXRpb24sIHhpKTtcclxuXHJcbiAgICAgICAgdGhpcy5pbnRlcnNlY3RTaGFwZShcclxuICAgICAgICAgICAgc2hhcGUsXHJcbiAgICAgICAgICAgIHFpLFxyXG4gICAgICAgICAgICB4aSxcclxuICAgICAgICAgICAgYm9keVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIGlmKHRoaXMucmVzdWx0Ll9zaG91bGRTdG9wKXtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgaW50ZXJzZWN0Qm9kaWVzXHJcbiAqIEBwYXJhbSB7QXJyYXl9IGJvZGllcyBBbiBhcnJheSBvZiBCb2R5IG9iamVjdHMuXHJcbiAqIEBwYXJhbSB7UmF5Y2FzdFJlc3VsdH0gW3Jlc3VsdF0gRGVwcmVjYXRlZFxyXG4gKi9cclxuUmF5LnByb3RvdHlwZS5pbnRlcnNlY3RCb2RpZXMgPSBmdW5jdGlvbiAoYm9kaWVzLCByZXN1bHQpIHtcclxuICAgIGlmKHJlc3VsdCl7XHJcbiAgICAgICAgdGhpcy5yZXN1bHQgPSByZXN1bHQ7XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlRGlyZWN0aW9uKCk7XHJcbiAgICB9XHJcblxyXG4gICAgZm9yICggdmFyIGkgPSAwLCBsID0gYm9kaWVzLmxlbmd0aDsgIXRoaXMucmVzdWx0Ll9zaG91bGRTdG9wICYmIGkgPCBsOyBpICsrICkge1xyXG4gICAgICAgIHRoaXMuaW50ZXJzZWN0Qm9keShib2RpZXNbaV0pO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFVwZGF0ZXMgdGhlIF9kaXJlY3Rpb24gdmVjdG9yLlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAbWV0aG9kIF91cGRhdGVEaXJlY3Rpb25cclxuICovXHJcblJheS5wcm90b3R5cGUuX3VwZGF0ZURpcmVjdGlvbiA9IGZ1bmN0aW9uKCl7XHJcbiAgICB0aGlzLnRvLnZzdWIodGhpcy5mcm9tLCB0aGlzLl9kaXJlY3Rpb24pO1xyXG4gICAgdGhpcy5fZGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgaW50ZXJzZWN0U2hhcGVcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtTaGFwZX0gc2hhcGVcclxuICogQHBhcmFtIHtRdWF0ZXJuaW9ufSBxdWF0XHJcbiAqIEBwYXJhbSB7VmVjM30gcG9zaXRpb25cclxuICogQHBhcmFtIHtCb2R5fSBib2R5XHJcbiAqL1xyXG5SYXkucHJvdG90eXBlLmludGVyc2VjdFNoYXBlID0gZnVuY3Rpb24oc2hhcGUsIHF1YXQsIHBvc2l0aW9uLCBib2R5KXtcclxuICAgIHZhciBmcm9tID0gdGhpcy5mcm9tO1xyXG5cclxuXHJcbiAgICAvLyBDaGVja2luZyBib3VuZGluZ1NwaGVyZVxyXG4gICAgdmFyIGRpc3RhbmNlID0gZGlzdGFuY2VGcm9tSW50ZXJzZWN0aW9uKGZyb20sIHRoaXMuX2RpcmVjdGlvbiwgcG9zaXRpb24pO1xyXG4gICAgaWYgKCBkaXN0YW5jZSA+IHNoYXBlLmJvdW5kaW5nU3BoZXJlUmFkaXVzICkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgaW50ZXJzZWN0TWV0aG9kID0gdGhpc1tzaGFwZS50eXBlXTtcclxuICAgIGlmKGludGVyc2VjdE1ldGhvZCl7XHJcbiAgICAgICAgaW50ZXJzZWN0TWV0aG9kLmNhbGwodGhpcywgc2hhcGUsIHF1YXQsIHBvc2l0aW9uLCBib2R5LCBzaGFwZSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG52YXIgdmVjdG9yID0gbmV3IFZlYzMoKTtcclxudmFyIG5vcm1hbCA9IG5ldyBWZWMzKCk7XHJcbnZhciBpbnRlcnNlY3RQb2ludCA9IG5ldyBWZWMzKCk7XHJcblxyXG52YXIgYSA9IG5ldyBWZWMzKCk7XHJcbnZhciBiID0gbmV3IFZlYzMoKTtcclxudmFyIGMgPSBuZXcgVmVjMygpO1xyXG52YXIgZCA9IG5ldyBWZWMzKCk7XHJcblxyXG52YXIgdG1wUmF5Y2FzdFJlc3VsdCA9IG5ldyBSYXljYXN0UmVzdWx0KCk7XHJcblxyXG4vKipcclxuICogQG1ldGhvZCBpbnRlcnNlY3RCb3hcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtICB7U2hhcGV9IHNoYXBlXHJcbiAqIEBwYXJhbSAge1F1YXRlcm5pb259IHF1YXRcclxuICogQHBhcmFtICB7VmVjM30gcG9zaXRpb25cclxuICogQHBhcmFtICB7Qm9keX0gYm9keVxyXG4gKi9cclxuUmF5LnByb3RvdHlwZS5pbnRlcnNlY3RCb3ggPSBmdW5jdGlvbihzaGFwZSwgcXVhdCwgcG9zaXRpb24sIGJvZHksIHJlcG9ydGVkU2hhcGUpe1xyXG4gICAgcmV0dXJuIHRoaXMuaW50ZXJzZWN0Q29udmV4KHNoYXBlLmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbiwgcXVhdCwgcG9zaXRpb24sIGJvZHksIHJlcG9ydGVkU2hhcGUpO1xyXG59O1xyXG5SYXkucHJvdG90eXBlW1NoYXBlLnR5cGVzLkJPWF0gPSBSYXkucHJvdG90eXBlLmludGVyc2VjdEJveDtcclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kIGludGVyc2VjdFBsYW5lXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSAge1NoYXBlfSBzaGFwZVxyXG4gKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSBxdWF0XHJcbiAqIEBwYXJhbSAge1ZlYzN9IHBvc2l0aW9uXHJcbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlcclxuICovXHJcblJheS5wcm90b3R5cGUuaW50ZXJzZWN0UGxhbmUgPSBmdW5jdGlvbihzaGFwZSwgcXVhdCwgcG9zaXRpb24sIGJvZHksIHJlcG9ydGVkU2hhcGUpe1xyXG4gICAgdmFyIGZyb20gPSB0aGlzLmZyb207XHJcbiAgICB2YXIgdG8gPSB0aGlzLnRvO1xyXG4gICAgdmFyIGRpcmVjdGlvbiA9IHRoaXMuX2RpcmVjdGlvbjtcclxuXHJcbiAgICAvLyBHZXQgcGxhbmUgbm9ybWFsXHJcbiAgICB2YXIgd29ybGROb3JtYWwgPSBuZXcgVmVjMygwLCAwLCAxKTtcclxuICAgIHF1YXQudm11bHQod29ybGROb3JtYWwsIHdvcmxkTm9ybWFsKTtcclxuXHJcbiAgICB2YXIgbGVuID0gbmV3IFZlYzMoKTtcclxuICAgIGZyb20udnN1Yihwb3NpdGlvbiwgbGVuKTtcclxuICAgIHZhciBwbGFuZVRvRnJvbSA9IGxlbi5kb3Qod29ybGROb3JtYWwpO1xyXG4gICAgdG8udnN1Yihwb3NpdGlvbiwgbGVuKTtcclxuICAgIHZhciBwbGFuZVRvVG8gPSBsZW4uZG90KHdvcmxkTm9ybWFsKTtcclxuXHJcbiAgICBpZihwbGFuZVRvRnJvbSAqIHBsYW5lVG9UbyA+IDApe1xyXG4gICAgICAgIC8vIFwiZnJvbVwiIGFuZCBcInRvXCIgYXJlIG9uIHRoZSBzYW1lIHNpZGUgb2YgdGhlIHBsYW5lLi4uIGJhaWwgb3V0XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmKGZyb20uZGlzdGFuY2VUbyh0bykgPCBwbGFuZVRvRnJvbSl7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBuX2RvdF9kaXIgPSB3b3JsZE5vcm1hbC5kb3QoZGlyZWN0aW9uKTtcclxuXHJcbiAgICBpZiAoTWF0aC5hYnMobl9kb3RfZGlyKSA8IHRoaXMucHJlY2lzaW9uKSB7XHJcbiAgICAgICAgLy8gTm8gaW50ZXJzZWN0aW9uXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBwbGFuZVBvaW50VG9Gcm9tID0gbmV3IFZlYzMoKTtcclxuICAgIHZhciBkaXJfc2NhbGVkX3dpdGhfdCA9IG5ldyBWZWMzKCk7XHJcbiAgICB2YXIgaGl0UG9pbnRXb3JsZCA9IG5ldyBWZWMzKCk7XHJcblxyXG4gICAgZnJvbS52c3ViKHBvc2l0aW9uLCBwbGFuZVBvaW50VG9Gcm9tKTtcclxuICAgIHZhciB0ID0gLXdvcmxkTm9ybWFsLmRvdChwbGFuZVBvaW50VG9Gcm9tKSAvIG5fZG90X2RpcjtcclxuICAgIGRpcmVjdGlvbi5zY2FsZSh0LCBkaXJfc2NhbGVkX3dpdGhfdCk7XHJcbiAgICBmcm9tLnZhZGQoZGlyX3NjYWxlZF93aXRoX3QsIGhpdFBvaW50V29ybGQpO1xyXG5cclxuICAgIHRoaXMucmVwb3J0SW50ZXJzZWN0aW9uKHdvcmxkTm9ybWFsLCBoaXRQb2ludFdvcmxkLCByZXBvcnRlZFNoYXBlLCBib2R5LCAtMSk7XHJcbn07XHJcblJheS5wcm90b3R5cGVbU2hhcGUudHlwZXMuUExBTkVdID0gUmF5LnByb3RvdHlwZS5pbnRlcnNlY3RQbGFuZTtcclxuXHJcbi8qKlxyXG4gKiBHZXQgdGhlIHdvcmxkIEFBQkIgb2YgdGhlIHJheS5cclxuICogQG1ldGhvZCBnZXRBQUJCXHJcbiAqIEBwYXJhbSAge0FBQkJ9IGFhYmJcclxuICovXHJcblJheS5wcm90b3R5cGUuZ2V0QUFCQiA9IGZ1bmN0aW9uKHJlc3VsdCl7XHJcbiAgICB2YXIgdG8gPSB0aGlzLnRvO1xyXG4gICAgdmFyIGZyb20gPSB0aGlzLmZyb207XHJcbiAgICByZXN1bHQubG93ZXJCb3VuZC54ID0gTWF0aC5taW4odG8ueCwgZnJvbS54KTtcclxuICAgIHJlc3VsdC5sb3dlckJvdW5kLnkgPSBNYXRoLm1pbih0by55LCBmcm9tLnkpO1xyXG4gICAgcmVzdWx0Lmxvd2VyQm91bmQueiA9IE1hdGgubWluKHRvLnosIGZyb20ueik7XHJcbiAgICByZXN1bHQudXBwZXJCb3VuZC54ID0gTWF0aC5tYXgodG8ueCwgZnJvbS54KTtcclxuICAgIHJlc3VsdC51cHBlckJvdW5kLnkgPSBNYXRoLm1heCh0by55LCBmcm9tLnkpO1xyXG4gICAgcmVzdWx0LnVwcGVyQm91bmQueiA9IE1hdGgubWF4KHRvLnosIGZyb20ueik7XHJcbn07XHJcblxyXG52YXIgaW50ZXJzZWN0Q29udmV4T3B0aW9ucyA9IHtcclxuICAgIGZhY2VMaXN0OiBbMF1cclxufTtcclxudmFyIHdvcmxkUGlsbGFyT2Zmc2V0ID0gbmV3IFZlYzMoKTtcclxudmFyIGludGVyc2VjdEhlaWdodGZpZWxkX2xvY2FsUmF5ID0gbmV3IFJheSgpO1xyXG52YXIgaW50ZXJzZWN0SGVpZ2h0ZmllbGRfaW5kZXggPSBbXTtcclxudmFyIGludGVyc2VjdEhlaWdodGZpZWxkX21pbk1heCA9IFtdO1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgaW50ZXJzZWN0SGVpZ2h0ZmllbGRcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtICB7U2hhcGV9IHNoYXBlXHJcbiAqIEBwYXJhbSAge1F1YXRlcm5pb259IHF1YXRcclxuICogQHBhcmFtICB7VmVjM30gcG9zaXRpb25cclxuICogQHBhcmFtICB7Qm9keX0gYm9keVxyXG4gKi9cclxuUmF5LnByb3RvdHlwZS5pbnRlcnNlY3RIZWlnaHRmaWVsZCA9IGZ1bmN0aW9uKHNoYXBlLCBxdWF0LCBwb3NpdGlvbiwgYm9keSwgcmVwb3J0ZWRTaGFwZSl7XHJcbiAgICB2YXIgZGF0YSA9IHNoYXBlLmRhdGEsXHJcbiAgICAgICAgdyA9IHNoYXBlLmVsZW1lbnRTaXplO1xyXG5cclxuICAgIC8vIENvbnZlcnQgdGhlIHJheSB0byBsb2NhbCBoZWlnaHRmaWVsZCBjb29yZGluYXRlc1xyXG4gICAgdmFyIGxvY2FsUmF5ID0gaW50ZXJzZWN0SGVpZ2h0ZmllbGRfbG9jYWxSYXk7IC8vbmV3IFJheSh0aGlzLmZyb20sIHRoaXMudG8pO1xyXG4gICAgbG9jYWxSYXkuZnJvbS5jb3B5KHRoaXMuZnJvbSk7XHJcbiAgICBsb2NhbFJheS50by5jb3B5KHRoaXMudG8pO1xyXG4gICAgVHJhbnNmb3JtLnBvaW50VG9Mb2NhbEZyYW1lKHBvc2l0aW9uLCBxdWF0LCBsb2NhbFJheS5mcm9tLCBsb2NhbFJheS5mcm9tKTtcclxuICAgIFRyYW5zZm9ybS5wb2ludFRvTG9jYWxGcmFtZShwb3NpdGlvbiwgcXVhdCwgbG9jYWxSYXkudG8sIGxvY2FsUmF5LnRvKTtcclxuICAgIGxvY2FsUmF5Ll91cGRhdGVEaXJlY3Rpb24oKTtcclxuXHJcbiAgICAvLyBHZXQgdGhlIGluZGV4IG9mIHRoZSBkYXRhIHBvaW50cyB0byB0ZXN0IGFnYWluc3RcclxuICAgIHZhciBpbmRleCA9IGludGVyc2VjdEhlaWdodGZpZWxkX2luZGV4O1xyXG4gICAgdmFyIGlNaW5YLCBpTWluWSwgaU1heFgsIGlNYXhZO1xyXG5cclxuICAgIC8vIFNldCB0byBtYXhcclxuICAgIGlNaW5YID0gaU1pblkgPSAwO1xyXG4gICAgaU1heFggPSBpTWF4WSA9IHNoYXBlLmRhdGEubGVuZ3RoIC0gMTtcclxuXHJcbiAgICB2YXIgYWFiYiA9IG5ldyBBQUJCKCk7XHJcbiAgICBsb2NhbFJheS5nZXRBQUJCKGFhYmIpO1xyXG5cclxuICAgIHNoYXBlLmdldEluZGV4T2ZQb3NpdGlvbihhYWJiLmxvd2VyQm91bmQueCwgYWFiYi5sb3dlckJvdW5kLnksIGluZGV4LCB0cnVlKTtcclxuICAgIGlNaW5YID0gTWF0aC5tYXgoaU1pblgsIGluZGV4WzBdKTtcclxuICAgIGlNaW5ZID0gTWF0aC5tYXgoaU1pblksIGluZGV4WzFdKTtcclxuICAgIHNoYXBlLmdldEluZGV4T2ZQb3NpdGlvbihhYWJiLnVwcGVyQm91bmQueCwgYWFiYi51cHBlckJvdW5kLnksIGluZGV4LCB0cnVlKTtcclxuICAgIGlNYXhYID0gTWF0aC5taW4oaU1heFgsIGluZGV4WzBdICsgMSk7XHJcbiAgICBpTWF4WSA9IE1hdGgubWluKGlNYXhZLCBpbmRleFsxXSArIDEpO1xyXG5cclxuICAgIGZvcih2YXIgaSA9IGlNaW5YOyBpIDwgaU1heFg7IGkrKyl7XHJcbiAgICAgICAgZm9yKHZhciBqID0gaU1pblk7IGogPCBpTWF4WTsgaisrKXtcclxuXHJcbiAgICAgICAgICAgIGlmKHRoaXMucmVzdWx0Ll9zaG91bGRTdG9wKXtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgc2hhcGUuZ2V0QWFiYkF0SW5kZXgoaSwgaiwgYWFiYik7XHJcbiAgICAgICAgICAgIGlmKCFhYWJiLm92ZXJsYXBzUmF5KGxvY2FsUmF5KSl7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gTG93ZXIgdHJpYW5nbGVcclxuICAgICAgICAgICAgc2hhcGUuZ2V0Q29udmV4VHJpYW5nbGVQaWxsYXIoaSwgaiwgZmFsc2UpO1xyXG4gICAgICAgICAgICBUcmFuc2Zvcm0ucG9pbnRUb1dvcmxkRnJhbWUocG9zaXRpb24sIHF1YXQsIHNoYXBlLnBpbGxhck9mZnNldCwgd29ybGRQaWxsYXJPZmZzZXQpO1xyXG4gICAgICAgICAgICB0aGlzLmludGVyc2VjdENvbnZleChzaGFwZS5waWxsYXJDb252ZXgsIHF1YXQsIHdvcmxkUGlsbGFyT2Zmc2V0LCBib2R5LCByZXBvcnRlZFNoYXBlLCBpbnRlcnNlY3RDb252ZXhPcHRpb25zKTtcclxuXHJcbiAgICAgICAgICAgIGlmKHRoaXMucmVzdWx0Ll9zaG91bGRTdG9wKXtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gVXBwZXIgdHJpYW5nbGVcclxuICAgICAgICAgICAgc2hhcGUuZ2V0Q29udmV4VHJpYW5nbGVQaWxsYXIoaSwgaiwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIFRyYW5zZm9ybS5wb2ludFRvV29ybGRGcmFtZShwb3NpdGlvbiwgcXVhdCwgc2hhcGUucGlsbGFyT2Zmc2V0LCB3b3JsZFBpbGxhck9mZnNldCk7XHJcbiAgICAgICAgICAgIHRoaXMuaW50ZXJzZWN0Q29udmV4KHNoYXBlLnBpbGxhckNvbnZleCwgcXVhdCwgd29ybGRQaWxsYXJPZmZzZXQsIGJvZHksIHJlcG9ydGVkU2hhcGUsIGludGVyc2VjdENvbnZleE9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuUmF5LnByb3RvdHlwZVtTaGFwZS50eXBlcy5IRUlHSFRGSUVMRF0gPSBSYXkucHJvdG90eXBlLmludGVyc2VjdEhlaWdodGZpZWxkO1xyXG5cclxudmFyIFJheV9pbnRlcnNlY3RTcGhlcmVfaW50ZXJzZWN0aW9uUG9pbnQgPSBuZXcgVmVjMygpO1xyXG52YXIgUmF5X2ludGVyc2VjdFNwaGVyZV9ub3JtYWwgPSBuZXcgVmVjMygpO1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgaW50ZXJzZWN0U3BoZXJlXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSAge1NoYXBlfSBzaGFwZVxyXG4gKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSBxdWF0XHJcbiAqIEBwYXJhbSAge1ZlYzN9IHBvc2l0aW9uXHJcbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlcclxuICovXHJcblJheS5wcm90b3R5cGUuaW50ZXJzZWN0U3BoZXJlID0gZnVuY3Rpb24oc2hhcGUsIHF1YXQsIHBvc2l0aW9uLCBib2R5LCByZXBvcnRlZFNoYXBlKXtcclxuICAgIHZhciBmcm9tID0gdGhpcy5mcm9tLFxyXG4gICAgICAgIHRvID0gdGhpcy50byxcclxuICAgICAgICByID0gc2hhcGUucmFkaXVzO1xyXG5cclxuICAgIHZhciBhID0gTWF0aC5wb3codG8ueCAtIGZyb20ueCwgMikgKyBNYXRoLnBvdyh0by55IC0gZnJvbS55LCAyKSArIE1hdGgucG93KHRvLnogLSBmcm9tLnosIDIpO1xyXG4gICAgdmFyIGIgPSAyICogKCh0by54IC0gZnJvbS54KSAqIChmcm9tLnggLSBwb3NpdGlvbi54KSArICh0by55IC0gZnJvbS55KSAqIChmcm9tLnkgLSBwb3NpdGlvbi55KSArICh0by56IC0gZnJvbS56KSAqIChmcm9tLnogLSBwb3NpdGlvbi56KSk7XHJcbiAgICB2YXIgYyA9IE1hdGgucG93KGZyb20ueCAtIHBvc2l0aW9uLngsIDIpICsgTWF0aC5wb3coZnJvbS55IC0gcG9zaXRpb24ueSwgMikgKyBNYXRoLnBvdyhmcm9tLnogLSBwb3NpdGlvbi56LCAyKSAtIE1hdGgucG93KHIsIDIpO1xyXG5cclxuICAgIHZhciBkZWx0YSA9IE1hdGgucG93KGIsIDIpIC0gNCAqIGEgKiBjO1xyXG5cclxuICAgIHZhciBpbnRlcnNlY3Rpb25Qb2ludCA9IFJheV9pbnRlcnNlY3RTcGhlcmVfaW50ZXJzZWN0aW9uUG9pbnQ7XHJcbiAgICB2YXIgbm9ybWFsID0gUmF5X2ludGVyc2VjdFNwaGVyZV9ub3JtYWw7XHJcblxyXG4gICAgaWYoZGVsdGEgPCAwKXtcclxuICAgICAgICAvLyBObyBpbnRlcnNlY3Rpb25cclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgfSBlbHNlIGlmKGRlbHRhID09PSAwKXtcclxuICAgICAgICAvLyBzaW5nbGUgaW50ZXJzZWN0aW9uIHBvaW50XHJcbiAgICAgICAgZnJvbS5sZXJwKHRvLCBkZWx0YSwgaW50ZXJzZWN0aW9uUG9pbnQpO1xyXG5cclxuICAgICAgICBpbnRlcnNlY3Rpb25Qb2ludC52c3ViKHBvc2l0aW9uLCBub3JtYWwpO1xyXG4gICAgICAgIG5vcm1hbC5ub3JtYWxpemUoKTtcclxuXHJcbiAgICAgICAgdGhpcy5yZXBvcnRJbnRlcnNlY3Rpb24obm9ybWFsLCBpbnRlcnNlY3Rpb25Qb2ludCwgcmVwb3J0ZWRTaGFwZSwgYm9keSwgLTEpO1xyXG5cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdmFyIGQxID0gKC0gYiAtIE1hdGguc3FydChkZWx0YSkpIC8gKDIgKiBhKTtcclxuICAgICAgICB2YXIgZDIgPSAoLSBiICsgTWF0aC5zcXJ0KGRlbHRhKSkgLyAoMiAqIGEpO1xyXG5cclxuICAgICAgICBpZihkMSA+PSAwICYmIGQxIDw9IDEpe1xyXG4gICAgICAgICAgICBmcm9tLmxlcnAodG8sIGQxLCBpbnRlcnNlY3Rpb25Qb2ludCk7XHJcbiAgICAgICAgICAgIGludGVyc2VjdGlvblBvaW50LnZzdWIocG9zaXRpb24sIG5vcm1hbCk7XHJcbiAgICAgICAgICAgIG5vcm1hbC5ub3JtYWxpemUoKTtcclxuICAgICAgICAgICAgdGhpcy5yZXBvcnRJbnRlcnNlY3Rpb24obm9ybWFsLCBpbnRlcnNlY3Rpb25Qb2ludCwgcmVwb3J0ZWRTaGFwZSwgYm9keSwgLTEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYodGhpcy5yZXN1bHQuX3Nob3VsZFN0b3Ape1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZihkMiA+PSAwICYmIGQyIDw9IDEpe1xyXG4gICAgICAgICAgICBmcm9tLmxlcnAodG8sIGQyLCBpbnRlcnNlY3Rpb25Qb2ludCk7XHJcbiAgICAgICAgICAgIGludGVyc2VjdGlvblBvaW50LnZzdWIocG9zaXRpb24sIG5vcm1hbCk7XHJcbiAgICAgICAgICAgIG5vcm1hbC5ub3JtYWxpemUoKTtcclxuICAgICAgICAgICAgdGhpcy5yZXBvcnRJbnRlcnNlY3Rpb24obm9ybWFsLCBpbnRlcnNlY3Rpb25Qb2ludCwgcmVwb3J0ZWRTaGFwZSwgYm9keSwgLTEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuUmF5LnByb3RvdHlwZVtTaGFwZS50eXBlcy5TUEhFUkVdID0gUmF5LnByb3RvdHlwZS5pbnRlcnNlY3RTcGhlcmU7XHJcblxyXG5cclxudmFyIGludGVyc2VjdENvbnZleF9ub3JtYWwgPSBuZXcgVmVjMygpO1xyXG52YXIgaW50ZXJzZWN0Q29udmV4X21pbkRpc3ROb3JtYWwgPSBuZXcgVmVjMygpO1xyXG52YXIgaW50ZXJzZWN0Q29udmV4X21pbkRpc3RJbnRlcnNlY3QgPSBuZXcgVmVjMygpO1xyXG52YXIgaW50ZXJzZWN0Q29udmV4X3ZlY3RvciA9IG5ldyBWZWMzKCk7XHJcblxyXG4vKipcclxuICogQG1ldGhvZCBpbnRlcnNlY3RDb252ZXhcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtICB7U2hhcGV9IHNoYXBlXHJcbiAqIEBwYXJhbSAge1F1YXRlcm5pb259IHF1YXRcclxuICogQHBhcmFtICB7VmVjM30gcG9zaXRpb25cclxuICogQHBhcmFtICB7Qm9keX0gYm9keVxyXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXHJcbiAqIEBwYXJhbSB7YXJyYXl9IFtvcHRpb25zLmZhY2VMaXN0XVxyXG4gKi9cclxuUmF5LnByb3RvdHlwZS5pbnRlcnNlY3RDb252ZXggPSBmdW5jdGlvbiBpbnRlcnNlY3RDb252ZXgoXHJcbiAgICBzaGFwZSxcclxuICAgIHF1YXQsXHJcbiAgICBwb3NpdGlvbixcclxuICAgIGJvZHksXHJcbiAgICByZXBvcnRlZFNoYXBlLFxyXG4gICAgb3B0aW9uc1xyXG4pe1xyXG4gICAgdmFyIG1pbkRpc3ROb3JtYWwgPSBpbnRlcnNlY3RDb252ZXhfbWluRGlzdE5vcm1hbDtcclxuICAgIHZhciBub3JtYWwgPSBpbnRlcnNlY3RDb252ZXhfbm9ybWFsO1xyXG4gICAgdmFyIHZlY3RvciA9IGludGVyc2VjdENvbnZleF92ZWN0b3I7XHJcbiAgICB2YXIgbWluRGlzdEludGVyc2VjdCA9IGludGVyc2VjdENvbnZleF9taW5EaXN0SW50ZXJzZWN0O1xyXG4gICAgdmFyIGZhY2VMaXN0ID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5mYWNlTGlzdCkgfHwgbnVsbDtcclxuXHJcbiAgICAvLyBDaGVja2luZyBmYWNlc1xyXG4gICAgdmFyIGZhY2VzID0gc2hhcGUuZmFjZXMsXHJcbiAgICAgICAgdmVydGljZXMgPSBzaGFwZS52ZXJ0aWNlcyxcclxuICAgICAgICBub3JtYWxzID0gc2hhcGUuZmFjZU5vcm1hbHM7XHJcbiAgICB2YXIgZGlyZWN0aW9uID0gdGhpcy5fZGlyZWN0aW9uO1xyXG5cclxuICAgIHZhciBmcm9tID0gdGhpcy5mcm9tO1xyXG4gICAgdmFyIHRvID0gdGhpcy50bztcclxuICAgIHZhciBmcm9tVG9EaXN0YW5jZSA9IGZyb20uZGlzdGFuY2VUbyh0byk7XHJcblxyXG4gICAgdmFyIG1pbkRpc3QgPSAtMTtcclxuICAgIHZhciBOZmFjZXMgPSBmYWNlTGlzdCA/IGZhY2VMaXN0Lmxlbmd0aCA6IGZhY2VzLmxlbmd0aDtcclxuICAgIHZhciByZXN1bHQgPSB0aGlzLnJlc3VsdDtcclxuXHJcbiAgICBmb3IgKHZhciBqID0gMDsgIXJlc3VsdC5fc2hvdWxkU3RvcCAmJiBqIDwgTmZhY2VzOyBqKyspIHtcclxuICAgICAgICB2YXIgZmkgPSBmYWNlTGlzdCA/IGZhY2VMaXN0W2pdIDogajtcclxuXHJcbiAgICAgICAgdmFyIGZhY2UgPSBmYWNlc1tmaV07XHJcbiAgICAgICAgdmFyIGZhY2VOb3JtYWwgPSBub3JtYWxzW2ZpXTtcclxuICAgICAgICB2YXIgcSA9IHF1YXQ7XHJcbiAgICAgICAgdmFyIHggPSBwb3NpdGlvbjtcclxuXHJcbiAgICAgICAgLy8gZGV0ZXJtaW5lIGlmIHJheSBpbnRlcnNlY3RzIHRoZSBwbGFuZSBvZiB0aGUgZmFjZVxyXG4gICAgICAgIC8vIG5vdGU6IHRoaXMgd29ya3MgcmVnYXJkbGVzcyBvZiB0aGUgZGlyZWN0aW9uIG9mIHRoZSBmYWNlIG5vcm1hbFxyXG5cclxuICAgICAgICAvLyBHZXQgcGxhbmUgcG9pbnQgaW4gd29ybGQgY29vcmRpbmF0ZXMuLi5cclxuICAgICAgICB2ZWN0b3IuY29weSh2ZXJ0aWNlc1tmYWNlWzBdXSk7XHJcbiAgICAgICAgcS52bXVsdCh2ZWN0b3IsdmVjdG9yKTtcclxuICAgICAgICB2ZWN0b3IudmFkZCh4LHZlY3Rvcik7XHJcblxyXG4gICAgICAgIC8vIC4uLmJ1dCBtYWtlIGl0IHJlbGF0aXZlIHRvIHRoZSByYXkgZnJvbS4gV2UnbGwgZml4IHRoaXMgbGF0ZXIuXHJcbiAgICAgICAgdmVjdG9yLnZzdWIoZnJvbSx2ZWN0b3IpO1xyXG5cclxuICAgICAgICAvLyBHZXQgcGxhbmUgbm9ybWFsXHJcbiAgICAgICAgcS52bXVsdChmYWNlTm9ybWFsLG5vcm1hbCk7XHJcblxyXG4gICAgICAgIC8vIElmIHRoaXMgZG90IHByb2R1Y3QgaXMgbmVnYXRpdmUsIHdlIGhhdmUgc29tZXRoaW5nIGludGVyZXN0aW5nXHJcbiAgICAgICAgdmFyIGRvdCA9IGRpcmVjdGlvbi5kb3Qobm9ybWFsKTtcclxuXHJcbiAgICAgICAgLy8gQmFpbCBvdXQgaWYgcmF5IGFuZCBwbGFuZSBhcmUgcGFyYWxsZWxcclxuICAgICAgICBpZiAoIE1hdGguYWJzKCBkb3QgKSA8IHRoaXMucHJlY2lzaW9uICl7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gY2FsYyBkaXN0YW5jZSB0byBwbGFuZVxyXG4gICAgICAgIHZhciBzY2FsYXIgPSBub3JtYWwuZG90KHZlY3RvcikgLyBkb3Q7XHJcblxyXG4gICAgICAgIC8vIGlmIG5lZ2F0aXZlIGRpc3RhbmNlLCB0aGVuIHBsYW5lIGlzIGJlaGluZCByYXlcclxuICAgICAgICBpZiAoc2NhbGFyIDwgMCl7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gaWYgKGRvdCA8IDApIHtcclxuXHJcbiAgICAgICAgLy8gSW50ZXJzZWN0aW9uIHBvaW50IGlzIGZyb20gKyBkaXJlY3Rpb24gKiBzY2FsYXJcclxuICAgICAgICBkaXJlY3Rpb24ubXVsdChzY2FsYXIsaW50ZXJzZWN0UG9pbnQpO1xyXG4gICAgICAgIGludGVyc2VjdFBvaW50LnZhZGQoZnJvbSxpbnRlcnNlY3RQb2ludCk7XHJcblxyXG4gICAgICAgIC8vIGEgaXMgdGhlIHBvaW50IHdlIGNvbXBhcmUgcG9pbnRzIGIgYW5kIGMgd2l0aC5cclxuICAgICAgICBhLmNvcHkodmVydGljZXNbZmFjZVswXV0pO1xyXG4gICAgICAgIHEudm11bHQoYSxhKTtcclxuICAgICAgICB4LnZhZGQoYSxhKTtcclxuXHJcbiAgICAgICAgZm9yKHZhciBpID0gMTsgIXJlc3VsdC5fc2hvdWxkU3RvcCAmJiBpIDwgZmFjZS5sZW5ndGggLSAxOyBpKyspe1xyXG4gICAgICAgICAgICAvLyBUcmFuc2Zvcm0gMyB2ZXJ0aWNlcyB0byB3b3JsZCBjb29yZHNcclxuICAgICAgICAgICAgYi5jb3B5KHZlcnRpY2VzW2ZhY2VbaV1dKTtcclxuICAgICAgICAgICAgYy5jb3B5KHZlcnRpY2VzW2ZhY2VbaSsxXV0pO1xyXG4gICAgICAgICAgICBxLnZtdWx0KGIsYik7XHJcbiAgICAgICAgICAgIHEudm11bHQoYyxjKTtcclxuICAgICAgICAgICAgeC52YWRkKGIsYik7XHJcbiAgICAgICAgICAgIHgudmFkZChjLGMpO1xyXG5cclxuICAgICAgICAgICAgdmFyIGRpc3RhbmNlID0gaW50ZXJzZWN0UG9pbnQuZGlzdGFuY2VUbyhmcm9tKTtcclxuXHJcbiAgICAgICAgICAgIGlmKCEocG9pbnRJblRyaWFuZ2xlKGludGVyc2VjdFBvaW50LCBhLCBiLCBjKSB8fCBwb2ludEluVHJpYW5nbGUoaW50ZXJzZWN0UG9pbnQsIGIsIGEsIGMpKSB8fCBkaXN0YW5jZSA+IGZyb21Ub0Rpc3RhbmNlKXtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLnJlcG9ydEludGVyc2VjdGlvbihub3JtYWwsIGludGVyc2VjdFBvaW50LCByZXBvcnRlZFNoYXBlLCBib2R5LCBmaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIH1cclxuICAgIH1cclxufTtcclxuUmF5LnByb3RvdHlwZVtTaGFwZS50eXBlcy5DT05WRVhQT0xZSEVEUk9OXSA9IFJheS5wcm90b3R5cGUuaW50ZXJzZWN0Q29udmV4O1xyXG5cclxudmFyIGludGVyc2VjdFRyaW1lc2hfbm9ybWFsID0gbmV3IFZlYzMoKTtcclxudmFyIGludGVyc2VjdFRyaW1lc2hfbG9jYWxEaXJlY3Rpb24gPSBuZXcgVmVjMygpO1xyXG52YXIgaW50ZXJzZWN0VHJpbWVzaF9sb2NhbEZyb20gPSBuZXcgVmVjMygpO1xyXG52YXIgaW50ZXJzZWN0VHJpbWVzaF9sb2NhbFRvID0gbmV3IFZlYzMoKTtcclxudmFyIGludGVyc2VjdFRyaW1lc2hfd29ybGROb3JtYWwgPSBuZXcgVmVjMygpO1xyXG52YXIgaW50ZXJzZWN0VHJpbWVzaF93b3JsZEludGVyc2VjdFBvaW50ID0gbmV3IFZlYzMoKTtcclxudmFyIGludGVyc2VjdFRyaW1lc2hfbG9jYWxBQUJCID0gbmV3IEFBQkIoKTtcclxudmFyIGludGVyc2VjdFRyaW1lc2hfdHJpYW5nbGVzID0gW107XHJcbnZhciBpbnRlcnNlY3RUcmltZXNoX3RyZWVUcmFuc2Zvcm0gPSBuZXcgVHJhbnNmb3JtKCk7XHJcblxyXG4vKipcclxuICogQG1ldGhvZCBpbnRlcnNlY3RUcmltZXNoXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSAge1NoYXBlfSBzaGFwZVxyXG4gKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSBxdWF0XHJcbiAqIEBwYXJhbSAge1ZlYzN9IHBvc2l0aW9uXHJcbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlcclxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxyXG4gKiBAdG9kbyBPcHRpbWl6ZSBieSB0cmFuc2Zvcm1pbmcgdGhlIHdvcmxkIHRvIGxvY2FsIHNwYWNlIGZpcnN0LlxyXG4gKiBAdG9kbyBVc2UgT2N0cmVlIGxvb2t1cFxyXG4gKi9cclxuUmF5LnByb3RvdHlwZS5pbnRlcnNlY3RUcmltZXNoID0gZnVuY3Rpb24gaW50ZXJzZWN0VHJpbWVzaChcclxuICAgIG1lc2gsXHJcbiAgICBxdWF0LFxyXG4gICAgcG9zaXRpb24sXHJcbiAgICBib2R5LFxyXG4gICAgcmVwb3J0ZWRTaGFwZSxcclxuICAgIG9wdGlvbnNcclxuKXtcclxuICAgIHZhciBub3JtYWwgPSBpbnRlcnNlY3RUcmltZXNoX25vcm1hbDtcclxuICAgIHZhciB0cmlhbmdsZXMgPSBpbnRlcnNlY3RUcmltZXNoX3RyaWFuZ2xlcztcclxuICAgIHZhciB0cmVlVHJhbnNmb3JtID0gaW50ZXJzZWN0VHJpbWVzaF90cmVlVHJhbnNmb3JtO1xyXG4gICAgdmFyIG1pbkRpc3ROb3JtYWwgPSBpbnRlcnNlY3RDb252ZXhfbWluRGlzdE5vcm1hbDtcclxuICAgIHZhciB2ZWN0b3IgPSBpbnRlcnNlY3RDb252ZXhfdmVjdG9yO1xyXG4gICAgdmFyIG1pbkRpc3RJbnRlcnNlY3QgPSBpbnRlcnNlY3RDb252ZXhfbWluRGlzdEludGVyc2VjdDtcclxuICAgIHZhciBsb2NhbEFBQkIgPSBpbnRlcnNlY3RUcmltZXNoX2xvY2FsQUFCQjtcclxuICAgIHZhciBsb2NhbERpcmVjdGlvbiA9IGludGVyc2VjdFRyaW1lc2hfbG9jYWxEaXJlY3Rpb247XHJcbiAgICB2YXIgbG9jYWxGcm9tID0gaW50ZXJzZWN0VHJpbWVzaF9sb2NhbEZyb207XHJcbiAgICB2YXIgbG9jYWxUbyA9IGludGVyc2VjdFRyaW1lc2hfbG9jYWxUbztcclxuICAgIHZhciB3b3JsZEludGVyc2VjdFBvaW50ID0gaW50ZXJzZWN0VHJpbWVzaF93b3JsZEludGVyc2VjdFBvaW50O1xyXG4gICAgdmFyIHdvcmxkTm9ybWFsID0gaW50ZXJzZWN0VHJpbWVzaF93b3JsZE5vcm1hbDtcclxuICAgIHZhciBmYWNlTGlzdCA9IChvcHRpb25zICYmIG9wdGlvbnMuZmFjZUxpc3QpIHx8IG51bGw7XHJcblxyXG4gICAgLy8gQ2hlY2tpbmcgZmFjZXNcclxuICAgIHZhciBpbmRpY2VzID0gbWVzaC5pbmRpY2VzLFxyXG4gICAgICAgIHZlcnRpY2VzID0gbWVzaC52ZXJ0aWNlcyxcclxuICAgICAgICBub3JtYWxzID0gbWVzaC5mYWNlTm9ybWFscztcclxuXHJcbiAgICB2YXIgZnJvbSA9IHRoaXMuZnJvbTtcclxuICAgIHZhciB0byA9IHRoaXMudG87XHJcbiAgICB2YXIgZGlyZWN0aW9uID0gdGhpcy5fZGlyZWN0aW9uO1xyXG5cclxuICAgIHZhciBtaW5EaXN0ID0gLTE7XHJcbiAgICB0cmVlVHJhbnNmb3JtLnBvc2l0aW9uLmNvcHkocG9zaXRpb24pO1xyXG4gICAgdHJlZVRyYW5zZm9ybS5xdWF0ZXJuaW9uLmNvcHkocXVhdCk7XHJcblxyXG4gICAgLy8gVHJhbnNmb3JtIHJheSB0byBsb2NhbCBzcGFjZSFcclxuICAgIFRyYW5zZm9ybS52ZWN0b3JUb0xvY2FsRnJhbWUocG9zaXRpb24sIHF1YXQsIGRpcmVjdGlvbiwgbG9jYWxEaXJlY3Rpb24pO1xyXG4gICAgVHJhbnNmb3JtLnBvaW50VG9Mb2NhbEZyYW1lKHBvc2l0aW9uLCBxdWF0LCBmcm9tLCBsb2NhbEZyb20pO1xyXG4gICAgVHJhbnNmb3JtLnBvaW50VG9Mb2NhbEZyYW1lKHBvc2l0aW9uLCBxdWF0LCB0bywgbG9jYWxUbyk7XHJcblxyXG4gICAgbG9jYWxUby54ICo9IG1lc2guc2NhbGUueDtcclxuICAgIGxvY2FsVG8ueSAqPSBtZXNoLnNjYWxlLnk7XHJcbiAgICBsb2NhbFRvLnogKj0gbWVzaC5zY2FsZS56O1xyXG4gICAgbG9jYWxGcm9tLnggKj0gbWVzaC5zY2FsZS54O1xyXG4gICAgbG9jYWxGcm9tLnkgKj0gbWVzaC5zY2FsZS55O1xyXG4gICAgbG9jYWxGcm9tLnogKj0gbWVzaC5zY2FsZS56O1xyXG5cclxuICAgIGxvY2FsVG8udnN1Yihsb2NhbEZyb20sIGxvY2FsRGlyZWN0aW9uKTtcclxuICAgIGxvY2FsRGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xyXG5cclxuICAgIHZhciBmcm9tVG9EaXN0YW5jZVNxdWFyZWQgPSBsb2NhbEZyb20uZGlzdGFuY2VTcXVhcmVkKGxvY2FsVG8pO1xyXG5cclxuICAgIG1lc2gudHJlZS5yYXlRdWVyeSh0aGlzLCB0cmVlVHJhbnNmb3JtLCB0cmlhbmdsZXMpO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwLCBOID0gdHJpYW5nbGVzLmxlbmd0aDsgIXRoaXMucmVzdWx0Ll9zaG91bGRTdG9wICYmIGkgIT09IE47IGkrKykge1xyXG4gICAgICAgIHZhciB0cmlhbmdsZXNJbmRleCA9IHRyaWFuZ2xlc1tpXTtcclxuXHJcbiAgICAgICAgbWVzaC5nZXROb3JtYWwodHJpYW5nbGVzSW5kZXgsIG5vcm1hbCk7XHJcblxyXG4gICAgICAgIC8vIGRldGVybWluZSBpZiByYXkgaW50ZXJzZWN0cyB0aGUgcGxhbmUgb2YgdGhlIGZhY2VcclxuICAgICAgICAvLyBub3RlOiB0aGlzIHdvcmtzIHJlZ2FyZGxlc3Mgb2YgdGhlIGRpcmVjdGlvbiBvZiB0aGUgZmFjZSBub3JtYWxcclxuXHJcbiAgICAgICAgLy8gR2V0IHBsYW5lIHBvaW50IGluIHdvcmxkIGNvb3JkaW5hdGVzLi4uXHJcbiAgICAgICAgbWVzaC5nZXRWZXJ0ZXgoaW5kaWNlc1t0cmlhbmdsZXNJbmRleCAqIDNdLCBhKTtcclxuXHJcbiAgICAgICAgLy8gLi4uYnV0IG1ha2UgaXQgcmVsYXRpdmUgdG8gdGhlIHJheSBmcm9tLiBXZSdsbCBmaXggdGhpcyBsYXRlci5cclxuICAgICAgICBhLnZzdWIobG9jYWxGcm9tLHZlY3Rvcik7XHJcblxyXG4gICAgICAgIC8vIElmIHRoaXMgZG90IHByb2R1Y3QgaXMgbmVnYXRpdmUsIHdlIGhhdmUgc29tZXRoaW5nIGludGVyZXN0aW5nXHJcbiAgICAgICAgdmFyIGRvdCA9IGxvY2FsRGlyZWN0aW9uLmRvdChub3JtYWwpO1xyXG5cclxuICAgICAgICAvLyBCYWlsIG91dCBpZiByYXkgYW5kIHBsYW5lIGFyZSBwYXJhbGxlbFxyXG4gICAgICAgIC8vIGlmIChNYXRoLmFicyggZG90ICkgPCB0aGlzLnByZWNpc2lvbil7XHJcbiAgICAgICAgLy8gICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIC8vIH1cclxuXHJcbiAgICAgICAgLy8gY2FsYyBkaXN0YW5jZSB0byBwbGFuZVxyXG4gICAgICAgIHZhciBzY2FsYXIgPSBub3JtYWwuZG90KHZlY3RvcikgLyBkb3Q7XHJcblxyXG4gICAgICAgIC8vIGlmIG5lZ2F0aXZlIGRpc3RhbmNlLCB0aGVuIHBsYW5lIGlzIGJlaGluZCByYXlcclxuICAgICAgICBpZiAoc2NhbGFyIDwgMCl7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gSW50ZXJzZWN0aW9uIHBvaW50IGlzIGZyb20gKyBkaXJlY3Rpb24gKiBzY2FsYXJcclxuICAgICAgICBsb2NhbERpcmVjdGlvbi5zY2FsZShzY2FsYXIsaW50ZXJzZWN0UG9pbnQpO1xyXG4gICAgICAgIGludGVyc2VjdFBvaW50LnZhZGQobG9jYWxGcm9tLGludGVyc2VjdFBvaW50KTtcclxuXHJcbiAgICAgICAgLy8gR2V0IHRyaWFuZ2xlIHZlcnRpY2VzXHJcbiAgICAgICAgbWVzaC5nZXRWZXJ0ZXgoaW5kaWNlc1t0cmlhbmdsZXNJbmRleCAqIDMgKyAxXSwgYik7XHJcbiAgICAgICAgbWVzaC5nZXRWZXJ0ZXgoaW5kaWNlc1t0cmlhbmdsZXNJbmRleCAqIDMgKyAyXSwgYyk7XHJcblxyXG4gICAgICAgIHZhciBzcXVhcmVkRGlzdGFuY2UgPSBpbnRlcnNlY3RQb2ludC5kaXN0YW5jZVNxdWFyZWQobG9jYWxGcm9tKTtcclxuXHJcbiAgICAgICAgaWYoIShwb2ludEluVHJpYW5nbGUoaW50ZXJzZWN0UG9pbnQsIGIsIGEsIGMpIHx8IHBvaW50SW5UcmlhbmdsZShpbnRlcnNlY3RQb2ludCwgYSwgYiwgYykpIHx8IHNxdWFyZWREaXN0YW5jZSA+IGZyb21Ub0Rpc3RhbmNlU3F1YXJlZCl7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gdHJhbnNmb3JtIGludGVyc2VjdHBvaW50IGFuZCBub3JtYWwgdG8gd29ybGRcclxuICAgICAgICBUcmFuc2Zvcm0udmVjdG9yVG9Xb3JsZEZyYW1lKHF1YXQsIG5vcm1hbCwgd29ybGROb3JtYWwpO1xyXG4gICAgICAgIFRyYW5zZm9ybS5wb2ludFRvV29ybGRGcmFtZShwb3NpdGlvbiwgcXVhdCwgaW50ZXJzZWN0UG9pbnQsIHdvcmxkSW50ZXJzZWN0UG9pbnQpO1xyXG4gICAgICAgIHRoaXMucmVwb3J0SW50ZXJzZWN0aW9uKHdvcmxkTm9ybWFsLCB3b3JsZEludGVyc2VjdFBvaW50LCByZXBvcnRlZFNoYXBlLCBib2R5LCB0cmlhbmdsZXNJbmRleCk7XHJcbiAgICB9XHJcbiAgICB0cmlhbmdsZXMubGVuZ3RoID0gMDtcclxufTtcclxuUmF5LnByb3RvdHlwZVtTaGFwZS50eXBlcy5UUklNRVNIXSA9IFJheS5wcm90b3R5cGUuaW50ZXJzZWN0VHJpbWVzaDtcclxuXHJcblxyXG4vKipcclxuICogQG1ldGhvZCByZXBvcnRJbnRlcnNlY3Rpb25cclxuICogQHByaXZhdGVcclxuICogQHBhcmFtICB7VmVjM30gbm9ybWFsXHJcbiAqIEBwYXJhbSAge1ZlYzN9IGhpdFBvaW50V29ybGRcclxuICogQHBhcmFtICB7U2hhcGV9IHNoYXBlXHJcbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlcclxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgaW50ZXJzZWN0aW9ucyBzaG91bGQgY29udGludWVcclxuICovXHJcblJheS5wcm90b3R5cGUucmVwb3J0SW50ZXJzZWN0aW9uID0gZnVuY3Rpb24obm9ybWFsLCBoaXRQb2ludFdvcmxkLCBzaGFwZSwgYm9keSwgaGl0RmFjZUluZGV4KXtcclxuICAgIHZhciBmcm9tID0gdGhpcy5mcm9tO1xyXG4gICAgdmFyIHRvID0gdGhpcy50bztcclxuICAgIHZhciBkaXN0YW5jZSA9IGZyb20uZGlzdGFuY2VUbyhoaXRQb2ludFdvcmxkKTtcclxuICAgIHZhciByZXN1bHQgPSB0aGlzLnJlc3VsdDtcclxuXHJcbiAgICAvLyBTa2lwIGJhY2sgZmFjZXM/XHJcbiAgICBpZih0aGlzLnNraXBCYWNrZmFjZXMgJiYgbm9ybWFsLmRvdCh0aGlzLl9kaXJlY3Rpb24pID4gMCl7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHJlc3VsdC5oaXRGYWNlSW5kZXggPSB0eXBlb2YoaGl0RmFjZUluZGV4KSAhPT0gJ3VuZGVmaW5lZCcgPyBoaXRGYWNlSW5kZXggOiAtMTtcclxuXHJcbiAgICBzd2l0Y2godGhpcy5tb2RlKXtcclxuICAgIGNhc2UgUmF5LkFMTDpcclxuICAgICAgICB0aGlzLmhhc0hpdCA9IHRydWU7XHJcbiAgICAgICAgcmVzdWx0LnNldChcclxuICAgICAgICAgICAgZnJvbSxcclxuICAgICAgICAgICAgdG8sXHJcbiAgICAgICAgICAgIG5vcm1hbCxcclxuICAgICAgICAgICAgaGl0UG9pbnRXb3JsZCxcclxuICAgICAgICAgICAgc2hhcGUsXHJcbiAgICAgICAgICAgIGJvZHksXHJcbiAgICAgICAgICAgIGRpc3RhbmNlXHJcbiAgICAgICAgKTtcclxuICAgICAgICByZXN1bHQuaGFzSGl0ID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmNhbGxiYWNrKHJlc3VsdCk7XHJcbiAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgY2FzZSBSYXkuQ0xPU0VTVDpcclxuXHJcbiAgICAgICAgLy8gU3RvcmUgaWYgY2xvc2VyIHRoYW4gY3VycmVudCBjbG9zZXN0XHJcbiAgICAgICAgaWYoZGlzdGFuY2UgPCByZXN1bHQuZGlzdGFuY2UgfHwgIXJlc3VsdC5oYXNIaXQpe1xyXG4gICAgICAgICAgICB0aGlzLmhhc0hpdCA9IHRydWU7XHJcbiAgICAgICAgICAgIHJlc3VsdC5oYXNIaXQgPSB0cnVlO1xyXG4gICAgICAgICAgICByZXN1bHQuc2V0KFxyXG4gICAgICAgICAgICAgICAgZnJvbSxcclxuICAgICAgICAgICAgICAgIHRvLFxyXG4gICAgICAgICAgICAgICAgbm9ybWFsLFxyXG4gICAgICAgICAgICAgICAgaGl0UG9pbnRXb3JsZCxcclxuICAgICAgICAgICAgICAgIHNoYXBlLFxyXG4gICAgICAgICAgICAgICAgYm9keSxcclxuICAgICAgICAgICAgICAgIGRpc3RhbmNlXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG5cclxuICAgIGNhc2UgUmF5LkFOWTpcclxuXHJcbiAgICAgICAgLy8gUmVwb3J0IGFuZCBzdG9wLlxyXG4gICAgICAgIHRoaXMuaGFzSGl0ID0gdHJ1ZTtcclxuICAgICAgICByZXN1bHQuaGFzSGl0ID0gdHJ1ZTtcclxuICAgICAgICByZXN1bHQuc2V0KFxyXG4gICAgICAgICAgICBmcm9tLFxyXG4gICAgICAgICAgICB0byxcclxuICAgICAgICAgICAgbm9ybWFsLFxyXG4gICAgICAgICAgICBoaXRQb2ludFdvcmxkLFxyXG4gICAgICAgICAgICBzaGFwZSxcclxuICAgICAgICAgICAgYm9keSxcclxuICAgICAgICAgICAgZGlzdGFuY2VcclxuICAgICAgICApO1xyXG4gICAgICAgIHJlc3VsdC5fc2hvdWxkU3RvcCA9IHRydWU7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbn07XHJcblxyXG52YXIgdjAgPSBuZXcgVmVjMygpLFxyXG4gICAgaW50ZXJzZWN0ID0gbmV3IFZlYzMoKTtcclxuZnVuY3Rpb24gZGlzdGFuY2VGcm9tSW50ZXJzZWN0aW9uKGZyb20sIGRpcmVjdGlvbiwgcG9zaXRpb24pIHtcclxuXHJcbiAgICAvLyB2MCBpcyB2ZWN0b3IgZnJvbSBmcm9tIHRvIHBvc2l0aW9uXHJcbiAgICBwb3NpdGlvbi52c3ViKGZyb20sdjApO1xyXG4gICAgdmFyIGRvdCA9IHYwLmRvdChkaXJlY3Rpb24pO1xyXG5cclxuICAgIC8vIGludGVyc2VjdCA9IGRpcmVjdGlvbipkb3QgKyBmcm9tXHJcbiAgICBkaXJlY3Rpb24ubXVsdChkb3QsaW50ZXJzZWN0KTtcclxuICAgIGludGVyc2VjdC52YWRkKGZyb20saW50ZXJzZWN0KTtcclxuXHJcbiAgICB2YXIgZGlzdGFuY2UgPSBwb3NpdGlvbi5kaXN0YW5jZVRvKGludGVyc2VjdCk7XHJcblxyXG4gICAgcmV0dXJuIGRpc3RhbmNlO1xyXG59XHJcblxyXG5cclxufSx7XCIuLi9jb2xsaXNpb24vQUFCQlwiOjMsXCIuLi9jb2xsaXNpb24vUmF5Y2FzdFJlc3VsdFwiOjExLFwiLi4vbWF0aC9RdWF0ZXJuaW9uXCI6MjksXCIuLi9tYXRoL1RyYW5zZm9ybVwiOjMwLFwiLi4vbWF0aC9WZWMzXCI6MzEsXCIuLi9zaGFwZXMvQm94XCI6MzgsXCIuLi9zaGFwZXMvQ29udmV4UG9seWhlZHJvblwiOjM5LFwiLi4vc2hhcGVzL1NoYXBlXCI6NDR9XSwxMTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XHJcbnZhciBWZWMzID0gX2RlcmVxXygnLi4vbWF0aC9WZWMzJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJheWNhc3RSZXN1bHQ7XHJcblxyXG4vKipcclxuICogU3RvcmFnZSBmb3IgUmF5IGNhc3RpbmcgZGF0YS5cclxuICogQGNsYXNzIFJheWNhc3RSZXN1bHRcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5mdW5jdGlvbiBSYXljYXN0UmVzdWx0KCl7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcm9wZXJ0eSB7VmVjM30gcmF5RnJvbVdvcmxkXHJcblx0ICovXHJcblx0dGhpcy5yYXlGcm9tV29ybGQgPSBuZXcgVmVjMygpO1xyXG5cclxuXHQvKipcclxuXHQgKiBAcHJvcGVydHkge1ZlYzN9IHJheVRvV29ybGRcclxuXHQgKi9cclxuXHR0aGlzLnJheVRvV29ybGQgPSBuZXcgVmVjMygpO1xyXG5cclxuXHQvKipcclxuXHQgKiBAcHJvcGVydHkge1ZlYzN9IGhpdE5vcm1hbFdvcmxkXHJcblx0ICovXHJcblx0dGhpcy5oaXROb3JtYWxXb3JsZCA9IG5ldyBWZWMzKCk7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcm9wZXJ0eSB7VmVjM30gaGl0UG9pbnRXb3JsZFxyXG5cdCAqL1xyXG5cdHRoaXMuaGl0UG9pbnRXb3JsZCA9IG5ldyBWZWMzKCk7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaGFzSGl0XHJcblx0ICovXHJcblx0dGhpcy5oYXNIaXQgPSBmYWxzZTtcclxuXHJcblx0LyoqXHJcblx0ICogVGhlIGhpdCBzaGFwZSwgb3IgbnVsbC5cclxuXHQgKiBAcHJvcGVydHkge1NoYXBlfSBzaGFwZVxyXG5cdCAqL1xyXG5cdHRoaXMuc2hhcGUgPSBudWxsO1xyXG5cclxuXHQvKipcclxuXHQgKiBUaGUgaGl0IGJvZHksIG9yIG51bGwuXHJcblx0ICogQHByb3BlcnR5IHtCb2R5fSBib2R5XHJcblx0ICovXHJcblx0dGhpcy5ib2R5ID0gbnVsbDtcclxuXHJcblx0LyoqXHJcblx0ICogVGhlIGluZGV4IG9mIHRoZSBoaXQgdHJpYW5nbGUsIGlmIHRoZSBoaXQgc2hhcGUgd2FzIGEgdHJpbWVzaC5cclxuXHQgKiBAcHJvcGVydHkge251bWJlcn0gaGl0RmFjZUluZGV4XHJcblx0ICogQGRlZmF1bHQgLTFcclxuXHQgKi9cclxuXHR0aGlzLmhpdEZhY2VJbmRleCA9IC0xO1xyXG5cclxuXHQvKipcclxuXHQgKiBEaXN0YW5jZSB0byB0aGUgaGl0LiBXaWxsIGJlIHNldCB0byAtMSBpZiB0aGVyZSB3YXMgbm8gaGl0LlxyXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkaXN0YW5jZVxyXG5cdCAqIEBkZWZhdWx0IC0xXHJcblx0ICovXHJcblx0dGhpcy5kaXN0YW5jZSA9IC0xO1xyXG5cclxuXHQvKipcclxuXHQgKiBJZiB0aGUgcmF5IHNob3VsZCBzdG9wIHRyYXZlcnNpbmcgdGhlIGJvZGllcy5cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gX3Nob3VsZFN0b3BcclxuXHQgKiBAZGVmYXVsdCBmYWxzZVxyXG5cdCAqL1xyXG5cdHRoaXMuX3Nob3VsZFN0b3AgPSBmYWxzZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJlc2V0IGFsbCByZXN1bHQgZGF0YS5cclxuICogQG1ldGhvZCByZXNldFxyXG4gKi9cclxuUmF5Y2FzdFJlc3VsdC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XHJcblx0dGhpcy5yYXlGcm9tV29ybGQuc2V0WmVybygpO1xyXG5cdHRoaXMucmF5VG9Xb3JsZC5zZXRaZXJvKCk7XHJcblx0dGhpcy5oaXROb3JtYWxXb3JsZC5zZXRaZXJvKCk7XHJcblx0dGhpcy5oaXRQb2ludFdvcmxkLnNldFplcm8oKTtcclxuXHR0aGlzLmhhc0hpdCA9IGZhbHNlO1xyXG5cdHRoaXMuc2hhcGUgPSBudWxsO1xyXG5cdHRoaXMuYm9keSA9IG51bGw7XHJcblx0dGhpcy5oaXRGYWNlSW5kZXggPSAtMTtcclxuXHR0aGlzLmRpc3RhbmNlID0gLTE7XHJcblx0dGhpcy5fc2hvdWxkU3RvcCA9IGZhbHNlO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgYWJvcnRcclxuICovXHJcblJheWNhc3RSZXN1bHQucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24oKXtcclxuXHR0aGlzLl9zaG91bGRTdG9wID0gdHJ1ZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kIHNldFxyXG4gKiBAcGFyYW0ge1ZlYzN9IHJheUZyb21Xb3JsZFxyXG4gKiBAcGFyYW0ge1ZlYzN9IHJheVRvV29ybGRcclxuICogQHBhcmFtIHtWZWMzfSBoaXROb3JtYWxXb3JsZFxyXG4gKiBAcGFyYW0ge1ZlYzN9IGhpdFBvaW50V29ybGRcclxuICogQHBhcmFtIHtTaGFwZX0gc2hhcGVcclxuICogQHBhcmFtIHtCb2R5fSBib2R5XHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBkaXN0YW5jZVxyXG4gKi9cclxuUmF5Y2FzdFJlc3VsdC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oXHJcblx0cmF5RnJvbVdvcmxkLFxyXG5cdHJheVRvV29ybGQsXHJcblx0aGl0Tm9ybWFsV29ybGQsXHJcblx0aGl0UG9pbnRXb3JsZCxcclxuXHRzaGFwZSxcclxuXHRib2R5LFxyXG5cdGRpc3RhbmNlXHJcbil7XHJcblx0dGhpcy5yYXlGcm9tV29ybGQuY29weShyYXlGcm9tV29ybGQpO1xyXG5cdHRoaXMucmF5VG9Xb3JsZC5jb3B5KHJheVRvV29ybGQpO1xyXG5cdHRoaXMuaGl0Tm9ybWFsV29ybGQuY29weShoaXROb3JtYWxXb3JsZCk7XHJcblx0dGhpcy5oaXRQb2ludFdvcmxkLmNvcHkoaGl0UG9pbnRXb3JsZCk7XHJcblx0dGhpcy5zaGFwZSA9IHNoYXBlO1xyXG5cdHRoaXMuYm9keSA9IGJvZHk7XHJcblx0dGhpcy5kaXN0YW5jZSA9IGRpc3RhbmNlO1xyXG59O1xyXG59LHtcIi4uL21hdGgvVmVjM1wiOjMxfV0sMTI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xyXG52YXIgU2hhcGUgPSBfZGVyZXFfKCcuLi9zaGFwZXMvU2hhcGUnKTtcclxudmFyIEJyb2FkcGhhc2UgPSBfZGVyZXFfKCcuLi9jb2xsaXNpb24vQnJvYWRwaGFzZScpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTQVBCcm9hZHBoYXNlO1xyXG5cclxuLyoqXHJcbiAqIFN3ZWVwIGFuZCBwcnVuZSBicm9hZHBoYXNlIGFsb25nIG9uZSBheGlzLlxyXG4gKlxyXG4gKiBAY2xhc3MgU0FQQnJvYWRwaGFzZVxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtXb3JsZH0gW3dvcmxkXVxyXG4gKiBAZXh0ZW5kcyBCcm9hZHBoYXNlXHJcbiAqL1xyXG5mdW5jdGlvbiBTQVBCcm9hZHBoYXNlKHdvcmxkKXtcclxuICAgIEJyb2FkcGhhc2UuYXBwbHkodGhpcyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMaXN0IG9mIGJvZGllcyBjdXJyZW50bHkgaW4gdGhlIGJyb2FkcGhhc2UuXHJcbiAgICAgKiBAcHJvcGVydHkgYXhpc0xpc3RcclxuICAgICAqIEB0eXBlIHtBcnJheX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5heGlzTGlzdCA9IFtdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHdvcmxkIHRvIHNlYXJjaCBpbi5cclxuICAgICAqIEBwcm9wZXJ0eSB3b3JsZFxyXG4gICAgICogQHR5cGUge1dvcmxkfVxyXG4gICAgICovXHJcbiAgICB0aGlzLndvcmxkID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEF4aXMgdG8gc29ydCB0aGUgYm9kaWVzIGFsb25nLiBTZXQgdG8gMCBmb3IgeCBheGlzLCBhbmQgMSBmb3IgeSBheGlzLiBGb3IgYmVzdCBwZXJmb3JtYW5jZSwgY2hvb3NlIGFuIGF4aXMgdGhhdCB0aGUgYm9kaWVzIGFyZSBzcHJlYWQgb3V0IG1vcmUgb24uXHJcbiAgICAgKiBAcHJvcGVydHkgYXhpc0luZGV4XHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmF4aXNJbmRleCA9IDA7XHJcblxyXG4gICAgdmFyIGF4aXNMaXN0ID0gdGhpcy5heGlzTGlzdDtcclxuXHJcbiAgICB0aGlzLl9hZGRCb2R5SGFuZGxlciA9IGZ1bmN0aW9uKGUpe1xyXG4gICAgICAgIGF4aXNMaXN0LnB1c2goZS5ib2R5KTtcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5fcmVtb3ZlQm9keUhhbmRsZXIgPSBmdW5jdGlvbihlKXtcclxuICAgICAgICB2YXIgaWR4ID0gYXhpc0xpc3QuaW5kZXhPZihlLmJvZHkpO1xyXG4gICAgICAgIGlmKGlkeCAhPT0gLTEpe1xyXG4gICAgICAgICAgICBheGlzTGlzdC5zcGxpY2UoaWR4LDEpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgaWYod29ybGQpe1xyXG4gICAgICAgIHRoaXMuc2V0V29ybGQod29ybGQpO1xyXG4gICAgfVxyXG59XHJcblNBUEJyb2FkcGhhc2UucHJvdG90eXBlID0gbmV3IEJyb2FkcGhhc2UoKTtcclxuXHJcbi8qKlxyXG4gKiBDaGFuZ2UgdGhlIHdvcmxkXHJcbiAqIEBtZXRob2Qgc2V0V29ybGRcclxuICogQHBhcmFtICB7V29ybGR9IHdvcmxkXHJcbiAqL1xyXG5TQVBCcm9hZHBoYXNlLnByb3RvdHlwZS5zZXRXb3JsZCA9IGZ1bmN0aW9uKHdvcmxkKXtcclxuICAgIC8vIENsZWFyIHRoZSBvbGQgYXhpcyBhcnJheVxyXG4gICAgdGhpcy5heGlzTGlzdC5sZW5ndGggPSAwO1xyXG5cclxuICAgIC8vIEFkZCBhbGwgYm9kaWVzIGZyb20gdGhlIG5ldyB3b3JsZFxyXG4gICAgZm9yKHZhciBpPTA7IGk8d29ybGQuYm9kaWVzLmxlbmd0aDsgaSsrKXtcclxuICAgICAgICB0aGlzLmF4aXNMaXN0LnB1c2god29ybGQuYm9kaWVzW2ldKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZW1vdmUgb2xkIGhhbmRsZXJzLCBpZiBhbnlcclxuICAgIHdvcmxkLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhZGRCb2R5XCIsIHRoaXMuX2FkZEJvZHlIYW5kbGVyKTtcclxuICAgIHdvcmxkLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZW1vdmVCb2R5XCIsIHRoaXMuX3JlbW92ZUJvZHlIYW5kbGVyKTtcclxuXHJcbiAgICAvLyBBZGQgaGFuZGxlcnMgdG8gdXBkYXRlIHRoZSBsaXN0IG9mIGJvZGllcy5cclxuICAgIHdvcmxkLmFkZEV2ZW50TGlzdGVuZXIoXCJhZGRCb2R5XCIsIHRoaXMuX2FkZEJvZHlIYW5kbGVyKTtcclxuICAgIHdvcmxkLmFkZEV2ZW50TGlzdGVuZXIoXCJyZW1vdmVCb2R5XCIsIHRoaXMuX3JlbW92ZUJvZHlIYW5kbGVyKTtcclxuXHJcbiAgICB0aGlzLndvcmxkID0gd29ybGQ7XHJcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZXRob2QgaW5zZXJ0aW9uU29ydFhcclxuICogQHBhcmFtICB7QXJyYXl9IGFcclxuICogQHJldHVybiB7QXJyYXl9XHJcbiAqL1xyXG5TQVBCcm9hZHBoYXNlLmluc2VydGlvblNvcnRYID0gZnVuY3Rpb24oYSkge1xyXG4gICAgZm9yKHZhciBpPTEsbD1hLmxlbmd0aDtpPGw7aSsrKSB7XHJcbiAgICAgICAgdmFyIHYgPSBhW2ldO1xyXG4gICAgICAgIGZvcih2YXIgaj1pIC0gMTtqPj0wO2otLSkge1xyXG4gICAgICAgICAgICBpZihhW2pdLmFhYmIubG93ZXJCb3VuZC54IDw9IHYuYWFiYi5sb3dlckJvdW5kLngpe1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYVtqKzFdID0gYVtqXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYVtqKzFdID0gdjtcclxuICAgIH1cclxuICAgIHJldHVybiBhO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBzdGF0aWNcclxuICogQG1ldGhvZCBpbnNlcnRpb25Tb3J0WVxyXG4gKiBAcGFyYW0gIHtBcnJheX0gYVxyXG4gKiBAcmV0dXJuIHtBcnJheX1cclxuICovXHJcblNBUEJyb2FkcGhhc2UuaW5zZXJ0aW9uU29ydFkgPSBmdW5jdGlvbihhKSB7XHJcbiAgICBmb3IodmFyIGk9MSxsPWEubGVuZ3RoO2k8bDtpKyspIHtcclxuICAgICAgICB2YXIgdiA9IGFbaV07XHJcbiAgICAgICAgZm9yKHZhciBqPWkgLSAxO2o+PTA7ai0tKSB7XHJcbiAgICAgICAgICAgIGlmKGFbal0uYWFiYi5sb3dlckJvdW5kLnkgPD0gdi5hYWJiLmxvd2VyQm91bmQueSl7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhW2orMV0gPSBhW2pdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhW2orMV0gPSB2O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGE7XHJcbn07XHJcblxyXG4vKipcclxuICogQHN0YXRpY1xyXG4gKiBAbWV0aG9kIGluc2VydGlvblNvcnRaXHJcbiAqIEBwYXJhbSAge0FycmF5fSBhXHJcbiAqIEByZXR1cm4ge0FycmF5fVxyXG4gKi9cclxuU0FQQnJvYWRwaGFzZS5pbnNlcnRpb25Tb3J0WiA9IGZ1bmN0aW9uKGEpIHtcclxuICAgIGZvcih2YXIgaT0xLGw9YS5sZW5ndGg7aTxsO2krKykge1xyXG4gICAgICAgIHZhciB2ID0gYVtpXTtcclxuICAgICAgICBmb3IodmFyIGo9aSAtIDE7aj49MDtqLS0pIHtcclxuICAgICAgICAgICAgaWYoYVtqXS5hYWJiLmxvd2VyQm91bmQueiA8PSB2LmFhYmIubG93ZXJCb3VuZC56KXtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFbaisxXSA9IGFbal07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFbaisxXSA9IHY7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb2xsZWN0IGFsbCBjb2xsaXNpb24gcGFpcnNcclxuICogQG1ldGhvZCBjb2xsaXNpb25QYWlyc1xyXG4gKiBAcGFyYW0gIHtXb3JsZH0gd29ybGRcclxuICogQHBhcmFtICB7QXJyYXl9IHAxXHJcbiAqIEBwYXJhbSAge0FycmF5fSBwMlxyXG4gKi9cclxuU0FQQnJvYWRwaGFzZS5wcm90b3R5cGUuY29sbGlzaW9uUGFpcnMgPSBmdW5jdGlvbih3b3JsZCxwMSxwMil7XHJcbiAgICB2YXIgYm9kaWVzID0gdGhpcy5heGlzTGlzdCxcclxuICAgICAgICBOID0gYm9kaWVzLmxlbmd0aCxcclxuICAgICAgICBheGlzSW5kZXggPSB0aGlzLmF4aXNJbmRleCxcclxuICAgICAgICBpLCBqO1xyXG5cclxuICAgIGlmKHRoaXMuZGlydHkpe1xyXG4gICAgICAgIHRoaXMuc29ydExpc3QoKTtcclxuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTG9vayB0aHJvdWdoIHRoZSBsaXN0XHJcbiAgICBmb3IoaT0wOyBpICE9PSBOOyBpKyspe1xyXG4gICAgICAgIHZhciBiaSA9IGJvZGllc1tpXTtcclxuXHJcbiAgICAgICAgZm9yKGo9aSsxOyBqIDwgTjsgaisrKXtcclxuICAgICAgICAgICAgdmFyIGJqID0gYm9kaWVzW2pdO1xyXG5cclxuICAgICAgICAgICAgaWYoIXRoaXMubmVlZEJyb2FkcGhhc2VDb2xsaXNpb24oYmksYmopKXtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZighU0FQQnJvYWRwaGFzZS5jaGVja0JvdW5kcyhiaSxiaixheGlzSW5kZXgpKXtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLmludGVyc2VjdGlvblRlc3QoYmksYmoscDEscDIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcblNBUEJyb2FkcGhhc2UucHJvdG90eXBlLnNvcnRMaXN0ID0gZnVuY3Rpb24oKXtcclxuICAgIHZhciBheGlzTGlzdCA9IHRoaXMuYXhpc0xpc3Q7XHJcbiAgICB2YXIgYXhpc0luZGV4ID0gdGhpcy5heGlzSW5kZXg7XHJcbiAgICB2YXIgTiA9IGF4aXNMaXN0Lmxlbmd0aDtcclxuXHJcbiAgICAvLyBVcGRhdGUgQUFCQnNcclxuICAgIGZvcih2YXIgaSA9IDA7IGkhPT1OOyBpKyspe1xyXG4gICAgICAgIHZhciBiaSA9IGF4aXNMaXN0W2ldO1xyXG4gICAgICAgIGlmKGJpLmFhYmJOZWVkc1VwZGF0ZSl7XHJcbiAgICAgICAgICAgIGJpLmNvbXB1dGVBQUJCKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFNvcnQgdGhlIGxpc3RcclxuICAgIGlmKGF4aXNJbmRleCA9PT0gMCl7XHJcbiAgICAgICAgU0FQQnJvYWRwaGFzZS5pbnNlcnRpb25Tb3J0WChheGlzTGlzdCk7XHJcbiAgICB9IGVsc2UgaWYoYXhpc0luZGV4ID09PSAxKXtcclxuICAgICAgICBTQVBCcm9hZHBoYXNlLmluc2VydGlvblNvcnRZKGF4aXNMaXN0KTtcclxuICAgIH0gZWxzZSBpZihheGlzSW5kZXggPT09IDIpe1xyXG4gICAgICAgIFNBUEJyb2FkcGhhc2UuaW5zZXJ0aW9uU29ydFooYXhpc0xpc3QpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIHRoZSBib3VuZHMgb2YgdHdvIGJvZGllcyBvdmVybGFwLCBhbG9uZyB0aGUgZ2l2ZW4gU0FQIGF4aXMuXHJcbiAqIEBzdGF0aWNcclxuICogQG1ldGhvZCBjaGVja0JvdW5kc1xyXG4gKiBAcGFyYW0gIHtCb2R5fSBiaVxyXG4gKiBAcGFyYW0gIHtCb2R5fSBialxyXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGF4aXNJbmRleFxyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gKi9cclxuU0FQQnJvYWRwaGFzZS5jaGVja0JvdW5kcyA9IGZ1bmN0aW9uKGJpLCBiaiwgYXhpc0luZGV4KXtcclxuICAgIHZhciBiaVBvcztcclxuICAgIHZhciBialBvcztcclxuXHJcbiAgICBpZihheGlzSW5kZXggPT09IDApe1xyXG4gICAgICAgIGJpUG9zID0gYmkucG9zaXRpb24ueDtcclxuICAgICAgICBialBvcyA9IGJqLnBvc2l0aW9uLng7XHJcbiAgICB9IGVsc2UgaWYoYXhpc0luZGV4ID09PSAxKXtcclxuICAgICAgICBiaVBvcyA9IGJpLnBvc2l0aW9uLnk7XHJcbiAgICAgICAgYmpQb3MgPSBiai5wb3NpdGlvbi55O1xyXG4gICAgfSBlbHNlIGlmKGF4aXNJbmRleCA9PT0gMil7XHJcbiAgICAgICAgYmlQb3MgPSBiaS5wb3NpdGlvbi56O1xyXG4gICAgICAgIGJqUG9zID0gYmoucG9zaXRpb24uejtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgcmkgPSBiaS5ib3VuZGluZ1JhZGl1cyxcclxuICAgICAgICByaiA9IGJqLmJvdW5kaW5nUmFkaXVzLFxyXG4gICAgICAgIGJvdW5kQTEgPSBiaVBvcyAtIHJpLFxyXG4gICAgICAgIGJvdW5kQTIgPSBiaVBvcyArIHJpLFxyXG4gICAgICAgIGJvdW5kQjEgPSBialBvcyAtIHJqLFxyXG4gICAgICAgIGJvdW5kQjIgPSBialBvcyArIHJqO1xyXG5cclxuICAgIHJldHVybiBib3VuZEIxIDwgYm91bmRBMjtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb21wdXRlcyB0aGUgdmFyaWFuY2Ugb2YgdGhlIGJvZHkgcG9zaXRpb25zIGFuZCBlc3RpbWF0ZXMgdGhlIGJlc3RcclxuICogYXhpcyB0byB1c2UuIFdpbGwgYXV0b21hdGljYWxseSBzZXQgcHJvcGVydHkgLmF4aXNJbmRleC5cclxuICogQG1ldGhvZCBhdXRvRGV0ZWN0QXhpc1xyXG4gKi9cclxuU0FQQnJvYWRwaGFzZS5wcm90b3R5cGUuYXV0b0RldGVjdEF4aXMgPSBmdW5jdGlvbigpe1xyXG4gICAgdmFyIHN1bVg9MCxcclxuICAgICAgICBzdW1YMj0wLFxyXG4gICAgICAgIHN1bVk9MCxcclxuICAgICAgICBzdW1ZMj0wLFxyXG4gICAgICAgIHN1bVo9MCxcclxuICAgICAgICBzdW1aMj0wLFxyXG4gICAgICAgIGJvZGllcyA9IHRoaXMuYXhpc0xpc3QsXHJcbiAgICAgICAgTiA9IGJvZGllcy5sZW5ndGgsXHJcbiAgICAgICAgaW52Tj0xL047XHJcblxyXG4gICAgZm9yKHZhciBpPTA7IGkhPT1OOyBpKyspe1xyXG4gICAgICAgIHZhciBiID0gYm9kaWVzW2ldO1xyXG5cclxuICAgICAgICB2YXIgY2VudGVyWCA9IGIucG9zaXRpb24ueDtcclxuICAgICAgICBzdW1YICs9IGNlbnRlclg7XHJcbiAgICAgICAgc3VtWDIgKz0gY2VudGVyWCpjZW50ZXJYO1xyXG5cclxuICAgICAgICB2YXIgY2VudGVyWSA9IGIucG9zaXRpb24ueTtcclxuICAgICAgICBzdW1ZICs9IGNlbnRlclk7XHJcbiAgICAgICAgc3VtWTIgKz0gY2VudGVyWSpjZW50ZXJZO1xyXG5cclxuICAgICAgICB2YXIgY2VudGVyWiA9IGIucG9zaXRpb24uejtcclxuICAgICAgICBzdW1aICs9IGNlbnRlclo7XHJcbiAgICAgICAgc3VtWjIgKz0gY2VudGVyWipjZW50ZXJaO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciB2YXJpYW5jZVggPSBzdW1YMiAtIHN1bVgqc3VtWCppbnZOLFxyXG4gICAgICAgIHZhcmlhbmNlWSA9IHN1bVkyIC0gc3VtWSpzdW1ZKmludk4sXHJcbiAgICAgICAgdmFyaWFuY2VaID0gc3VtWjIgLSBzdW1aKnN1bVoqaW52TjtcclxuXHJcbiAgICBpZih2YXJpYW5jZVggPiB2YXJpYW5jZVkpe1xyXG4gICAgICAgIGlmKHZhcmlhbmNlWCA+IHZhcmlhbmNlWil7XHJcbiAgICAgICAgICAgIHRoaXMuYXhpc0luZGV4ID0gMDtcclxuICAgICAgICB9IGVsc2V7XHJcbiAgICAgICAgICAgIHRoaXMuYXhpc0luZGV4ID0gMjtcclxuICAgICAgICB9XHJcbiAgICB9IGVsc2UgaWYodmFyaWFuY2VZID4gdmFyaWFuY2VaKXtcclxuICAgICAgICB0aGlzLmF4aXNJbmRleCA9IDE7XHJcbiAgICB9IGVsc2V7XHJcbiAgICAgICAgdGhpcy5heGlzSW5kZXggPSAyO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYWxsIHRoZSBib2RpZXMgd2l0aGluIGFuIEFBQkIuXHJcbiAqIEBtZXRob2QgYWFiYlF1ZXJ5XHJcbiAqIEBwYXJhbSAge1dvcmxkfSB3b3JsZFxyXG4gKiBAcGFyYW0gIHtBQUJCfSBhYWJiXHJcbiAqIEBwYXJhbSB7YXJyYXl9IHJlc3VsdCBBbiBhcnJheSB0byBzdG9yZSByZXN1bHRpbmcgYm9kaWVzIGluLlxyXG4gKiBAcmV0dXJuIHthcnJheX1cclxuICovXHJcblNBUEJyb2FkcGhhc2UucHJvdG90eXBlLmFhYmJRdWVyeSA9IGZ1bmN0aW9uKHdvcmxkLCBhYWJiLCByZXN1bHQpe1xyXG4gICAgcmVzdWx0ID0gcmVzdWx0IHx8IFtdO1xyXG5cclxuICAgIGlmKHRoaXMuZGlydHkpe1xyXG4gICAgICAgIHRoaXMuc29ydExpc3QoKTtcclxuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGF4aXNJbmRleCA9IHRoaXMuYXhpc0luZGV4LCBheGlzID0gJ3gnO1xyXG4gICAgaWYoYXhpc0luZGV4ID09PSAxKXsgYXhpcyA9ICd5JzsgfVxyXG4gICAgaWYoYXhpc0luZGV4ID09PSAyKXsgYXhpcyA9ICd6JzsgfVxyXG5cclxuICAgIHZhciBheGlzTGlzdCA9IHRoaXMuYXhpc0xpc3Q7XHJcbiAgICB2YXIgbG93ZXIgPSBhYWJiLmxvd2VyQm91bmRbYXhpc107XHJcbiAgICB2YXIgdXBwZXIgPSBhYWJiLnVwcGVyQm91bmRbYXhpc107XHJcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYXhpc0xpc3QubGVuZ3RoOyBpKyspe1xyXG4gICAgICAgIHZhciBiID0gYXhpc0xpc3RbaV07XHJcblxyXG4gICAgICAgIGlmKGIuYWFiYk5lZWRzVXBkYXRlKXtcclxuICAgICAgICAgICAgYi5jb21wdXRlQUFCQigpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYoYi5hYWJiLm92ZXJsYXBzKGFhYmIpKXtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2goYik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcbn0se1wiLi4vY29sbGlzaW9uL0Jyb2FkcGhhc2VcIjo1LFwiLi4vc2hhcGVzL1NoYXBlXCI6NDR9XSwxMzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XHJcbm1vZHVsZS5leHBvcnRzID0gQ29uZVR3aXN0Q29uc3RyYWludDtcclxuXHJcbnZhciBDb25zdHJhaW50ID0gX2RlcmVxXygnLi9Db25zdHJhaW50Jyk7XHJcbnZhciBQb2ludFRvUG9pbnRDb25zdHJhaW50ID0gX2RlcmVxXygnLi9Qb2ludFRvUG9pbnRDb25zdHJhaW50Jyk7XHJcbnZhciBDb25lRXF1YXRpb24gPSBfZGVyZXFfKCcuLi9lcXVhdGlvbnMvQ29uZUVxdWF0aW9uJyk7XHJcbnZhciBSb3RhdGlvbmFsRXF1YXRpb24gPSBfZGVyZXFfKCcuLi9lcXVhdGlvbnMvUm90YXRpb25hbEVxdWF0aW9uJyk7XHJcbnZhciBDb250YWN0RXF1YXRpb24gPSBfZGVyZXFfKCcuLi9lcXVhdGlvbnMvQ29udGFjdEVxdWF0aW9uJyk7XHJcbnZhciBWZWMzID0gX2RlcmVxXygnLi4vbWF0aC9WZWMzJyk7XHJcblxyXG4vKipcclxuICogQGNsYXNzIENvbmVUd2lzdENvbnN0cmFpbnRcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBhdXRob3Igc2NodGVwcGVcclxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxyXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cclxuICogQHBhcmFtIHtWZWMzfSBbb3B0aW9ucy5waXZvdEFdXHJcbiAqIEBwYXJhbSB7VmVjM30gW29wdGlvbnMucGl2b3RCXVxyXG4gKiBAcGFyYW0ge1ZlYzN9IFtvcHRpb25zLmF4aXNBXVxyXG4gKiBAcGFyYW0ge1ZlYzN9IFtvcHRpb25zLmF4aXNCXVxyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4Rm9yY2U9MWU2XVxyXG4gKiBAZXh0ZW5kcyBQb2ludFRvUG9pbnRDb25zdHJhaW50XHJcbiAqL1xyXG5mdW5jdGlvbiBDb25lVHdpc3RDb25zdHJhaW50KGJvZHlBLCBib2R5Qiwgb3B0aW9ucyl7XHJcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICAgIHZhciBtYXhGb3JjZSA9IHR5cGVvZihvcHRpb25zLm1heEZvcmNlKSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLm1heEZvcmNlIDogMWU2O1xyXG5cclxuICAgIC8vIFNldCBwaXZvdCBwb2ludCBpbiBiZXR3ZWVuXHJcbiAgICB2YXIgcGl2b3RBID0gb3B0aW9ucy5waXZvdEEgPyBvcHRpb25zLnBpdm90QS5jbG9uZSgpIDogbmV3IFZlYzMoKTtcclxuICAgIHZhciBwaXZvdEIgPSBvcHRpb25zLnBpdm90QiA/IG9wdGlvbnMucGl2b3RCLmNsb25lKCkgOiBuZXcgVmVjMygpO1xyXG4gICAgdGhpcy5heGlzQSA9IG9wdGlvbnMuYXhpc0EgPyBvcHRpb25zLmF4aXNBLmNsb25lKCkgOiBuZXcgVmVjMygpO1xyXG4gICAgdGhpcy5heGlzQiA9IG9wdGlvbnMuYXhpc0IgPyBvcHRpb25zLmF4aXNCLmNsb25lKCkgOiBuZXcgVmVjMygpO1xyXG5cclxuICAgIFBvaW50VG9Qb2ludENvbnN0cmFpbnQuY2FsbCh0aGlzLCBib2R5QSwgcGl2b3RBLCBib2R5QiwgcGl2b3RCLCBtYXhGb3JjZSk7XHJcblxyXG4gICAgdGhpcy5jb2xsaWRlQ29ubmVjdGVkID0gISFvcHRpb25zLmNvbGxpZGVDb25uZWN0ZWQ7XHJcblxyXG4gICAgdGhpcy5hbmdsZSA9IHR5cGVvZihvcHRpb25zLmFuZ2xlKSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLmFuZ2xlIDogMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcm9wZXJ0eSB7Q29uZUVxdWF0aW9ufSBjb25lRXF1YXRpb25cclxuICAgICAqL1xyXG4gICAgdmFyIGMgPSB0aGlzLmNvbmVFcXVhdGlvbiA9IG5ldyBDb25lRXF1YXRpb24oYm9keUEsYm9keUIsb3B0aW9ucyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkge1JvdGF0aW9uYWxFcXVhdGlvbn0gdHdpc3RFcXVhdGlvblxyXG4gICAgICovXHJcbiAgICB2YXIgdCA9IHRoaXMudHdpc3RFcXVhdGlvbiA9IG5ldyBSb3RhdGlvbmFsRXF1YXRpb24oYm9keUEsYm9keUIsb3B0aW9ucyk7XHJcbiAgICB0aGlzLnR3aXN0QW5nbGUgPSB0eXBlb2Yob3B0aW9ucy50d2lzdEFuZ2xlKSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLnR3aXN0QW5nbGUgOiAwO1xyXG5cclxuICAgIC8vIE1ha2UgdGhlIGNvbmUgZXF1YXRpb24gcHVzaCB0aGUgYm9kaWVzIHRvd2FyZCB0aGUgY29uZSBheGlzLCBub3Qgb3V0d2FyZFxyXG4gICAgYy5tYXhGb3JjZSA9IDA7XHJcbiAgICBjLm1pbkZvcmNlID0gLW1heEZvcmNlO1xyXG5cclxuICAgIC8vIE1ha2UgdGhlIHR3aXN0IGVxdWF0aW9uIGFkZCB0b3JxdWUgdG93YXJkIHRoZSBpbml0aWFsIHBvc2l0aW9uXHJcbiAgICB0Lm1heEZvcmNlID0gMDtcclxuICAgIHQubWluRm9yY2UgPSAtbWF4Rm9yY2U7XHJcblxyXG4gICAgdGhpcy5lcXVhdGlvbnMucHVzaChjLCB0KTtcclxufVxyXG5Db25lVHdpc3RDb25zdHJhaW50LnByb3RvdHlwZSA9IG5ldyBQb2ludFRvUG9pbnRDb25zdHJhaW50KCk7XHJcbkNvbmVUd2lzdENvbnN0cmFpbnQuY29uc3RydWN0b3IgPSBDb25lVHdpc3RDb25zdHJhaW50O1xyXG5cclxudmFyIENvbmVUd2lzdENvbnN0cmFpbnRfdXBkYXRlX3RtcFZlYzEgPSBuZXcgVmVjMygpO1xyXG52YXIgQ29uZVR3aXN0Q29uc3RyYWludF91cGRhdGVfdG1wVmVjMiA9IG5ldyBWZWMzKCk7XHJcblxyXG5Db25lVHdpc3RDb25zdHJhaW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbigpe1xyXG4gICAgdmFyIGJvZHlBID0gdGhpcy5ib2R5QSxcclxuICAgICAgICBib2R5QiA9IHRoaXMuYm9keUIsXHJcbiAgICAgICAgY29uZSA9IHRoaXMuY29uZUVxdWF0aW9uLFxyXG4gICAgICAgIHR3aXN0ID0gdGhpcy50d2lzdEVxdWF0aW9uO1xyXG5cclxuICAgIFBvaW50VG9Qb2ludENvbnN0cmFpbnQucHJvdG90eXBlLnVwZGF0ZS5jYWxsKHRoaXMpO1xyXG5cclxuICAgIC8vIFVwZGF0ZSB0aGUgYXhlcyB0byB0aGUgY29uZSBjb25zdHJhaW50XHJcbiAgICBib2R5QS52ZWN0b3JUb1dvcmxkRnJhbWUodGhpcy5heGlzQSwgY29uZS5heGlzQSk7XHJcbiAgICBib2R5Qi52ZWN0b3JUb1dvcmxkRnJhbWUodGhpcy5heGlzQiwgY29uZS5heGlzQik7XHJcblxyXG4gICAgLy8gVXBkYXRlIHRoZSB3b3JsZCBheGVzIGluIHRoZSB0d2lzdCBjb25zdHJhaW50XHJcbiAgICB0aGlzLmF4aXNBLnRhbmdlbnRzKHR3aXN0LmF4aXNBLCB0d2lzdC5heGlzQSk7XHJcbiAgICBib2R5QS52ZWN0b3JUb1dvcmxkRnJhbWUodHdpc3QuYXhpc0EsIHR3aXN0LmF4aXNBKTtcclxuXHJcbiAgICB0aGlzLmF4aXNCLnRhbmdlbnRzKHR3aXN0LmF4aXNCLCB0d2lzdC5heGlzQik7XHJcbiAgICBib2R5Qi52ZWN0b3JUb1dvcmxkRnJhbWUodHdpc3QuYXhpc0IsIHR3aXN0LmF4aXNCKTtcclxuXHJcbiAgICBjb25lLmFuZ2xlID0gdGhpcy5hbmdsZTtcclxuICAgIHR3aXN0Lm1heEFuZ2xlID0gdGhpcy50d2lzdEFuZ2xlO1xyXG59O1xyXG5cclxuXHJcbn0se1wiLi4vZXF1YXRpb25zL0NvbmVFcXVhdGlvblwiOjE5LFwiLi4vZXF1YXRpb25zL0NvbnRhY3RFcXVhdGlvblwiOjIwLFwiLi4vZXF1YXRpb25zL1JvdGF0aW9uYWxFcXVhdGlvblwiOjIzLFwiLi4vbWF0aC9WZWMzXCI6MzEsXCIuL0NvbnN0cmFpbnRcIjoxNCxcIi4vUG9pbnRUb1BvaW50Q29uc3RyYWludFwiOjE4fV0sMTQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xyXG5tb2R1bGUuZXhwb3J0cyA9IENvbnN0cmFpbnQ7XHJcblxyXG52YXIgVXRpbHMgPSBfZGVyZXFfKCcuLi91dGlscy9VdGlscycpO1xyXG5cclxuLyoqXHJcbiAqIENvbnN0cmFpbnQgYmFzZSBjbGFzc1xyXG4gKiBAY2xhc3MgQ29uc3RyYWludFxyXG4gKiBAYXV0aG9yIHNjaHRlcHBlXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXHJcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUJcclxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNvbGxpZGVDb25uZWN0ZWQ9dHJ1ZV1cclxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy53YWtlVXBCb2RpZXM9dHJ1ZV1cclxuICovXHJcbmZ1bmN0aW9uIENvbnN0cmFpbnQoYm9keUEsIGJvZHlCLCBvcHRpb25zKXtcclxuICAgIG9wdGlvbnMgPSBVdGlscy5kZWZhdWx0cyhvcHRpb25zLHtcclxuICAgICAgICBjb2xsaWRlQ29ubmVjdGVkIDogdHJ1ZSxcclxuICAgICAgICB3YWtlVXBCb2RpZXMgOiB0cnVlLFxyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFcXVhdGlvbnMgdG8gYmUgc29sdmVkIGluIHRoaXMgY29uc3RyYWludFxyXG4gICAgICogQHByb3BlcnR5IGVxdWF0aW9uc1xyXG4gICAgICogQHR5cGUge0FycmF5fVxyXG4gICAgICovXHJcbiAgICB0aGlzLmVxdWF0aW9ucyA9IFtdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IHtCb2R5fSBib2R5QVxyXG4gICAgICovXHJcbiAgICB0aGlzLmJvZHlBID0gYm9keUE7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkge0JvZHl9IGJvZHlCXHJcbiAgICAgKi9cclxuICAgIHRoaXMuYm9keUIgPSBib2R5QjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBpZFxyXG4gICAgICovXHJcbiAgICB0aGlzLmlkID0gQ29uc3RyYWludC5pZENvdW50ZXIrKztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0byB0cnVlIGlmIHlvdSB3YW50IHRoZSBib2RpZXMgdG8gY29sbGlkZSB3aGVuIHRoZXkgYXJlIGNvbm5lY3RlZC5cclxuICAgICAqIEBwcm9wZXJ0eSBjb2xsaWRlQ29ubmVjdGVkXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5jb2xsaWRlQ29ubmVjdGVkID0gb3B0aW9ucy5jb2xsaWRlQ29ubmVjdGVkO1xyXG5cclxuICAgIGlmKG9wdGlvbnMud2FrZVVwQm9kaWVzKXtcclxuICAgICAgICBpZihib2R5QSl7XHJcbiAgICAgICAgICAgIGJvZHlBLndha2VVcCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZihib2R5Qil7XHJcbiAgICAgICAgICAgIGJvZHlCLndha2VVcCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFVwZGF0ZSBhbGwgdGhlIGVxdWF0aW9ucyB3aXRoIGRhdGEuXHJcbiAqIEBtZXRob2QgdXBkYXRlXHJcbiAqL1xyXG5Db25zdHJhaW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbigpe1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKFwibWV0aG9kIHVwZGF0ZSgpIG5vdCBpbXBsbWVtZW50ZWQgaW4gdGhpcyBDb25zdHJhaW50IHN1YmNsYXNzIVwiKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBFbmFibGVzIGFsbCBlcXVhdGlvbnMgaW4gdGhlIGNvbnN0cmFpbnQuXHJcbiAqIEBtZXRob2QgZW5hYmxlXHJcbiAqL1xyXG5Db25zdHJhaW50LnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbigpe1xyXG4gICAgdmFyIGVxcyA9IHRoaXMuZXF1YXRpb25zO1xyXG4gICAgZm9yKHZhciBpPTA7IGk8ZXFzLmxlbmd0aDsgaSsrKXtcclxuICAgICAgICBlcXNbaV0uZW5hYmxlZCA9IHRydWU7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogRGlzYWJsZXMgYWxsIGVxdWF0aW9ucyBpbiB0aGUgY29uc3RyYWludC5cclxuICogQG1ldGhvZCBkaXNhYmxlXHJcbiAqL1xyXG5Db25zdHJhaW50LnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24oKXtcclxuICAgIHZhciBlcXMgPSB0aGlzLmVxdWF0aW9ucztcclxuICAgIGZvcih2YXIgaT0wOyBpPGVxcy5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgZXFzW2ldLmVuYWJsZWQgPSBmYWxzZTtcclxuICAgIH1cclxufTtcclxuXHJcbkNvbnN0cmFpbnQuaWRDb3VudGVyID0gMDtcclxuXHJcbn0se1wiLi4vdXRpbHMvVXRpbHNcIjo1NH1dLDE1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcclxubW9kdWxlLmV4cG9ydHMgPSBEaXN0YW5jZUNvbnN0cmFpbnQ7XHJcblxyXG52YXIgQ29uc3RyYWludCA9IF9kZXJlcV8oJy4vQ29uc3RyYWludCcpO1xyXG52YXIgQ29udGFjdEVxdWF0aW9uID0gX2RlcmVxXygnLi4vZXF1YXRpb25zL0NvbnRhY3RFcXVhdGlvbicpO1xyXG5cclxuLyoqXHJcbiAqIENvbnN0cmFpbnMgdHdvIGJvZGllcyB0byBiZSBhdCBhIGNvbnN0YW50IGRpc3RhbmNlIGZyb20gZWFjaCBvdGhlcnMgY2VudGVyIG9mIG1hc3MuXHJcbiAqIEBjbGFzcyBEaXN0YW5jZUNvbnN0cmFpbnRcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBhdXRob3Igc2NodGVwcGVcclxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxyXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbZGlzdGFuY2VdIFRoZSBkaXN0YW5jZSB0byBrZWVwLiBJZiB1bmRlZmluZWQsIGl0IHdpbGwgYmUgc2V0IHRvIHRoZSBjdXJyZW50IGRpc3RhbmNlIGJldHdlZW4gYm9keUEgYW5kIGJvZHlCXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbbWF4Rm9yY2U9MWU2XVxyXG4gKiBAZXh0ZW5kcyBDb25zdHJhaW50XHJcbiAqL1xyXG5mdW5jdGlvbiBEaXN0YW5jZUNvbnN0cmFpbnQoYm9keUEsYm9keUIsZGlzdGFuY2UsbWF4Rm9yY2Upe1xyXG4gICAgQ29uc3RyYWludC5jYWxsKHRoaXMsYm9keUEsYm9keUIpO1xyXG5cclxuICAgIGlmKHR5cGVvZihkaXN0YW5jZSk9PT1cInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgICAgZGlzdGFuY2UgPSBib2R5QS5wb3NpdGlvbi5kaXN0YW5jZVRvKGJvZHlCLnBvc2l0aW9uKTtcclxuICAgIH1cclxuXHJcbiAgICBpZih0eXBlb2YobWF4Rm9yY2UpPT09XCJ1bmRlZmluZWRcIikge1xyXG4gICAgICAgIG1heEZvcmNlID0gMWU2O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGRpc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZGlzdGFuY2UgPSBkaXN0YW5jZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcm9wZXJ0eSB7Q29udGFjdEVxdWF0aW9ufSBkaXN0YW5jZUVxdWF0aW9uXHJcbiAgICAgKi9cclxuICAgIHZhciBlcSA9IHRoaXMuZGlzdGFuY2VFcXVhdGlvbiA9IG5ldyBDb250YWN0RXF1YXRpb24oYm9keUEsIGJvZHlCKTtcclxuICAgIHRoaXMuZXF1YXRpb25zLnB1c2goZXEpO1xyXG5cclxuICAgIC8vIE1ha2UgaXQgYmlkaXJlY3Rpb25hbFxyXG4gICAgZXEubWluRm9yY2UgPSAtbWF4Rm9yY2U7XHJcbiAgICBlcS5tYXhGb3JjZSA9ICBtYXhGb3JjZTtcclxufVxyXG5EaXN0YW5jZUNvbnN0cmFpbnQucHJvdG90eXBlID0gbmV3IENvbnN0cmFpbnQoKTtcclxuXHJcbkRpc3RhbmNlQ29uc3RyYWludC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKXtcclxuICAgIHZhciBib2R5QSA9IHRoaXMuYm9keUE7XHJcbiAgICB2YXIgYm9keUIgPSB0aGlzLmJvZHlCO1xyXG4gICAgdmFyIGVxID0gdGhpcy5kaXN0YW5jZUVxdWF0aW9uO1xyXG4gICAgdmFyIGhhbGZEaXN0ID0gdGhpcy5kaXN0YW5jZSAqIDAuNTtcclxuICAgIHZhciBub3JtYWwgPSBlcS5uaTtcclxuXHJcbiAgICBib2R5Qi5wb3NpdGlvbi52c3ViKGJvZHlBLnBvc2l0aW9uLCBub3JtYWwpO1xyXG4gICAgbm9ybWFsLm5vcm1hbGl6ZSgpO1xyXG4gICAgbm9ybWFsLm11bHQoaGFsZkRpc3QsIGVxLnJpKTtcclxuICAgIG5vcm1hbC5tdWx0KC1oYWxmRGlzdCwgZXEucmopO1xyXG59O1xyXG59LHtcIi4uL2VxdWF0aW9ucy9Db250YWN0RXF1YXRpb25cIjoyMCxcIi4vQ29uc3RyYWludFwiOjE0fV0sMTY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xyXG5tb2R1bGUuZXhwb3J0cyA9IEhpbmdlQ29uc3RyYWludDtcclxuXHJcbnZhciBDb25zdHJhaW50ID0gX2RlcmVxXygnLi9Db25zdHJhaW50Jyk7XHJcbnZhciBQb2ludFRvUG9pbnRDb25zdHJhaW50ID0gX2RlcmVxXygnLi9Qb2ludFRvUG9pbnRDb25zdHJhaW50Jyk7XHJcbnZhciBSb3RhdGlvbmFsRXF1YXRpb24gPSBfZGVyZXFfKCcuLi9lcXVhdGlvbnMvUm90YXRpb25hbEVxdWF0aW9uJyk7XHJcbnZhciBSb3RhdGlvbmFsTW90b3JFcXVhdGlvbiA9IF9kZXJlcV8oJy4uL2VxdWF0aW9ucy9Sb3RhdGlvbmFsTW90b3JFcXVhdGlvbicpO1xyXG52YXIgQ29udGFjdEVxdWF0aW9uID0gX2RlcmVxXygnLi4vZXF1YXRpb25zL0NvbnRhY3RFcXVhdGlvbicpO1xyXG52YXIgVmVjMyA9IF9kZXJlcV8oJy4uL21hdGgvVmVjMycpO1xyXG5cclxuLyoqXHJcbiAqIEhpbmdlIGNvbnN0cmFpbnQuIFRoaW5rIG9mIGl0IGFzIGEgZG9vciBoaW5nZS4gSXQgdHJpZXMgdG8ga2VlcCB0aGUgZG9vciBpbiB0aGUgY29ycmVjdCBwbGFjZSBhbmQgd2l0aCB0aGUgY29ycmVjdCBvcmllbnRhdGlvbi5cclxuICogQGNsYXNzIEhpbmdlQ29uc3RyYWludFxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQGF1dGhvciBzY2h0ZXBwZVxyXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXHJcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUJcclxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxyXG4gKiBAcGFyYW0ge1ZlYzN9IFtvcHRpb25zLnBpdm90QV0gQSBwb2ludCBkZWZpbmVkIGxvY2FsbHkgaW4gYm9keUEuIFRoaXMgZGVmaW5lcyB0aGUgb2Zmc2V0IG9mIGF4aXNBLlxyXG4gKiBAcGFyYW0ge1ZlYzN9IFtvcHRpb25zLmF4aXNBXSBBbiBheGlzIHRoYXQgYm9keUEgY2FuIHJvdGF0ZSBhcm91bmQsIGRlZmluZWQgbG9jYWxseSBpbiBib2R5QS5cclxuICogQHBhcmFtIHtWZWMzfSBbb3B0aW9ucy5waXZvdEJdXHJcbiAqIEBwYXJhbSB7VmVjM30gW29wdGlvbnMuYXhpc0JdXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhGb3JjZT0xZTZdXHJcbiAqIEBleHRlbmRzIFBvaW50VG9Qb2ludENvbnN0cmFpbnRcclxuICovXHJcbmZ1bmN0aW9uIEhpbmdlQ29uc3RyYWludChib2R5QSwgYm9keUIsIG9wdGlvbnMpe1xyXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgICB2YXIgbWF4Rm9yY2UgPSB0eXBlb2Yob3B0aW9ucy5tYXhGb3JjZSkgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5tYXhGb3JjZSA6IDFlNjtcclxuICAgIHZhciBwaXZvdEEgPSBvcHRpb25zLnBpdm90QSA/IG9wdGlvbnMucGl2b3RBLmNsb25lKCkgOiBuZXcgVmVjMygpO1xyXG4gICAgdmFyIHBpdm90QiA9IG9wdGlvbnMucGl2b3RCID8gb3B0aW9ucy5waXZvdEIuY2xvbmUoKSA6IG5ldyBWZWMzKCk7XHJcblxyXG4gICAgUG9pbnRUb1BvaW50Q29uc3RyYWludC5jYWxsKHRoaXMsIGJvZHlBLCBwaXZvdEEsIGJvZHlCLCBwaXZvdEIsIG1heEZvcmNlKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJvdGF0aW9uIGF4aXMsIGRlZmluZWQgbG9jYWxseSBpbiBib2R5QS5cclxuICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gYXhpc0FcclxuICAgICAqL1xyXG4gICAgdmFyIGF4aXNBID0gdGhpcy5heGlzQSA9IG9wdGlvbnMuYXhpc0EgPyBvcHRpb25zLmF4aXNBLmNsb25lKCkgOiBuZXcgVmVjMygxLDAsMCk7XHJcbiAgICBheGlzQS5ub3JtYWxpemUoKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJvdGF0aW9uIGF4aXMsIGRlZmluZWQgbG9jYWxseSBpbiBib2R5Qi5cclxuICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gYXhpc0JcclxuICAgICAqL1xyXG4gICAgdmFyIGF4aXNCID0gdGhpcy5heGlzQiA9IG9wdGlvbnMuYXhpc0IgPyBvcHRpb25zLmF4aXNCLmNsb25lKCkgOiBuZXcgVmVjMygxLDAsMCk7XHJcbiAgICBheGlzQi5ub3JtYWxpemUoKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcm9wZXJ0eSB7Um90YXRpb25hbEVxdWF0aW9ufSByb3RhdGlvbmFsRXF1YXRpb24xXHJcbiAgICAgKi9cclxuICAgIHZhciByMSA9IHRoaXMucm90YXRpb25hbEVxdWF0aW9uMSA9IG5ldyBSb3RhdGlvbmFsRXF1YXRpb24oYm9keUEsYm9keUIsb3B0aW9ucyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkge1JvdGF0aW9uYWxFcXVhdGlvbn0gcm90YXRpb25hbEVxdWF0aW9uMlxyXG4gICAgICovXHJcbiAgICB2YXIgcjIgPSB0aGlzLnJvdGF0aW9uYWxFcXVhdGlvbjIgPSBuZXcgUm90YXRpb25hbEVxdWF0aW9uKGJvZHlBLGJvZHlCLG9wdGlvbnMpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IHtSb3RhdGlvbmFsTW90b3JFcXVhdGlvbn0gbW90b3JFcXVhdGlvblxyXG4gICAgICovXHJcbiAgICB2YXIgbW90b3IgPSB0aGlzLm1vdG9yRXF1YXRpb24gPSBuZXcgUm90YXRpb25hbE1vdG9yRXF1YXRpb24oYm9keUEsYm9keUIsbWF4Rm9yY2UpO1xyXG4gICAgbW90b3IuZW5hYmxlZCA9IGZhbHNlOyAvLyBOb3QgZW5hYmxlZCBieSBkZWZhdWx0XHJcblxyXG4gICAgLy8gRXF1YXRpb25zIHRvIGJlIGZlZCB0byB0aGUgc29sdmVyXHJcbiAgICB0aGlzLmVxdWF0aW9ucy5wdXNoKFxyXG4gICAgICAgIHIxLCAvLyByb3RhdGlvbmFsMVxyXG4gICAgICAgIHIyLCAvLyByb3RhdGlvbmFsMlxyXG4gICAgICAgIG1vdG9yXHJcbiAgICApO1xyXG59XHJcbkhpbmdlQ29uc3RyYWludC5wcm90b3R5cGUgPSBuZXcgUG9pbnRUb1BvaW50Q29uc3RyYWludCgpO1xyXG5IaW5nZUNvbnN0cmFpbnQuY29uc3RydWN0b3IgPSBIaW5nZUNvbnN0cmFpbnQ7XHJcblxyXG4vKipcclxuICogQG1ldGhvZCBlbmFibGVNb3RvclxyXG4gKi9cclxuSGluZ2VDb25zdHJhaW50LnByb3RvdHlwZS5lbmFibGVNb3RvciA9IGZ1bmN0aW9uKCl7XHJcbiAgICB0aGlzLm1vdG9yRXF1YXRpb24uZW5hYmxlZCA9IHRydWU7XHJcbn07XHJcblxyXG4vKipcclxuICogQG1ldGhvZCBkaXNhYmxlTW90b3JcclxuICovXHJcbkhpbmdlQ29uc3RyYWludC5wcm90b3R5cGUuZGlzYWJsZU1vdG9yID0gZnVuY3Rpb24oKXtcclxuICAgIHRoaXMubW90b3JFcXVhdGlvbi5lbmFibGVkID0gZmFsc2U7XHJcbn07XHJcblxyXG4vKipcclxuICogQG1ldGhvZCBzZXRNb3RvclNwZWVkXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBzcGVlZFxyXG4gKi9cclxuSGluZ2VDb25zdHJhaW50LnByb3RvdHlwZS5zZXRNb3RvclNwZWVkID0gZnVuY3Rpb24oc3BlZWQpe1xyXG4gICAgdGhpcy5tb3RvckVxdWF0aW9uLnRhcmdldFZlbG9jaXR5ID0gc3BlZWQ7XHJcbn07XHJcblxyXG4vKipcclxuICogQG1ldGhvZCBzZXRNb3Rvck1heEZvcmNlXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhGb3JjZVxyXG4gKi9cclxuSGluZ2VDb25zdHJhaW50LnByb3RvdHlwZS5zZXRNb3Rvck1heEZvcmNlID0gZnVuY3Rpb24obWF4Rm9yY2Upe1xyXG4gICAgdGhpcy5tb3RvckVxdWF0aW9uLm1heEZvcmNlID0gbWF4Rm9yY2U7XHJcbiAgICB0aGlzLm1vdG9yRXF1YXRpb24ubWluRm9yY2UgPSAtbWF4Rm9yY2U7XHJcbn07XHJcblxyXG52YXIgSGluZ2VDb25zdHJhaW50X3VwZGF0ZV90bXBWZWMxID0gbmV3IFZlYzMoKTtcclxudmFyIEhpbmdlQ29uc3RyYWludF91cGRhdGVfdG1wVmVjMiA9IG5ldyBWZWMzKCk7XHJcblxyXG5IaW5nZUNvbnN0cmFpbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCl7XHJcbiAgICB2YXIgYm9keUEgPSB0aGlzLmJvZHlBLFxyXG4gICAgICAgIGJvZHlCID0gdGhpcy5ib2R5QixcclxuICAgICAgICBtb3RvciA9IHRoaXMubW90b3JFcXVhdGlvbixcclxuICAgICAgICByMSA9IHRoaXMucm90YXRpb25hbEVxdWF0aW9uMSxcclxuICAgICAgICByMiA9IHRoaXMucm90YXRpb25hbEVxdWF0aW9uMixcclxuICAgICAgICB3b3JsZEF4aXNBID0gSGluZ2VDb25zdHJhaW50X3VwZGF0ZV90bXBWZWMxLFxyXG4gICAgICAgIHdvcmxkQXhpc0IgPSBIaW5nZUNvbnN0cmFpbnRfdXBkYXRlX3RtcFZlYzI7XHJcblxyXG4gICAgdmFyIGF4aXNBID0gdGhpcy5heGlzQTtcclxuICAgIHZhciBheGlzQiA9IHRoaXMuYXhpc0I7XHJcblxyXG4gICAgUG9pbnRUb1BvaW50Q29uc3RyYWludC5wcm90b3R5cGUudXBkYXRlLmNhbGwodGhpcyk7XHJcblxyXG4gICAgLy8gR2V0IHdvcmxkIGF4ZXNcclxuICAgIGJvZHlBLnF1YXRlcm5pb24udm11bHQoYXhpc0EsIHdvcmxkQXhpc0EpO1xyXG4gICAgYm9keUIucXVhdGVybmlvbi52bXVsdChheGlzQiwgd29ybGRBeGlzQik7XHJcblxyXG4gICAgd29ybGRBeGlzQS50YW5nZW50cyhyMS5heGlzQSwgcjIuYXhpc0EpO1xyXG4gICAgcjEuYXhpc0IuY29weSh3b3JsZEF4aXNCKTtcclxuICAgIHIyLmF4aXNCLmNvcHkod29ybGRBeGlzQik7XHJcblxyXG4gICAgaWYodGhpcy5tb3RvckVxdWF0aW9uLmVuYWJsZWQpe1xyXG4gICAgICAgIGJvZHlBLnF1YXRlcm5pb24udm11bHQodGhpcy5heGlzQSwgbW90b3IuYXhpc0EpO1xyXG4gICAgICAgIGJvZHlCLnF1YXRlcm5pb24udm11bHQodGhpcy5heGlzQiwgbW90b3IuYXhpc0IpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcbn0se1wiLi4vZXF1YXRpb25zL0NvbnRhY3RFcXVhdGlvblwiOjIwLFwiLi4vZXF1YXRpb25zL1JvdGF0aW9uYWxFcXVhdGlvblwiOjIzLFwiLi4vZXF1YXRpb25zL1JvdGF0aW9uYWxNb3RvckVxdWF0aW9uXCI6MjQsXCIuLi9tYXRoL1ZlYzNcIjozMSxcIi4vQ29uc3RyYWludFwiOjE0LFwiLi9Qb2ludFRvUG9pbnRDb25zdHJhaW50XCI6MTh9XSwxNzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XHJcbm1vZHVsZS5leHBvcnRzID0gTG9ja0NvbnN0cmFpbnQ7XHJcblxyXG52YXIgQ29uc3RyYWludCA9IF9kZXJlcV8oJy4vQ29uc3RyYWludCcpO1xyXG52YXIgUG9pbnRUb1BvaW50Q29uc3RyYWludCA9IF9kZXJlcV8oJy4vUG9pbnRUb1BvaW50Q29uc3RyYWludCcpO1xyXG52YXIgUm90YXRpb25hbEVxdWF0aW9uID0gX2RlcmVxXygnLi4vZXF1YXRpb25zL1JvdGF0aW9uYWxFcXVhdGlvbicpO1xyXG52YXIgUm90YXRpb25hbE1vdG9yRXF1YXRpb24gPSBfZGVyZXFfKCcuLi9lcXVhdGlvbnMvUm90YXRpb25hbE1vdG9yRXF1YXRpb24nKTtcclxudmFyIENvbnRhY3RFcXVhdGlvbiA9IF9kZXJlcV8oJy4uL2VxdWF0aW9ucy9Db250YWN0RXF1YXRpb24nKTtcclxudmFyIFZlYzMgPSBfZGVyZXFfKCcuLi9tYXRoL1ZlYzMnKTtcclxuXHJcbi8qKlxyXG4gKiBMb2NrIGNvbnN0cmFpbnQuIFdpbGwgcmVtb3ZlIGFsbCBkZWdyZWVzIG9mIGZyZWVkb20gYmV0d2VlbiB0aGUgYm9kaWVzLlxyXG4gKiBAY2xhc3MgTG9ja0NvbnN0cmFpbnRcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBhdXRob3Igc2NodGVwcGVcclxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxyXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heEZvcmNlPTFlNl1cclxuICogQGV4dGVuZHMgUG9pbnRUb1BvaW50Q29uc3RyYWludFxyXG4gKi9cclxuZnVuY3Rpb24gTG9ja0NvbnN0cmFpbnQoYm9keUEsIGJvZHlCLCBvcHRpb25zKXtcclxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgdmFyIG1heEZvcmNlID0gdHlwZW9mKG9wdGlvbnMubWF4Rm9yY2UpICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMubWF4Rm9yY2UgOiAxZTY7XHJcblxyXG4gICAgLy8gU2V0IHBpdm90IHBvaW50IGluIGJldHdlZW5cclxuICAgIHZhciBwaXZvdEEgPSBuZXcgVmVjMygpO1xyXG4gICAgdmFyIHBpdm90QiA9IG5ldyBWZWMzKCk7XHJcbiAgICB2YXIgaGFsZldheSA9IG5ldyBWZWMzKCk7XHJcbiAgICBib2R5QS5wb3NpdGlvbi52YWRkKGJvZHlCLnBvc2l0aW9uLCBoYWxmV2F5KTtcclxuICAgIGhhbGZXYXkuc2NhbGUoMC41LCBoYWxmV2F5KTtcclxuICAgIGJvZHlCLnBvaW50VG9Mb2NhbEZyYW1lKGhhbGZXYXksIHBpdm90Qik7XHJcbiAgICBib2R5QS5wb2ludFRvTG9jYWxGcmFtZShoYWxmV2F5LCBwaXZvdEEpO1xyXG5cclxuICAgIC8vIFRoZSBwb2ludC10by1wb2ludCBjb25zdHJhaW50IHdpbGwga2VlcCBhIHBvaW50IHNoYXJlZCBiZXR3ZWVuIHRoZSBib2RpZXNcclxuICAgIFBvaW50VG9Qb2ludENvbnN0cmFpbnQuY2FsbCh0aGlzLCBib2R5QSwgcGl2b3RBLCBib2R5QiwgcGl2b3RCLCBtYXhGb3JjZSk7XHJcblxyXG4gICAgLy8gU3RvcmUgaW5pdGlhbCByb3RhdGlvbiBvZiB0aGUgYm9kaWVzIGFzIHVuaXQgdmVjdG9ycyBpbiB0aGUgbG9jYWwgYm9keSBzcGFjZXNcclxuICAgIHRoaXMueEEgPSBib2R5QS52ZWN0b3JUb0xvY2FsRnJhbWUoVmVjMy5VTklUX1gpO1xyXG4gICAgdGhpcy54QiA9IGJvZHlCLnZlY3RvclRvTG9jYWxGcmFtZShWZWMzLlVOSVRfWCk7XHJcbiAgICB0aGlzLnlBID0gYm9keUEudmVjdG9yVG9Mb2NhbEZyYW1lKFZlYzMuVU5JVF9ZKTtcclxuICAgIHRoaXMueUIgPSBib2R5Qi52ZWN0b3JUb0xvY2FsRnJhbWUoVmVjMy5VTklUX1kpO1xyXG4gICAgdGhpcy56QSA9IGJvZHlBLnZlY3RvclRvTG9jYWxGcmFtZShWZWMzLlVOSVRfWik7XHJcbiAgICB0aGlzLnpCID0gYm9keUIudmVjdG9yVG9Mb2NhbEZyYW1lKFZlYzMuVU5JVF9aKTtcclxuXHJcbiAgICAvLyAuLi5hbmQgdGhlIGZvbGxvd2luZyByb3RhdGlvbmFsIGVxdWF0aW9ucyB3aWxsIGtlZXAgYWxsIHJvdGF0aW9uYWwgRE9GJ3MgaW4gcGxhY2VcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcm9wZXJ0eSB7Um90YXRpb25hbEVxdWF0aW9ufSByb3RhdGlvbmFsRXF1YXRpb24xXHJcbiAgICAgKi9cclxuICAgIHZhciByMSA9IHRoaXMucm90YXRpb25hbEVxdWF0aW9uMSA9IG5ldyBSb3RhdGlvbmFsRXF1YXRpb24oYm9keUEsYm9keUIsb3B0aW9ucyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkge1JvdGF0aW9uYWxFcXVhdGlvbn0gcm90YXRpb25hbEVxdWF0aW9uMlxyXG4gICAgICovXHJcbiAgICB2YXIgcjIgPSB0aGlzLnJvdGF0aW9uYWxFcXVhdGlvbjIgPSBuZXcgUm90YXRpb25hbEVxdWF0aW9uKGJvZHlBLGJvZHlCLG9wdGlvbnMpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IHtSb3RhdGlvbmFsRXF1YXRpb259IHJvdGF0aW9uYWxFcXVhdGlvbjNcclxuICAgICAqL1xyXG4gICAgdmFyIHIzID0gdGhpcy5yb3RhdGlvbmFsRXF1YXRpb24zID0gbmV3IFJvdGF0aW9uYWxFcXVhdGlvbihib2R5QSxib2R5QixvcHRpb25zKTtcclxuXHJcbiAgICB0aGlzLmVxdWF0aW9ucy5wdXNoKHIxLCByMiwgcjMpO1xyXG59XHJcbkxvY2tDb25zdHJhaW50LnByb3RvdHlwZSA9IG5ldyBQb2ludFRvUG9pbnRDb25zdHJhaW50KCk7XHJcbkxvY2tDb25zdHJhaW50LmNvbnN0cnVjdG9yID0gTG9ja0NvbnN0cmFpbnQ7XHJcblxyXG52YXIgTG9ja0NvbnN0cmFpbnRfdXBkYXRlX3RtcFZlYzEgPSBuZXcgVmVjMygpO1xyXG52YXIgTG9ja0NvbnN0cmFpbnRfdXBkYXRlX3RtcFZlYzIgPSBuZXcgVmVjMygpO1xyXG5cclxuTG9ja0NvbnN0cmFpbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCl7XHJcbiAgICB2YXIgYm9keUEgPSB0aGlzLmJvZHlBLFxyXG4gICAgICAgIGJvZHlCID0gdGhpcy5ib2R5QixcclxuICAgICAgICBtb3RvciA9IHRoaXMubW90b3JFcXVhdGlvbixcclxuICAgICAgICByMSA9IHRoaXMucm90YXRpb25hbEVxdWF0aW9uMSxcclxuICAgICAgICByMiA9IHRoaXMucm90YXRpb25hbEVxdWF0aW9uMixcclxuICAgICAgICByMyA9IHRoaXMucm90YXRpb25hbEVxdWF0aW9uMyxcclxuICAgICAgICB3b3JsZEF4aXNBID0gTG9ja0NvbnN0cmFpbnRfdXBkYXRlX3RtcFZlYzEsXHJcbiAgICAgICAgd29ybGRBeGlzQiA9IExvY2tDb25zdHJhaW50X3VwZGF0ZV90bXBWZWMyO1xyXG5cclxuICAgIFBvaW50VG9Qb2ludENvbnN0cmFpbnQucHJvdG90eXBlLnVwZGF0ZS5jYWxsKHRoaXMpO1xyXG5cclxuICAgIC8vIFRoZXNlIHZlY3RvciBwYWlycyBtdXN0IGJlIG9ydGhvZ29uYWxcclxuICAgIGJvZHlBLnZlY3RvclRvV29ybGRGcmFtZSh0aGlzLnhBLCByMS5heGlzQSk7XHJcbiAgICBib2R5Qi52ZWN0b3JUb1dvcmxkRnJhbWUodGhpcy55QiwgcjEuYXhpc0IpO1xyXG5cclxuICAgIGJvZHlBLnZlY3RvclRvV29ybGRGcmFtZSh0aGlzLnlBLCByMi5heGlzQSk7XHJcbiAgICBib2R5Qi52ZWN0b3JUb1dvcmxkRnJhbWUodGhpcy56QiwgcjIuYXhpc0IpO1xyXG5cclxuICAgIGJvZHlBLnZlY3RvclRvV29ybGRGcmFtZSh0aGlzLnpBLCByMy5heGlzQSk7XHJcbiAgICBib2R5Qi52ZWN0b3JUb1dvcmxkRnJhbWUodGhpcy54QiwgcjMuYXhpc0IpO1xyXG59O1xyXG5cclxuXHJcbn0se1wiLi4vZXF1YXRpb25zL0NvbnRhY3RFcXVhdGlvblwiOjIwLFwiLi4vZXF1YXRpb25zL1JvdGF0aW9uYWxFcXVhdGlvblwiOjIzLFwiLi4vZXF1YXRpb25zL1JvdGF0aW9uYWxNb3RvckVxdWF0aW9uXCI6MjQsXCIuLi9tYXRoL1ZlYzNcIjozMSxcIi4vQ29uc3RyYWludFwiOjE0LFwiLi9Qb2ludFRvUG9pbnRDb25zdHJhaW50XCI6MTh9XSwxODpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XHJcbm1vZHVsZS5leHBvcnRzID0gUG9pbnRUb1BvaW50Q29uc3RyYWludDtcclxuXHJcbnZhciBDb25zdHJhaW50ID0gX2RlcmVxXygnLi9Db25zdHJhaW50Jyk7XHJcbnZhciBDb250YWN0RXF1YXRpb24gPSBfZGVyZXFfKCcuLi9lcXVhdGlvbnMvQ29udGFjdEVxdWF0aW9uJyk7XHJcbnZhciBWZWMzID0gX2RlcmVxXygnLi4vbWF0aC9WZWMzJyk7XHJcblxyXG4vKipcclxuICogQ29ubmVjdHMgdHdvIGJvZGllcyBhdCBnaXZlbiBvZmZzZXQgcG9pbnRzLlxyXG4gKiBAY2xhc3MgUG9pbnRUb1BvaW50Q29uc3RyYWludFxyXG4gKiBAZXh0ZW5kcyBDb25zdHJhaW50XHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXHJcbiAqIEBwYXJhbSB7VmVjM30gcGl2b3RBIFRoZSBwb2ludCByZWxhdGl2ZSB0byB0aGUgY2VudGVyIG9mIG1hc3Mgb2YgYm9keUEgd2hpY2ggYm9keUEgaXMgY29uc3RyYWluZWQgdG8uXHJcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUIgQm9keSB0aGF0IHdpbGwgYmUgY29uc3RyYWluZWQgaW4gYSBzaW1pbGFyIHdheSB0byB0aGUgc2FtZSBwb2ludCBhcyBib2R5QS4gV2Ugd2lsbCB0aGVyZWZvcmUgZ2V0IGEgbGluayBiZXR3ZWVuIGJvZHlBIGFuZCBib2R5Qi4gSWYgbm90IHNwZWNpZmllZCwgYm9keUEgd2lsbCBiZSBjb25zdHJhaW5lZCB0byBhIHN0YXRpYyBwb2ludC5cclxuICogQHBhcmFtIHtWZWMzfSBwaXZvdEIgU2VlIHBpdm90QS5cclxuICogQHBhcmFtIHtOdW1iZXJ9IG1heEZvcmNlIFRoZSBtYXhpbXVtIGZvcmNlIHRoYXQgc2hvdWxkIGJlIGFwcGxpZWQgdG8gY29uc3RyYWluIHRoZSBib2RpZXMuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqICAgICB2YXIgYm9keUEgPSBuZXcgQm9keSh7IG1hc3M6IDEgfSk7XHJcbiAqICAgICB2YXIgYm9keUIgPSBuZXcgQm9keSh7IG1hc3M6IDEgfSk7XHJcbiAqICAgICBib2R5QS5wb3NpdGlvbi5zZXQoLTEsIDAsIDApO1xyXG4gKiAgICAgYm9keUIucG9zaXRpb24uc2V0KDEsIDAsIDApO1xyXG4gKiAgICAgYm9keUEuYWRkU2hhcGUoc2hhcGVBKTtcclxuICogICAgIGJvZHlCLmFkZFNoYXBlKHNoYXBlQik7XHJcbiAqICAgICB3b3JsZC5hZGRCb2R5KGJvZHlBKTtcclxuICogICAgIHdvcmxkLmFkZEJvZHkoYm9keUIpO1xyXG4gKiAgICAgdmFyIGxvY2FsUGl2b3RBID0gbmV3IFZlYzMoMSwgMCwgMCk7XHJcbiAqICAgICB2YXIgbG9jYWxQaXZvdEIgPSBuZXcgVmVjMygtMSwgMCwgMCk7XHJcbiAqICAgICB2YXIgY29uc3RyYWludCA9IG5ldyBQb2ludFRvUG9pbnRDb25zdHJhaW50KGJvZHlBLCBsb2NhbFBpdm90QSwgYm9keUIsIGxvY2FsUGl2b3RCKTtcclxuICogICAgIHdvcmxkLmFkZENvbnN0cmFpbnQoY29uc3RyYWludCk7XHJcbiAqL1xyXG5mdW5jdGlvbiBQb2ludFRvUG9pbnRDb25zdHJhaW50KGJvZHlBLHBpdm90QSxib2R5QixwaXZvdEIsbWF4Rm9yY2Upe1xyXG4gICAgQ29uc3RyYWludC5jYWxsKHRoaXMsYm9keUEsYm9keUIpO1xyXG5cclxuICAgIG1heEZvcmNlID0gdHlwZW9mKG1heEZvcmNlKSAhPT0gJ3VuZGVmaW5lZCcgPyBtYXhGb3JjZSA6IDFlNjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFBpdm90LCBkZWZpbmVkIGxvY2FsbHkgaW4gYm9keUEuXHJcbiAgICAgKiBAcHJvcGVydHkge1ZlYzN9IHBpdm90QVxyXG4gICAgICovXHJcbiAgICB0aGlzLnBpdm90QSA9IHBpdm90QSA/IHBpdm90QS5jbG9uZSgpIDogbmV3IFZlYzMoKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFBpdm90LCBkZWZpbmVkIGxvY2FsbHkgaW4gYm9keUIuXHJcbiAgICAgKiBAcHJvcGVydHkge1ZlYzN9IHBpdm90QlxyXG4gICAgICovXHJcbiAgICB0aGlzLnBpdm90QiA9IHBpdm90QiA/IHBpdm90Qi5jbG9uZSgpIDogbmV3IFZlYzMoKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcm9wZXJ0eSB7Q29udGFjdEVxdWF0aW9ufSBlcXVhdGlvblhcclxuICAgICAqL1xyXG4gICAgdmFyIHggPSB0aGlzLmVxdWF0aW9uWCA9IG5ldyBDb250YWN0RXF1YXRpb24oYm9keUEsYm9keUIpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IHtDb250YWN0RXF1YXRpb259IGVxdWF0aW9uWVxyXG4gICAgICovXHJcbiAgICB2YXIgeSA9IHRoaXMuZXF1YXRpb25ZID0gbmV3IENvbnRhY3RFcXVhdGlvbihib2R5QSxib2R5Qik7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkge0NvbnRhY3RFcXVhdGlvbn0gZXF1YXRpb25aXHJcbiAgICAgKi9cclxuICAgIHZhciB6ID0gdGhpcy5lcXVhdGlvblogPSBuZXcgQ29udGFjdEVxdWF0aW9uKGJvZHlBLGJvZHlCKTtcclxuXHJcbiAgICAvLyBFcXVhdGlvbnMgdG8gYmUgZmVkIHRvIHRoZSBzb2x2ZXJcclxuICAgIHRoaXMuZXF1YXRpb25zLnB1c2goeCwgeSwgeik7XHJcblxyXG4gICAgLy8gTWFrZSB0aGUgZXF1YXRpb25zIGJpZGlyZWN0aW9uYWxcclxuICAgIHgubWluRm9yY2UgPSB5Lm1pbkZvcmNlID0gei5taW5Gb3JjZSA9IC1tYXhGb3JjZTtcclxuICAgIHgubWF4Rm9yY2UgPSB5Lm1heEZvcmNlID0gei5tYXhGb3JjZSA9ICBtYXhGb3JjZTtcclxuXHJcbiAgICB4Lm5pLnNldCgxLCAwLCAwKTtcclxuICAgIHkubmkuc2V0KDAsIDEsIDApO1xyXG4gICAgei5uaS5zZXQoMCwgMCwgMSk7XHJcbn1cclxuUG9pbnRUb1BvaW50Q29uc3RyYWludC5wcm90b3R5cGUgPSBuZXcgQ29uc3RyYWludCgpO1xyXG5cclxuUG9pbnRUb1BvaW50Q29uc3RyYWludC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKXtcclxuICAgIHZhciBib2R5QSA9IHRoaXMuYm9keUE7XHJcbiAgICB2YXIgYm9keUIgPSB0aGlzLmJvZHlCO1xyXG4gICAgdmFyIHggPSB0aGlzLmVxdWF0aW9uWDtcclxuICAgIHZhciB5ID0gdGhpcy5lcXVhdGlvblk7XHJcbiAgICB2YXIgeiA9IHRoaXMuZXF1YXRpb25aO1xyXG5cclxuICAgIC8vIFJvdGF0ZSB0aGUgcGl2b3RzIHRvIHdvcmxkIHNwYWNlXHJcbiAgICBib2R5QS5xdWF0ZXJuaW9uLnZtdWx0KHRoaXMucGl2b3RBLHgucmkpO1xyXG4gICAgYm9keUIucXVhdGVybmlvbi52bXVsdCh0aGlzLnBpdm90Qix4LnJqKTtcclxuXHJcbiAgICB5LnJpLmNvcHkoeC5yaSk7XHJcbiAgICB5LnJqLmNvcHkoeC5yaik7XHJcbiAgICB6LnJpLmNvcHkoeC5yaSk7XHJcbiAgICB6LnJqLmNvcHkoeC5yaik7XHJcbn07XHJcbn0se1wiLi4vZXF1YXRpb25zL0NvbnRhY3RFcXVhdGlvblwiOjIwLFwiLi4vbWF0aC9WZWMzXCI6MzEsXCIuL0NvbnN0cmFpbnRcIjoxNH1dLDE5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcclxubW9kdWxlLmV4cG9ydHMgPSBDb25lRXF1YXRpb247XHJcblxyXG52YXIgVmVjMyA9IF9kZXJlcV8oJy4uL21hdGgvVmVjMycpO1xyXG52YXIgTWF0MyA9IF9kZXJlcV8oJy4uL21hdGgvTWF0MycpO1xyXG52YXIgRXF1YXRpb24gPSBfZGVyZXFfKCcuL0VxdWF0aW9uJyk7XHJcblxyXG4vKipcclxuICogQ29uZSBlcXVhdGlvbi4gV29ya3MgdG8ga2VlcCB0aGUgZ2l2ZW4gYm9keSB3b3JsZCB2ZWN0b3JzIGFsaWduZWQsIG9yIHRpbHRlZCB3aXRoaW4gYSBnaXZlbiBhbmdsZSBmcm9tIGVhY2ggb3RoZXIuXHJcbiAqIEBjbGFzcyBDb25lRXF1YXRpb25cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBhdXRob3Igc2NodGVwcGVcclxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxyXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXHJcbiAqIEBwYXJhbSB7VmVjM30gW29wdGlvbnMuYXhpc0FdIExvY2FsIGF4aXMgaW4gQVxyXG4gKiBAcGFyYW0ge1ZlYzN9IFtvcHRpb25zLmF4aXNCXSBMb2NhbCBheGlzIGluIEJcclxuICogQHBhcmFtIHtWZWMzfSBbb3B0aW9ucy5hbmdsZV0gVGhlIFwiY29uZSBhbmdsZVwiIHRvIGtlZXBcclxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1heEZvcmNlPTFlNl1cclxuICogQGV4dGVuZHMgRXF1YXRpb25cclxuICovXHJcbmZ1bmN0aW9uIENvbmVFcXVhdGlvbihib2R5QSwgYm9keUIsIG9wdGlvbnMpe1xyXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgICB2YXIgbWF4Rm9yY2UgPSB0eXBlb2Yob3B0aW9ucy5tYXhGb3JjZSkgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5tYXhGb3JjZSA6IDFlNjtcclxuXHJcbiAgICBFcXVhdGlvbi5jYWxsKHRoaXMsYm9keUEsYm9keUIsLW1heEZvcmNlLCBtYXhGb3JjZSk7XHJcblxyXG4gICAgdGhpcy5heGlzQSA9IG9wdGlvbnMuYXhpc0EgPyBvcHRpb25zLmF4aXNBLmNsb25lKCkgOiBuZXcgVmVjMygxLCAwLCAwKTtcclxuICAgIHRoaXMuYXhpc0IgPSBvcHRpb25zLmF4aXNCID8gb3B0aW9ucy5heGlzQi5jbG9uZSgpIDogbmV3IFZlYzMoMCwgMSwgMCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgY29uZSBhbmdsZSB0byBrZWVwXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gYW5nbGVcclxuICAgICAqL1xyXG4gICAgdGhpcy5hbmdsZSA9IHR5cGVvZihvcHRpb25zLmFuZ2xlKSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLmFuZ2xlIDogMDtcclxufVxyXG5cclxuQ29uZUVxdWF0aW9uLnByb3RvdHlwZSA9IG5ldyBFcXVhdGlvbigpO1xyXG5Db25lRXF1YXRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29uZUVxdWF0aW9uO1xyXG5cclxudmFyIHRtcFZlYzEgPSBuZXcgVmVjMygpO1xyXG52YXIgdG1wVmVjMiA9IG5ldyBWZWMzKCk7XHJcblxyXG5Db25lRXF1YXRpb24ucHJvdG90eXBlLmNvbXB1dGVCID0gZnVuY3Rpb24oaCl7XHJcbiAgICB2YXIgYSA9IHRoaXMuYSxcclxuICAgICAgICBiID0gdGhpcy5iLFxyXG5cclxuICAgICAgICBuaSA9IHRoaXMuYXhpc0EsXHJcbiAgICAgICAgbmogPSB0aGlzLmF4aXNCLFxyXG5cclxuICAgICAgICBuaXhuaiA9IHRtcFZlYzEsXHJcbiAgICAgICAgbmp4bmkgPSB0bXBWZWMyLFxyXG5cclxuICAgICAgICBHQSA9IHRoaXMuamFjb2JpYW5FbGVtZW50QSxcclxuICAgICAgICBHQiA9IHRoaXMuamFjb2JpYW5FbGVtZW50QjtcclxuXHJcbiAgICAvLyBDYWx1Y2xhdGUgY3Jvc3MgcHJvZHVjdHNcclxuICAgIG5pLmNyb3NzKG5qLCBuaXhuaik7XHJcbiAgICBuai5jcm9zcyhuaSwgbmp4bmkpO1xyXG5cclxuICAgIC8vIFRoZSBhbmdsZSBiZXR3ZWVuIHR3byB2ZWN0b3IgaXM6XHJcbiAgICAvLyBjb3ModGhldGEpID0gYSAqIGIgLyAobGVuZ3RoKGEpICogbGVuZ3RoKGIpID0geyBsZW4oYSkgPSBsZW4oYikgPSAxIH0gPSBhICogYlxyXG5cclxuICAgIC8vIGcgPSBhICogYlxyXG4gICAgLy8gZ2RvdCA9IChiIHggYSkgKiB3aSArIChhIHggYikgKiB3alxyXG4gICAgLy8gRyA9IFswIGJ4YSAwIGF4Yl1cclxuICAgIC8vIFcgPSBbdmkgd2kgdmogd2pdXHJcbiAgICBHQS5yb3RhdGlvbmFsLmNvcHkobmp4bmkpO1xyXG4gICAgR0Iucm90YXRpb25hbC5jb3B5KG5peG5qKTtcclxuXHJcbiAgICB2YXIgZyA9IE1hdGguY29zKHRoaXMuYW5nbGUpIC0gbmkuZG90KG5qKSxcclxuICAgICAgICBHVyA9IHRoaXMuY29tcHV0ZUdXKCksXHJcbiAgICAgICAgR2lNZiA9IHRoaXMuY29tcHV0ZUdpTWYoKTtcclxuXHJcbiAgICB2YXIgQiA9IC0gZyAqIGEgLSBHVyAqIGIgLSBoICogR2lNZjtcclxuXHJcbiAgICByZXR1cm4gQjtcclxufTtcclxuXHJcblxyXG59LHtcIi4uL21hdGgvTWF0M1wiOjI4LFwiLi4vbWF0aC9WZWMzXCI6MzEsXCIuL0VxdWF0aW9uXCI6MjF9XSwyMDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XHJcbm1vZHVsZS5leHBvcnRzID0gQ29udGFjdEVxdWF0aW9uO1xyXG5cclxudmFyIEVxdWF0aW9uID0gX2RlcmVxXygnLi9FcXVhdGlvbicpO1xyXG52YXIgVmVjMyA9IF9kZXJlcV8oJy4uL21hdGgvVmVjMycpO1xyXG52YXIgTWF0MyA9IF9kZXJlcV8oJy4uL21hdGgvTWF0MycpO1xyXG5cclxuLyoqXHJcbiAqIENvbnRhY3Qvbm9uLXBlbmV0cmF0aW9uIGNvbnN0cmFpbnQgZXF1YXRpb25cclxuICogQGNsYXNzIENvbnRhY3RFcXVhdGlvblxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQGF1dGhvciBzY2h0ZXBwZVxyXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXHJcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUJcclxuICogQGV4dGVuZHMgRXF1YXRpb25cclxuICovXHJcbmZ1bmN0aW9uIENvbnRhY3RFcXVhdGlvbihib2R5QSwgYm9keUIsIG1heEZvcmNlKXtcclxuICAgIG1heEZvcmNlID0gdHlwZW9mKG1heEZvcmNlKSAhPT0gJ3VuZGVmaW5lZCcgPyBtYXhGb3JjZSA6IDFlNjtcclxuICAgIEVxdWF0aW9uLmNhbGwodGhpcywgYm9keUEsIGJvZHlCLCAwLCBtYXhGb3JjZSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkgc2lcclxuICAgICAqIEB0eXBlIHtTaGFwZX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5zaSA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkgc2pcclxuICAgICAqIEB0eXBlIHtTaGFwZX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5zaiA9IG51bGw7XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IHJlc3RpdHV0aW9uXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLnJlc3RpdHV0aW9uID0gMC4wOyAvLyBcImJvdW5jaW5lc3NcIjogdTEgPSAtZSp1MFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogV29ybGQtb3JpZW50ZWQgdmVjdG9yIHRoYXQgZ29lcyBmcm9tIHRoZSBjZW50ZXIgb2YgYmkgdG8gdGhlIGNvbnRhY3QgcG9pbnQuXHJcbiAgICAgKiBAcHJvcGVydHkge1ZlYzN9IHJpXHJcbiAgICAgKi9cclxuICAgIHRoaXMucmkgPSBuZXcgVmVjMygpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV29ybGQtb3JpZW50ZWQgdmVjdG9yIHRoYXQgc3RhcnRzIGluIGJvZHkgaiBwb3NpdGlvbiBhbmQgZ29lcyB0byB0aGUgY29udGFjdCBwb2ludC5cclxuICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gcmpcclxuICAgICAqL1xyXG4gICAgdGhpcy5yaiA9IG5ldyBWZWMzKCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb250YWN0IG5vcm1hbCwgcG9pbnRpbmcgb3V0IG9mIGJvZHkgaS5cclxuICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gbmlcclxuICAgICAqL1xyXG4gICAgdGhpcy5uaSA9IG5ldyBWZWMzKCk7XHJcbn1cclxuXHJcbkNvbnRhY3RFcXVhdGlvbi5wcm90b3R5cGUgPSBuZXcgRXF1YXRpb24oKTtcclxuQ29udGFjdEVxdWF0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvbnRhY3RFcXVhdGlvbjtcclxuXHJcbnZhciBDb250YWN0RXF1YXRpb25fY29tcHV0ZUJfdGVtcDEgPSBuZXcgVmVjMygpOyAvLyBUZW1wIHZlY3RvcnNcclxudmFyIENvbnRhY3RFcXVhdGlvbl9jb21wdXRlQl90ZW1wMiA9IG5ldyBWZWMzKCk7XHJcbnZhciBDb250YWN0RXF1YXRpb25fY29tcHV0ZUJfdGVtcDMgPSBuZXcgVmVjMygpO1xyXG5Db250YWN0RXF1YXRpb24ucHJvdG90eXBlLmNvbXB1dGVCID0gZnVuY3Rpb24oaCl7XHJcbiAgICB2YXIgYSA9IHRoaXMuYSxcclxuICAgICAgICBiID0gdGhpcy5iLFxyXG4gICAgICAgIGJpID0gdGhpcy5iaSxcclxuICAgICAgICBiaiA9IHRoaXMuYmosXHJcbiAgICAgICAgcmkgPSB0aGlzLnJpLFxyXG4gICAgICAgIHJqID0gdGhpcy5yaixcclxuICAgICAgICByaXhuID0gQ29udGFjdEVxdWF0aW9uX2NvbXB1dGVCX3RlbXAxLFxyXG4gICAgICAgIHJqeG4gPSBDb250YWN0RXF1YXRpb25fY29tcHV0ZUJfdGVtcDIsXHJcblxyXG4gICAgICAgIHZpID0gYmkudmVsb2NpdHksXHJcbiAgICAgICAgd2kgPSBiaS5hbmd1bGFyVmVsb2NpdHksXHJcbiAgICAgICAgZmkgPSBiaS5mb3JjZSxcclxuICAgICAgICB0YXVpID0gYmkudG9ycXVlLFxyXG5cclxuICAgICAgICB2aiA9IGJqLnZlbG9jaXR5LFxyXG4gICAgICAgIHdqID0gYmouYW5ndWxhclZlbG9jaXR5LFxyXG4gICAgICAgIGZqID0gYmouZm9yY2UsXHJcbiAgICAgICAgdGF1aiA9IGJqLnRvcnF1ZSxcclxuXHJcbiAgICAgICAgcGVuZXRyYXRpb25WZWMgPSBDb250YWN0RXF1YXRpb25fY29tcHV0ZUJfdGVtcDMsXHJcblxyXG4gICAgICAgIEdBID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRBLFxyXG4gICAgICAgIEdCID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRCLFxyXG5cclxuICAgICAgICBuID0gdGhpcy5uaTtcclxuXHJcbiAgICAvLyBDYWx1Y2xhdGUgY3Jvc3MgcHJvZHVjdHNcclxuICAgIHJpLmNyb3NzKG4scml4bik7XHJcbiAgICByai5jcm9zcyhuLHJqeG4pO1xyXG5cclxuICAgIC8vIGcgPSB4aityaiAtKHhpK3JpKVxyXG4gICAgLy8gRyA9IFsgLW5pICAtcml4biAgbmkgIHJqeG4gXVxyXG4gICAgbi5uZWdhdGUoR0Euc3BhdGlhbCk7XHJcbiAgICByaXhuLm5lZ2F0ZShHQS5yb3RhdGlvbmFsKTtcclxuICAgIEdCLnNwYXRpYWwuY29weShuKTtcclxuICAgIEdCLnJvdGF0aW9uYWwuY29weShyanhuKTtcclxuXHJcbiAgICAvLyBDYWxjdWxhdGUgdGhlIHBlbmV0cmF0aW9uIHZlY3RvclxyXG4gICAgcGVuZXRyYXRpb25WZWMuY29weShiai5wb3NpdGlvbik7XHJcbiAgICBwZW5ldHJhdGlvblZlYy52YWRkKHJqLHBlbmV0cmF0aW9uVmVjKTtcclxuICAgIHBlbmV0cmF0aW9uVmVjLnZzdWIoYmkucG9zaXRpb24scGVuZXRyYXRpb25WZWMpO1xyXG4gICAgcGVuZXRyYXRpb25WZWMudnN1YihyaSxwZW5ldHJhdGlvblZlYyk7XHJcblxyXG4gICAgdmFyIGcgPSBuLmRvdChwZW5ldHJhdGlvblZlYyk7XHJcblxyXG4gICAgLy8gQ29tcHV0ZSBpdGVyYXRpb25cclxuICAgIHZhciBlUGx1c09uZSA9IHRoaXMucmVzdGl0dXRpb24gKyAxO1xyXG4gICAgdmFyIEdXID0gZVBsdXNPbmUgKiB2ai5kb3QobikgLSBlUGx1c09uZSAqIHZpLmRvdChuKSArIHdqLmRvdChyanhuKSAtIHdpLmRvdChyaXhuKTtcclxuICAgIHZhciBHaU1mID0gdGhpcy5jb21wdXRlR2lNZigpO1xyXG5cclxuICAgIHZhciBCID0gLSBnICogYSAtIEdXICogYiAtIGgqR2lNZjtcclxuXHJcbiAgICByZXR1cm4gQjtcclxufTtcclxuXHJcbnZhciBDb250YWN0RXF1YXRpb25fZ2V0SW1wYWN0VmVsb2NpdHlBbG9uZ05vcm1hbF92aSA9IG5ldyBWZWMzKCk7XHJcbnZhciBDb250YWN0RXF1YXRpb25fZ2V0SW1wYWN0VmVsb2NpdHlBbG9uZ05vcm1hbF92aiA9IG5ldyBWZWMzKCk7XHJcbnZhciBDb250YWN0RXF1YXRpb25fZ2V0SW1wYWN0VmVsb2NpdHlBbG9uZ05vcm1hbF94aSA9IG5ldyBWZWMzKCk7XHJcbnZhciBDb250YWN0RXF1YXRpb25fZ2V0SW1wYWN0VmVsb2NpdHlBbG9uZ05vcm1hbF94aiA9IG5ldyBWZWMzKCk7XHJcbnZhciBDb250YWN0RXF1YXRpb25fZ2V0SW1wYWN0VmVsb2NpdHlBbG9uZ05vcm1hbF9yZWxWZWwgPSBuZXcgVmVjMygpO1xyXG5cclxuLyoqXHJcbiAqIEdldCB0aGUgY3VycmVudCByZWxhdGl2ZSB2ZWxvY2l0eSBpbiB0aGUgY29udGFjdCBwb2ludC5cclxuICogQG1ldGhvZCBnZXRJbXBhY3RWZWxvY2l0eUFsb25nTm9ybWFsXHJcbiAqIEByZXR1cm4ge251bWJlcn1cclxuICovXHJcbkNvbnRhY3RFcXVhdGlvbi5wcm90b3R5cGUuZ2V0SW1wYWN0VmVsb2NpdHlBbG9uZ05vcm1hbCA9IGZ1bmN0aW9uKCl7XHJcbiAgICB2YXIgdmkgPSBDb250YWN0RXF1YXRpb25fZ2V0SW1wYWN0VmVsb2NpdHlBbG9uZ05vcm1hbF92aTtcclxuICAgIHZhciB2aiA9IENvbnRhY3RFcXVhdGlvbl9nZXRJbXBhY3RWZWxvY2l0eUFsb25nTm9ybWFsX3ZqO1xyXG4gICAgdmFyIHhpID0gQ29udGFjdEVxdWF0aW9uX2dldEltcGFjdFZlbG9jaXR5QWxvbmdOb3JtYWxfeGk7XHJcbiAgICB2YXIgeGogPSBDb250YWN0RXF1YXRpb25fZ2V0SW1wYWN0VmVsb2NpdHlBbG9uZ05vcm1hbF94ajtcclxuICAgIHZhciByZWxWZWwgPSBDb250YWN0RXF1YXRpb25fZ2V0SW1wYWN0VmVsb2NpdHlBbG9uZ05vcm1hbF9yZWxWZWw7XHJcblxyXG4gICAgdGhpcy5iaS5wb3NpdGlvbi52YWRkKHRoaXMucmksIHhpKTtcclxuICAgIHRoaXMuYmoucG9zaXRpb24udmFkZCh0aGlzLnJqLCB4aik7XHJcblxyXG4gICAgdGhpcy5iaS5nZXRWZWxvY2l0eUF0V29ybGRQb2ludCh4aSwgdmkpO1xyXG4gICAgdGhpcy5iai5nZXRWZWxvY2l0eUF0V29ybGRQb2ludCh4aiwgdmopO1xyXG5cclxuICAgIHZpLnZzdWIodmosIHJlbFZlbCk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMubmkuZG90KHJlbFZlbCk7XHJcbn07XHJcblxyXG5cclxufSx7XCIuLi9tYXRoL01hdDNcIjoyOCxcIi4uL21hdGgvVmVjM1wiOjMxLFwiLi9FcXVhdGlvblwiOjIxfV0sMjE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xyXG5tb2R1bGUuZXhwb3J0cyA9IEVxdWF0aW9uO1xyXG5cclxudmFyIEphY29iaWFuRWxlbWVudCA9IF9kZXJlcV8oJy4uL21hdGgvSmFjb2JpYW5FbGVtZW50JyksXHJcbiAgICBWZWMzID0gX2RlcmVxXygnLi4vbWF0aC9WZWMzJyk7XHJcblxyXG4vKipcclxuICogRXF1YXRpb24gYmFzZSBjbGFzc1xyXG4gKiBAY2xhc3MgRXF1YXRpb25cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBhdXRob3Igc2NodGVwcGVcclxuICogQHBhcmFtIHtCb2R5fSBiaVxyXG4gKiBAcGFyYW0ge0JvZHl9IGJqXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtaW5Gb3JjZSBNaW5pbXVtIChyZWFkOiBuZWdhdGl2ZSBtYXgpIGZvcmNlIHRvIGJlIGFwcGxpZWQgYnkgdGhlIGNvbnN0cmFpbnQuXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtYXhGb3JjZSBNYXhpbXVtIChyZWFkOiBwb3NpdGl2ZSBtYXgpIGZvcmNlIHRvIGJlIGFwcGxpZWQgYnkgdGhlIGNvbnN0cmFpbnQuXHJcbiAqL1xyXG5mdW5jdGlvbiBFcXVhdGlvbihiaSxiaixtaW5Gb3JjZSxtYXhGb3JjZSl7XHJcbiAgICB0aGlzLmlkID0gRXF1YXRpb24uaWQrKztcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtaW5Gb3JjZVxyXG4gICAgICovXHJcbiAgICB0aGlzLm1pbkZvcmNlID0gdHlwZW9mKG1pbkZvcmNlKT09PVwidW5kZWZpbmVkXCIgPyAtMWU2IDogbWluRm9yY2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbWF4Rm9yY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5tYXhGb3JjZSA9IHR5cGVvZihtYXhGb3JjZSk9PT1cInVuZGVmaW5lZFwiID8gMWU2IDogbWF4Rm9yY2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkgYmlcclxuICAgICAqIEB0eXBlIHtCb2R5fVxyXG4gICAgICovXHJcbiAgICB0aGlzLmJpID0gYmk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkgYmpcclxuICAgICAqIEB0eXBlIHtCb2R5fVxyXG4gICAgICovXHJcbiAgICB0aGlzLmJqID0gYmo7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTUE9PSyBwYXJhbWV0ZXJcclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBhXHJcbiAgICAgKi9cclxuICAgIHRoaXMuYSA9IDAuMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNQT09LIHBhcmFtZXRlclxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGJcclxuICAgICAqL1xyXG4gICAgdGhpcy5iID0gMC4wO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU1BPT0sgcGFyYW1ldGVyXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZXBzXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZXBzID0gMC4wO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IHtKYWNvYmlhbkVsZW1lbnR9IGphY29iaWFuRWxlbWVudEFcclxuICAgICAqL1xyXG4gICAgdGhpcy5qYWNvYmlhbkVsZW1lbnRBID0gbmV3IEphY29iaWFuRWxlbWVudCgpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IHtKYWNvYmlhbkVsZW1lbnR9IGphY29iaWFuRWxlbWVudEJcclxuICAgICAqL1xyXG4gICAgdGhpcy5qYWNvYmlhbkVsZW1lbnRCID0gbmV3IEphY29iaWFuRWxlbWVudCgpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBlbmFibGVkXHJcbiAgICAgKiBAZGVmYXVsdCB0cnVlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIG51bWJlciwgcHJvcG9ydGlvbmFsIHRvIHRoZSBmb3JjZSBhZGRlZCB0byB0aGUgYm9kaWVzLlxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG11bHRpcGxpZXJcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXHJcbiAgICB0aGlzLm11bHRpcGxpZXIgPSAwO1xyXG5cclxuICAgIC8vIFNldCB0eXBpY2FsIHNwb29rIHBhcmFtc1xyXG4gICAgdGhpcy5zZXRTcG9va1BhcmFtcygxZTcsNCwxLzYwKTtcclxufVxyXG5FcXVhdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBFcXVhdGlvbjtcclxuXHJcbkVxdWF0aW9uLmlkID0gMDtcclxuXHJcbi8qKlxyXG4gKiBSZWNhbGN1bGF0ZXMgYSxiLGVwcy5cclxuICogQG1ldGhvZCBzZXRTcG9va1BhcmFtc1xyXG4gKi9cclxuRXF1YXRpb24ucHJvdG90eXBlLnNldFNwb29rUGFyYW1zID0gZnVuY3Rpb24oc3RpZmZuZXNzLHJlbGF4YXRpb24sdGltZVN0ZXApe1xyXG4gICAgdmFyIGQgPSByZWxheGF0aW9uLFxyXG4gICAgICAgIGsgPSBzdGlmZm5lc3MsXHJcbiAgICAgICAgaCA9IHRpbWVTdGVwO1xyXG4gICAgdGhpcy5hID0gNC4wIC8gKGggKiAoMSArIDQgKiBkKSk7XHJcbiAgICB0aGlzLmIgPSAoNC4wICogZCkgLyAoMSArIDQgKiBkKTtcclxuICAgIHRoaXMuZXBzID0gNC4wIC8gKGggKiBoICogayAqICgxICsgNCAqIGQpKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb21wdXRlcyB0aGUgUkhTIG9mIHRoZSBTUE9PSyBlcXVhdGlvblxyXG4gKiBAbWV0aG9kIGNvbXB1dGVCXHJcbiAqIEByZXR1cm4ge051bWJlcn1cclxuICovXHJcbkVxdWF0aW9uLnByb3RvdHlwZS5jb21wdXRlQiA9IGZ1bmN0aW9uKGEsYixoKXtcclxuICAgIHZhciBHVyA9IHRoaXMuY29tcHV0ZUdXKCksXHJcbiAgICAgICAgR3EgPSB0aGlzLmNvbXB1dGVHcSgpLFxyXG4gICAgICAgIEdpTWYgPSB0aGlzLmNvbXB1dGVHaU1mKCk7XHJcbiAgICByZXR1cm4gLSBHcSAqIGEgLSBHVyAqIGIgLSBHaU1mKmg7XHJcbn07XHJcblxyXG4vKipcclxuICogQ29tcHV0ZXMgRypxLCB3aGVyZSBxIGFyZSB0aGUgZ2VuZXJhbGl6ZWQgYm9keSBjb29yZGluYXRlc1xyXG4gKiBAbWV0aG9kIGNvbXB1dGVHcVxyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XHJcbiAqL1xyXG5FcXVhdGlvbi5wcm90b3R5cGUuY29tcHV0ZUdxID0gZnVuY3Rpb24oKXtcclxuICAgIHZhciBHQSA9IHRoaXMuamFjb2JpYW5FbGVtZW50QSxcclxuICAgICAgICBHQiA9IHRoaXMuamFjb2JpYW5FbGVtZW50QixcclxuICAgICAgICBiaSA9IHRoaXMuYmksXHJcbiAgICAgICAgYmogPSB0aGlzLmJqLFxyXG4gICAgICAgIHhpID0gYmkucG9zaXRpb24sXHJcbiAgICAgICAgeGogPSBiai5wb3NpdGlvbjtcclxuICAgIHJldHVybiBHQS5zcGF0aWFsLmRvdCh4aSkgKyBHQi5zcGF0aWFsLmRvdCh4aik7XHJcbn07XHJcblxyXG52YXIgemVybyA9IG5ldyBWZWMzKCk7XHJcblxyXG4vKipcclxuICogQ29tcHV0ZXMgRypXLCB3aGVyZSBXIGFyZSB0aGUgYm9keSB2ZWxvY2l0aWVzXHJcbiAqIEBtZXRob2QgY29tcHV0ZUdXXHJcbiAqIEByZXR1cm4ge051bWJlcn1cclxuICovXHJcbkVxdWF0aW9uLnByb3RvdHlwZS5jb21wdXRlR1cgPSBmdW5jdGlvbigpe1xyXG4gICAgdmFyIEdBID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRBLFxyXG4gICAgICAgIEdCID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRCLFxyXG4gICAgICAgIGJpID0gdGhpcy5iaSxcclxuICAgICAgICBiaiA9IHRoaXMuYmosXHJcbiAgICAgICAgdmkgPSBiaS52ZWxvY2l0eSxcclxuICAgICAgICB2aiA9IGJqLnZlbG9jaXR5LFxyXG4gICAgICAgIHdpID0gYmkuYW5ndWxhclZlbG9jaXR5LFxyXG4gICAgICAgIHdqID0gYmouYW5ndWxhclZlbG9jaXR5O1xyXG4gICAgcmV0dXJuIEdBLm11bHRpcGx5VmVjdG9ycyh2aSx3aSkgKyBHQi5tdWx0aXBseVZlY3RvcnModmosd2opO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBDb21wdXRlcyBHKldsYW1iZGEsIHdoZXJlIFcgYXJlIHRoZSBib2R5IHZlbG9jaXRpZXNcclxuICogQG1ldGhvZCBjb21wdXRlR1dsYW1iZGFcclxuICogQHJldHVybiB7TnVtYmVyfVxyXG4gKi9cclxuRXF1YXRpb24ucHJvdG90eXBlLmNvbXB1dGVHV2xhbWJkYSA9IGZ1bmN0aW9uKCl7XHJcbiAgICB2YXIgR0EgPSB0aGlzLmphY29iaWFuRWxlbWVudEEsXHJcbiAgICAgICAgR0IgPSB0aGlzLmphY29iaWFuRWxlbWVudEIsXHJcbiAgICAgICAgYmkgPSB0aGlzLmJpLFxyXG4gICAgICAgIGJqID0gdGhpcy5iaixcclxuICAgICAgICB2aSA9IGJpLnZsYW1iZGEsXHJcbiAgICAgICAgdmogPSBiai52bGFtYmRhLFxyXG4gICAgICAgIHdpID0gYmkud2xhbWJkYSxcclxuICAgICAgICB3aiA9IGJqLndsYW1iZGE7XHJcbiAgICByZXR1cm4gR0EubXVsdGlwbHlWZWN0b3JzKHZpLHdpKSArIEdCLm11bHRpcGx5VmVjdG9ycyh2aix3aik7XHJcbn07XHJcblxyXG4vKipcclxuICogQ29tcHV0ZXMgRyppbnYoTSkqZiwgd2hlcmUgTSBpcyB0aGUgbWFzcyBtYXRyaXggd2l0aCBkaWFnb25hbCBibG9ja3MgZm9yIGVhY2ggYm9keSwgYW5kIGYgYXJlIHRoZSBmb3JjZXMgb24gdGhlIGJvZGllcy5cclxuICogQG1ldGhvZCBjb21wdXRlR2lNZlxyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XHJcbiAqL1xyXG52YXIgaU1maSA9IG5ldyBWZWMzKCksXHJcbiAgICBpTWZqID0gbmV3IFZlYzMoKSxcclxuICAgIGludklpX3ZtdWx0X3RhdWkgPSBuZXcgVmVjMygpLFxyXG4gICAgaW52SWpfdm11bHRfdGF1aiA9IG5ldyBWZWMzKCk7XHJcbkVxdWF0aW9uLnByb3RvdHlwZS5jb21wdXRlR2lNZiA9IGZ1bmN0aW9uKCl7XHJcbiAgICB2YXIgR0EgPSB0aGlzLmphY29iaWFuRWxlbWVudEEsXHJcbiAgICAgICAgR0IgPSB0aGlzLmphY29iaWFuRWxlbWVudEIsXHJcbiAgICAgICAgYmkgPSB0aGlzLmJpLFxyXG4gICAgICAgIGJqID0gdGhpcy5iaixcclxuICAgICAgICBmaSA9IGJpLmZvcmNlLFxyXG4gICAgICAgIHRpID0gYmkudG9ycXVlLFxyXG4gICAgICAgIGZqID0gYmouZm9yY2UsXHJcbiAgICAgICAgdGogPSBiai50b3JxdWUsXHJcbiAgICAgICAgaW52TWFzc2kgPSBiaS5pbnZNYXNzU29sdmUsXHJcbiAgICAgICAgaW52TWFzc2ogPSBiai5pbnZNYXNzU29sdmU7XHJcblxyXG4gICAgZmkuc2NhbGUoaW52TWFzc2ksaU1maSk7XHJcbiAgICBmai5zY2FsZShpbnZNYXNzaixpTWZqKTtcclxuXHJcbiAgICBiaS5pbnZJbmVydGlhV29ybGRTb2x2ZS52bXVsdCh0aSxpbnZJaV92bXVsdF90YXVpKTtcclxuICAgIGJqLmludkluZXJ0aWFXb3JsZFNvbHZlLnZtdWx0KHRqLGludklqX3ZtdWx0X3RhdWopO1xyXG5cclxuICAgIHJldHVybiBHQS5tdWx0aXBseVZlY3RvcnMoaU1maSxpbnZJaV92bXVsdF90YXVpKSArIEdCLm11bHRpcGx5VmVjdG9ycyhpTWZqLGludklqX3ZtdWx0X3RhdWopO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbXB1dGVzIEcqaW52KE0pKkcnXHJcbiAqIEBtZXRob2QgY29tcHV0ZUdpTUd0XHJcbiAqIEByZXR1cm4ge051bWJlcn1cclxuICovXHJcbnZhciB0bXAgPSBuZXcgVmVjMygpO1xyXG5FcXVhdGlvbi5wcm90b3R5cGUuY29tcHV0ZUdpTUd0ID0gZnVuY3Rpb24oKXtcclxuICAgIHZhciBHQSA9IHRoaXMuamFjb2JpYW5FbGVtZW50QSxcclxuICAgICAgICBHQiA9IHRoaXMuamFjb2JpYW5FbGVtZW50QixcclxuICAgICAgICBiaSA9IHRoaXMuYmksXHJcbiAgICAgICAgYmogPSB0aGlzLmJqLFxyXG4gICAgICAgIGludk1hc3NpID0gYmkuaW52TWFzc1NvbHZlLFxyXG4gICAgICAgIGludk1hc3NqID0gYmouaW52TWFzc1NvbHZlLFxyXG4gICAgICAgIGludklpID0gYmkuaW52SW5lcnRpYVdvcmxkU29sdmUsXHJcbiAgICAgICAgaW52SWogPSBiai5pbnZJbmVydGlhV29ybGRTb2x2ZSxcclxuICAgICAgICByZXN1bHQgPSBpbnZNYXNzaSArIGludk1hc3NqO1xyXG5cclxuICAgIGludklpLnZtdWx0KEdBLnJvdGF0aW9uYWwsdG1wKTtcclxuICAgIHJlc3VsdCArPSB0bXAuZG90KEdBLnJvdGF0aW9uYWwpO1xyXG5cclxuICAgIGludklqLnZtdWx0KEdCLnJvdGF0aW9uYWwsdG1wKTtcclxuICAgIHJlc3VsdCArPSB0bXAuZG90KEdCLnJvdGF0aW9uYWwpO1xyXG5cclxuICAgIHJldHVybiAgcmVzdWx0O1xyXG59O1xyXG5cclxudmFyIGFkZFRvV2xhbWJkYV90ZW1wID0gbmV3IFZlYzMoKSxcclxuICAgIGFkZFRvV2xhbWJkYV9HaSA9IG5ldyBWZWMzKCksXHJcbiAgICBhZGRUb1dsYW1iZGFfR2ogPSBuZXcgVmVjMygpLFxyXG4gICAgYWRkVG9XbGFtYmRhX3JpID0gbmV3IFZlYzMoKSxcclxuICAgIGFkZFRvV2xhbWJkYV9yaiA9IG5ldyBWZWMzKCksXHJcbiAgICBhZGRUb1dsYW1iZGFfTWRpYWcgPSBuZXcgVmVjMygpO1xyXG5cclxuLyoqXHJcbiAqIEFkZCBjb25zdHJhaW50IHZlbG9jaXR5IHRvIHRoZSBib2RpZXMuXHJcbiAqIEBtZXRob2QgYWRkVG9XbGFtYmRhXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YWxhbWJkYVxyXG4gKi9cclxuRXF1YXRpb24ucHJvdG90eXBlLmFkZFRvV2xhbWJkYSA9IGZ1bmN0aW9uKGRlbHRhbGFtYmRhKXtcclxuICAgIHZhciBHQSA9IHRoaXMuamFjb2JpYW5FbGVtZW50QSxcclxuICAgICAgICBHQiA9IHRoaXMuamFjb2JpYW5FbGVtZW50QixcclxuICAgICAgICBiaSA9IHRoaXMuYmksXHJcbiAgICAgICAgYmogPSB0aGlzLmJqLFxyXG4gICAgICAgIHRlbXAgPSBhZGRUb1dsYW1iZGFfdGVtcDtcclxuXHJcbiAgICAvLyBBZGQgdG8gbGluZWFyIHZlbG9jaXR5XHJcbiAgICAvLyB2X2xhbWJkYSArPSBpbnYoTSkgKiBkZWx0YV9sYW1iYSAqIEdcclxuICAgIGJpLnZsYW1iZGEuYWRkU2NhbGVkVmVjdG9yKGJpLmludk1hc3NTb2x2ZSAqIGRlbHRhbGFtYmRhLCBHQS5zcGF0aWFsLCBiaS52bGFtYmRhKTtcclxuICAgIGJqLnZsYW1iZGEuYWRkU2NhbGVkVmVjdG9yKGJqLmludk1hc3NTb2x2ZSAqIGRlbHRhbGFtYmRhLCBHQi5zcGF0aWFsLCBiai52bGFtYmRhKTtcclxuXHJcbiAgICAvLyBBZGQgdG8gYW5ndWxhciB2ZWxvY2l0eVxyXG4gICAgYmkuaW52SW5lcnRpYVdvcmxkU29sdmUudm11bHQoR0Eucm90YXRpb25hbCx0ZW1wKTtcclxuICAgIGJpLndsYW1iZGEuYWRkU2NhbGVkVmVjdG9yKGRlbHRhbGFtYmRhLCB0ZW1wLCBiaS53bGFtYmRhKTtcclxuXHJcbiAgICBiai5pbnZJbmVydGlhV29ybGRTb2x2ZS52bXVsdChHQi5yb3RhdGlvbmFsLHRlbXApO1xyXG4gICAgYmoud2xhbWJkYS5hZGRTY2FsZWRWZWN0b3IoZGVsdGFsYW1iZGEsIHRlbXAsIGJqLndsYW1iZGEpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbXB1dGUgdGhlIGRlbm9taW5hdG9yIHBhcnQgb2YgdGhlIFNQT09LIGVxdWF0aW9uOiBDID0gRyppbnYoTSkqRycgKyBlcHNcclxuICogQG1ldGhvZCBjb21wdXRlSW52Q1xyXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGVwc1xyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XHJcbiAqL1xyXG5FcXVhdGlvbi5wcm90b3R5cGUuY29tcHV0ZUMgPSBmdW5jdGlvbigpe1xyXG4gICAgcmV0dXJuIHRoaXMuY29tcHV0ZUdpTUd0KCkgKyB0aGlzLmVwcztcclxufTtcclxuXHJcbn0se1wiLi4vbWF0aC9KYWNvYmlhbkVsZW1lbnRcIjoyNyxcIi4uL21hdGgvVmVjM1wiOjMxfV0sMjI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xyXG5tb2R1bGUuZXhwb3J0cyA9IEZyaWN0aW9uRXF1YXRpb247XHJcblxyXG52YXIgRXF1YXRpb24gPSBfZGVyZXFfKCcuL0VxdWF0aW9uJyk7XHJcbnZhciBWZWMzID0gX2RlcmVxXygnLi4vbWF0aC9WZWMzJyk7XHJcbnZhciBNYXQzID0gX2RlcmVxXygnLi4vbWF0aC9NYXQzJyk7XHJcblxyXG4vKipcclxuICogQ29uc3RyYWlucyB0aGUgc2xpcHBpbmcgaW4gYSBjb250YWN0IGFsb25nIGEgdGFuZ2VudFxyXG4gKiBAY2xhc3MgRnJpY3Rpb25FcXVhdGlvblxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQGF1dGhvciBzY2h0ZXBwZVxyXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXHJcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUJcclxuICogQHBhcmFtIHtOdW1iZXJ9IHNsaXBGb3JjZSBzaG91bGQgYmUgKy1GX2ZyaWN0aW9uID0gKy1tdSAqIEZfbm9ybWFsID0gKy1tdSAqIG0gKiBnXHJcbiAqIEBleHRlbmRzIEVxdWF0aW9uXHJcbiAqL1xyXG5mdW5jdGlvbiBGcmljdGlvbkVxdWF0aW9uKGJvZHlBLCBib2R5Qiwgc2xpcEZvcmNlKXtcclxuICAgIEVxdWF0aW9uLmNhbGwodGhpcyxib2R5QSwgYm9keUIsIC1zbGlwRm9yY2UsIHNsaXBGb3JjZSk7XHJcbiAgICB0aGlzLnJpID0gbmV3IFZlYzMoKTtcclxuICAgIHRoaXMucmogPSBuZXcgVmVjMygpO1xyXG4gICAgdGhpcy50ID0gbmV3IFZlYzMoKTsgLy8gdGFuZ2VudFxyXG59XHJcblxyXG5GcmljdGlvbkVxdWF0aW9uLnByb3RvdHlwZSA9IG5ldyBFcXVhdGlvbigpO1xyXG5GcmljdGlvbkVxdWF0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEZyaWN0aW9uRXF1YXRpb247XHJcblxyXG52YXIgRnJpY3Rpb25FcXVhdGlvbl9jb21wdXRlQl90ZW1wMSA9IG5ldyBWZWMzKCk7XHJcbnZhciBGcmljdGlvbkVxdWF0aW9uX2NvbXB1dGVCX3RlbXAyID0gbmV3IFZlYzMoKTtcclxuRnJpY3Rpb25FcXVhdGlvbi5wcm90b3R5cGUuY29tcHV0ZUIgPSBmdW5jdGlvbihoKXtcclxuICAgIHZhciBhID0gdGhpcy5hLFxyXG4gICAgICAgIGIgPSB0aGlzLmIsXHJcbiAgICAgICAgYmkgPSB0aGlzLmJpLFxyXG4gICAgICAgIGJqID0gdGhpcy5iaixcclxuICAgICAgICByaSA9IHRoaXMucmksXHJcbiAgICAgICAgcmogPSB0aGlzLnJqLFxyXG4gICAgICAgIHJpeHQgPSBGcmljdGlvbkVxdWF0aW9uX2NvbXB1dGVCX3RlbXAxLFxyXG4gICAgICAgIHJqeHQgPSBGcmljdGlvbkVxdWF0aW9uX2NvbXB1dGVCX3RlbXAyLFxyXG4gICAgICAgIHQgPSB0aGlzLnQ7XHJcblxyXG4gICAgLy8gQ2FsdWNsYXRlIGNyb3NzIHByb2R1Y3RzXHJcbiAgICByaS5jcm9zcyh0LHJpeHQpO1xyXG4gICAgcmouY3Jvc3ModCxyanh0KTtcclxuXHJcbiAgICAvLyBHID0gWy10IC1yaXh0IHQgcmp4dF1cclxuICAgIC8vIEFuZCByZW1lbWJlciwgdGhpcyBpcyBhIHB1cmUgdmVsb2NpdHkgY29uc3RyYWludCwgZyBpcyBhbHdheXMgemVybyFcclxuICAgIHZhciBHQSA9IHRoaXMuamFjb2JpYW5FbGVtZW50QSxcclxuICAgICAgICBHQiA9IHRoaXMuamFjb2JpYW5FbGVtZW50QjtcclxuICAgIHQubmVnYXRlKEdBLnNwYXRpYWwpO1xyXG4gICAgcml4dC5uZWdhdGUoR0Eucm90YXRpb25hbCk7XHJcbiAgICBHQi5zcGF0aWFsLmNvcHkodCk7XHJcbiAgICBHQi5yb3RhdGlvbmFsLmNvcHkocmp4dCk7XHJcblxyXG4gICAgdmFyIEdXID0gdGhpcy5jb21wdXRlR1coKTtcclxuICAgIHZhciBHaU1mID0gdGhpcy5jb21wdXRlR2lNZigpO1xyXG5cclxuICAgIHZhciBCID0gLSBHVyAqIGIgLSBoICogR2lNZjtcclxuXHJcbiAgICByZXR1cm4gQjtcclxufTtcclxuXHJcbn0se1wiLi4vbWF0aC9NYXQzXCI6MjgsXCIuLi9tYXRoL1ZlYzNcIjozMSxcIi4vRXF1YXRpb25cIjoyMX1dLDIzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcclxubW9kdWxlLmV4cG9ydHMgPSBSb3RhdGlvbmFsRXF1YXRpb247XHJcblxyXG52YXIgVmVjMyA9IF9kZXJlcV8oJy4uL21hdGgvVmVjMycpO1xyXG52YXIgTWF0MyA9IF9kZXJlcV8oJy4uL21hdGgvTWF0MycpO1xyXG52YXIgRXF1YXRpb24gPSBfZGVyZXFfKCcuL0VxdWF0aW9uJyk7XHJcblxyXG4vKipcclxuICogUm90YXRpb25hbCBjb25zdHJhaW50LiBXb3JrcyB0byBrZWVwIHRoZSBsb2NhbCB2ZWN0b3JzIG9ydGhvZ29uYWwgdG8gZWFjaCBvdGhlciBpbiB3b3JsZCBzcGFjZS5cclxuICogQGNsYXNzIFJvdGF0aW9uYWxFcXVhdGlvblxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQGF1dGhvciBzY2h0ZXBwZVxyXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXHJcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUJcclxuICogQHBhcmFtIHtWZWMzfSBbb3B0aW9ucy5heGlzQV1cclxuICogQHBhcmFtIHtWZWMzfSBbb3B0aW9ucy5heGlzQl1cclxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1heEZvcmNlXVxyXG4gKiBAZXh0ZW5kcyBFcXVhdGlvblxyXG4gKi9cclxuZnVuY3Rpb24gUm90YXRpb25hbEVxdWF0aW9uKGJvZHlBLCBib2R5Qiwgb3B0aW9ucyl7XHJcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICAgIHZhciBtYXhGb3JjZSA9IHR5cGVvZihvcHRpb25zLm1heEZvcmNlKSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLm1heEZvcmNlIDogMWU2O1xyXG5cclxuICAgIEVxdWF0aW9uLmNhbGwodGhpcyxib2R5QSxib2R5QiwtbWF4Rm9yY2UsIG1heEZvcmNlKTtcclxuXHJcbiAgICB0aGlzLmF4aXNBID0gb3B0aW9ucy5heGlzQSA/IG9wdGlvbnMuYXhpc0EuY2xvbmUoKSA6IG5ldyBWZWMzKDEsIDAsIDApO1xyXG4gICAgdGhpcy5heGlzQiA9IG9wdGlvbnMuYXhpc0IgPyBvcHRpb25zLmF4aXNCLmNsb25lKCkgOiBuZXcgVmVjMygwLCAxLCAwKTtcclxuXHJcbiAgICB0aGlzLm1heEFuZ2xlID0gTWF0aC5QSSAvIDI7XHJcbn1cclxuXHJcblJvdGF0aW9uYWxFcXVhdGlvbi5wcm90b3R5cGUgPSBuZXcgRXF1YXRpb24oKTtcclxuUm90YXRpb25hbEVxdWF0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJvdGF0aW9uYWxFcXVhdGlvbjtcclxuXHJcbnZhciB0bXBWZWMxID0gbmV3IFZlYzMoKTtcclxudmFyIHRtcFZlYzIgPSBuZXcgVmVjMygpO1xyXG5cclxuUm90YXRpb25hbEVxdWF0aW9uLnByb3RvdHlwZS5jb21wdXRlQiA9IGZ1bmN0aW9uKGgpe1xyXG4gICAgdmFyIGEgPSB0aGlzLmEsXHJcbiAgICAgICAgYiA9IHRoaXMuYixcclxuXHJcbiAgICAgICAgbmkgPSB0aGlzLmF4aXNBLFxyXG4gICAgICAgIG5qID0gdGhpcy5heGlzQixcclxuXHJcbiAgICAgICAgbml4bmogPSB0bXBWZWMxLFxyXG4gICAgICAgIG5qeG5pID0gdG1wVmVjMixcclxuXHJcbiAgICAgICAgR0EgPSB0aGlzLmphY29iaWFuRWxlbWVudEEsXHJcbiAgICAgICAgR0IgPSB0aGlzLmphY29iaWFuRWxlbWVudEI7XHJcblxyXG4gICAgLy8gQ2FsdWNsYXRlIGNyb3NzIHByb2R1Y3RzXHJcbiAgICBuaS5jcm9zcyhuaiwgbml4bmopO1xyXG4gICAgbmouY3Jvc3MobmksIG5qeG5pKTtcclxuXHJcbiAgICAvLyBnID0gbmkgKiBualxyXG4gICAgLy8gZ2RvdCA9IChuaiB4IG5pKSAqIHdpICsgKG5pIHggbmopICogd2pcclxuICAgIC8vIEcgPSBbMCBuanhuaSAwIG5peG5qXVxyXG4gICAgLy8gVyA9IFt2aSB3aSB2aiB3al1cclxuICAgIEdBLnJvdGF0aW9uYWwuY29weShuanhuaSk7XHJcbiAgICBHQi5yb3RhdGlvbmFsLmNvcHkobml4bmopO1xyXG5cclxuICAgIHZhciBnID0gTWF0aC5jb3ModGhpcy5tYXhBbmdsZSkgLSBuaS5kb3QobmopLFxyXG4gICAgICAgIEdXID0gdGhpcy5jb21wdXRlR1coKSxcclxuICAgICAgICBHaU1mID0gdGhpcy5jb21wdXRlR2lNZigpO1xyXG5cclxuICAgIHZhciBCID0gLSBnICogYSAtIEdXICogYiAtIGggKiBHaU1mO1xyXG5cclxuICAgIHJldHVybiBCO1xyXG59O1xyXG5cclxuXHJcbn0se1wiLi4vbWF0aC9NYXQzXCI6MjgsXCIuLi9tYXRoL1ZlYzNcIjozMSxcIi4vRXF1YXRpb25cIjoyMX1dLDI0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcclxubW9kdWxlLmV4cG9ydHMgPSBSb3RhdGlvbmFsTW90b3JFcXVhdGlvbjtcclxuXHJcbnZhciBWZWMzID0gX2RlcmVxXygnLi4vbWF0aC9WZWMzJyk7XHJcbnZhciBNYXQzID0gX2RlcmVxXygnLi4vbWF0aC9NYXQzJyk7XHJcbnZhciBFcXVhdGlvbiA9IF9kZXJlcV8oJy4vRXF1YXRpb24nKTtcclxuXHJcbi8qKlxyXG4gKiBSb3RhdGlvbmFsIG1vdG9yIGNvbnN0cmFpbnQuIFRyaWVzIHRvIGtlZXAgdGhlIHJlbGF0aXZlIGFuZ3VsYXIgdmVsb2NpdHkgb2YgdGhlIGJvZGllcyB0byBhIGdpdmVuIHZhbHVlLlxyXG4gKiBAY2xhc3MgUm90YXRpb25hbE1vdG9yRXF1YXRpb25cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBhdXRob3Igc2NodGVwcGVcclxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxyXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtYXhGb3JjZVxyXG4gKiBAZXh0ZW5kcyBFcXVhdGlvblxyXG4gKi9cclxuZnVuY3Rpb24gUm90YXRpb25hbE1vdG9yRXF1YXRpb24oYm9keUEsIGJvZHlCLCBtYXhGb3JjZSl7XHJcbiAgICBtYXhGb3JjZSA9IHR5cGVvZihtYXhGb3JjZSkhPT0ndW5kZWZpbmVkJyA/IG1heEZvcmNlIDogMWU2O1xyXG4gICAgRXF1YXRpb24uY2FsbCh0aGlzLGJvZHlBLGJvZHlCLC1tYXhGb3JjZSxtYXhGb3JjZSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXb3JsZCBvcmllbnRlZCByb3RhdGlvbmFsIGF4aXNcclxuICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gYXhpc0FcclxuICAgICAqL1xyXG4gICAgdGhpcy5heGlzQSA9IG5ldyBWZWMzKCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXb3JsZCBvcmllbnRlZCByb3RhdGlvbmFsIGF4aXNcclxuICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gYXhpc0JcclxuICAgICAqL1xyXG4gICAgdGhpcy5heGlzQiA9IG5ldyBWZWMzKCk7IC8vIFdvcmxkIG9yaWVudGVkIHJvdGF0aW9uYWwgYXhpc1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTW90b3IgdmVsb2NpdHlcclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSB0YXJnZXRWZWxvY2l0eVxyXG4gICAgICovXHJcbiAgICB0aGlzLnRhcmdldFZlbG9jaXR5ID0gMDtcclxufVxyXG5cclxuUm90YXRpb25hbE1vdG9yRXF1YXRpb24ucHJvdG90eXBlID0gbmV3IEVxdWF0aW9uKCk7XHJcblJvdGF0aW9uYWxNb3RvckVxdWF0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJvdGF0aW9uYWxNb3RvckVxdWF0aW9uO1xyXG5cclxuUm90YXRpb25hbE1vdG9yRXF1YXRpb24ucHJvdG90eXBlLmNvbXB1dGVCID0gZnVuY3Rpb24oaCl7XHJcbiAgICB2YXIgYSA9IHRoaXMuYSxcclxuICAgICAgICBiID0gdGhpcy5iLFxyXG4gICAgICAgIGJpID0gdGhpcy5iaSxcclxuICAgICAgICBiaiA9IHRoaXMuYmosXHJcblxyXG4gICAgICAgIGF4aXNBID0gdGhpcy5heGlzQSxcclxuICAgICAgICBheGlzQiA9IHRoaXMuYXhpc0IsXHJcblxyXG4gICAgICAgIEdBID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRBLFxyXG4gICAgICAgIEdCID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRCO1xyXG5cclxuICAgIC8vIGcgPSAwXHJcbiAgICAvLyBnZG90ID0gYXhpc0EgKiB3aSAtIGF4aXNCICogd2pcclxuICAgIC8vIGdkb3QgPSBHICogVyA9IEcgKiBbdmkgd2kgdmogd2pdXHJcbiAgICAvLyA9PlxyXG4gICAgLy8gRyA9IFswIGF4aXNBIDAgLWF4aXNCXVxyXG5cclxuICAgIEdBLnJvdGF0aW9uYWwuY29weShheGlzQSk7XHJcbiAgICBheGlzQi5uZWdhdGUoR0Iucm90YXRpb25hbCk7XHJcblxyXG4gICAgdmFyIEdXID0gdGhpcy5jb21wdXRlR1coKSAtIHRoaXMudGFyZ2V0VmVsb2NpdHksXHJcbiAgICAgICAgR2lNZiA9IHRoaXMuY29tcHV0ZUdpTWYoKTtcclxuXHJcbiAgICB2YXIgQiA9IC0gR1cgKiBiIC0gaCAqIEdpTWY7XHJcblxyXG4gICAgcmV0dXJuIEI7XHJcbn07XHJcblxyXG59LHtcIi4uL21hdGgvTWF0M1wiOjI4LFwiLi4vbWF0aC9WZWMzXCI6MzEsXCIuL0VxdWF0aW9uXCI6MjF9XSwyNTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XHJcbnZhciBVdGlscyA9IF9kZXJlcV8oJy4uL3V0aWxzL1V0aWxzJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENvbnRhY3RNYXRlcmlhbDtcclxuXHJcbi8qKlxyXG4gKiBEZWZpbmVzIHdoYXQgaGFwcGVucyB3aGVuIHR3byBtYXRlcmlhbHMgbWVldC5cclxuICogQGNsYXNzIENvbnRhY3RNYXRlcmlhbFxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtNYXRlcmlhbH0gbTFcclxuICogQHBhcmFtIHtNYXRlcmlhbH0gbTJcclxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZnJpY3Rpb249MC4zXVxyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVzdGl0dXRpb249MC4zXVxyXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuY29udGFjdEVxdWF0aW9uU3RpZmZuZXNzPTFlN11cclxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmNvbnRhY3RFcXVhdGlvblJlbGF4YXRpb249M11cclxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmZyaWN0aW9uRXF1YXRpb25TdGlmZm5lc3M9MWU3XVxyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZnJpY3Rpb25FcXVhdGlvblJlbGF4YXRpb249M11cclxuICovXHJcbmZ1bmN0aW9uIENvbnRhY3RNYXRlcmlhbChtMSwgbTIsIG9wdGlvbnMpe1xyXG4gICAgb3B0aW9ucyA9IFV0aWxzLmRlZmF1bHRzKG9wdGlvbnMsIHtcclxuICAgICAgICBmcmljdGlvbjogMC4zLFxyXG4gICAgICAgIHJlc3RpdHV0aW9uOiAwLjMsXHJcbiAgICAgICAgY29udGFjdEVxdWF0aW9uU3RpZmZuZXNzOiAxZTcsXHJcbiAgICAgICAgY29udGFjdEVxdWF0aW9uUmVsYXhhdGlvbjogMyxcclxuICAgICAgICBmcmljdGlvbkVxdWF0aW9uU3RpZmZuZXNzOiAxZTcsXHJcbiAgICAgICAgZnJpY3Rpb25FcXVhdGlvblJlbGF4YXRpb246IDNcclxuICAgIH0pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSWRlbnRpZmllciBvZiB0aGlzIG1hdGVyaWFsXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gaWRcclxuICAgICAqL1xyXG4gICAgdGhpcy5pZCA9IENvbnRhY3RNYXRlcmlhbC5pZENvdW50ZXIrKztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFBhcnRpY2lwYXRpbmcgbWF0ZXJpYWxzXHJcbiAgICAgKiBAcHJvcGVydHkge0FycmF5fSBtYXRlcmlhbHNcclxuICAgICAqIEB0b2RvICBTaG91bGQgYmUgLm1hdGVyaWFsQSBhbmQgLm1hdGVyaWFsQiBpbnN0ZWFkXHJcbiAgICAgKi9cclxuICAgIHRoaXMubWF0ZXJpYWxzID0gW20xLCBtMl07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGcmljdGlvbiBjb2VmZmljaWVudFxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGZyaWN0aW9uXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZnJpY3Rpb24gPSBvcHRpb25zLmZyaWN0aW9uO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVzdGl0dXRpb24gY29lZmZpY2llbnRcclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSByZXN0aXR1dGlvblxyXG4gICAgICovXHJcbiAgICB0aGlzLnJlc3RpdHV0aW9uID0gb3B0aW9ucy5yZXN0aXR1dGlvbjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFN0aWZmbmVzcyBvZiB0aGUgcHJvZHVjZWQgY29udGFjdCBlcXVhdGlvbnNcclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBjb250YWN0RXF1YXRpb25TdGlmZm5lc3NcclxuICAgICAqL1xyXG4gICAgdGhpcy5jb250YWN0RXF1YXRpb25TdGlmZm5lc3MgPSBvcHRpb25zLmNvbnRhY3RFcXVhdGlvblN0aWZmbmVzcztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbGF4YXRpb24gdGltZSBvZiB0aGUgcHJvZHVjZWQgY29udGFjdCBlcXVhdGlvbnNcclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBjb250YWN0RXF1YXRpb25SZWxheGF0aW9uXHJcbiAgICAgKi9cclxuICAgIHRoaXMuY29udGFjdEVxdWF0aW9uUmVsYXhhdGlvbiA9IG9wdGlvbnMuY29udGFjdEVxdWF0aW9uUmVsYXhhdGlvbjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFN0aWZmbmVzcyBvZiB0aGUgcHJvZHVjZWQgZnJpY3Rpb24gZXF1YXRpb25zXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gZnJpY3Rpb25FcXVhdGlvblN0aWZmbmVzc1xyXG4gICAgICovXHJcbiAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25TdGlmZm5lc3MgPSBvcHRpb25zLmZyaWN0aW9uRXF1YXRpb25TdGlmZm5lc3M7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWxheGF0aW9uIHRpbWUgb2YgdGhlIHByb2R1Y2VkIGZyaWN0aW9uIGVxdWF0aW9uc1xyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGZyaWN0aW9uRXF1YXRpb25SZWxheGF0aW9uXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvblJlbGF4YXRpb24gPSBvcHRpb25zLmZyaWN0aW9uRXF1YXRpb25SZWxheGF0aW9uO1xyXG59XHJcblxyXG5Db250YWN0TWF0ZXJpYWwuaWRDb3VudGVyID0gMDtcclxuXHJcbn0se1wiLi4vdXRpbHMvVXRpbHNcIjo1NH1dLDI2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcclxubW9kdWxlLmV4cG9ydHMgPSBNYXRlcmlhbDtcclxuXHJcbi8qKlxyXG4gKiBEZWZpbmVzIGEgcGh5c2ljcyBtYXRlcmlhbC5cclxuICogQGNsYXNzIE1hdGVyaWFsXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXHJcbiAqIEBhdXRob3Igc2NodGVwcGVcclxuICovXHJcbmZ1bmN0aW9uIE1hdGVyaWFsKG9wdGlvbnMpe1xyXG4gICAgdmFyIG5hbWUgPSAnJztcclxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuICAgIC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IGZpeFxyXG4gICAgaWYodHlwZW9mKG9wdGlvbnMpID09PSAnc3RyaW5nJyl7XHJcbiAgICAgICAgbmFtZSA9IG9wdGlvbnM7XHJcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xyXG4gICAgfSBlbHNlIGlmKHR5cGVvZihvcHRpb25zKSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICBuYW1lID0gJyc7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkgbmFtZVxyXG4gICAgICogQHR5cGUge1N0cmluZ31cclxuICAgICAqL1xyXG4gICAgdGhpcy5uYW1lID0gbmFtZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIG1hdGVyaWFsIGlkLlxyXG4gICAgICogQHByb3BlcnR5IGlkXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmlkID0gTWF0ZXJpYWwuaWRDb3VudGVyKys7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGcmljdGlvbiBmb3IgdGhpcyBtYXRlcmlhbC4gSWYgbm9uLW5lZ2F0aXZlLCBpdCB3aWxsIGJlIHVzZWQgaW5zdGVhZCBvZiB0aGUgZnJpY3Rpb24gZ2l2ZW4gYnkgQ29udGFjdE1hdGVyaWFscy4gSWYgdGhlcmUncyBubyBtYXRjaGluZyBDb250YWN0TWF0ZXJpYWwsIHRoZSB2YWx1ZSBmcm9tIC5kZWZhdWx0Q29udGFjdE1hdGVyaWFsIGluIHRoZSBXb3JsZCB3aWxsIGJlIHVzZWQuXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZnJpY3Rpb25cclxuICAgICAqL1xyXG4gICAgdGhpcy5mcmljdGlvbiA9IHR5cGVvZihvcHRpb25zLmZyaWN0aW9uKSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLmZyaWN0aW9uIDogLTE7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXN0aXR1dGlvbiBmb3IgdGhpcyBtYXRlcmlhbC4gSWYgbm9uLW5lZ2F0aXZlLCBpdCB3aWxsIGJlIHVzZWQgaW5zdGVhZCBvZiB0aGUgcmVzdGl0dXRpb24gZ2l2ZW4gYnkgQ29udGFjdE1hdGVyaWFscy4gSWYgdGhlcmUncyBubyBtYXRjaGluZyBDb250YWN0TWF0ZXJpYWwsIHRoZSB2YWx1ZSBmcm9tIC5kZWZhdWx0Q29udGFjdE1hdGVyaWFsIGluIHRoZSBXb3JsZCB3aWxsIGJlIHVzZWQuXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gcmVzdGl0dXRpb25cclxuICAgICAqL1xyXG4gICAgdGhpcy5yZXN0aXR1dGlvbiA9IHR5cGVvZihvcHRpb25zLnJlc3RpdHV0aW9uKSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLnJlc3RpdHV0aW9uIDogLTE7XHJcbn1cclxuXHJcbk1hdGVyaWFsLmlkQ291bnRlciA9IDA7XHJcblxyXG59LHt9XSwyNzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XHJcbm1vZHVsZS5leHBvcnRzID0gSmFjb2JpYW5FbGVtZW50O1xyXG5cclxudmFyIFZlYzMgPSBfZGVyZXFfKCcuL1ZlYzMnKTtcclxuXHJcbi8qKlxyXG4gKiBBbiBlbGVtZW50IGNvbnRhaW5pbmcgNiBlbnRyaWVzLCAzIHNwYXRpYWwgYW5kIDMgcm90YXRpb25hbCBkZWdyZWVzIG9mIGZyZWVkb20uXHJcbiAqIEBjbGFzcyBKYWNvYmlhbkVsZW1lbnRcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5mdW5jdGlvbiBKYWNvYmlhbkVsZW1lbnQoKXtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gc3BhdGlhbFxyXG4gICAgICovXHJcbiAgICB0aGlzLnNwYXRpYWwgPSBuZXcgVmVjMygpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IHtWZWMzfSByb3RhdGlvbmFsXHJcbiAgICAgKi9cclxuICAgIHRoaXMucm90YXRpb25hbCA9IG5ldyBWZWMzKCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBNdWx0aXBseSB3aXRoIG90aGVyIEphY29iaWFuRWxlbWVudFxyXG4gKiBAbWV0aG9kIG11bHRpcGx5RWxlbWVudFxyXG4gKiBAcGFyYW0gIHtKYWNvYmlhbkVsZW1lbnR9IGVsZW1lbnRcclxuICogQHJldHVybiB7TnVtYmVyfVxyXG4gKi9cclxuSmFjb2JpYW5FbGVtZW50LnByb3RvdHlwZS5tdWx0aXBseUVsZW1lbnQgPSBmdW5jdGlvbihlbGVtZW50KXtcclxuICAgIHJldHVybiBlbGVtZW50LnNwYXRpYWwuZG90KHRoaXMuc3BhdGlhbCkgKyBlbGVtZW50LnJvdGF0aW9uYWwuZG90KHRoaXMucm90YXRpb25hbCk7XHJcbn07XHJcblxyXG4vKipcclxuICogTXVsdGlwbHkgd2l0aCB0d28gdmVjdG9yc1xyXG4gKiBAbWV0aG9kIG11bHRpcGx5VmVjdG9yc1xyXG4gKiBAcGFyYW0gIHtWZWMzfSBzcGF0aWFsXHJcbiAqIEBwYXJhbSAge1ZlYzN9IHJvdGF0aW9uYWxcclxuICogQHJldHVybiB7TnVtYmVyfVxyXG4gKi9cclxuSmFjb2JpYW5FbGVtZW50LnByb3RvdHlwZS5tdWx0aXBseVZlY3RvcnMgPSBmdW5jdGlvbihzcGF0aWFsLHJvdGF0aW9uYWwpe1xyXG4gICAgcmV0dXJuIHNwYXRpYWwuZG90KHRoaXMuc3BhdGlhbCkgKyByb3RhdGlvbmFsLmRvdCh0aGlzLnJvdGF0aW9uYWwpO1xyXG59O1xyXG5cclxufSx7XCIuL1ZlYzNcIjozMX1dLDI4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcclxubW9kdWxlLmV4cG9ydHMgPSBNYXQzO1xyXG5cclxudmFyIFZlYzMgPSBfZGVyZXFfKCcuL1ZlYzMnKTtcclxuXHJcbi8qKlxyXG4gKiBBIDN4MyBtYXRyaXguXHJcbiAqIEBjbGFzcyBNYXQzXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0gYXJyYXkgZWxlbWVudHMgQXJyYXkgb2YgbmluZSBlbGVtZW50cy4gT3B0aW9uYWwuXHJcbiAqIEBhdXRob3Igc2NodGVwcGUgLyBodHRwOi8vZ2l0aHViLmNvbS9zY2h0ZXBwZVxyXG4gKi9cclxuZnVuY3Rpb24gTWF0MyhlbGVtZW50cyl7XHJcbiAgICAvKipcclxuICAgICAqIEEgdmVjdG9yIG9mIGxlbmd0aCA5LCBjb250YWluaW5nIGFsbCBtYXRyaXggZWxlbWVudHNcclxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IGVsZW1lbnRzXHJcbiAgICAgKi9cclxuICAgIGlmKGVsZW1lbnRzKXtcclxuICAgICAgICB0aGlzLmVsZW1lbnRzID0gZWxlbWVudHM7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuZWxlbWVudHMgPSBbMCwwLDAsMCwwLDAsMCwwLDBdO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogU2V0cyB0aGUgbWF0cml4IHRvIGlkZW50aXR5XHJcbiAqIEBtZXRob2QgaWRlbnRpdHlcclxuICogQHRvZG8gU2hvdWxkIHBlcmhhcHMgYmUgcmVuYW1lZCB0byBzZXRJZGVudGl0eSgpIHRvIGJlIG1vcmUgY2xlYXIuXHJcbiAqIEB0b2RvIENyZWF0ZSBhbm90aGVyIGZ1bmN0aW9uIHRoYXQgaW1tZWRpYXRlbHkgY3JlYXRlcyBhbiBpZGVudGl0eSBtYXRyaXggZWcuIGV5ZSgpXHJcbiAqL1xyXG5NYXQzLnByb3RvdHlwZS5pZGVudGl0eSA9IGZ1bmN0aW9uKCl7XHJcbiAgICB2YXIgZSA9IHRoaXMuZWxlbWVudHM7XHJcbiAgICBlWzBdID0gMTtcclxuICAgIGVbMV0gPSAwO1xyXG4gICAgZVsyXSA9IDA7XHJcblxyXG4gICAgZVszXSA9IDA7XHJcbiAgICBlWzRdID0gMTtcclxuICAgIGVbNV0gPSAwO1xyXG5cclxuICAgIGVbNl0gPSAwO1xyXG4gICAgZVs3XSA9IDA7XHJcbiAgICBlWzhdID0gMTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTZXQgYWxsIGVsZW1lbnRzIHRvIHplcm9cclxuICogQG1ldGhvZCBzZXRaZXJvXHJcbiAqL1xyXG5NYXQzLnByb3RvdHlwZS5zZXRaZXJvID0gZnVuY3Rpb24oKXtcclxuICAgIHZhciBlID0gdGhpcy5lbGVtZW50cztcclxuICAgIGVbMF0gPSAwO1xyXG4gICAgZVsxXSA9IDA7XHJcbiAgICBlWzJdID0gMDtcclxuICAgIGVbM10gPSAwO1xyXG4gICAgZVs0XSA9IDA7XHJcbiAgICBlWzVdID0gMDtcclxuICAgIGVbNl0gPSAwO1xyXG4gICAgZVs3XSA9IDA7XHJcbiAgICBlWzhdID0gMDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTZXRzIHRoZSBtYXRyaXggZGlhZ29uYWwgZWxlbWVudHMgZnJvbSBhIFZlYzNcclxuICogQG1ldGhvZCBzZXRUcmFjZVxyXG4gKiBAcGFyYW0ge1ZlYzN9IHZlYzNcclxuICovXHJcbk1hdDMucHJvdG90eXBlLnNldFRyYWNlID0gZnVuY3Rpb24odmVjMyl7XHJcbiAgICB2YXIgZSA9IHRoaXMuZWxlbWVudHM7XHJcbiAgICBlWzBdID0gdmVjMy54O1xyXG4gICAgZVs0XSA9IHZlYzMueTtcclxuICAgIGVbOF0gPSB2ZWMzLno7XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0cyB0aGUgbWF0cml4IGRpYWdvbmFsIGVsZW1lbnRzXHJcbiAqIEBtZXRob2QgZ2V0VHJhY2VcclxuICogQHJldHVybiB7VmVjM31cclxuICovXHJcbk1hdDMucHJvdG90eXBlLmdldFRyYWNlID0gZnVuY3Rpb24odGFyZ2V0KXtcclxuICAgIHZhciB0YXJnZXQgPSB0YXJnZXQgfHwgbmV3IFZlYzMoKTtcclxuICAgIHZhciBlID0gdGhpcy5lbGVtZW50cztcclxuICAgIHRhcmdldC54ID0gZVswXTtcclxuICAgIHRhcmdldC55ID0gZVs0XTtcclxuICAgIHRhcmdldC56ID0gZVs4XTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBNYXRyaXgtVmVjdG9yIG11bHRpcGxpY2F0aW9uXHJcbiAqIEBtZXRob2Qgdm11bHRcclxuICogQHBhcmFtIHtWZWMzfSB2IFRoZSB2ZWN0b3IgdG8gbXVsdGlwbHkgd2l0aFxyXG4gKiBAcGFyYW0ge1ZlYzN9IHRhcmdldCBPcHRpb25hbCwgdGFyZ2V0IHRvIHNhdmUgdGhlIHJlc3VsdCBpbi5cclxuICovXHJcbk1hdDMucHJvdG90eXBlLnZtdWx0ID0gZnVuY3Rpb24odix0YXJnZXQpe1xyXG4gICAgdGFyZ2V0ID0gdGFyZ2V0IHx8IG5ldyBWZWMzKCk7XHJcblxyXG4gICAgdmFyIGUgPSB0aGlzLmVsZW1lbnRzLFxyXG4gICAgICAgIHggPSB2LngsXHJcbiAgICAgICAgeSA9IHYueSxcclxuICAgICAgICB6ID0gdi56O1xyXG4gICAgdGFyZ2V0LnggPSBlWzBdKnggKyBlWzFdKnkgKyBlWzJdKno7XHJcbiAgICB0YXJnZXQueSA9IGVbM10qeCArIGVbNF0qeSArIGVbNV0qejtcclxuICAgIHRhcmdldC56ID0gZVs2XSp4ICsgZVs3XSp5ICsgZVs4XSp6O1xyXG5cclxuICAgIHJldHVybiB0YXJnZXQ7XHJcbn07XHJcblxyXG4vKipcclxuICogTWF0cml4LXNjYWxhciBtdWx0aXBsaWNhdGlvblxyXG4gKiBAbWV0aG9kIHNtdWx0XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzXHJcbiAqL1xyXG5NYXQzLnByb3RvdHlwZS5zbXVsdCA9IGZ1bmN0aW9uKHMpe1xyXG4gICAgZm9yKHZhciBpPTA7IGk8dGhpcy5lbGVtZW50cy5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgdGhpcy5lbGVtZW50c1tpXSAqPSBzO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIE1hdHJpeCBtdWx0aXBsaWNhdGlvblxyXG4gKiBAbWV0aG9kIG1tdWx0XHJcbiAqIEBwYXJhbSB7TWF0M30gbSBNYXRyaXggdG8gbXVsdGlwbHkgd2l0aCBmcm9tIGxlZnQgc2lkZS5cclxuICogQHJldHVybiB7TWF0M30gVGhlIHJlc3VsdC5cclxuICovXHJcbk1hdDMucHJvdG90eXBlLm1tdWx0ID0gZnVuY3Rpb24obSx0YXJnZXQpe1xyXG4gICAgdmFyIHIgPSB0YXJnZXQgfHwgbmV3IE1hdDMoKTtcclxuICAgIGZvcih2YXIgaT0wOyBpPDM7IGkrKyl7XHJcbiAgICAgICAgZm9yKHZhciBqPTA7IGo8MzsgaisrKXtcclxuICAgICAgICAgICAgdmFyIHN1bSA9IDAuMDtcclxuICAgICAgICAgICAgZm9yKHZhciBrPTA7IGs8MzsgaysrKXtcclxuICAgICAgICAgICAgICAgIHN1bSArPSBtLmVsZW1lbnRzW2krayozXSAqIHRoaXMuZWxlbWVudHNbaytqKjNdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHIuZWxlbWVudHNbaStqKjNdID0gc3VtO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFNjYWxlIGVhY2ggY29sdW1uIG9mIHRoZSBtYXRyaXhcclxuICogQG1ldGhvZCBzY2FsZVxyXG4gKiBAcGFyYW0ge1ZlYzN9IHZcclxuICogQHJldHVybiB7TWF0M30gVGhlIHJlc3VsdC5cclxuICovXHJcbk1hdDMucHJvdG90eXBlLnNjYWxlID0gZnVuY3Rpb24odix0YXJnZXQpe1xyXG4gICAgdGFyZ2V0ID0gdGFyZ2V0IHx8IG5ldyBNYXQzKCk7XHJcbiAgICB2YXIgZSA9IHRoaXMuZWxlbWVudHMsXHJcbiAgICAgICAgdCA9IHRhcmdldC5lbGVtZW50cztcclxuICAgIGZvcih2YXIgaT0wOyBpIT09MzsgaSsrKXtcclxuICAgICAgICB0WzMqaSArIDBdID0gdi54ICogZVszKmkgKyAwXTtcclxuICAgICAgICB0WzMqaSArIDFdID0gdi55ICogZVszKmkgKyAxXTtcclxuICAgICAgICB0WzMqaSArIDJdID0gdi56ICogZVszKmkgKyAyXTtcclxuICAgIH1cclxuICAgIHJldHVybiB0YXJnZXQ7XHJcbn07XHJcblxyXG4vKipcclxuICogU29sdmUgQXg9YlxyXG4gKiBAbWV0aG9kIHNvbHZlXHJcbiAqIEBwYXJhbSB7VmVjM30gYiBUaGUgcmlnaHQgaGFuZCBzaWRlXHJcbiAqIEBwYXJhbSB7VmVjM30gdGFyZ2V0IE9wdGlvbmFsLiBUYXJnZXQgdmVjdG9yIHRvIHNhdmUgaW4uXHJcbiAqIEByZXR1cm4ge1ZlYzN9IFRoZSBzb2x1dGlvbiB4XHJcbiAqIEB0b2RvIHNob3VsZCByZXVzZSBhcnJheXNcclxuICovXHJcbk1hdDMucHJvdG90eXBlLnNvbHZlID0gZnVuY3Rpb24oYix0YXJnZXQpe1xyXG4gICAgdGFyZ2V0ID0gdGFyZ2V0IHx8IG5ldyBWZWMzKCk7XHJcblxyXG4gICAgLy8gQ29uc3RydWN0IGVxdWF0aW9uc1xyXG4gICAgdmFyIG5yID0gMzsgLy8gbnVtIHJvd3NcclxuICAgIHZhciBuYyA9IDQ7IC8vIG51bSBjb2xzXHJcbiAgICB2YXIgZXFucyA9IFtdO1xyXG4gICAgZm9yKHZhciBpPTA7IGk8bnIqbmM7IGkrKyl7XHJcbiAgICAgICAgZXFucy5wdXNoKDApO1xyXG4gICAgfVxyXG4gICAgdmFyIGksajtcclxuICAgIGZvcihpPTA7IGk8MzsgaSsrKXtcclxuICAgICAgICBmb3Ioaj0wOyBqPDM7IGorKyl7XHJcbiAgICAgICAgICAgIGVxbnNbaStuYypqXSA9IHRoaXMuZWxlbWVudHNbaSszKmpdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVxbnNbMys0KjBdID0gYi54O1xyXG4gICAgZXFuc1szKzQqMV0gPSBiLnk7XHJcbiAgICBlcW5zWzMrNCoyXSA9IGIuejtcclxuXHJcbiAgICAvLyBDb21wdXRlIHJpZ2h0IHVwcGVyIHRyaWFuZ3VsYXIgdmVyc2lvbiBvZiB0aGUgbWF0cml4IC0gR2F1c3MgZWxpbWluYXRpb25cclxuICAgIHZhciBuID0gMywgayA9IG4sIG5wO1xyXG4gICAgdmFyIGtwID0gNDsgLy8gbnVtIHJvd3NcclxuICAgIHZhciBwLCBlbHM7XHJcbiAgICBkbyB7XHJcbiAgICAgICAgaSA9IGsgLSBuO1xyXG4gICAgICAgIGlmIChlcW5zW2krbmMqaV0gPT09IDApIHtcclxuICAgICAgICAgICAgLy8gdGhlIHBpdm90IGlzIG51bGwsIHN3YXAgbGluZXNcclxuICAgICAgICAgICAgZm9yIChqID0gaSArIDE7IGogPCBrOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChlcW5zW2krbmMqal0gIT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBucCA9IGtwO1xyXG4gICAgICAgICAgICAgICAgICAgIGRvIHsgIC8vIGRvIGxpZ25lKCBpICkgPSBsaWduZSggaSApICsgbGlnbmUoIGsgKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwID0ga3AgLSBucDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXFuc1twK25jKmldICs9IGVxbnNbcCtuYypqXTtcclxuICAgICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW5wKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZXFuc1tpK25jKmldICE9PSAwKSB7XHJcbiAgICAgICAgICAgIGZvciAoaiA9IGkgKyAxOyBqIDwgazsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbXVsdGlwbGllciA9IGVxbnNbaStuYypqXSAvIGVxbnNbaStuYyppXTtcclxuICAgICAgICAgICAgICAgIG5wID0ga3A7XHJcbiAgICAgICAgICAgICAgICBkbyB7ICAvLyBkbyBsaWduZSggayApID0gbGlnbmUoIGsgKSAtIG11bHRpcGxpZXIgKiBsaWduZSggaSApXHJcbiAgICAgICAgICAgICAgICAgICAgcCA9IGtwIC0gbnA7XHJcbiAgICAgICAgICAgICAgICAgICAgZXFuc1twK25jKmpdID0gcCA8PSBpID8gMCA6IGVxbnNbcCtuYypqXSAtIGVxbnNbcCtuYyppXSAqIG11bHRpcGxpZXIgO1xyXG4gICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1ucCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9IHdoaWxlICgtLW4pO1xyXG5cclxuICAgIC8vIEdldCB0aGUgc29sdXRpb25cclxuICAgIHRhcmdldC56ID0gZXFuc1syKm5jKzNdIC8gZXFuc1syKm5jKzJdO1xyXG4gICAgdGFyZ2V0LnkgPSAoZXFuc1sxKm5jKzNdIC0gZXFuc1sxKm5jKzJdKnRhcmdldC56KSAvIGVxbnNbMSpuYysxXTtcclxuICAgIHRhcmdldC54ID0gKGVxbnNbMCpuYyszXSAtIGVxbnNbMCpuYysyXSp0YXJnZXQueiAtIGVxbnNbMCpuYysxXSp0YXJnZXQueSkgLyBlcW5zWzAqbmMrMF07XHJcblxyXG4gICAgaWYoaXNOYU4odGFyZ2V0LngpIHx8IGlzTmFOKHRhcmdldC55KSB8fCBpc05hTih0YXJnZXQueikgfHwgdGFyZ2V0Lng9PT1JbmZpbml0eSB8fCB0YXJnZXQueT09PUluZmluaXR5IHx8IHRhcmdldC56PT09SW5maW5pdHkpe1xyXG4gICAgICAgIHRocm93IFwiQ291bGQgbm90IHNvbHZlIGVxdWF0aW9uISBHb3QgeD1bXCIrdGFyZ2V0LnRvU3RyaW5nKCkrXCJdLCBiPVtcIitiLnRvU3RyaW5nKCkrXCJdLCBBPVtcIit0aGlzLnRvU3RyaW5nKCkrXCJdXCI7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRhcmdldDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXQgYW4gZWxlbWVudCBpbiB0aGUgbWF0cml4IGJ5IGluZGV4LiBJbmRleCBzdGFydHMgYXQgMCwgbm90IDEhISFcclxuICogQG1ldGhvZCBlXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByb3dcclxuICogQHBhcmFtIHtOdW1iZXJ9IGNvbHVtblxyXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgT3B0aW9uYWwuIElmIHByb3ZpZGVkLCB0aGUgbWF0cml4IGVsZW1lbnQgd2lsbCBiZSBzZXQgdG8gdGhpcyB2YWx1ZS5cclxuICogQHJldHVybiB7TnVtYmVyfVxyXG4gKi9cclxuTWF0My5wcm90b3R5cGUuZSA9IGZ1bmN0aW9uKCByb3cgLCBjb2x1bW4gLHZhbHVlKXtcclxuICAgIGlmKHZhbHVlPT09dW5kZWZpbmVkKXtcclxuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50c1tjb2x1bW4rMypyb3ddO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBTZXQgdmFsdWVcclxuICAgICAgICB0aGlzLmVsZW1lbnRzW2NvbHVtbiszKnJvd10gPSB2YWx1ZTtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb3B5IGFub3RoZXIgbWF0cml4IGludG8gdGhpcyBtYXRyaXggb2JqZWN0LlxyXG4gKiBAbWV0aG9kIGNvcHlcclxuICogQHBhcmFtIHtNYXQzfSBzb3VyY2VcclxuICogQHJldHVybiB7TWF0M30gdGhpc1xyXG4gKi9cclxuTWF0My5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKHNvdXJjZSl7XHJcbiAgICBmb3IodmFyIGk9MDsgaSA8IHNvdXJjZS5lbGVtZW50cy5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgdGhpcy5lbGVtZW50c1tpXSA9IHNvdXJjZS5lbGVtZW50c1tpXTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hdHJpeC5cclxuICogQG1ldGhvZCB0b1N0cmluZ1xyXG4gKiBAcmV0dXJuIHN0cmluZ1xyXG4gKi9cclxuTWF0My5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpe1xyXG4gICAgdmFyIHIgPSBcIlwiO1xyXG4gICAgdmFyIHNlcCA9IFwiLFwiO1xyXG4gICAgZm9yKHZhciBpPTA7IGk8OTsgaSsrKXtcclxuICAgICAgICByICs9IHRoaXMuZWxlbWVudHNbaV0gKyBzZXA7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcjtcclxufTtcclxuXHJcbi8qKlxyXG4gKiByZXZlcnNlIHRoZSBtYXRyaXhcclxuICogQG1ldGhvZCByZXZlcnNlXHJcbiAqIEBwYXJhbSB7TWF0M30gdGFyZ2V0IE9wdGlvbmFsLiBUYXJnZXQgbWF0cml4IHRvIHNhdmUgaW4uXHJcbiAqIEByZXR1cm4ge01hdDN9IFRoZSBzb2x1dGlvbiB4XHJcbiAqL1xyXG5NYXQzLnByb3RvdHlwZS5yZXZlcnNlID0gZnVuY3Rpb24odGFyZ2V0KXtcclxuXHJcbiAgICB0YXJnZXQgPSB0YXJnZXQgfHwgbmV3IE1hdDMoKTtcclxuXHJcbiAgICAvLyBDb25zdHJ1Y3QgZXF1YXRpb25zXHJcbiAgICB2YXIgbnIgPSAzOyAvLyBudW0gcm93c1xyXG4gICAgdmFyIG5jID0gNjsgLy8gbnVtIGNvbHNcclxuICAgIHZhciBlcW5zID0gW107XHJcbiAgICBmb3IodmFyIGk9MDsgaTxucipuYzsgaSsrKXtcclxuICAgICAgICBlcW5zLnB1c2goMCk7XHJcbiAgICB9XHJcbiAgICB2YXIgaSxqO1xyXG4gICAgZm9yKGk9MDsgaTwzOyBpKyspe1xyXG4gICAgICAgIGZvcihqPTA7IGo8MzsgaisrKXtcclxuICAgICAgICAgICAgZXFuc1tpK25jKmpdID0gdGhpcy5lbGVtZW50c1tpKzMqal07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZXFuc1szKzYqMF0gPSAxO1xyXG4gICAgZXFuc1szKzYqMV0gPSAwO1xyXG4gICAgZXFuc1szKzYqMl0gPSAwO1xyXG4gICAgZXFuc1s0KzYqMF0gPSAwO1xyXG4gICAgZXFuc1s0KzYqMV0gPSAxO1xyXG4gICAgZXFuc1s0KzYqMl0gPSAwO1xyXG4gICAgZXFuc1s1KzYqMF0gPSAwO1xyXG4gICAgZXFuc1s1KzYqMV0gPSAwO1xyXG4gICAgZXFuc1s1KzYqMl0gPSAxO1xyXG5cclxuICAgIC8vIENvbXB1dGUgcmlnaHQgdXBwZXIgdHJpYW5ndWxhciB2ZXJzaW9uIG9mIHRoZSBtYXRyaXggLSBHYXVzcyBlbGltaW5hdGlvblxyXG4gICAgdmFyIG4gPSAzLCBrID0gbiwgbnA7XHJcbiAgICB2YXIga3AgPSBuYzsgLy8gbnVtIHJvd3NcclxuICAgIHZhciBwO1xyXG4gICAgZG8ge1xyXG4gICAgICAgIGkgPSBrIC0gbjtcclxuICAgICAgICBpZiAoZXFuc1tpK25jKmldID09PSAwKSB7XHJcbiAgICAgICAgICAgIC8vIHRoZSBwaXZvdCBpcyBudWxsLCBzd2FwIGxpbmVzXHJcbiAgICAgICAgICAgIGZvciAoaiA9IGkgKyAxOyBqIDwgazsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXFuc1tpK25jKmpdICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbnAgPSBrcDtcclxuICAgICAgICAgICAgICAgICAgICBkbyB7IC8vIGRvIGxpbmUoIGkgKSA9IGxpbmUoIGkgKSArIGxpbmUoIGsgKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwID0ga3AgLSBucDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXFuc1twK25jKmldICs9IGVxbnNbcCtuYypqXTtcclxuICAgICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW5wKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZXFuc1tpK25jKmldICE9PSAwKSB7XHJcbiAgICAgICAgICAgIGZvciAoaiA9IGkgKyAxOyBqIDwgazsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbXVsdGlwbGllciA9IGVxbnNbaStuYypqXSAvIGVxbnNbaStuYyppXTtcclxuICAgICAgICAgICAgICAgIG5wID0ga3A7XHJcbiAgICAgICAgICAgICAgICBkbyB7IC8vIGRvIGxpbmUoIGsgKSA9IGxpbmUoIGsgKSAtIG11bHRpcGxpZXIgKiBsaW5lKCBpIClcclxuICAgICAgICAgICAgICAgICAgICBwID0ga3AgLSBucDtcclxuICAgICAgICAgICAgICAgICAgICBlcW5zW3ArbmMqal0gPSBwIDw9IGkgPyAwIDogZXFuc1twK25jKmpdIC0gZXFuc1twK25jKmldICogbXVsdGlwbGllciA7XHJcbiAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW5wKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0gd2hpbGUgKC0tbik7XHJcblxyXG4gICAgLy8gZWxpbWluYXRlIHRoZSB1cHBlciBsZWZ0IHRyaWFuZ2xlIG9mIHRoZSBtYXRyaXhcclxuICAgIGkgPSAyO1xyXG4gICAgZG8ge1xyXG4gICAgICAgIGogPSBpLTE7XHJcbiAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICB2YXIgbXVsdGlwbGllciA9IGVxbnNbaStuYypqXSAvIGVxbnNbaStuYyppXTtcclxuICAgICAgICAgICAgbnAgPSBuYztcclxuICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgcCA9IG5jIC0gbnA7XHJcbiAgICAgICAgICAgICAgICBlcW5zW3ArbmMqal0gPSAgZXFuc1twK25jKmpdIC0gZXFuc1twK25jKmldICogbXVsdGlwbGllciA7XHJcbiAgICAgICAgICAgIH0gd2hpbGUgKC0tbnApO1xyXG4gICAgICAgIH0gd2hpbGUgKGotLSk7XHJcbiAgICB9IHdoaWxlICgtLWkpO1xyXG5cclxuICAgIC8vIG9wZXJhdGlvbnMgb24gdGhlIGRpYWdvbmFsXHJcbiAgICBpID0gMjtcclxuICAgIGRvIHtcclxuICAgICAgICB2YXIgbXVsdGlwbGllciA9IDEgLyBlcW5zW2krbmMqaV07XHJcbiAgICAgICAgbnAgPSBuYztcclxuICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgIHAgPSBuYyAtIG5wO1xyXG4gICAgICAgICAgICBlcW5zW3ArbmMqaV0gPSBlcW5zW3ArbmMqaV0gKiBtdWx0aXBsaWVyIDtcclxuICAgICAgICB9IHdoaWxlICgtLW5wKTtcclxuICAgIH0gd2hpbGUgKGktLSk7XHJcblxyXG4gICAgaSA9IDI7XHJcbiAgICBkbyB7XHJcbiAgICAgICAgaiA9IDI7XHJcbiAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICBwID0gZXFuc1tucitqK25jKmldO1xyXG4gICAgICAgICAgICBpZiggaXNOYU4oIHAgKSB8fCBwID09PUluZmluaXR5ICl7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBcIkNvdWxkIG5vdCByZXZlcnNlISBBPVtcIit0aGlzLnRvU3RyaW5nKCkrXCJdXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGFyZ2V0LmUoIGkgLCBqICwgcCApO1xyXG4gICAgICAgIH0gd2hpbGUgKGotLSk7XHJcbiAgICB9IHdoaWxlIChpLS0pO1xyXG5cclxuICAgIHJldHVybiB0YXJnZXQ7XHJcbn07XHJcblxyXG4vKipcclxuICogU2V0IHRoZSBtYXRyaXggZnJvbSBhIHF1YXRlcmlvblxyXG4gKiBAbWV0aG9kIHNldFJvdGF0aW9uRnJvbVF1YXRlcm5pb25cclxuICogQHBhcmFtIHtRdWF0ZXJuaW9ufSBxXHJcbiAqL1xyXG5NYXQzLnByb3RvdHlwZS5zZXRSb3RhdGlvbkZyb21RdWF0ZXJuaW9uID0gZnVuY3Rpb24oIHEgKSB7XHJcbiAgICB2YXIgeCA9IHEueCwgeSA9IHEueSwgeiA9IHEueiwgdyA9IHEudyxcclxuICAgICAgICB4MiA9IHggKyB4LCB5MiA9IHkgKyB5LCB6MiA9IHogKyB6LFxyXG4gICAgICAgIHh4ID0geCAqIHgyLCB4eSA9IHggKiB5MiwgeHogPSB4ICogejIsXHJcbiAgICAgICAgeXkgPSB5ICogeTIsIHl6ID0geSAqIHoyLCB6eiA9IHogKiB6MixcclxuICAgICAgICB3eCA9IHcgKiB4Miwgd3kgPSB3ICogeTIsIHd6ID0gdyAqIHoyLFxyXG4gICAgICAgIGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuICAgIGVbMyowICsgMF0gPSAxIC0gKCB5eSArIHp6ICk7XHJcbiAgICBlWzMqMCArIDFdID0geHkgLSB3ejtcclxuICAgIGVbMyowICsgMl0gPSB4eiArIHd5O1xyXG5cclxuICAgIGVbMyoxICsgMF0gPSB4eSArIHd6O1xyXG4gICAgZVszKjEgKyAxXSA9IDEgLSAoIHh4ICsgenogKTtcclxuICAgIGVbMyoxICsgMl0gPSB5eiAtIHd4O1xyXG5cclxuICAgIGVbMyoyICsgMF0gPSB4eiAtIHd5O1xyXG4gICAgZVszKjIgKyAxXSA9IHl6ICsgd3g7XHJcbiAgICBlWzMqMiArIDJdID0gMSAtICggeHggKyB5eSApO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRyYW5zcG9zZSB0aGUgbWF0cml4XHJcbiAqIEBtZXRob2QgdHJhbnNwb3NlXHJcbiAqIEBwYXJhbSAge01hdDN9IHRhcmdldCBXaGVyZSB0byBzdG9yZSB0aGUgcmVzdWx0LlxyXG4gKiBAcmV0dXJuIHtNYXQzfSBUaGUgdGFyZ2V0IE1hdDMsIG9yIGEgbmV3IE1hdDMgaWYgdGFyZ2V0IHdhcyBvbWl0dGVkLlxyXG4gKi9cclxuTWF0My5wcm90b3R5cGUudHJhbnNwb3NlID0gZnVuY3Rpb24oIHRhcmdldCApIHtcclxuICAgIHRhcmdldCA9IHRhcmdldCB8fCBuZXcgTWF0MygpO1xyXG5cclxuICAgIHZhciBNdCA9IHRhcmdldC5lbGVtZW50cyxcclxuICAgICAgICBNID0gdGhpcy5lbGVtZW50cztcclxuXHJcbiAgICBmb3IodmFyIGk9MDsgaSE9PTM7IGkrKyl7XHJcbiAgICAgICAgZm9yKHZhciBqPTA7IGohPT0zOyBqKyspe1xyXG4gICAgICAgICAgICBNdFszKmkgKyBqXSA9IE1bMypqICsgaV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0YXJnZXQ7XHJcbn07XHJcblxyXG59LHtcIi4vVmVjM1wiOjMxfV0sMjk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xyXG5tb2R1bGUuZXhwb3J0cyA9IFF1YXRlcm5pb247XHJcblxyXG52YXIgVmVjMyA9IF9kZXJlcV8oJy4vVmVjMycpO1xyXG5cclxuLyoqXHJcbiAqIEEgUXVhdGVybmlvbiBkZXNjcmliZXMgYSByb3RhdGlvbiBpbiAzRCBzcGFjZS4gVGhlIFF1YXRlcm5pb24gaXMgbWF0aGVtYXRpY2FsbHkgZGVmaW5lZCBhcyBRID0geCppICsgeSpqICsgeiprICsgdywgd2hlcmUgKGksaixrKSBhcmUgaW1hZ2luYXJ5IGJhc2lzIHZlY3RvcnMuICh4LHkseikgY2FuIGJlIHNlZW4gYXMgYSB2ZWN0b3IgcmVsYXRlZCB0byB0aGUgYXhpcyBvZiByb3RhdGlvbiwgd2hpbGUgdGhlIHJlYWwgbXVsdGlwbGllciwgdywgaXMgcmVsYXRlZCB0byB0aGUgYW1vdW50IG9mIHJvdGF0aW9uLlxyXG4gKiBAY2xhc3MgUXVhdGVybmlvblxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtOdW1iZXJ9IHggTXVsdGlwbGllciBvZiB0aGUgaW1hZ2luYXJ5IGJhc2lzIHZlY3RvciBpLlxyXG4gKiBAcGFyYW0ge051bWJlcn0geSBNdWx0aXBsaWVyIG9mIHRoZSBpbWFnaW5hcnkgYmFzaXMgdmVjdG9yIGouXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IE11bHRpcGxpZXIgb2YgdGhlIGltYWdpbmFyeSBiYXNpcyB2ZWN0b3Igay5cclxuICogQHBhcmFtIHtOdW1iZXJ9IHcgTXVsdGlwbGllciBvZiB0aGUgcmVhbCBwYXJ0LlxyXG4gKiBAc2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUXVhdGVybmlvblxyXG4gKi9cclxuZnVuY3Rpb24gUXVhdGVybmlvbih4LHkseix3KXtcclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHhcclxuICAgICAqL1xyXG4gICAgdGhpcy54ID0geCE9PXVuZGVmaW5lZCA/IHggOiAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHlcclxuICAgICAqL1xyXG4gICAgdGhpcy55ID0geSE9PXVuZGVmaW5lZCA/IHkgOiAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHpcclxuICAgICAqL1xyXG4gICAgdGhpcy56ID0geiE9PXVuZGVmaW5lZCA/IHogOiAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG11bHRpcGxpZXIgb2YgdGhlIHJlYWwgcXVhdGVybmlvbiBiYXNpcyB2ZWN0b3IuXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gd1xyXG4gICAgICovXHJcbiAgICB0aGlzLncgPSB3IT09dW5kZWZpbmVkID8gdyA6IDE7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTZXQgdGhlIHZhbHVlIG9mIHRoZSBxdWF0ZXJuaW9uLlxyXG4gKiBAbWV0aG9kIHNldFxyXG4gKiBAcGFyYW0ge051bWJlcn0geFxyXG4gKiBAcGFyYW0ge051bWJlcn0geVxyXG4gKiBAcGFyYW0ge051bWJlcn0gelxyXG4gKiBAcGFyYW0ge051bWJlcn0gd1xyXG4gKi9cclxuUXVhdGVybmlvbi5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oeCx5LHosdyl7XHJcbiAgICB0aGlzLnggPSB4O1xyXG4gICAgdGhpcy55ID0geTtcclxuICAgIHRoaXMueiA9IHo7XHJcbiAgICB0aGlzLncgPSB3O1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogQ29udmVydCB0byBhIHJlYWRhYmxlIGZvcm1hdFxyXG4gKiBAbWV0aG9kIHRvU3RyaW5nXHJcbiAqIEByZXR1cm4gc3RyaW5nXHJcbiAqL1xyXG5RdWF0ZXJuaW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCl7XHJcbiAgICByZXR1cm4gdGhpcy54K1wiLFwiK3RoaXMueStcIixcIit0aGlzLnorXCIsXCIrdGhpcy53O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnQgdG8gYW4gQXJyYXlcclxuICogQG1ldGhvZCB0b0FycmF5XHJcbiAqIEByZXR1cm4gQXJyYXlcclxuICovXHJcblF1YXRlcm5pb24ucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbigpe1xyXG4gICAgcmV0dXJuIFt0aGlzLngsIHRoaXMueSwgdGhpcy56LCB0aGlzLnddO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFNldCB0aGUgcXVhdGVybmlvbiBjb21wb25lbnRzIGdpdmVuIGFuIGF4aXMgYW5kIGFuIGFuZ2xlLlxyXG4gKiBAbWV0aG9kIHNldEZyb21BeGlzQW5nbGVcclxuICogQHBhcmFtIHtWZWMzfSBheGlzXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBhbmdsZSBpbiByYWRpYW5zXHJcbiAqL1xyXG5RdWF0ZXJuaW9uLnByb3RvdHlwZS5zZXRGcm9tQXhpc0FuZ2xlID0gZnVuY3Rpb24oYXhpcyxhbmdsZSl7XHJcbiAgICB2YXIgcyA9IE1hdGguc2luKGFuZ2xlKjAuNSk7XHJcbiAgICB0aGlzLnggPSBheGlzLnggKiBzO1xyXG4gICAgdGhpcy55ID0gYXhpcy55ICogcztcclxuICAgIHRoaXMueiA9IGF4aXMueiAqIHM7XHJcbiAgICB0aGlzLncgPSBNYXRoLmNvcyhhbmdsZSowLjUpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhlIHF1YXRlcm5pb24gdG8gYXhpcy9hbmdsZSByZXByZXNlbnRhdGlvbi5cclxuICogQG1ldGhvZCB0b0F4aXNBbmdsZVxyXG4gKiBAcGFyYW0ge1ZlYzN9IFt0YXJnZXRBeGlzXSBBIHZlY3RvciBvYmplY3QgdG8gcmV1c2UgZm9yIHN0b3JpbmcgdGhlIGF4aXMuXHJcbiAqIEByZXR1cm4ge0FycmF5fSBBbiBhcnJheSwgZmlyc3QgZWxlbW50IGlzIHRoZSBheGlzIGFuZCB0aGUgc2Vjb25kIGlzIHRoZSBhbmdsZSBpbiByYWRpYW5zLlxyXG4gKi9cclxuUXVhdGVybmlvbi5wcm90b3R5cGUudG9BeGlzQW5nbGUgPSBmdW5jdGlvbih0YXJnZXRBeGlzKXtcclxuICAgIHRhcmdldEF4aXMgPSB0YXJnZXRBeGlzIHx8IG5ldyBWZWMzKCk7XHJcbiAgICB0aGlzLm5vcm1hbGl6ZSgpOyAvLyBpZiB3PjEgYWNvcyBhbmQgc3FydCB3aWxsIHByb2R1Y2UgZXJyb3JzLCB0aGlzIGNhbnQgaGFwcGVuIGlmIHF1YXRlcm5pb24gaXMgbm9ybWFsaXNlZFxyXG4gICAgdmFyIGFuZ2xlID0gMiAqIE1hdGguYWNvcyh0aGlzLncpO1xyXG4gICAgdmFyIHMgPSBNYXRoLnNxcnQoMS10aGlzLncqdGhpcy53KTsgLy8gYXNzdW1pbmcgcXVhdGVybmlvbiBub3JtYWxpc2VkIHRoZW4gdyBpcyBsZXNzIHRoYW4gMSwgc28gdGVybSBhbHdheXMgcG9zaXRpdmUuXHJcbiAgICBpZiAocyA8IDAuMDAxKSB7IC8vIHRlc3QgdG8gYXZvaWQgZGl2aWRlIGJ5IHplcm8sIHMgaXMgYWx3YXlzIHBvc2l0aXZlIGR1ZSB0byBzcXJ0XHJcbiAgICAgICAgLy8gaWYgcyBjbG9zZSB0byB6ZXJvIHRoZW4gZGlyZWN0aW9uIG9mIGF4aXMgbm90IGltcG9ydGFudFxyXG4gICAgICAgIHRhcmdldEF4aXMueCA9IHRoaXMueDsgLy8gaWYgaXQgaXMgaW1wb3J0YW50IHRoYXQgYXhpcyBpcyBub3JtYWxpc2VkIHRoZW4gcmVwbGFjZSB3aXRoIHg9MTsgeT16PTA7XHJcbiAgICAgICAgdGFyZ2V0QXhpcy55ID0gdGhpcy55O1xyXG4gICAgICAgIHRhcmdldEF4aXMueiA9IHRoaXMuejtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGFyZ2V0QXhpcy54ID0gdGhpcy54IC8gczsgLy8gbm9ybWFsaXNlIGF4aXNcclxuICAgICAgICB0YXJnZXRBeGlzLnkgPSB0aGlzLnkgLyBzO1xyXG4gICAgICAgIHRhcmdldEF4aXMueiA9IHRoaXMueiAvIHM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gW3RhcmdldEF4aXMsYW5nbGVdO1xyXG59O1xyXG5cclxudmFyIHNmdl90MSA9IG5ldyBWZWMzKCksXHJcbiAgICBzZnZfdDIgPSBuZXcgVmVjMygpO1xyXG5cclxuLyoqXHJcbiAqIFNldCB0aGUgcXVhdGVybmlvbiB2YWx1ZSBnaXZlbiB0d28gdmVjdG9ycy4gVGhlIHJlc3VsdGluZyByb3RhdGlvbiB3aWxsIGJlIHRoZSBuZWVkZWQgcm90YXRpb24gdG8gcm90YXRlIHUgdG8gdi5cclxuICogQG1ldGhvZCBzZXRGcm9tVmVjdG9yc1xyXG4gKiBAcGFyYW0ge1ZlYzN9IHVcclxuICogQHBhcmFtIHtWZWMzfSB2XHJcbiAqL1xyXG5RdWF0ZXJuaW9uLnByb3RvdHlwZS5zZXRGcm9tVmVjdG9ycyA9IGZ1bmN0aW9uKHUsdil7XHJcbiAgICBpZih1LmlzQW50aXBhcmFsbGVsVG8odikpe1xyXG4gICAgICAgIHZhciB0MSA9IHNmdl90MTtcclxuICAgICAgICB2YXIgdDIgPSBzZnZfdDI7XHJcblxyXG4gICAgICAgIHUudGFuZ2VudHModDEsdDIpO1xyXG4gICAgICAgIHRoaXMuc2V0RnJvbUF4aXNBbmdsZSh0MSxNYXRoLlBJKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdmFyIGEgPSB1LmNyb3NzKHYpO1xyXG4gICAgICAgIHRoaXMueCA9IGEueDtcclxuICAgICAgICB0aGlzLnkgPSBhLnk7XHJcbiAgICAgICAgdGhpcy56ID0gYS56O1xyXG4gICAgICAgIHRoaXMudyA9IE1hdGguc3FydChNYXRoLnBvdyh1Lm5vcm0oKSwyKSAqIE1hdGgucG93KHYubm9ybSgpLDIpKSArIHUuZG90KHYpO1xyXG4gICAgICAgIHRoaXMubm9ybWFsaXplKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBRdWF0ZXJuaW9uIG11bHRpcGxpY2F0aW9uXHJcbiAqIEBtZXRob2QgbXVsdFxyXG4gKiBAcGFyYW0ge1F1YXRlcm5pb259IHFcclxuICogQHBhcmFtIHtRdWF0ZXJuaW9ufSB0YXJnZXQgT3B0aW9uYWwuXHJcbiAqIEByZXR1cm4ge1F1YXRlcm5pb259XHJcbiAqL1xyXG52YXIgUXVhdGVybmlvbl9tdWx0X3ZhID0gbmV3IFZlYzMoKTtcclxudmFyIFF1YXRlcm5pb25fbXVsdF92YiA9IG5ldyBWZWMzKCk7XHJcbnZhciBRdWF0ZXJuaW9uX211bHRfdmF4dmIgPSBuZXcgVmVjMygpO1xyXG5RdWF0ZXJuaW9uLnByb3RvdHlwZS5tdWx0ID0gZnVuY3Rpb24ocSx0YXJnZXQpe1xyXG4gICAgdGFyZ2V0ID0gdGFyZ2V0IHx8IG5ldyBRdWF0ZXJuaW9uKCk7XHJcblxyXG4gICAgdmFyIGF4ID0gdGhpcy54LCBheSA9IHRoaXMueSwgYXogPSB0aGlzLnosIGF3ID0gdGhpcy53LFxyXG4gICAgICAgIGJ4ID0gcS54LCBieSA9IHEueSwgYnogPSBxLnosIGJ3ID0gcS53O1xyXG5cclxuICAgIHRhcmdldC54ID0gYXggKiBidyArIGF3ICogYnggKyBheSAqIGJ6IC0gYXogKiBieTtcclxuICAgIHRhcmdldC55ID0gYXkgKiBidyArIGF3ICogYnkgKyBheiAqIGJ4IC0gYXggKiBiejtcclxuICAgIHRhcmdldC56ID0gYXogKiBidyArIGF3ICogYnogKyBheCAqIGJ5IC0gYXkgKiBieDtcclxuICAgIHRhcmdldC53ID0gYXcgKiBidyAtIGF4ICogYnggLSBheSAqIGJ5IC0gYXogKiBiejtcclxuXHJcbiAgICByZXR1cm4gdGFyZ2V0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldCB0aGUgaW52ZXJzZSBxdWF0ZXJuaW9uIHJvdGF0aW9uLlxyXG4gKiBAbWV0aG9kIGludmVyc2VcclxuICogQHBhcmFtIHtRdWF0ZXJuaW9ufSB0YXJnZXRcclxuICogQHJldHVybiB7UXVhdGVybmlvbn1cclxuICovXHJcblF1YXRlcm5pb24ucHJvdG90eXBlLmludmVyc2UgPSBmdW5jdGlvbih0YXJnZXQpe1xyXG4gICAgdmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLnosIHcgPSB0aGlzLnc7XHJcbiAgICB0YXJnZXQgPSB0YXJnZXQgfHwgbmV3IFF1YXRlcm5pb24oKTtcclxuXHJcbiAgICB0aGlzLmNvbmp1Z2F0ZSh0YXJnZXQpO1xyXG4gICAgdmFyIGlub3JtMiA9IDEvKHgqeCArIHkqeSArIHoqeiArIHcqdyk7XHJcbiAgICB0YXJnZXQueCAqPSBpbm9ybTI7XHJcbiAgICB0YXJnZXQueSAqPSBpbm9ybTI7XHJcbiAgICB0YXJnZXQueiAqPSBpbm9ybTI7XHJcbiAgICB0YXJnZXQudyAqPSBpbm9ybTI7XHJcblxyXG4gICAgcmV0dXJuIHRhcmdldDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXQgdGhlIHF1YXRlcm5pb24gY29uanVnYXRlXHJcbiAqIEBtZXRob2QgY29uanVnYXRlXHJcbiAqIEBwYXJhbSB7UXVhdGVybmlvbn0gdGFyZ2V0XHJcbiAqIEByZXR1cm4ge1F1YXRlcm5pb259XHJcbiAqL1xyXG5RdWF0ZXJuaW9uLnByb3RvdHlwZS5jb25qdWdhdGUgPSBmdW5jdGlvbih0YXJnZXQpe1xyXG4gICAgdGFyZ2V0ID0gdGFyZ2V0IHx8IG5ldyBRdWF0ZXJuaW9uKCk7XHJcblxyXG4gICAgdGFyZ2V0LnggPSAtdGhpcy54O1xyXG4gICAgdGFyZ2V0LnkgPSAtdGhpcy55O1xyXG4gICAgdGFyZ2V0LnogPSAtdGhpcy56O1xyXG4gICAgdGFyZ2V0LncgPSB0aGlzLnc7XHJcblxyXG4gICAgcmV0dXJuIHRhcmdldDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBOb3JtYWxpemUgdGhlIHF1YXRlcm5pb24uIE5vdGUgdGhhdCB0aGlzIGNoYW5nZXMgdGhlIHZhbHVlcyBvZiB0aGUgcXVhdGVybmlvbi5cclxuICogQG1ldGhvZCBub3JtYWxpemVcclxuICovXHJcblF1YXRlcm5pb24ucHJvdG90eXBlLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKCl7XHJcbiAgICB2YXIgbCA9IE1hdGguc3FydCh0aGlzLngqdGhpcy54K3RoaXMueSp0aGlzLnkrdGhpcy56KnRoaXMueit0aGlzLncqdGhpcy53KTtcclxuICAgIGlmICggbCA9PT0gMCApIHtcclxuICAgICAgICB0aGlzLnggPSAwO1xyXG4gICAgICAgIHRoaXMueSA9IDA7XHJcbiAgICAgICAgdGhpcy56ID0gMDtcclxuICAgICAgICB0aGlzLncgPSAwO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBsID0gMSAvIGw7XHJcbiAgICAgICAgdGhpcy54ICo9IGw7XHJcbiAgICAgICAgdGhpcy55ICo9IGw7XHJcbiAgICAgICAgdGhpcy56ICo9IGw7XHJcbiAgICAgICAgdGhpcy53ICo9IGw7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBcHByb3hpbWF0aW9uIG9mIHF1YXRlcm5pb24gbm9ybWFsaXphdGlvbi4gV29ya3MgYmVzdCB3aGVuIHF1YXQgaXMgYWxyZWFkeSBhbG1vc3Qtbm9ybWFsaXplZC5cclxuICogQG1ldGhvZCBub3JtYWxpemVGYXN0XHJcbiAqIEBzZWUgaHR0cDovL2pzcGVyZi5jb20vZmFzdC1xdWF0ZXJuaW9uLW5vcm1hbGl6YXRpb25cclxuICogQGF1dGhvciB1bnBoYXNlZCwgaHR0cHM6Ly9naXRodWIuY29tL3VucGhhc2VkXHJcbiAqL1xyXG5RdWF0ZXJuaW9uLnByb3RvdHlwZS5ub3JtYWxpemVGYXN0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGYgPSAoMy4wLSh0aGlzLngqdGhpcy54K3RoaXMueSp0aGlzLnkrdGhpcy56KnRoaXMueit0aGlzLncqdGhpcy53KSkvMi4wO1xyXG4gICAgaWYgKCBmID09PSAwICkge1xyXG4gICAgICAgIHRoaXMueCA9IDA7XHJcbiAgICAgICAgdGhpcy55ID0gMDtcclxuICAgICAgICB0aGlzLnogPSAwO1xyXG4gICAgICAgIHRoaXMudyA9IDA7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMueCAqPSBmO1xyXG4gICAgICAgIHRoaXMueSAqPSBmO1xyXG4gICAgICAgIHRoaXMueiAqPSBmO1xyXG4gICAgICAgIHRoaXMudyAqPSBmO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogTXVsdGlwbHkgdGhlIHF1YXRlcm5pb24gYnkgYSB2ZWN0b3JcclxuICogQG1ldGhvZCB2bXVsdFxyXG4gKiBAcGFyYW0ge1ZlYzN9IHZcclxuICogQHBhcmFtIHtWZWMzfSB0YXJnZXQgT3B0aW9uYWxcclxuICogQHJldHVybiB7VmVjM31cclxuICovXHJcblF1YXRlcm5pb24ucHJvdG90eXBlLnZtdWx0ID0gZnVuY3Rpb24odix0YXJnZXQpe1xyXG4gICAgdGFyZ2V0ID0gdGFyZ2V0IHx8IG5ldyBWZWMzKCk7XHJcblxyXG4gICAgdmFyIHggPSB2LngsXHJcbiAgICAgICAgeSA9IHYueSxcclxuICAgICAgICB6ID0gdi56O1xyXG5cclxuICAgIHZhciBxeCA9IHRoaXMueCxcclxuICAgICAgICBxeSA9IHRoaXMueSxcclxuICAgICAgICBxeiA9IHRoaXMueixcclxuICAgICAgICBxdyA9IHRoaXMudztcclxuXHJcbiAgICAvLyBxKnZcclxuICAgIHZhciBpeCA9ICBxdyAqIHggKyBxeSAqIHogLSBxeiAqIHksXHJcbiAgICBpeSA9ICBxdyAqIHkgKyBxeiAqIHggLSBxeCAqIHosXHJcbiAgICBpeiA9ICBxdyAqIHogKyBxeCAqIHkgLSBxeSAqIHgsXHJcbiAgICBpdyA9IC1xeCAqIHggLSBxeSAqIHkgLSBxeiAqIHo7XHJcblxyXG4gICAgdGFyZ2V0LnggPSBpeCAqIHF3ICsgaXcgKiAtcXggKyBpeSAqIC1xeiAtIGl6ICogLXF5O1xyXG4gICAgdGFyZ2V0LnkgPSBpeSAqIHF3ICsgaXcgKiAtcXkgKyBpeiAqIC1xeCAtIGl4ICogLXF6O1xyXG4gICAgdGFyZ2V0LnogPSBpeiAqIHF3ICsgaXcgKiAtcXogKyBpeCAqIC1xeSAtIGl5ICogLXF4O1xyXG5cclxuICAgIHJldHVybiB0YXJnZXQ7XHJcbn07XHJcblxyXG4vKipcclxuICogQ29waWVzIHZhbHVlIG9mIHNvdXJjZSB0byB0aGlzIHF1YXRlcm5pb24uXHJcbiAqIEBtZXRob2QgY29weVxyXG4gKiBAcGFyYW0ge1F1YXRlcm5pb259IHNvdXJjZVxyXG4gKiBAcmV0dXJuIHtRdWF0ZXJuaW9ufSB0aGlzXHJcbiAqL1xyXG5RdWF0ZXJuaW9uLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24oc291cmNlKXtcclxuICAgIHRoaXMueCA9IHNvdXJjZS54O1xyXG4gICAgdGhpcy55ID0gc291cmNlLnk7XHJcbiAgICB0aGlzLnogPSBzb3VyY2UuejtcclxuICAgIHRoaXMudyA9IHNvdXJjZS53O1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogQ29udmVydCB0aGUgcXVhdGVybmlvbiB0byBldWxlciBhbmdsZSByZXByZXNlbnRhdGlvbi4gT3JkZXI6IFlaWCwgYXMgdGhpcyBwYWdlIGRlc2NyaWJlczogaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvc3RhbmRhcmRzL2luZGV4Lmh0bVxyXG4gKiBAbWV0aG9kIHRvRXVsZXJcclxuICogQHBhcmFtIHtWZWMzfSB0YXJnZXRcclxuICogQHBhcmFtIHN0cmluZyBvcmRlciBUaHJlZS1jaGFyYWN0ZXIgc3RyaW5nIGUuZy4gXCJZWlhcIiwgd2hpY2ggYWxzbyBpcyBkZWZhdWx0LlxyXG4gKi9cclxuUXVhdGVybmlvbi5wcm90b3R5cGUudG9FdWxlciA9IGZ1bmN0aW9uKHRhcmdldCxvcmRlcil7XHJcbiAgICBvcmRlciA9IG9yZGVyIHx8IFwiWVpYXCI7XHJcblxyXG4gICAgdmFyIGhlYWRpbmcsIGF0dGl0dWRlLCBiYW5rO1xyXG4gICAgdmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLnosIHcgPSB0aGlzLnc7XHJcblxyXG4gICAgc3dpdGNoKG9yZGVyKXtcclxuICAgIGNhc2UgXCJZWlhcIjpcclxuICAgICAgICB2YXIgdGVzdCA9IHgqeSArIHoqdztcclxuICAgICAgICBpZiAodGVzdCA+IDAuNDk5KSB7IC8vIHNpbmd1bGFyaXR5IGF0IG5vcnRoIHBvbGVcclxuICAgICAgICAgICAgaGVhZGluZyA9IDIgKiBNYXRoLmF0YW4yKHgsdyk7XHJcbiAgICAgICAgICAgIGF0dGl0dWRlID0gTWF0aC5QSS8yO1xyXG4gICAgICAgICAgICBiYW5rID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRlc3QgPCAtMC40OTkpIHsgLy8gc2luZ3VsYXJpdHkgYXQgc291dGggcG9sZVxyXG4gICAgICAgICAgICBoZWFkaW5nID0gLTIgKiBNYXRoLmF0YW4yKHgsdyk7XHJcbiAgICAgICAgICAgIGF0dGl0dWRlID0gLSBNYXRoLlBJLzI7XHJcbiAgICAgICAgICAgIGJhbmsgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZihpc05hTihoZWFkaW5nKSl7XHJcbiAgICAgICAgICAgIHZhciBzcXggPSB4Kng7XHJcbiAgICAgICAgICAgIHZhciBzcXkgPSB5Knk7XHJcbiAgICAgICAgICAgIHZhciBzcXogPSB6Kno7XHJcbiAgICAgICAgICAgIGhlYWRpbmcgPSBNYXRoLmF0YW4yKDIqeSp3IC0gMip4KnogLCAxIC0gMipzcXkgLSAyKnNxeik7IC8vIEhlYWRpbmdcclxuICAgICAgICAgICAgYXR0aXR1ZGUgPSBNYXRoLmFzaW4oMip0ZXN0KTsgLy8gYXR0aXR1ZGVcclxuICAgICAgICAgICAgYmFuayA9IE1hdGguYXRhbjIoMip4KncgLSAyKnkqeiAsIDEgLSAyKnNxeCAtIDIqc3F6KTsgLy8gYmFua1xyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXVsZXIgb3JkZXIgXCIrb3JkZXIrXCIgbm90IHN1cHBvcnRlZCB5ZXQuXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIHRhcmdldC55ID0gaGVhZGluZztcclxuICAgIHRhcmdldC56ID0gYXR0aXR1ZGU7XHJcbiAgICB0YXJnZXQueCA9IGJhbms7XHJcbn07XHJcblxyXG4vKipcclxuICogU2VlIGh0dHA6Ly93d3cubWF0aHdvcmtzLmNvbS9tYXRsYWJjZW50cmFsL2ZpbGVleGNoYW5nZS8yMDY5Ni1mdW5jdGlvbi10by1jb252ZXJ0LWJldHdlZW4tZGNtLWV1bGVyLWFuZ2xlcy1xdWF0ZXJuaW9ucy1hbmQtZXVsZXItdmVjdG9ycy9jb250ZW50L1NwaW5DYWxjLm1cclxuICogQG1ldGhvZCBzZXRGcm9tRXVsZXJcclxuICogQHBhcmFtIHtOdW1iZXJ9IHhcclxuICogQHBhcmFtIHtOdW1iZXJ9IHlcclxuICogQHBhcmFtIHtOdW1iZXJ9IHpcclxuICogQHBhcmFtIHtTdHJpbmd9IG9yZGVyIFRoZSBvcmRlciB0byBhcHBseSBhbmdsZXM6ICdYWVonIG9yICdZWFonIG9yIGFueSBvdGhlciBjb21iaW5hdGlvblxyXG4gKi9cclxuUXVhdGVybmlvbi5wcm90b3R5cGUuc2V0RnJvbUV1bGVyID0gZnVuY3Rpb24gKCB4LCB5LCB6LCBvcmRlciApIHtcclxuICAgIG9yZGVyID0gb3JkZXIgfHwgXCJYWVpcIjtcclxuXHJcbiAgICB2YXIgYzEgPSBNYXRoLmNvcyggeCAvIDIgKTtcclxuICAgIHZhciBjMiA9IE1hdGguY29zKCB5IC8gMiApO1xyXG4gICAgdmFyIGMzID0gTWF0aC5jb3MoIHogLyAyICk7XHJcbiAgICB2YXIgczEgPSBNYXRoLnNpbiggeCAvIDIgKTtcclxuICAgIHZhciBzMiA9IE1hdGguc2luKCB5IC8gMiApO1xyXG4gICAgdmFyIHMzID0gTWF0aC5zaW4oIHogLyAyICk7XHJcblxyXG4gICAgaWYgKCBvcmRlciA9PT0gJ1hZWicgKSB7XHJcblxyXG4gICAgICAgIHRoaXMueCA9IHMxICogYzIgKiBjMyArIGMxICogczIgKiBzMztcclxuICAgICAgICB0aGlzLnkgPSBjMSAqIHMyICogYzMgLSBzMSAqIGMyICogczM7XHJcbiAgICAgICAgdGhpcy56ID0gYzEgKiBjMiAqIHMzICsgczEgKiBzMiAqIGMzO1xyXG4gICAgICAgIHRoaXMudyA9IGMxICogYzIgKiBjMyAtIHMxICogczIgKiBzMztcclxuXHJcbiAgICB9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1lYWicgKSB7XHJcblxyXG4gICAgICAgIHRoaXMueCA9IHMxICogYzIgKiBjMyArIGMxICogczIgKiBzMztcclxuICAgICAgICB0aGlzLnkgPSBjMSAqIHMyICogYzMgLSBzMSAqIGMyICogczM7XHJcbiAgICAgICAgdGhpcy56ID0gYzEgKiBjMiAqIHMzIC0gczEgKiBzMiAqIGMzO1xyXG4gICAgICAgIHRoaXMudyA9IGMxICogYzIgKiBjMyArIHMxICogczIgKiBzMztcclxuXHJcbiAgICB9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1pYWScgKSB7XHJcblxyXG4gICAgICAgIHRoaXMueCA9IHMxICogYzIgKiBjMyAtIGMxICogczIgKiBzMztcclxuICAgICAgICB0aGlzLnkgPSBjMSAqIHMyICogYzMgKyBzMSAqIGMyICogczM7XHJcbiAgICAgICAgdGhpcy56ID0gYzEgKiBjMiAqIHMzICsgczEgKiBzMiAqIGMzO1xyXG4gICAgICAgIHRoaXMudyA9IGMxICogYzIgKiBjMyAtIHMxICogczIgKiBzMztcclxuXHJcbiAgICB9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1pZWCcgKSB7XHJcblxyXG4gICAgICAgIHRoaXMueCA9IHMxICogYzIgKiBjMyAtIGMxICogczIgKiBzMztcclxuICAgICAgICB0aGlzLnkgPSBjMSAqIHMyICogYzMgKyBzMSAqIGMyICogczM7XHJcbiAgICAgICAgdGhpcy56ID0gYzEgKiBjMiAqIHMzIC0gczEgKiBzMiAqIGMzO1xyXG4gICAgICAgIHRoaXMudyA9IGMxICogYzIgKiBjMyArIHMxICogczIgKiBzMztcclxuXHJcbiAgICB9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1laWCcgKSB7XHJcblxyXG4gICAgICAgIHRoaXMueCA9IHMxICogYzIgKiBjMyArIGMxICogczIgKiBzMztcclxuICAgICAgICB0aGlzLnkgPSBjMSAqIHMyICogYzMgKyBzMSAqIGMyICogczM7XHJcbiAgICAgICAgdGhpcy56ID0gYzEgKiBjMiAqIHMzIC0gczEgKiBzMiAqIGMzO1xyXG4gICAgICAgIHRoaXMudyA9IGMxICogYzIgKiBjMyAtIHMxICogczIgKiBzMztcclxuXHJcbiAgICB9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1haWScgKSB7XHJcblxyXG4gICAgICAgIHRoaXMueCA9IHMxICogYzIgKiBjMyAtIGMxICogczIgKiBzMztcclxuICAgICAgICB0aGlzLnkgPSBjMSAqIHMyICogYzMgLSBzMSAqIGMyICogczM7XHJcbiAgICAgICAgdGhpcy56ID0gYzEgKiBjMiAqIHMzICsgczEgKiBzMiAqIGMzO1xyXG4gICAgICAgIHRoaXMudyA9IGMxICogYzIgKiBjMyArIHMxICogczIgKiBzMztcclxuXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogQG1ldGhvZCBjbG9uZVxyXG4gKiBAcmV0dXJuIHtRdWF0ZXJuaW9ufVxyXG4gKi9cclxuUXVhdGVybmlvbi5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpe1xyXG4gICAgcmV0dXJuIG5ldyBRdWF0ZXJuaW9uKHRoaXMueCwgdGhpcy55LCB0aGlzLnosIHRoaXMudyk7XHJcbn07XHJcblxyXG4vKipcclxuICogUGVyZm9ybXMgYSBzcGhlcmljYWwgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gcXVhdFxyXG4gKlxyXG4gKiBAbWV0aG9kIHNsZXJwXHJcbiAqIEBwYXJhbSB7UXVhdGVybmlvbn0gdG9RdWF0IHNlY29uZCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50IGJldHdlZW4gdGhlIHNlbGYgcXVhdGVybmlvbiBhbmQgdG9RdWF0XHJcbiAqIEBwYXJhbSB7UXVhdGVybmlvbn0gW3RhcmdldF0gQSBxdWF0ZXJuaW9uIHRvIHN0b3JlIHRoZSByZXN1bHQgaW4uIElmIG5vdCBwcm92aWRlZCwgYSBuZXcgb25lIHdpbGwgYmUgY3JlYXRlZC5cclxuICogQHJldHVybnMge1F1YXRlcm5pb259IFRoZSBcInRhcmdldFwiIG9iamVjdFxyXG4gKi9cclxuUXVhdGVybmlvbi5wcm90b3R5cGUuc2xlcnAgPSBmdW5jdGlvbiAodG9RdWF0LCB0LCB0YXJnZXQpIHtcclxuICAgIHRhcmdldCA9IHRhcmdldCB8fCBuZXcgUXVhdGVybmlvbigpO1xyXG5cclxuICAgIHZhciBheCA9IHRoaXMueCxcclxuICAgICAgICBheSA9IHRoaXMueSxcclxuICAgICAgICBheiA9IHRoaXMueixcclxuICAgICAgICBhdyA9IHRoaXMudyxcclxuICAgICAgICBieCA9IHRvUXVhdC54LFxyXG4gICAgICAgIGJ5ID0gdG9RdWF0LnksXHJcbiAgICAgICAgYnogPSB0b1F1YXQueixcclxuICAgICAgICBidyA9IHRvUXVhdC53O1xyXG5cclxuICAgIHZhciBvbWVnYSwgY29zb20sIHNpbm9tLCBzY2FsZTAsIHNjYWxlMTtcclxuXHJcbiAgICAvLyBjYWxjIGNvc2luZVxyXG4gICAgY29zb20gPSBheCAqIGJ4ICsgYXkgKiBieSArIGF6ICogYnogKyBhdyAqIGJ3O1xyXG5cclxuICAgIC8vIGFkanVzdCBzaWducyAoaWYgbmVjZXNzYXJ5KVxyXG4gICAgaWYgKCBjb3NvbSA8IDAuMCApIHtcclxuICAgICAgICBjb3NvbSA9IC1jb3NvbTtcclxuICAgICAgICBieCA9IC0gYng7XHJcbiAgICAgICAgYnkgPSAtIGJ5O1xyXG4gICAgICAgIGJ6ID0gLSBiejtcclxuICAgICAgICBidyA9IC0gYnc7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gY2FsY3VsYXRlIGNvZWZmaWNpZW50c1xyXG4gICAgaWYgKCAoMS4wIC0gY29zb20pID4gMC4wMDAwMDEgKSB7XHJcbiAgICAgICAgLy8gc3RhbmRhcmQgY2FzZSAoc2xlcnApXHJcbiAgICAgICAgb21lZ2EgID0gTWF0aC5hY29zKGNvc29tKTtcclxuICAgICAgICBzaW5vbSAgPSBNYXRoLnNpbihvbWVnYSk7XHJcbiAgICAgICAgc2NhbGUwID0gTWF0aC5zaW4oKDEuMCAtIHQpICogb21lZ2EpIC8gc2lub207XHJcbiAgICAgICAgc2NhbGUxID0gTWF0aC5zaW4odCAqIG9tZWdhKSAvIHNpbm9tO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBcImZyb21cIiBhbmQgXCJ0b1wiIHF1YXRlcm5pb25zIGFyZSB2ZXJ5IGNsb3NlXHJcbiAgICAgICAgLy8gIC4uLiBzbyB3ZSBjYW4gZG8gYSBsaW5lYXIgaW50ZXJwb2xhdGlvblxyXG4gICAgICAgIHNjYWxlMCA9IDEuMCAtIHQ7XHJcbiAgICAgICAgc2NhbGUxID0gdDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBjYWxjdWxhdGUgZmluYWwgdmFsdWVzXHJcbiAgICB0YXJnZXQueCA9IHNjYWxlMCAqIGF4ICsgc2NhbGUxICogYng7XHJcbiAgICB0YXJnZXQueSA9IHNjYWxlMCAqIGF5ICsgc2NhbGUxICogYnk7XHJcbiAgICB0YXJnZXQueiA9IHNjYWxlMCAqIGF6ICsgc2NhbGUxICogYno7XHJcbiAgICB0YXJnZXQudyA9IHNjYWxlMCAqIGF3ICsgc2NhbGUxICogYnc7XHJcblxyXG4gICAgcmV0dXJuIHRhcmdldDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSb3RhdGUgYW4gYWJzb2x1dGUgb3JpZW50YXRpb24gcXVhdGVybmlvbiBnaXZlbiBhbiBhbmd1bGFyIHZlbG9jaXR5IGFuZCBhIHRpbWUgc3RlcC5cclxuICogQHBhcmFtICB7VmVjM30gYW5ndWxhclZlbG9jaXR5XHJcbiAqIEBwYXJhbSAge251bWJlcn0gZHRcclxuICogQHBhcmFtICB7VmVjM30gYW5ndWxhckZhY3RvclxyXG4gKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSB0YXJnZXRcclxuICogQHJldHVybiB7UXVhdGVybmlvbn0gVGhlIFwidGFyZ2V0XCIgb2JqZWN0XHJcbiAqL1xyXG5RdWF0ZXJuaW9uLnByb3RvdHlwZS5pbnRlZ3JhdGUgPSBmdW5jdGlvbihhbmd1bGFyVmVsb2NpdHksIGR0LCBhbmd1bGFyRmFjdG9yLCB0YXJnZXQpe1xyXG4gICAgdGFyZ2V0ID0gdGFyZ2V0IHx8IG5ldyBRdWF0ZXJuaW9uKCk7XHJcblxyXG4gICAgdmFyIGF4ID0gYW5ndWxhclZlbG9jaXR5LnggKiBhbmd1bGFyRmFjdG9yLngsXHJcbiAgICAgICAgYXkgPSBhbmd1bGFyVmVsb2NpdHkueSAqIGFuZ3VsYXJGYWN0b3IueSxcclxuICAgICAgICBheiA9IGFuZ3VsYXJWZWxvY2l0eS56ICogYW5ndWxhckZhY3Rvci56LFxyXG4gICAgICAgIGJ4ID0gdGhpcy54LFxyXG4gICAgICAgIGJ5ID0gdGhpcy55LFxyXG4gICAgICAgIGJ6ID0gdGhpcy56LFxyXG4gICAgICAgIGJ3ID0gdGhpcy53O1xyXG5cclxuICAgIHZhciBoYWxmX2R0ID0gZHQgKiAwLjU7XHJcblxyXG4gICAgdGFyZ2V0LnggKz0gaGFsZl9kdCAqIChheCAqIGJ3ICsgYXkgKiBieiAtIGF6ICogYnkpO1xyXG4gICAgdGFyZ2V0LnkgKz0gaGFsZl9kdCAqIChheSAqIGJ3ICsgYXogKiBieCAtIGF4ICogYnopO1xyXG4gICAgdGFyZ2V0LnogKz0gaGFsZl9kdCAqIChheiAqIGJ3ICsgYXggKiBieSAtIGF5ICogYngpO1xyXG4gICAgdGFyZ2V0LncgKz0gaGFsZl9kdCAqICgtIGF4ICogYnggLSBheSAqIGJ5IC0gYXogKiBieik7XHJcblxyXG4gICAgcmV0dXJuIHRhcmdldDtcclxufTtcclxufSx7XCIuL1ZlYzNcIjozMX1dLDMwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcclxudmFyIFZlYzMgPSBfZGVyZXFfKCcuL1ZlYzMnKTtcclxudmFyIFF1YXRlcm5pb24gPSBfZGVyZXFfKCcuL1F1YXRlcm5pb24nKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtO1xyXG5cclxuLyoqXHJcbiAqIEBjbGFzcyBUcmFuc2Zvcm1cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5mdW5jdGlvbiBUcmFuc2Zvcm0ob3B0aW9ucykge1xyXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcm9wZXJ0eSB7VmVjM30gcG9zaXRpb25cclxuXHQgKi9cclxuXHR0aGlzLnBvc2l0aW9uID0gbmV3IFZlYzMoKTtcclxuICAgIGlmKG9wdGlvbnMucG9zaXRpb24pe1xyXG4gICAgICAgIHRoaXMucG9zaXRpb24uY29weShvcHRpb25zLnBvc2l0aW9uKTtcclxuICAgIH1cclxuXHJcblx0LyoqXHJcblx0ICogQHByb3BlcnR5IHtRdWF0ZXJuaW9ufSBxdWF0ZXJuaW9uXHJcblx0ICovXHJcblx0dGhpcy5xdWF0ZXJuaW9uID0gbmV3IFF1YXRlcm5pb24oKTtcclxuICAgIGlmKG9wdGlvbnMucXVhdGVybmlvbil7XHJcbiAgICAgICAgdGhpcy5xdWF0ZXJuaW9uLmNvcHkob3B0aW9ucy5xdWF0ZXJuaW9uKTtcclxuICAgIH1cclxufVxyXG5cclxudmFyIHRtcFF1YXQgPSBuZXcgUXVhdGVybmlvbigpO1xyXG5cclxuLyoqXHJcbiAqIEBzdGF0aWNcclxuICogQG1ldGhvZCBwb2ludFRvTG9jYUZyYW1lXHJcbiAqIEBwYXJhbSB7VmVjM30gcG9zaXRpb25cclxuICogQHBhcmFtIHtRdWF0ZXJuaW9ufSBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7VmVjM30gd29ybGRQb2ludFxyXG4gKiBAcGFyYW0ge1ZlYzN9IHJlc3VsdFxyXG4gKi9cclxuVHJhbnNmb3JtLnBvaW50VG9Mb2NhbEZyYW1lID0gZnVuY3Rpb24ocG9zaXRpb24sIHF1YXRlcm5pb24sIHdvcmxkUG9pbnQsIHJlc3VsdCl7XHJcbiAgICB2YXIgcmVzdWx0ID0gcmVzdWx0IHx8IG5ldyBWZWMzKCk7XHJcbiAgICB3b3JsZFBvaW50LnZzdWIocG9zaXRpb24sIHJlc3VsdCk7XHJcbiAgICBxdWF0ZXJuaW9uLmNvbmp1Z2F0ZSh0bXBRdWF0KTtcclxuICAgIHRtcFF1YXQudm11bHQocmVzdWx0LCByZXN1bHQpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXQgYSBnbG9iYWwgcG9pbnQgaW4gbG9jYWwgdHJhbnNmb3JtIGNvb3JkaW5hdGVzLlxyXG4gKiBAbWV0aG9kIHBvaW50VG9Mb2NhbFxyXG4gKiBAcGFyYW0gIHtWZWMzfSBwb2ludFxyXG4gKiBAcGFyYW0gIHtWZWMzfSByZXN1bHRcclxuICogQHJldHVybiB7VmVjM30gVGhlIFwicmVzdWx0XCIgdmVjdG9yIG9iamVjdFxyXG4gKi9cclxuVHJhbnNmb3JtLnByb3RvdHlwZS5wb2ludFRvTG9jYWwgPSBmdW5jdGlvbih3b3JsZFBvaW50LCByZXN1bHQpe1xyXG4gICAgcmV0dXJuIFRyYW5zZm9ybS5wb2ludFRvTG9jYWxGcmFtZSh0aGlzLnBvc2l0aW9uLCB0aGlzLnF1YXRlcm5pb24sIHdvcmxkUG9pbnQsIHJlc3VsdCk7XHJcbn07XHJcblxyXG4vKipcclxuICogQHN0YXRpY1xyXG4gKiBAbWV0aG9kIHBvaW50VG9Xb3JsZEZyYW1lXHJcbiAqIEBwYXJhbSB7VmVjM30gcG9zaXRpb25cclxuICogQHBhcmFtIHtWZWMzfSBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7VmVjM30gbG9jYWxQb2ludFxyXG4gKiBAcGFyYW0ge1ZlYzN9IHJlc3VsdFxyXG4gKi9cclxuVHJhbnNmb3JtLnBvaW50VG9Xb3JsZEZyYW1lID0gZnVuY3Rpb24ocG9zaXRpb24sIHF1YXRlcm5pb24sIGxvY2FsUG9pbnQsIHJlc3VsdCl7XHJcbiAgICB2YXIgcmVzdWx0ID0gcmVzdWx0IHx8IG5ldyBWZWMzKCk7XHJcbiAgICBxdWF0ZXJuaW9uLnZtdWx0KGxvY2FsUG9pbnQsIHJlc3VsdCk7XHJcbiAgICByZXN1bHQudmFkZChwb3NpdGlvbiwgcmVzdWx0KTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0IGEgbG9jYWwgcG9pbnQgaW4gZ2xvYmFsIHRyYW5zZm9ybSBjb29yZGluYXRlcy5cclxuICogQG1ldGhvZCBwb2ludFRvV29ybGRcclxuICogQHBhcmFtICB7VmVjM30gcG9pbnRcclxuICogQHBhcmFtICB7VmVjM30gcmVzdWx0XHJcbiAqIEByZXR1cm4ge1ZlYzN9IFRoZSBcInJlc3VsdFwiIHZlY3RvciBvYmplY3RcclxuICovXHJcblRyYW5zZm9ybS5wcm90b3R5cGUucG9pbnRUb1dvcmxkID0gZnVuY3Rpb24obG9jYWxQb2ludCwgcmVzdWx0KXtcclxuICAgIHJldHVybiBUcmFuc2Zvcm0ucG9pbnRUb1dvcmxkRnJhbWUodGhpcy5wb3NpdGlvbiwgdGhpcy5xdWF0ZXJuaW9uLCBsb2NhbFBvaW50LCByZXN1bHQpO1xyXG59O1xyXG5cclxuXHJcblRyYW5zZm9ybS5wcm90b3R5cGUudmVjdG9yVG9Xb3JsZEZyYW1lID0gZnVuY3Rpb24obG9jYWxWZWN0b3IsIHJlc3VsdCl7XHJcbiAgICB2YXIgcmVzdWx0ID0gcmVzdWx0IHx8IG5ldyBWZWMzKCk7XHJcbiAgICB0aGlzLnF1YXRlcm5pb24udm11bHQobG9jYWxWZWN0b3IsIHJlc3VsdCk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxuVHJhbnNmb3JtLnZlY3RvclRvV29ybGRGcmFtZSA9IGZ1bmN0aW9uKHF1YXRlcm5pb24sIGxvY2FsVmVjdG9yLCByZXN1bHQpe1xyXG4gICAgcXVhdGVybmlvbi52bXVsdChsb2NhbFZlY3RvciwgcmVzdWx0KTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG5UcmFuc2Zvcm0udmVjdG9yVG9Mb2NhbEZyYW1lID0gZnVuY3Rpb24ocG9zaXRpb24sIHF1YXRlcm5pb24sIHdvcmxkVmVjdG9yLCByZXN1bHQpe1xyXG4gICAgdmFyIHJlc3VsdCA9IHJlc3VsdCB8fCBuZXcgVmVjMygpO1xyXG4gICAgcXVhdGVybmlvbi53ICo9IC0xO1xyXG4gICAgcXVhdGVybmlvbi52bXVsdCh3b3JsZFZlY3RvciwgcmVzdWx0KTtcclxuICAgIHF1YXRlcm5pb24udyAqPSAtMTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG59LHtcIi4vUXVhdGVybmlvblwiOjI5LFwiLi9WZWMzXCI6MzF9XSwzMTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XHJcbm1vZHVsZS5leHBvcnRzID0gVmVjMztcclxuXHJcbnZhciBNYXQzID0gX2RlcmVxXygnLi9NYXQzJyk7XHJcblxyXG4vKipcclxuICogMy1kaW1lbnNpb25hbCB2ZWN0b3JcclxuICogQGNsYXNzIFZlYzNcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB4XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB5XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB6XHJcbiAqIEBhdXRob3Igc2NodGVwcGVcclxuICogQGV4YW1wbGVcclxuICogICAgIHZhciB2ID0gbmV3IFZlYzMoMSwgMiwgMyk7XHJcbiAqICAgICBjb25zb2xlLmxvZygneD0nICsgdi54KTsgLy8geD0xXHJcbiAqL1xyXG5mdW5jdGlvbiBWZWMzKHgseSx6KXtcclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IHhcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMueCA9IHh8fDAuMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcm9wZXJ0eSB5XHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLnkgPSB5fHwwLjA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkgelxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy56ID0genx8MC4wO1xyXG59XHJcblxyXG4vKipcclxuICogQHN0YXRpY1xyXG4gKiBAcHJvcGVydHkge1ZlYzN9IFpFUk9cclxuICovXHJcblZlYzMuWkVSTyA9IG5ldyBWZWMzKDAsIDAsIDApO1xyXG5cclxuLyoqXHJcbiAqIEBzdGF0aWNcclxuICogQHByb3BlcnR5IHtWZWMzfSBVTklUX1hcclxuICovXHJcblZlYzMuVU5JVF9YID0gbmV3IFZlYzMoMSwgMCwgMCk7XHJcblxyXG4vKipcclxuICogQHN0YXRpY1xyXG4gKiBAcHJvcGVydHkge1ZlYzN9IFVOSVRfWVxyXG4gKi9cclxuVmVjMy5VTklUX1kgPSBuZXcgVmVjMygwLCAxLCAwKTtcclxuXHJcbi8qKlxyXG4gKiBAc3RhdGljXHJcbiAqIEBwcm9wZXJ0eSB7VmVjM30gVU5JVF9aXHJcbiAqL1xyXG5WZWMzLlVOSVRfWiA9IG5ldyBWZWMzKDAsIDAsIDEpO1xyXG5cclxuLyoqXHJcbiAqIFZlY3RvciBjcm9zcyBwcm9kdWN0XHJcbiAqIEBtZXRob2QgY3Jvc3NcclxuICogQHBhcmFtIHtWZWMzfSB2XHJcbiAqIEBwYXJhbSB7VmVjM30gdGFyZ2V0IE9wdGlvbmFsLiBUYXJnZXQgdG8gc2F2ZSBpbi5cclxuICogQHJldHVybiB7VmVjM31cclxuICovXHJcblZlYzMucHJvdG90eXBlLmNyb3NzID0gZnVuY3Rpb24odix0YXJnZXQpe1xyXG4gICAgdmFyIHZ4PXYueCwgdnk9di55LCB2ej12LnosIHg9dGhpcy54LCB5PXRoaXMueSwgej10aGlzLno7XHJcbiAgICB0YXJnZXQgPSB0YXJnZXQgfHwgbmV3IFZlYzMoKTtcclxuXHJcbiAgICB0YXJnZXQueCA9ICh5ICogdnopIC0gKHogKiB2eSk7XHJcbiAgICB0YXJnZXQueSA9ICh6ICogdngpIC0gKHggKiB2eik7XHJcbiAgICB0YXJnZXQueiA9ICh4ICogdnkpIC0gKHkgKiB2eCk7XHJcblxyXG4gICAgcmV0dXJuIHRhcmdldDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTZXQgdGhlIHZlY3RvcnMnIDMgZWxlbWVudHNcclxuICogQG1ldGhvZCBzZXRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHhcclxuICogQHBhcmFtIHtOdW1iZXJ9IHlcclxuICogQHBhcmFtIHtOdW1iZXJ9IHpcclxuICogQHJldHVybiBWZWMzXHJcbiAqL1xyXG5WZWMzLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbih4LHkseil7XHJcbiAgICB0aGlzLnggPSB4O1xyXG4gICAgdGhpcy55ID0geTtcclxuICAgIHRoaXMueiA9IHo7XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTZXQgYWxsIGNvbXBvbmVudHMgb2YgdGhlIHZlY3RvciB0byB6ZXJvLlxyXG4gKiBAbWV0aG9kIHNldFplcm9cclxuICovXHJcblZlYzMucHJvdG90eXBlLnNldFplcm8gPSBmdW5jdGlvbigpe1xyXG4gICAgdGhpcy54ID0gdGhpcy55ID0gdGhpcy56ID0gMDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBWZWN0b3IgYWRkaXRpb25cclxuICogQG1ldGhvZCB2YWRkXHJcbiAqIEBwYXJhbSB7VmVjM30gdlxyXG4gKiBAcGFyYW0ge1ZlYzN9IHRhcmdldCBPcHRpb25hbC5cclxuICogQHJldHVybiB7VmVjM31cclxuICovXHJcblZlYzMucHJvdG90eXBlLnZhZGQgPSBmdW5jdGlvbih2LHRhcmdldCl7XHJcbiAgICBpZih0YXJnZXQpe1xyXG4gICAgICAgIHRhcmdldC54ID0gdi54ICsgdGhpcy54O1xyXG4gICAgICAgIHRhcmdldC55ID0gdi55ICsgdGhpcy55O1xyXG4gICAgICAgIHRhcmdldC56ID0gdi56ICsgdGhpcy56O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gbmV3IFZlYzModGhpcy54ICsgdi54LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy55ICsgdi55LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy56ICsgdi56KTtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBWZWN0b3Igc3VidHJhY3Rpb25cclxuICogQG1ldGhvZCB2c3ViXHJcbiAqIEBwYXJhbSB7VmVjM30gdlxyXG4gKiBAcGFyYW0ge1ZlYzN9IHRhcmdldCBPcHRpb25hbC4gVGFyZ2V0IHRvIHNhdmUgaW4uXHJcbiAqIEByZXR1cm4ge1ZlYzN9XHJcbiAqL1xyXG5WZWMzLnByb3RvdHlwZS52c3ViID0gZnVuY3Rpb24odix0YXJnZXQpe1xyXG4gICAgaWYodGFyZ2V0KXtcclxuICAgICAgICB0YXJnZXQueCA9IHRoaXMueCAtIHYueDtcclxuICAgICAgICB0YXJnZXQueSA9IHRoaXMueSAtIHYueTtcclxuICAgICAgICB0YXJnZXQueiA9IHRoaXMueiAtIHYuejtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWZWMzKHRoaXMueC12LngsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnktdi55LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy56LXYueik7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0IHRoZSBjcm9zcyBwcm9kdWN0IG1hdHJpeCBhX2Nyb3NzIGZyb20gYSB2ZWN0b3IsIHN1Y2ggdGhhdCBhIHggYiA9IGFfY3Jvc3MgKiBiID0gY1xyXG4gKiBAbWV0aG9kIGNyb3NzbWF0XHJcbiAqIEBzZWUgaHR0cDovL3d3dzguY3MudW11LnNlL2t1cnNlci9UREJEMjQvVlQwNi9sZWN0dXJlcy9MZWN0dXJlNi5wZGZcclxuICogQHJldHVybiB7TWF0M31cclxuICovXHJcblZlYzMucHJvdG90eXBlLmNyb3NzbWF0ID0gZnVuY3Rpb24oKXtcclxuICAgIHJldHVybiBuZXcgTWF0MyhbICAgICAwLCAgLXRoaXMueiwgICB0aGlzLnksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnosICAgICAgICAwLCAgLXRoaXMueCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgLXRoaXMueSwgICB0aGlzLngsICAgICAgICAwXSk7XHJcbn07XHJcblxyXG4vKipcclxuICogTm9ybWFsaXplIHRoZSB2ZWN0b3IuIE5vdGUgdGhhdCB0aGlzIGNoYW5nZXMgdGhlIHZhbHVlcyBpbiB0aGUgdmVjdG9yLlxyXG4gKiBAbWV0aG9kIG5vcm1hbGl6ZVxyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IFJldHVybnMgdGhlIG5vcm0gb2YgdGhlIHZlY3RvclxyXG4gKi9cclxuVmVjMy5wcm90b3R5cGUubm9ybWFsaXplID0gZnVuY3Rpb24oKXtcclxuICAgIHZhciB4PXRoaXMueCwgeT10aGlzLnksIHo9dGhpcy56O1xyXG4gICAgdmFyIG4gPSBNYXRoLnNxcnQoeCp4ICsgeSp5ICsgeip6KTtcclxuICAgIGlmKG4+MC4wKXtcclxuICAgICAgICB2YXIgaW52TiA9IDEvbjtcclxuICAgICAgICB0aGlzLnggKj0gaW52TjtcclxuICAgICAgICB0aGlzLnkgKj0gaW52TjtcclxuICAgICAgICB0aGlzLnogKj0gaW52TjtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gTWFrZSBzb21ldGhpbmcgdXBcclxuICAgICAgICB0aGlzLnggPSAwO1xyXG4gICAgICAgIHRoaXMueSA9IDA7XHJcbiAgICAgICAgdGhpcy56ID0gMDtcclxuICAgIH1cclxuICAgIHJldHVybiBuO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldCB0aGUgdmVyc2lvbiBvZiB0aGlzIHZlY3RvciB0aGF0IGlzIG9mIGxlbmd0aCAxLlxyXG4gKiBAbWV0aG9kIHVuaXRcclxuICogQHBhcmFtIHtWZWMzfSB0YXJnZXQgT3B0aW9uYWwgdGFyZ2V0IHRvIHNhdmUgaW5cclxuICogQHJldHVybiB7VmVjM30gUmV0dXJucyB0aGUgdW5pdCB2ZWN0b3JcclxuICovXHJcblZlYzMucHJvdG90eXBlLnVuaXQgPSBmdW5jdGlvbih0YXJnZXQpe1xyXG4gICAgdGFyZ2V0ID0gdGFyZ2V0IHx8IG5ldyBWZWMzKCk7XHJcbiAgICB2YXIgeD10aGlzLngsIHk9dGhpcy55LCB6PXRoaXMuejtcclxuICAgIHZhciBuaW52ID0gTWF0aC5zcXJ0KHgqeCArIHkqeSArIHoqeik7XHJcbiAgICBpZihuaW52PjAuMCl7XHJcbiAgICAgICAgbmludiA9IDEuMC9uaW52O1xyXG4gICAgICAgIHRhcmdldC54ID0geCAqIG5pbnY7XHJcbiAgICAgICAgdGFyZ2V0LnkgPSB5ICogbmludjtcclxuICAgICAgICB0YXJnZXQueiA9IHogKiBuaW52O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB0YXJnZXQueCA9IDE7XHJcbiAgICAgICAgdGFyZ2V0LnkgPSAwO1xyXG4gICAgICAgIHRhcmdldC56ID0gMDtcclxuICAgIH1cclxuICAgIHJldHVybiB0YXJnZXQ7XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0IHRoZSBsZW5ndGggb2YgdGhlIHZlY3RvclxyXG4gKiBAbWV0aG9kIG5vcm1cclxuICogQHJldHVybiB7TnVtYmVyfVxyXG4gKiBAZGVwcmVjYXRlZCBVc2UgLmxlbmd0aCgpIGluc3RlYWRcclxuICovXHJcblZlYzMucHJvdG90eXBlLm5vcm0gPSBmdW5jdGlvbigpe1xyXG4gICAgdmFyIHg9dGhpcy54LCB5PXRoaXMueSwgej10aGlzLno7XHJcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHgqeCArIHkqeSArIHoqeik7XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0IHRoZSBsZW5ndGggb2YgdGhlIHZlY3RvclxyXG4gKiBAbWV0aG9kIGxlbmd0aFxyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XHJcbiAqL1xyXG5WZWMzLnByb3RvdHlwZS5sZW5ndGggPSBWZWMzLnByb3RvdHlwZS5ub3JtO1xyXG5cclxuLyoqXHJcbiAqIEdldCB0aGUgc3F1YXJlZCBsZW5ndGggb2YgdGhlIHZlY3RvclxyXG4gKiBAbWV0aG9kIG5vcm0yXHJcbiAqIEByZXR1cm4ge051bWJlcn1cclxuICogQGRlcHJlY2F0ZWQgVXNlIC5sZW5ndGhTcXVhcmVkKCkgaW5zdGVhZC5cclxuICovXHJcblZlYzMucHJvdG90eXBlLm5vcm0yID0gZnVuY3Rpb24oKXtcclxuICAgIHJldHVybiB0aGlzLmRvdCh0aGlzKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXQgdGhlIHNxdWFyZWQgbGVuZ3RoIG9mIHRoZSB2ZWN0b3IuXHJcbiAqIEBtZXRob2QgbGVuZ3RoU3F1YXJlZFxyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XHJcbiAqL1xyXG5WZWMzLnByb3RvdHlwZS5sZW5ndGhTcXVhcmVkID0gVmVjMy5wcm90b3R5cGUubm9ybTI7XHJcblxyXG4vKipcclxuICogR2V0IGRpc3RhbmNlIGZyb20gdGhpcyBwb2ludCB0byBhbm90aGVyIHBvaW50XHJcbiAqIEBtZXRob2QgZGlzdGFuY2VUb1xyXG4gKiBAcGFyYW0gIHtWZWMzfSBwXHJcbiAqIEByZXR1cm4ge051bWJlcn1cclxuICovXHJcblZlYzMucHJvdG90eXBlLmRpc3RhbmNlVG8gPSBmdW5jdGlvbihwKXtcclxuICAgIHZhciB4PXRoaXMueCwgeT10aGlzLnksIHo9dGhpcy56O1xyXG4gICAgdmFyIHB4PXAueCwgcHk9cC55LCBwej1wLno7XHJcbiAgICByZXR1cm4gTWF0aC5zcXJ0KChweC14KSoocHgteCkrXHJcbiAgICAgICAgICAgICAgICAgICAgIChweS15KSoocHkteSkrXHJcbiAgICAgICAgICAgICAgICAgICAgIChwei16KSoocHoteikpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldCBzcXVhcmVkIGRpc3RhbmNlIGZyb20gdGhpcyBwb2ludCB0byBhbm90aGVyIHBvaW50XHJcbiAqIEBtZXRob2QgZGlzdGFuY2VTcXVhcmVkXHJcbiAqIEBwYXJhbSAge1ZlYzN9IHBcclxuICogQHJldHVybiB7TnVtYmVyfVxyXG4gKi9cclxuVmVjMy5wcm90b3R5cGUuZGlzdGFuY2VTcXVhcmVkID0gZnVuY3Rpb24ocCl7XHJcbiAgICB2YXIgeD10aGlzLngsIHk9dGhpcy55LCB6PXRoaXMuejtcclxuICAgIHZhciBweD1wLngsIHB5PXAueSwgcHo9cC56O1xyXG4gICAgcmV0dXJuIChweC14KSoocHgteCkgKyAocHkteSkqKHB5LXkpICsgKHB6LXopKihwei16KTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBNdWx0aXBseSBhbGwgdGhlIGNvbXBvbmVudHMgb2YgdGhlIHZlY3RvciB3aXRoIGEgc2NhbGFyLlxyXG4gKiBAZGVwcmVjYXRlZCBVc2UgLnNjYWxlIGluc3RlYWRcclxuICogQG1ldGhvZCBtdWx0XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsYXJcclxuICogQHBhcmFtIHtWZWMzfSB0YXJnZXQgVGhlIHZlY3RvciB0byBzYXZlIHRoZSByZXN1bHQgaW4uXHJcbiAqIEByZXR1cm4ge1ZlYzN9XHJcbiAqIEBkZXByZWNhdGVkIFVzZSAuc2NhbGUoKSBpbnN0ZWFkXHJcbiAqL1xyXG5WZWMzLnByb3RvdHlwZS5tdWx0ID0gZnVuY3Rpb24oc2NhbGFyLHRhcmdldCl7XHJcbiAgICB0YXJnZXQgPSB0YXJnZXQgfHwgbmV3IFZlYzMoKTtcclxuICAgIHZhciB4ID0gdGhpcy54LFxyXG4gICAgICAgIHkgPSB0aGlzLnksXHJcbiAgICAgICAgeiA9IHRoaXMuejtcclxuICAgIHRhcmdldC54ID0gc2NhbGFyICogeDtcclxuICAgIHRhcmdldC55ID0gc2NhbGFyICogeTtcclxuICAgIHRhcmdldC56ID0gc2NhbGFyICogejtcclxuICAgIHJldHVybiB0YXJnZXQ7XHJcbn07XHJcblxyXG4vKipcclxuICogTXVsdGlwbHkgdGhlIHZlY3RvciB3aXRoIGFuIG90aGVyIHZlY3RvciwgY29tcG9uZW50LXdpc2UuXHJcbiAqIEBtZXRob2QgbXVsdFxyXG4gKiBAcGFyYW0ge051bWJlcn0gdmVjdG9yXHJcbiAqIEBwYXJhbSB7VmVjM30gdGFyZ2V0IFRoZSB2ZWN0b3IgdG8gc2F2ZSB0aGUgcmVzdWx0IGluLlxyXG4gKiBAcmV0dXJuIHtWZWMzfVxyXG4gKi9cclxuVmVjMy5wcm90b3R5cGUudm11bCA9IGZ1bmN0aW9uKHZlY3RvciwgdGFyZ2V0KXtcclxuICAgIHRhcmdldCA9IHRhcmdldCB8fCBuZXcgVmVjMygpO1xyXG4gICAgdGFyZ2V0LnggPSB2ZWN0b3IueCAqIHRoaXMueDtcclxuICAgIHRhcmdldC55ID0gdmVjdG9yLnkgKiB0aGlzLnk7XHJcbiAgICB0YXJnZXQueiA9IHZlY3Rvci56ICogdGhpcy56O1xyXG4gICAgcmV0dXJuIHRhcmdldDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBNdWx0aXBseSB0aGUgdmVjdG9yIHdpdGggYSBzY2FsYXIuXHJcbiAqIEBtZXRob2Qgc2NhbGVcclxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxhclxyXG4gKiBAcGFyYW0ge1ZlYzN9IHRhcmdldFxyXG4gKiBAcmV0dXJuIHtWZWMzfVxyXG4gKi9cclxuVmVjMy5wcm90b3R5cGUuc2NhbGUgPSBWZWMzLnByb3RvdHlwZS5tdWx0O1xyXG5cclxuLyoqXHJcbiAqIFNjYWxlIGEgdmVjdG9yIGFuZCBhZGQgaXQgdG8gdGhpcyB2ZWN0b3IuIFNhdmUgdGhlIHJlc3VsdCBpbiBcInRhcmdldFwiLiAodGFyZ2V0ID0gdGhpcyArIHZlY3RvciAqIHNjYWxhcilcclxuICogQG1ldGhvZCBhZGRTY2FsZWRWZWN0b3JcclxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxhclxyXG4gKiBAcGFyYW0ge1ZlYzN9IHZlY3RvclxyXG4gKiBAcGFyYW0ge1ZlYzN9IHRhcmdldCBUaGUgdmVjdG9yIHRvIHNhdmUgdGhlIHJlc3VsdCBpbi5cclxuICogQHJldHVybiB7VmVjM31cclxuICovXHJcblZlYzMucHJvdG90eXBlLmFkZFNjYWxlZFZlY3RvciA9IGZ1bmN0aW9uKHNjYWxhciwgdmVjdG9yLCB0YXJnZXQpe1xyXG4gICAgdGFyZ2V0ID0gdGFyZ2V0IHx8IG5ldyBWZWMzKCk7XHJcbiAgICB0YXJnZXQueCA9IHRoaXMueCArIHNjYWxhciAqIHZlY3Rvci54O1xyXG4gICAgdGFyZ2V0LnkgPSB0aGlzLnkgKyBzY2FsYXIgKiB2ZWN0b3IueTtcclxuICAgIHRhcmdldC56ID0gdGhpcy56ICsgc2NhbGFyICogdmVjdG9yLno7XHJcbiAgICByZXR1cm4gdGFyZ2V0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENhbGN1bGF0ZSBkb3QgcHJvZHVjdFxyXG4gKiBAbWV0aG9kIGRvdFxyXG4gKiBAcGFyYW0ge1ZlYzN9IHZcclxuICogQHJldHVybiB7TnVtYmVyfVxyXG4gKi9cclxuVmVjMy5wcm90b3R5cGUuZG90ID0gZnVuY3Rpb24odil7XHJcbiAgICByZXR1cm4gdGhpcy54ICogdi54ICsgdGhpcy55ICogdi55ICsgdGhpcy56ICogdi56O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgaXNaZXJvXHJcbiAqIEByZXR1cm4gYm9vbFxyXG4gKi9cclxuVmVjMy5wcm90b3R5cGUuaXNaZXJvID0gZnVuY3Rpb24oKXtcclxuICAgIHJldHVybiB0aGlzLng9PT0wICYmIHRoaXMueT09PTAgJiYgdGhpcy56PT09MDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBNYWtlIHRoZSB2ZWN0b3IgcG9pbnQgaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvbi5cclxuICogQG1ldGhvZCBuZWdhdGVcclxuICogQHBhcmFtIHtWZWMzfSB0YXJnZXQgT3B0aW9uYWwgdGFyZ2V0IHRvIHNhdmUgaW5cclxuICogQHJldHVybiB7VmVjM31cclxuICovXHJcblZlYzMucHJvdG90eXBlLm5lZ2F0ZSA9IGZ1bmN0aW9uKHRhcmdldCl7XHJcbiAgICB0YXJnZXQgPSB0YXJnZXQgfHwgbmV3IFZlYzMoKTtcclxuICAgIHRhcmdldC54ID0gLXRoaXMueDtcclxuICAgIHRhcmdldC55ID0gLXRoaXMueTtcclxuICAgIHRhcmdldC56ID0gLXRoaXMuejtcclxuICAgIHJldHVybiB0YXJnZXQ7XHJcbn07XHJcblxyXG4vKipcclxuICogQ29tcHV0ZSB0d28gYXJ0aWZpY2lhbCB0YW5nZW50cyB0byB0aGUgdmVjdG9yXHJcbiAqIEBtZXRob2QgdGFuZ2VudHNcclxuICogQHBhcmFtIHtWZWMzfSB0MSBWZWN0b3Igb2JqZWN0IHRvIHNhdmUgdGhlIGZpcnN0IHRhbmdlbnQgaW5cclxuICogQHBhcmFtIHtWZWMzfSB0MiBWZWN0b3Igb2JqZWN0IHRvIHNhdmUgdGhlIHNlY29uZCB0YW5nZW50IGluXHJcbiAqL1xyXG52YXIgVmVjM190YW5nZW50c19uID0gbmV3IFZlYzMoKTtcclxudmFyIFZlYzNfdGFuZ2VudHNfcmFuZFZlYyA9IG5ldyBWZWMzKCk7XHJcblZlYzMucHJvdG90eXBlLnRhbmdlbnRzID0gZnVuY3Rpb24odDEsdDIpe1xyXG4gICAgdmFyIG5vcm0gPSB0aGlzLm5vcm0oKTtcclxuICAgIGlmKG5vcm0+MC4wKXtcclxuICAgICAgICB2YXIgbiA9IFZlYzNfdGFuZ2VudHNfbjtcclxuICAgICAgICB2YXIgaW5vcm0gPSAxL25vcm07XHJcbiAgICAgICAgbi5zZXQodGhpcy54Kmlub3JtLHRoaXMueSppbm9ybSx0aGlzLnoqaW5vcm0pO1xyXG4gICAgICAgIHZhciByYW5kVmVjID0gVmVjM190YW5nZW50c19yYW5kVmVjO1xyXG4gICAgICAgIGlmKE1hdGguYWJzKG4ueCkgPCAwLjkpe1xyXG4gICAgICAgICAgICByYW5kVmVjLnNldCgxLDAsMCk7XHJcbiAgICAgICAgICAgIG4uY3Jvc3MocmFuZFZlYyx0MSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmFuZFZlYy5zZXQoMCwxLDApO1xyXG4gICAgICAgICAgICBuLmNyb3NzKHJhbmRWZWMsdDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBuLmNyb3NzKHQxLHQyKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gVGhlIG5vcm1hbCBsZW5ndGggaXMgemVybywgbWFrZSBzb21ldGhpbmcgdXBcclxuICAgICAgICB0MS5zZXQoMSwgMCwgMCk7XHJcbiAgICAgICAgdDIuc2V0KDAsIDEsIDApO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRvIGEgbW9yZSByZWFkYWJsZSBmb3JtYXRcclxuICogQG1ldGhvZCB0b1N0cmluZ1xyXG4gKiBAcmV0dXJuIHN0cmluZ1xyXG4gKi9cclxuVmVjMy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpe1xyXG4gICAgcmV0dXJuIHRoaXMueCtcIixcIit0aGlzLnkrXCIsXCIrdGhpcy56O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRvIGFuIGFycmF5XHJcbiAqIEBtZXRob2QgdG9BcnJheVxyXG4gKiBAcmV0dXJuIEFycmF5XHJcbiAqL1xyXG5WZWMzLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24oKXtcclxuICAgIHJldHVybiBbdGhpcy54LCB0aGlzLnksIHRoaXMuel07XHJcbn07XHJcblxyXG4vKipcclxuICogQ29waWVzIHZhbHVlIG9mIHNvdXJjZSB0byB0aGlzIHZlY3Rvci5cclxuICogQG1ldGhvZCBjb3B5XHJcbiAqIEBwYXJhbSB7VmVjM30gc291cmNlXHJcbiAqIEByZXR1cm4ge1ZlYzN9IHRoaXNcclxuICovXHJcblZlYzMucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbihzb3VyY2Upe1xyXG4gICAgdGhpcy54ID0gc291cmNlLng7XHJcbiAgICB0aGlzLnkgPSBzb3VyY2UueTtcclxuICAgIHRoaXMueiA9IHNvdXJjZS56O1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIERvIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmVjdG9yc1xyXG4gKiBAbWV0aG9kIGxlcnBcclxuICogQHBhcmFtIHtWZWMzfSB2XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IEEgbnVtYmVyIGJldHdlZW4gMCBhbmQgMS4gMCB3aWxsIG1ha2UgdGhpcyBmdW5jdGlvbiByZXR1cm4gdSwgYW5kIDEgd2lsbCBtYWtlIGl0IHJldHVybiB2LiBOdW1iZXJzIGluIGJldHdlZW4gd2lsbCBnZW5lcmF0ZSBhIHZlY3RvciBpbiBiZXR3ZWVuIHRoZW0uXHJcbiAqIEBwYXJhbSB7VmVjM30gdGFyZ2V0XHJcbiAqL1xyXG5WZWMzLnByb3RvdHlwZS5sZXJwID0gZnVuY3Rpb24odix0LHRhcmdldCl7XHJcbiAgICB2YXIgeD10aGlzLngsIHk9dGhpcy55LCB6PXRoaXMuejtcclxuICAgIHRhcmdldC54ID0geCArICh2LngteCkqdDtcclxuICAgIHRhcmdldC55ID0geSArICh2LnkteSkqdDtcclxuICAgIHRhcmdldC56ID0geiArICh2LnoteikqdDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiBhIHZlY3RvciBlcXVhbHMgaXMgYWxtb3N0IGVxdWFsIHRvIGFub3RoZXIgb25lLlxyXG4gKiBAbWV0aG9kIGFsbW9zdEVxdWFsc1xyXG4gKiBAcGFyYW0ge1ZlYzN9IHZcclxuICogQHBhcmFtIHtOdW1iZXJ9IHByZWNpc2lvblxyXG4gKiBAcmV0dXJuIGJvb2xcclxuICovXHJcblZlYzMucHJvdG90eXBlLmFsbW9zdEVxdWFscyA9IGZ1bmN0aW9uKHYscHJlY2lzaW9uKXtcclxuICAgIGlmKHByZWNpc2lvbj09PXVuZGVmaW5lZCl7XHJcbiAgICAgICAgcHJlY2lzaW9uID0gMWUtNjtcclxuICAgIH1cclxuICAgIGlmKCBNYXRoLmFicyh0aGlzLngtdi54KT5wcmVjaXNpb24gfHxcclxuICAgICAgICBNYXRoLmFicyh0aGlzLnktdi55KT5wcmVjaXNpb24gfHxcclxuICAgICAgICBNYXRoLmFicyh0aGlzLnotdi56KT5wcmVjaXNpb24pe1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIGEgdmVjdG9yIGlzIGFsbW9zdCB6ZXJvXHJcbiAqIEBtZXRob2QgYWxtb3N0WmVyb1xyXG4gKiBAcGFyYW0ge051bWJlcn0gcHJlY2lzaW9uXHJcbiAqL1xyXG5WZWMzLnByb3RvdHlwZS5hbG1vc3RaZXJvID0gZnVuY3Rpb24ocHJlY2lzaW9uKXtcclxuICAgIGlmKHByZWNpc2lvbj09PXVuZGVmaW5lZCl7XHJcbiAgICAgICAgcHJlY2lzaW9uID0gMWUtNjtcclxuICAgIH1cclxuICAgIGlmKCBNYXRoLmFicyh0aGlzLngpPnByZWNpc2lvbiB8fFxyXG4gICAgICAgIE1hdGguYWJzKHRoaXMueSk+cHJlY2lzaW9uIHx8XHJcbiAgICAgICAgTWF0aC5hYnModGhpcy56KT5wcmVjaXNpb24pe1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59O1xyXG5cclxudmFyIGFudGlwX25lZyA9IG5ldyBWZWMzKCk7XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgdGhlIHZlY3RvciBpcyBhbnRpLXBhcmFsbGVsIHRvIGFub3RoZXIgdmVjdG9yLlxyXG4gKiBAbWV0aG9kIGlzQW50aXBhcmFsbGVsVG9cclxuICogQHBhcmFtICB7VmVjM30gIHZcclxuICogQHBhcmFtICB7TnVtYmVyfSAgcHJlY2lzaW9uIFNldCB0byB6ZXJvIGZvciBleGFjdCBjb21wYXJpc29uc1xyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gKi9cclxuVmVjMy5wcm90b3R5cGUuaXNBbnRpcGFyYWxsZWxUbyA9IGZ1bmN0aW9uKHYscHJlY2lzaW9uKXtcclxuICAgIHRoaXMubmVnYXRlKGFudGlwX25lZyk7XHJcbiAgICByZXR1cm4gYW50aXBfbmVnLmFsbW9zdEVxdWFscyh2LHByZWNpc2lvbik7XHJcbn07XHJcblxyXG4vKipcclxuICogQ2xvbmUgdGhlIHZlY3RvclxyXG4gKiBAbWV0aG9kIGNsb25lXHJcbiAqIEByZXR1cm4ge1ZlYzN9XHJcbiAqL1xyXG5WZWMzLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCl7XHJcbiAgICByZXR1cm4gbmV3IFZlYzModGhpcy54LCB0aGlzLnksIHRoaXMueik7XHJcbn07XHJcbn0se1wiLi9NYXQzXCI6Mjh9XSwzMjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XHJcbm1vZHVsZS5leHBvcnRzID0gQm9keTtcclxuXHJcbnZhciBFdmVudFRhcmdldCA9IF9kZXJlcV8oJy4uL3V0aWxzL0V2ZW50VGFyZ2V0Jyk7XHJcbnZhciBTaGFwZSA9IF9kZXJlcV8oJy4uL3NoYXBlcy9TaGFwZScpO1xyXG52YXIgVmVjMyA9IF9kZXJlcV8oJy4uL21hdGgvVmVjMycpO1xyXG52YXIgTWF0MyA9IF9kZXJlcV8oJy4uL21hdGgvTWF0MycpO1xyXG52YXIgUXVhdGVybmlvbiA9IF9kZXJlcV8oJy4uL21hdGgvUXVhdGVybmlvbicpO1xyXG52YXIgTWF0ZXJpYWwgPSBfZGVyZXFfKCcuLi9tYXRlcmlhbC9NYXRlcmlhbCcpO1xyXG52YXIgQUFCQiA9IF9kZXJlcV8oJy4uL2NvbGxpc2lvbi9BQUJCJyk7XHJcbnZhciBCb3ggPSBfZGVyZXFfKCcuLi9zaGFwZXMvQm94Jyk7XHJcbnZhciBXb3JsZCA9IF9kZXJlcV8oJy4uL3dvcmxkL1dvcmxkJyk7XHJcblxyXG4vKipcclxuICogQmFzZSBjbGFzcyBmb3IgYWxsIGJvZHkgdHlwZXMuXHJcbiAqIEBjbGFzcyBCb2R5XHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAZXh0ZW5kcyBFdmVudFRhcmdldFxyXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXHJcbiAqIEBwYXJhbSB7VmVjM30gW29wdGlvbnMucG9zaXRpb25dXHJcbiAqIEBwYXJhbSB7VmVjM30gW29wdGlvbnMudmVsb2NpdHldXHJcbiAqIEBwYXJhbSB7VmVjM30gW29wdGlvbnMuYW5ndWxhclZlbG9jaXR5XVxyXG4gKiBAcGFyYW0ge1F1YXRlcm5pb259IFtvcHRpb25zLnF1YXRlcm5pb25dXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXNzXVxyXG4gKiBAcGFyYW0ge01hdGVyaWFsfSBbb3B0aW9ucy5tYXRlcmlhbF1cclxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnR5cGVdXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5saW5lYXJEYW1waW5nPTAuMDFdXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5hbmd1bGFyRGFtcGluZz0wLjAxXVxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmFsbG93U2xlZXA9dHJ1ZV1cclxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnNsZWVwU3BlZWRMaW1pdD0wLjFdXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5zbGVlcFRpbWVMaW1pdD0xXVxyXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuY29sbGlzaW9uRmlsdGVyR3JvdXA9MV1cclxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmNvbGxpc2lvbkZpbHRlck1hc2s9LTFdXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZml4ZWRSb3RhdGlvbj1mYWxzZV1cclxuICogQHBhcmFtIHtWZWMzfSBbb3B0aW9ucy5saW5lYXJGYWN0b3JdXHJcbiAqIEBwYXJhbSB7VmVjM30gW29wdGlvbnMuYW5ndWxhckZhY3Rvcl1cclxuICogQHBhcmFtIHtTaGFwZX0gW29wdGlvbnMuc2hhcGVdXHJcbiAqIEBleGFtcGxlXHJcbiAqICAgICB2YXIgYm9keSA9IG5ldyBCb2R5KHtcclxuICogICAgICAgICBtYXNzOiAxXHJcbiAqICAgICB9KTtcclxuICogICAgIHZhciBzaGFwZSA9IG5ldyBTcGhlcmUoMSk7XHJcbiAqICAgICBib2R5LmFkZFNoYXBlKHNoYXBlKTtcclxuICogICAgIHdvcmxkLmFkZEJvZHkoYm9keSk7XHJcbiAqL1xyXG5mdW5jdGlvbiBCb2R5KG9wdGlvbnMpe1xyXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG4gICAgRXZlbnRUYXJnZXQuYXBwbHkodGhpcyk7XHJcblxyXG4gICAgdGhpcy5pZCA9IEJvZHkuaWRDb3VudGVyKys7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWZlcmVuY2UgdG8gdGhlIHdvcmxkIHRoZSBib2R5IGlzIGxpdmluZyBpblxyXG4gICAgICogQHByb3BlcnR5IHdvcmxkXHJcbiAgICAgKiBAdHlwZSB7V29ybGR9XHJcbiAgICAgKi9cclxuICAgIHRoaXMud29ybGQgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyB1c2VkIEJFRk9SRSBzdGVwcGluZyB0aGUgc3lzdGVtLiBVc2UgaXQgdG8gYXBwbHkgZm9yY2VzLCBmb3IgZXhhbXBsZS4gSW5zaWRlIHRoZSBmdW5jdGlvbiwgXCJ0aGlzXCIgd2lsbCByZWZlciB0byB0aGlzIEJvZHkgb2JqZWN0LlxyXG4gICAgICogQHByb3BlcnR5IHByZVN0ZXBcclxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgICAqIEBkZXByZWNhdGVkIFVzZSBXb3JsZCBldmVudHMgaW5zdGVhZFxyXG4gICAgICovXHJcbiAgICB0aGlzLnByZVN0ZXAgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyB1c2VkIEFGVEVSIHN0ZXBwaW5nIHRoZSBzeXN0ZW0uIEluc2lkZSB0aGUgZnVuY3Rpb24sIFwidGhpc1wiIHdpbGwgcmVmZXIgdG8gdGhpcyBCb2R5IG9iamVjdC5cclxuICAgICAqIEBwcm9wZXJ0eSBwb3N0U3RlcFxyXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIFdvcmxkIGV2ZW50cyBpbnN0ZWFkXHJcbiAgICAgKi9cclxuICAgIHRoaXMucG9zdFN0ZXAgPSBudWxsO1xyXG5cclxuICAgIHRoaXMudmxhbWJkYSA9IG5ldyBWZWMzKCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gY29sbGlzaW9uRmlsdGVyR3JvdXBcclxuICAgICAqL1xyXG4gICAgdGhpcy5jb2xsaXNpb25GaWx0ZXJHcm91cCA9IHR5cGVvZihvcHRpb25zLmNvbGxpc2lvbkZpbHRlckdyb3VwKSA9PT0gJ251bWJlcicgPyBvcHRpb25zLmNvbGxpc2lvbkZpbHRlckdyb3VwIDogMTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBjb2xsaXNpb25GaWx0ZXJNYXNrXHJcbiAgICAgKi9cclxuICAgIHRoaXMuY29sbGlzaW9uRmlsdGVyTWFzayA9IHR5cGVvZihvcHRpb25zLmNvbGxpc2lvbkZpbHRlck1hc2spID09PSAnbnVtYmVyJyA/IG9wdGlvbnMuY29sbGlzaW9uRmlsdGVyTWFzayA6IC0xO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV2hldGhlciB0byBwcm9kdWNlIGNvbnRhY3QgZm9yY2VzIHdoZW4gaW4gY29udGFjdCB3aXRoIG90aGVyIGJvZGllcy4gTm90ZSB0aGF0IGNvbnRhY3RzIHdpbGwgYmUgZ2VuZXJhdGVkLCBidXQgdGhleSB3aWxsIGJlIGRpc2FibGVkLlxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGNvbGxpc2lvblJlc3BvbnNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuY29sbGlzaW9uUmVzcG9uc2UgPSB0cnVlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV29ybGQgc3BhY2UgcG9zaXRpb24gb2YgdGhlIGJvZHkuXHJcbiAgICAgKiBAcHJvcGVydHkgcG9zaXRpb25cclxuICAgICAqIEB0eXBlIHtWZWMzfVxyXG4gICAgICovXHJcbiAgICB0aGlzLnBvc2l0aW9uID0gbmV3IFZlYzMoKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gcHJldmlvdXNQb3NpdGlvblxyXG4gICAgICovXHJcbiAgICB0aGlzLnByZXZpb3VzUG9zaXRpb24gPSBuZXcgVmVjMygpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW50ZXJwb2xhdGVkIHBvc2l0aW9uIG9mIHRoZSBib2R5LlxyXG4gICAgICogQHByb3BlcnR5IHtWZWMzfSBpbnRlcnBvbGF0ZWRQb3NpdGlvblxyXG4gICAgICovXHJcbiAgICB0aGlzLmludGVycG9sYXRlZFBvc2l0aW9uID0gbmV3IFZlYzMoKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEluaXRpYWwgcG9zaXRpb24gb2YgdGhlIGJvZHlcclxuICAgICAqIEBwcm9wZXJ0eSBpbml0UG9zaXRpb25cclxuICAgICAqIEB0eXBlIHtWZWMzfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmluaXRQb3NpdGlvbiA9IG5ldyBWZWMzKCk7XHJcblxyXG4gICAgaWYob3B0aW9ucy5wb3NpdGlvbil7XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbi5jb3B5KG9wdGlvbnMucG9zaXRpb24pO1xyXG4gICAgICAgIHRoaXMucHJldmlvdXNQb3NpdGlvbi5jb3B5KG9wdGlvbnMucG9zaXRpb24pO1xyXG4gICAgICAgIHRoaXMuaW50ZXJwb2xhdGVkUG9zaXRpb24uY29weShvcHRpb25zLnBvc2l0aW9uKTtcclxuICAgICAgICB0aGlzLmluaXRQb3NpdGlvbi5jb3B5KG9wdGlvbnMucG9zaXRpb24pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogV29ybGQgc3BhY2UgdmVsb2NpdHkgb2YgdGhlIGJvZHkuXHJcbiAgICAgKiBAcHJvcGVydHkgdmVsb2NpdHlcclxuICAgICAqIEB0eXBlIHtWZWMzfVxyXG4gICAgICovXHJcbiAgICB0aGlzLnZlbG9jaXR5ID0gbmV3IFZlYzMoKTtcclxuXHJcbiAgICBpZihvcHRpb25zLnZlbG9jaXR5KXtcclxuICAgICAgICB0aGlzLnZlbG9jaXR5LmNvcHkob3B0aW9ucy52ZWxvY2l0eSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkgaW5pdFZlbG9jaXR5XHJcbiAgICAgKiBAdHlwZSB7VmVjM31cclxuICAgICAqL1xyXG4gICAgdGhpcy5pbml0VmVsb2NpdHkgPSBuZXcgVmVjMygpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTGluZWFyIGZvcmNlIG9uIHRoZSBib2R5IGluIHdvcmxkIHNwYWNlLlxyXG4gICAgICogQHByb3BlcnR5IGZvcmNlXHJcbiAgICAgKiBAdHlwZSB7VmVjM31cclxuICAgICAqL1xyXG4gICAgdGhpcy5mb3JjZSA9IG5ldyBWZWMzKCk7XHJcblxyXG4gICAgdmFyIG1hc3MgPSB0eXBlb2Yob3B0aW9ucy5tYXNzKSA9PT0gJ251bWJlcicgPyBvcHRpb25zLm1hc3MgOiAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IG1hc3NcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgKi9cclxuICAgIHRoaXMubWFzcyA9IG1hc3M7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkgaW52TWFzc1xyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5pbnZNYXNzID0gbWFzcyA+IDAgPyAxLjAgLyBtYXNzIDogMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcm9wZXJ0eSBtYXRlcmlhbFxyXG4gICAgICogQHR5cGUge01hdGVyaWFsfVxyXG4gICAgICovXHJcbiAgICB0aGlzLm1hdGVyaWFsID0gb3B0aW9ucy5tYXRlcmlhbCB8fCBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IGxpbmVhckRhbXBpbmdcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubGluZWFyRGFtcGluZyA9IHR5cGVvZihvcHRpb25zLmxpbmVhckRhbXBpbmcpID09PSAnbnVtYmVyJyA/IG9wdGlvbnMubGluZWFyRGFtcGluZyA6IDAuMDE7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBPbmUgb2Y6IEJvZHkuRFlOQU1JQywgQm9keS5TVEFUSUMgYW5kIEJvZHkuS0lORU1BVElDLlxyXG4gICAgICogQHByb3BlcnR5IHR5cGVcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMudHlwZSA9IChtYXNzIDw9IDAuMCA/IEJvZHkuU1RBVElDIDogQm9keS5EWU5BTUlDKTtcclxuICAgIGlmKHR5cGVvZihvcHRpb25zLnR5cGUpID09PSB0eXBlb2YoQm9keS5TVEFUSUMpKXtcclxuICAgICAgICB0aGlzLnR5cGUgPSBvcHRpb25zLnR5cGU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJZiB0cnVlLCB0aGUgYm9keSB3aWxsIGF1dG9tYXRpY2FsbHkgZmFsbCB0byBzbGVlcC5cclxuICAgICAqIEBwcm9wZXJ0eSBhbGxvd1NsZWVwXHJcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAqIEBkZWZhdWx0IHRydWVcclxuICAgICAqL1xyXG4gICAgdGhpcy5hbGxvd1NsZWVwID0gdHlwZW9mKG9wdGlvbnMuYWxsb3dTbGVlcCkgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5hbGxvd1NsZWVwIDogdHJ1ZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEN1cnJlbnQgc2xlZXAgc3RhdGUuXHJcbiAgICAgKiBAcHJvcGVydHkgc2xlZXBTdGF0ZVxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5zbGVlcFN0YXRlID0gMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIElmIHRoZSBzcGVlZCAodGhlIG5vcm0gb2YgdGhlIHZlbG9jaXR5KSBpcyBzbWFsbGVyIHRoYW4gdGhpcyB2YWx1ZSwgdGhlIGJvZHkgaXMgY29uc2lkZXJlZCBzbGVlcHkuXHJcbiAgICAgKiBAcHJvcGVydHkgc2xlZXBTcGVlZExpbWl0XHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgMC4xXHJcbiAgICAgKi9cclxuICAgIHRoaXMuc2xlZXBTcGVlZExpbWl0ID0gdHlwZW9mKG9wdGlvbnMuc2xlZXBTcGVlZExpbWl0KSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLnNsZWVwU3BlZWRMaW1pdCA6IDAuMTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIElmIHRoZSBib2R5IGhhcyBiZWVuIHNsZWVweSBmb3IgdGhpcyBzbGVlcFRpbWVMaW1pdCBzZWNvbmRzLCBpdCBpcyBjb25zaWRlcmVkIHNsZWVwaW5nLlxyXG4gICAgICogQHByb3BlcnR5IHNsZWVwVGltZUxpbWl0XHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgMVxyXG4gICAgICovXHJcbiAgICB0aGlzLnNsZWVwVGltZUxpbWl0ID0gdHlwZW9mKG9wdGlvbnMuc2xlZXBUaW1lTGltaXQpICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMuc2xlZXBUaW1lTGltaXQgOiAxO1xyXG5cclxuICAgIHRoaXMudGltZUxhc3RTbGVlcHkgPSAwO1xyXG5cclxuICAgIHRoaXMuX3dha2VVcEFmdGVyTmFycm93cGhhc2UgPSBmYWxzZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdvcmxkIHNwYWNlIHJvdGF0aW9uYWwgZm9yY2Ugb24gdGhlIGJvZHksIGFyb3VuZCBjZW50ZXIgb2YgbWFzcy5cclxuICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gdG9ycXVlXHJcbiAgICAgKi9cclxuICAgIHRoaXMudG9ycXVlID0gbmV3IFZlYzMoKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdvcmxkIHNwYWNlIG9yaWVudGF0aW9uIG9mIHRoZSBib2R5LlxyXG4gICAgICogQHByb3BlcnR5IHF1YXRlcm5pb25cclxuICAgICAqIEB0eXBlIHtRdWF0ZXJuaW9ufVxyXG4gICAgICovXHJcbiAgICB0aGlzLnF1YXRlcm5pb24gPSBuZXcgUXVhdGVybmlvbigpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IGluaXRRdWF0ZXJuaW9uXHJcbiAgICAgKiBAdHlwZSB7UXVhdGVybmlvbn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5pbml0UXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkge1F1YXRlcm5pb259IHByZXZpb3VzUXVhdGVybmlvblxyXG4gICAgICovXHJcbiAgICB0aGlzLnByZXZpb3VzUXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnRlcnBvbGF0ZWQgb3JpZW50YXRpb24gb2YgdGhlIGJvZHkuXHJcbiAgICAgKiBAcHJvcGVydHkge1F1YXRlcm5pb259IGludGVycG9sYXRlZFF1YXRlcm5pb25cclxuICAgICAqL1xyXG4gICAgdGhpcy5pbnRlcnBvbGF0ZWRRdWF0ZXJuaW9uID0gbmV3IFF1YXRlcm5pb24oKTtcclxuXHJcbiAgICBpZihvcHRpb25zLnF1YXRlcm5pb24pe1xyXG4gICAgICAgIHRoaXMucXVhdGVybmlvbi5jb3B5KG9wdGlvbnMucXVhdGVybmlvbik7XHJcbiAgICAgICAgdGhpcy5pbml0UXVhdGVybmlvbi5jb3B5KG9wdGlvbnMucXVhdGVybmlvbik7XHJcbiAgICAgICAgdGhpcy5wcmV2aW91c1F1YXRlcm5pb24uY29weShvcHRpb25zLnF1YXRlcm5pb24pO1xyXG4gICAgICAgIHRoaXMuaW50ZXJwb2xhdGVkUXVhdGVybmlvbi5jb3B5KG9wdGlvbnMucXVhdGVybmlvbik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbmd1bGFyIHZlbG9jaXR5IG9mIHRoZSBib2R5LCBpbiB3b3JsZCBzcGFjZS4gVGhpbmsgb2YgdGhlIGFuZ3VsYXIgdmVsb2NpdHkgYXMgYSB2ZWN0b3IsIHdoaWNoIHRoZSBib2R5IHJvdGF0ZXMgYXJvdW5kLiBUaGUgbGVuZ3RoIG9mIHRoaXMgdmVjdG9yIGRldGVybWluZXMgaG93IGZhc3QgKGluIHJhZGlhbnMgcGVyIHNlY29uZCkgdGhlIGJvZHkgcm90YXRlcy5cclxuICAgICAqIEBwcm9wZXJ0eSBhbmd1bGFyVmVsb2NpdHlcclxuICAgICAqIEB0eXBlIHtWZWMzfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmFuZ3VsYXJWZWxvY2l0eSA9IG5ldyBWZWMzKCk7XHJcblxyXG4gICAgaWYob3B0aW9ucy5hbmd1bGFyVmVsb2NpdHkpe1xyXG4gICAgICAgIHRoaXMuYW5ndWxhclZlbG9jaXR5LmNvcHkob3B0aW9ucy5hbmd1bGFyVmVsb2NpdHkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IGluaXRBbmd1bGFyVmVsb2NpdHlcclxuICAgICAqIEB0eXBlIHtWZWMzfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmluaXRBbmd1bGFyVmVsb2NpdHkgPSBuZXcgVmVjMygpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IHNoYXBlc1xyXG4gICAgICogQHR5cGUge2FycmF5fVxyXG4gICAgICovXHJcbiAgICB0aGlzLnNoYXBlcyA9IFtdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUG9zaXRpb24gb2YgZWFjaCBTaGFwZSBpbiB0aGUgYm9keSwgZ2l2ZW4gaW4gbG9jYWwgQm9keSBzcGFjZS5cclxuICAgICAqIEBwcm9wZXJ0eSBzaGFwZU9mZnNldHNcclxuICAgICAqIEB0eXBlIHthcnJheX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5zaGFwZU9mZnNldHMgPSBbXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE9yaWVudGF0aW9uIG9mIGVhY2ggU2hhcGUsIGdpdmVuIGluIGxvY2FsIEJvZHkgc3BhY2UuXHJcbiAgICAgKiBAcHJvcGVydHkgc2hhcGVPcmllbnRhdGlvbnNcclxuICAgICAqIEB0eXBlIHthcnJheX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5zaGFwZU9yaWVudGF0aW9ucyA9IFtdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IGluZXJ0aWFcclxuICAgICAqIEB0eXBlIHtWZWMzfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmluZXJ0aWEgPSBuZXcgVmVjMygpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IHtWZWMzfSBpbnZJbmVydGlhXHJcbiAgICAgKi9cclxuICAgIHRoaXMuaW52SW5lcnRpYSA9IG5ldyBWZWMzKCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkge01hdDN9IGludkluZXJ0aWFXb3JsZFxyXG4gICAgICovXHJcbiAgICB0aGlzLmludkluZXJ0aWFXb3JsZCA9IG5ldyBNYXQzKCk7XHJcblxyXG4gICAgdGhpcy5pbnZNYXNzU29sdmUgPSAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IHtWZWMzfSBpbnZJbmVydGlhU29sdmVcclxuICAgICAqL1xyXG4gICAgdGhpcy5pbnZJbmVydGlhU29sdmUgPSBuZXcgVmVjMygpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IHtNYXQzfSBpbnZJbmVydGlhV29ybGRTb2x2ZVxyXG4gICAgICovXHJcbiAgICB0aGlzLmludkluZXJ0aWFXb3JsZFNvbHZlID0gbmV3IE1hdDMoKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0byB0cnVlIGlmIHlvdSBkb24ndCB3YW50IHRoZSBib2R5IHRvIHJvdGF0ZS4gTWFrZSBzdXJlIHRvIHJ1biAudXBkYXRlTWFzc1Byb3BlcnRpZXMoKSBhZnRlciBjaGFuZ2luZyB0aGlzLlxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBmaXhlZFJvdGF0aW9uXHJcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxyXG4gICAgICovXHJcbiAgICB0aGlzLmZpeGVkUm90YXRpb24gPSB0eXBlb2Yob3B0aW9ucy5maXhlZFJvdGF0aW9uKSAhPT0gXCJ1bmRlZmluZWRcIiA/IG9wdGlvbnMuZml4ZWRSb3RhdGlvbiA6IGZhbHNlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogdXNlIGdyYXZpdHkgP1xyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSB1c2VHcmF2aXR5XHJcbiAgICAgKiBAZGVmYXVsdCB0cnVlXHJcbiAgICAgKi9cclxuICAgIHRoaXMudXNlR3Jhdml0eSA9IHRydWU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gYW5ndWxhckRhbXBpbmdcclxuICAgICAqL1xyXG4gICAgdGhpcy5hbmd1bGFyRGFtcGluZyA9IHR5cGVvZihvcHRpb25zLmFuZ3VsYXJEYW1waW5nKSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLmFuZ3VsYXJEYW1waW5nIDogMC4wMTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFVzZSB0aGlzIHByb3BlcnR5IHRvIGxpbWl0IHRoZSBtb3Rpb24gYWxvbmcgYW55IHdvcmxkIGF4aXMuICgxLDEsMSkgd2lsbCBhbGxvdyBtb3Rpb24gYWxvbmcgYWxsIGF4ZXMgd2hpbGUgKDAsMCwwKSBhbGxvd3Mgbm9uZS5cclxuICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gbGluZWFyRmFjdG9yXHJcbiAgICAgKi9cclxuICAgIHRoaXMubGluZWFyRmFjdG9yID0gbmV3IFZlYzMoMSwxLDEpO1xyXG4gICAgaWYob3B0aW9ucy5saW5lYXJGYWN0b3Ipe1xyXG4gICAgICAgIHRoaXMubGluZWFyRmFjdG9yLmNvcHkob3B0aW9ucy5saW5lYXJGYWN0b3IpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXNlIHRoaXMgcHJvcGVydHkgdG8gbGltaXQgdGhlIHJvdGF0aW9uYWwgbW90aW9uIGFsb25nIGFueSB3b3JsZCBheGlzLiAoMSwxLDEpIHdpbGwgYWxsb3cgcm90YXRpb24gYWxvbmcgYWxsIGF4ZXMgd2hpbGUgKDAsMCwwKSBhbGxvd3Mgbm9uZS5cclxuICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gYW5ndWxhckZhY3RvclxyXG4gICAgICovXHJcbiAgICB0aGlzLmFuZ3VsYXJGYWN0b3IgPSBuZXcgVmVjMygxLDEsMSk7XHJcbiAgICBpZihvcHRpb25zLmFuZ3VsYXJGYWN0b3Ipe1xyXG4gICAgICAgIHRoaXMuYW5ndWxhckZhY3Rvci5jb3B5KG9wdGlvbnMuYW5ndWxhckZhY3Rvcik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXb3JsZCBzcGFjZSBib3VuZGluZyBib3ggb2YgdGhlIGJvZHkgYW5kIGl0cyBzaGFwZXMuXHJcbiAgICAgKiBAcHJvcGVydHkgYWFiYlxyXG4gICAgICogQHR5cGUge0FBQkJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuYWFiYiA9IG5ldyBBQUJCKCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbmRpY2F0ZXMgaWYgdGhlIEFBQkIgbmVlZHMgdG8gYmUgdXBkYXRlZCBiZWZvcmUgdXNlLlxyXG4gICAgICogQHByb3BlcnR5IGFhYmJOZWVkc1VwZGF0ZVxyXG4gICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIHRoaXMuYWFiYk5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRvdGFsIGJvdW5kaW5nIHJhZGl1cyBvZiB0aGUgQm9keSBpbmNsdWRpbmcgaXRzIHNoYXBlcywgcmVsYXRpdmUgdG8gYm9keS5wb3NpdGlvbi5cclxuICAgICAqIEBwcm9wZXJ0eSBib3VuZGluZ1JhZGl1c1xyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5ib3VuZGluZ1JhZGl1cyA9IDA7XHJcblxyXG4gICAgdGhpcy53bGFtYmRhID0gbmV3IFZlYzMoKTtcclxuXHJcbiAgICBpZihvcHRpb25zLnNoYXBlKXtcclxuICAgICAgICB0aGlzLmFkZFNoYXBlKG9wdGlvbnMuc2hhcGUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogaGFzIHRyaWdnZXI/XHJcbiAgICAgKi9cclxuICAgIHRoaXMuaGFzVHJpZ2dlciA9IHRydWU7XHJcblxyXG4gICAgdGhpcy51cGRhdGVNYXNzUHJvcGVydGllcygpO1xyXG59XHJcbkJvZHkucHJvdG90eXBlID0gbmV3IEV2ZW50VGFyZ2V0KCk7XHJcbkJvZHkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQm9keTtcclxuXHJcbi8qKlxyXG4gKiBEaXNwYXRjaGVkIGFmdGVyIHR3byBib2RpZXMgY29sbGlkZS4gVGhpcyBldmVudCBpcyBkaXNwYXRjaGVkIG9uIGVhY2hcclxuICogb2YgdGhlIHR3byBib2RpZXMgaW52b2x2ZWQgaW4gdGhlIGNvbGxpc2lvbi5cclxuICogQGV2ZW50IGNvbGxpZGVcclxuICogQHBhcmFtIHtCb2R5fSBib2R5IFRoZSBib2R5IHRoYXQgd2FzIGludm9sdmVkIGluIHRoZSBjb2xsaXNpb24uXHJcbiAqIEBwYXJhbSB7Q29udGFjdEVxdWF0aW9ufSBjb250YWN0IFRoZSBkZXRhaWxzIG9mIHRoZSBjb2xsaXNpb24uXHJcbiAqL1xyXG5Cb2R5LkNPTExJREVfRVZFTlRfTkFNRSA9IFwiY29sbGlkZVwiO1xyXG5cclxuXHJcbi8qKlxyXG4gKiBBIGR5bmFtaWMgYm9keSBpcyBmdWxseSBzaW11bGF0ZWQuIENhbiBiZSBtb3ZlZCBtYW51YWxseSBieSB0aGUgdXNlciwgYnV0IG5vcm1hbGx5IHRoZXkgbW92ZSBhY2NvcmRpbmcgdG8gZm9yY2VzLiBBIGR5bmFtaWMgYm9keSBjYW4gY29sbGlkZSB3aXRoIGFsbCBib2R5IHR5cGVzLiBBIGR5bmFtaWMgYm9keSBhbHdheXMgaGFzIGZpbml0ZSwgbm9uLXplcm8gbWFzcy5cclxuICogQHN0YXRpY1xyXG4gKiBAcHJvcGVydHkgRFlOQU1JQ1xyXG4gKiBAdHlwZSB7TnVtYmVyfVxyXG4gKi9cclxuQm9keS5EWU5BTUlDID0gMTtcclxuXHJcbi8qKlxyXG4gKiBBIHN0YXRpYyBib2R5IGRvZXMgbm90IG1vdmUgZHVyaW5nIHNpbXVsYXRpb24gYW5kIGJlaGF2ZXMgYXMgaWYgaXQgaGFzIGluZmluaXRlIG1hc3MuIFN0YXRpYyBib2RpZXMgY2FuIGJlIG1vdmVkIG1hbnVhbGx5IGJ5IHNldHRpbmcgdGhlIHBvc2l0aW9uIG9mIHRoZSBib2R5LiBUaGUgdmVsb2NpdHkgb2YgYSBzdGF0aWMgYm9keSBpcyBhbHdheXMgemVyby4gU3RhdGljIGJvZGllcyBkbyBub3QgY29sbGlkZSB3aXRoIG90aGVyIHN0YXRpYyBvciBraW5lbWF0aWMgYm9kaWVzLlxyXG4gKiBAc3RhdGljXHJcbiAqIEBwcm9wZXJ0eSBTVEFUSUNcclxuICogQHR5cGUge051bWJlcn1cclxuICovXHJcbkJvZHkuU1RBVElDID0gMjtcclxuXHJcbi8qKlxyXG4gKiBBIGtpbmVtYXRpYyBib2R5IG1vdmVzIHVuZGVyIHNpbXVsYXRpb24gYWNjb3JkaW5nIHRvIGl0cyB2ZWxvY2l0eS4gVGhleSBkbyBub3QgcmVzcG9uZCB0byBmb3JjZXMuIFRoZXkgY2FuIGJlIG1vdmVkIG1hbnVhbGx5LCBidXQgbm9ybWFsbHkgYSBraW5lbWF0aWMgYm9keSBpcyBtb3ZlZCBieSBzZXR0aW5nIGl0cyB2ZWxvY2l0eS4gQSBraW5lbWF0aWMgYm9keSBiZWhhdmVzIGFzIGlmIGl0IGhhcyBpbmZpbml0ZSBtYXNzLiBLaW5lbWF0aWMgYm9kaWVzIGRvIG5vdCBjb2xsaWRlIHdpdGggb3RoZXIgc3RhdGljIG9yIGtpbmVtYXRpYyBib2RpZXMuXHJcbiAqIEBzdGF0aWNcclxuICogQHByb3BlcnR5IEtJTkVNQVRJQ1xyXG4gKiBAdHlwZSB7TnVtYmVyfVxyXG4gKi9cclxuQm9keS5LSU5FTUFUSUMgPSA0O1xyXG5cclxuXHJcblxyXG4vKipcclxuICogQHN0YXRpY1xyXG4gKiBAcHJvcGVydHkgQVdBS0VcclxuICogQHR5cGUge251bWJlcn1cclxuICovXHJcbkJvZHkuQVdBS0UgPSAwO1xyXG5cclxuLyoqXHJcbiAqIEBzdGF0aWNcclxuICogQHByb3BlcnR5IFNMRUVQWVxyXG4gKiBAdHlwZSB7bnVtYmVyfVxyXG4gKi9cclxuQm9keS5TTEVFUFkgPSAxO1xyXG5cclxuLyoqXHJcbiAqIEBzdGF0aWNcclxuICogQHByb3BlcnR5IFNMRUVQSU5HXHJcbiAqIEB0eXBlIHtudW1iZXJ9XHJcbiAqL1xyXG5Cb2R5LlNMRUVQSU5HID0gMjtcclxuXHJcbkJvZHkuaWRDb3VudGVyID0gMDtcclxuXHJcbi8qKlxyXG4gKiBEaXNwYXRjaGVkIGFmdGVyIGEgc2xlZXBpbmcgYm9keSBoYXMgd29rZW4gdXAuXHJcbiAqIEBldmVudCB3YWtldXBcclxuICovXHJcbkJvZHkud2FrZXVwRXZlbnQgPSB7XHJcbiAgICB0eXBlOiBcIndha2V1cFwiXHJcbn07XHJcblxyXG4vKipcclxuICogV2FrZSB0aGUgYm9keSB1cC5cclxuICogQG1ldGhvZCB3YWtlVXBcclxuICovXHJcbkJvZHkucHJvdG90eXBlLndha2VVcCA9IGZ1bmN0aW9uKCl7XHJcbiAgICB2YXIgcyA9IHRoaXMuc2xlZXBTdGF0ZTtcclxuICAgIHRoaXMuc2xlZXBTdGF0ZSA9IDA7XHJcbiAgICB0aGlzLl93YWtlVXBBZnRlck5hcnJvd3BoYXNlID0gZmFsc2U7XHJcbiAgICBpZihzID09PSBCb2R5LlNMRUVQSU5HKXtcclxuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoQm9keS53YWtldXBFdmVudCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogRm9yY2UgYm9keSBzbGVlcFxyXG4gKiBAbWV0aG9kIHNsZWVwXHJcbiAqL1xyXG5Cb2R5LnByb3RvdHlwZS5zbGVlcCA9IGZ1bmN0aW9uKCl7XHJcbiAgICB0aGlzLnNsZWVwU3RhdGUgPSBCb2R5LlNMRUVQSU5HO1xyXG4gICAgdGhpcy52ZWxvY2l0eS5zZXQoMCwwLDApO1xyXG4gICAgdGhpcy5hbmd1bGFyVmVsb2NpdHkuc2V0KDAsMCwwKTtcclxuICAgIHRoaXMuX3dha2VVcEFmdGVyTmFycm93cGhhc2UgPSBmYWxzZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBEaXNwYXRjaGVkIGFmdGVyIGEgYm9keSBoYXMgZ29uZSBpbiB0byB0aGUgc2xlZXB5IHN0YXRlLlxyXG4gKiBAZXZlbnQgc2xlZXB5XHJcbiAqL1xyXG5Cb2R5LnNsZWVweUV2ZW50ID0ge1xyXG4gICAgdHlwZTogXCJzbGVlcHlcIlxyXG59O1xyXG5cclxuLyoqXHJcbiAqIERpc3BhdGNoZWQgYWZ0ZXIgYSBib2R5IGhhcyBmYWxsZW4gYXNsZWVwLlxyXG4gKiBAZXZlbnQgc2xlZXBcclxuICovXHJcbkJvZHkuc2xlZXBFdmVudCA9IHtcclxuICAgIHR5cGU6IFwic2xlZXBcIlxyXG59O1xyXG5cclxuLyoqXHJcbiAqIENhbGxlZCBldmVyeSB0aW1lc3RlcCB0byB1cGRhdGUgaW50ZXJuYWwgc2xlZXAgdGltZXIgYW5kIGNoYW5nZSBzbGVlcCBzdGF0ZSBpZiBuZWVkZWQuXHJcbiAqIEBtZXRob2Qgc2xlZXBUaWNrXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lIFRoZSB3b3JsZCB0aW1lIGluIHNlY29uZHNcclxuICovXHJcbkJvZHkucHJvdG90eXBlLnNsZWVwVGljayA9IGZ1bmN0aW9uKHRpbWUpe1xyXG4gICAgaWYodGhpcy5hbGxvd1NsZWVwKXtcclxuICAgICAgICB2YXIgc2xlZXBTdGF0ZSA9IHRoaXMuc2xlZXBTdGF0ZTtcclxuICAgICAgICB2YXIgc3BlZWRTcXVhcmVkID0gdGhpcy52ZWxvY2l0eS5ub3JtMigpICsgdGhpcy5hbmd1bGFyVmVsb2NpdHkubm9ybTIoKTtcclxuICAgICAgICB2YXIgc3BlZWRMaW1pdFNxdWFyZWQgPSBNYXRoLnBvdyh0aGlzLnNsZWVwU3BlZWRMaW1pdCwyKTtcclxuICAgICAgICBpZihzbGVlcFN0YXRlPT09Qm9keS5BV0FLRSAmJiBzcGVlZFNxdWFyZWQgPCBzcGVlZExpbWl0U3F1YXJlZCl7XHJcbiAgICAgICAgICAgIHRoaXMuc2xlZXBTdGF0ZSA9IEJvZHkuU0xFRVBZOyAvLyBTbGVlcHlcclxuICAgICAgICAgICAgdGhpcy50aW1lTGFzdFNsZWVweSA9IHRpbWU7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChCb2R5LnNsZWVweUV2ZW50KTtcclxuICAgICAgICB9IGVsc2UgaWYoc2xlZXBTdGF0ZT09PUJvZHkuU0xFRVBZICYmIHNwZWVkU3F1YXJlZCA+IHNwZWVkTGltaXRTcXVhcmVkKXtcclxuICAgICAgICAgICAgdGhpcy53YWtlVXAoKTsgLy8gV2FrZSB1cFxyXG4gICAgICAgIH0gZWxzZSBpZihzbGVlcFN0YXRlPT09Qm9keS5TTEVFUFkgJiYgKHRpbWUgLSB0aGlzLnRpbWVMYXN0U2xlZXB5ICkgPiB0aGlzLnNsZWVwVGltZUxpbWl0KXtcclxuICAgICAgICAgICAgdGhpcy5zbGVlcCgpOyAvLyBTbGVlcGluZ1xyXG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoQm9keS5zbGVlcEV2ZW50KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogSWYgdGhlIGJvZHkgaXMgc2xlZXBpbmcsIGl0IHNob3VsZCBiZSBpbW1vdmFibGUgLyBoYXZlIGluZmluaXRlIG1hc3MgZHVyaW5nIHNvbHZlLiBXZSBzb2x2ZSBpdCBieSBoYXZpbmcgYSBzZXBhcmF0ZSBcInNvbHZlIG1hc3NcIi5cclxuICogQG1ldGhvZCB1cGRhdGVTb2x2ZU1hc3NQcm9wZXJ0aWVzXHJcbiAqL1xyXG5Cb2R5LnByb3RvdHlwZS51cGRhdGVTb2x2ZU1hc3NQcm9wZXJ0aWVzID0gZnVuY3Rpb24oKXtcclxuICAgIGlmKHRoaXMuc2xlZXBTdGF0ZSA9PT0gQm9keS5TTEVFUElORyB8fCB0aGlzLnR5cGUgPT09IEJvZHkuS0lORU1BVElDKXtcclxuICAgICAgICB0aGlzLmludk1hc3NTb2x2ZSA9IDA7XHJcbiAgICAgICAgdGhpcy5pbnZJbmVydGlhU29sdmUuc2V0WmVybygpO1xyXG4gICAgICAgIHRoaXMuaW52SW5lcnRpYVdvcmxkU29sdmUuc2V0WmVybygpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmludk1hc3NTb2x2ZSA9IHRoaXMuaW52TWFzcztcclxuICAgICAgICB0aGlzLmludkluZXJ0aWFTb2x2ZS5jb3B5KHRoaXMuaW52SW5lcnRpYSk7XHJcbiAgICAgICAgdGhpcy5pbnZJbmVydGlhV29ybGRTb2x2ZS5jb3B5KHRoaXMuaW52SW5lcnRpYVdvcmxkKTtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0IGEgd29ybGQgcG9pbnQgdG8gbG9jYWwgYm9keSBmcmFtZS5cclxuICogQG1ldGhvZCBwb2ludFRvTG9jYWxGcmFtZVxyXG4gKiBAcGFyYW0gIHtWZWMzfSB3b3JsZFBvaW50XHJcbiAqIEBwYXJhbSAge1ZlYzN9IHJlc3VsdFxyXG4gKiBAcmV0dXJuIHtWZWMzfVxyXG4gKi9cclxuQm9keS5wcm90b3R5cGUucG9pbnRUb0xvY2FsRnJhbWUgPSBmdW5jdGlvbih3b3JsZFBvaW50LHJlc3VsdCl7XHJcbiAgICB2YXIgcmVzdWx0ID0gcmVzdWx0IHx8IG5ldyBWZWMzKCk7XHJcbiAgICB3b3JsZFBvaW50LnZzdWIodGhpcy5wb3NpdGlvbixyZXN1bHQpO1xyXG4gICAgdGhpcy5xdWF0ZXJuaW9uLmNvbmp1Z2F0ZSgpLnZtdWx0KHJlc3VsdCxyZXN1bHQpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0IGEgd29ybGQgdmVjdG9yIHRvIGxvY2FsIGJvZHkgZnJhbWUuXHJcbiAqIEBtZXRob2QgdmVjdG9yVG9Mb2NhbEZyYW1lXHJcbiAqIEBwYXJhbSAge1ZlYzN9IHdvcmxkUG9pbnRcclxuICogQHBhcmFtICB7VmVjM30gcmVzdWx0XHJcbiAqIEByZXR1cm4ge1ZlYzN9XHJcbiAqL1xyXG5Cb2R5LnByb3RvdHlwZS52ZWN0b3JUb0xvY2FsRnJhbWUgPSBmdW5jdGlvbih3b3JsZFZlY3RvciwgcmVzdWx0KXtcclxuICAgIHZhciByZXN1bHQgPSByZXN1bHQgfHwgbmV3IFZlYzMoKTtcclxuICAgIHRoaXMucXVhdGVybmlvbi5jb25qdWdhdGUoKS52bXVsdCh3b3JsZFZlY3RvcixyZXN1bHQpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0IGEgbG9jYWwgYm9keSBwb2ludCB0byB3b3JsZCBmcmFtZS5cclxuICogQG1ldGhvZCBwb2ludFRvV29ybGRGcmFtZVxyXG4gKiBAcGFyYW0gIHtWZWMzfSBsb2NhbFBvaW50XHJcbiAqIEBwYXJhbSAge1ZlYzN9IHJlc3VsdFxyXG4gKiBAcmV0dXJuIHtWZWMzfVxyXG4gKi9cclxuQm9keS5wcm90b3R5cGUucG9pbnRUb1dvcmxkRnJhbWUgPSBmdW5jdGlvbihsb2NhbFBvaW50LHJlc3VsdCl7XHJcbiAgICB2YXIgcmVzdWx0ID0gcmVzdWx0IHx8IG5ldyBWZWMzKCk7XHJcbiAgICB0aGlzLnF1YXRlcm5pb24udm11bHQobG9jYWxQb2ludCxyZXN1bHQpO1xyXG4gICAgcmVzdWx0LnZhZGQodGhpcy5wb3NpdGlvbixyZXN1bHQpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0IGEgbG9jYWwgYm9keSBwb2ludCB0byB3b3JsZCBmcmFtZS5cclxuICogQG1ldGhvZCB2ZWN0b3JUb1dvcmxkRnJhbWVcclxuICogQHBhcmFtICB7VmVjM30gbG9jYWxWZWN0b3JcclxuICogQHBhcmFtICB7VmVjM30gcmVzdWx0XHJcbiAqIEByZXR1cm4ge1ZlYzN9XHJcbiAqL1xyXG5Cb2R5LnByb3RvdHlwZS52ZWN0b3JUb1dvcmxkRnJhbWUgPSBmdW5jdGlvbihsb2NhbFZlY3RvciwgcmVzdWx0KXtcclxuICAgIHZhciByZXN1bHQgPSByZXN1bHQgfHwgbmV3IFZlYzMoKTtcclxuICAgIHRoaXMucXVhdGVybmlvbi52bXVsdChsb2NhbFZlY3RvciwgcmVzdWx0KTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG52YXIgdG1wVmVjID0gbmV3IFZlYzMoKTtcclxudmFyIHRtcFF1YXQgPSBuZXcgUXVhdGVybmlvbigpO1xyXG5cclxuLyoqXHJcbiAqIEFkZCBhIHNoYXBlIHRvIHRoZSBib2R5IHdpdGggYSBsb2NhbCBvZmZzZXQgYW5kIG9yaWVudGF0aW9uLlxyXG4gKiBAbWV0aG9kIGFkZFNoYXBlXHJcbiAqIEBwYXJhbSB7U2hhcGV9IHNoYXBlXHJcbiAqIEBwYXJhbSB7VmVjM30gW19vZmZzZXRdXHJcbiAqIEBwYXJhbSB7UXVhdGVybmlvbn0gW19vcmllbnRhdGlvbl1cclxuICogQHJldHVybiB7Qm9keX0gVGhlIGJvZHkgb2JqZWN0LCBmb3IgY2hhaW5hYmlsaXR5LlxyXG4gKi9cclxuQm9keS5wcm90b3R5cGUuYWRkU2hhcGUgPSBmdW5jdGlvbihzaGFwZSwgX29mZnNldCwgX29yaWVudGF0aW9uKXtcclxuXHJcbiAgICB2YXIgb2Zmc2V0O1xyXG4gICAgdmFyIG9yaWVudGF0aW9uO1xyXG5cclxuICAgIGlmIChERUJVRykge1xyXG4gICAgICAgIG9mZnNldCA9IG5ldyBWZWMzKCk7XHJcbiAgICAgICAgb3JpZW50YXRpb24gPSBuZXcgUXVhdGVybmlvbigpO1xyXG4gICAgICAgIGlmIChfb2Zmc2V0KSB7XHJcbiAgICAgICAgICAgIG9mZnNldC5jb3B5KF9vZmZzZXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoX29yaWVudGF0aW9uKSB7XHJcbiAgICAgICAgICAgIG9yaWVudGF0aW9uLmNvcHkoX29yaWVudGF0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIG9mZnNldCA9IF9vZmZzZXQ7XHJcbiAgICAgICAgb3JpZW50YXRpb24gPSBfb3JpZW50YXRpb247XHJcbiAgICAgICAgaWYgKCFvZmZzZXQpIHtcclxuICAgICAgICAgICAgb2Zmc2V0ID0gbmV3IFZlYzMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFvcmllbnRhdGlvbikge1xyXG4gICAgICAgICAgICBvcmllbnRhdGlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIFdvcmxkLmlkVG9TaGFwZU1hcFtzaGFwZS5pZF0gPSBzaGFwZTtcclxuICAgIHRoaXMuc2hhcGVzLnB1c2goc2hhcGUpO1xyXG4gICAgdGhpcy5zaGFwZU9mZnNldHMucHVzaChvZmZzZXQpO1xyXG4gICAgdGhpcy5zaGFwZU9yaWVudGF0aW9ucy5wdXNoKG9yaWVudGF0aW9uKTtcclxuICAgIHRoaXMudXBkYXRlTWFzc1Byb3BlcnRpZXMoKTtcclxuICAgIHRoaXMudXBkYXRlQm91bmRpbmdSYWRpdXMoKTtcclxuXHJcbiAgICB0aGlzLmFhYmJOZWVkc1VwZGF0ZSA9IHRydWU7XHJcbiAgICB0aGlzLnVwZGF0ZUhhc1RyaWdnZXIoKTtcclxuICAgIHNoYXBlLmJvZHkgPSB0aGlzO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogUmVtb3ZlIGEgc2hhcGUgZnJvbSB0aGUgYm9keVxyXG4gKi9cclxuQm9keS5wcm90b3R5cGUucmVtb3ZlU2hhcGUgPSBmdW5jdGlvbihzaGFwZSl7ICAgXHJcbiAgICB2YXIgaWR4ID0gdGhpcy5zaGFwZXMuaW5kZXhPZihzaGFwZSk7XHJcbiAgICBpZiAoaWR4ID09PSAtMSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIC8vIHNoYXBlLmJvZHkgPSBudWxsOyAgbmVlZGVkID9cclxuICAgIC8vIGRlbGV0ZSBXb3JsZC5pZFRvU2hhcGVNYXBbc2hhcGUuaWRdOyAgbmVlZGVkID9cclxuXHJcbiAgICB0aGlzLnNoYXBlcy5zcGxpY2UoaWR4LCAxKTtcclxuICAgIHRoaXMuc2hhcGVPZmZzZXRzLnNwbGljZShpZHgsIDEpO1xyXG4gICAgdGhpcy5zaGFwZU9yaWVudGF0aW9ucy5zcGxpY2UoaWR4LCAxKTtcclxuXHJcbiAgICB0aGlzLnVwZGF0ZU1hc3NQcm9wZXJ0aWVzKCk7XHJcbiAgICB0aGlzLnVwZGF0ZUJvdW5kaW5nUmFkaXVzKCk7XHJcblxyXG4gICAgdGhpcy5hYWJiTmVlZHNVcGRhdGUgPSB0cnVlO1xyXG4gICAgdGhpcy51cGRhdGVIYXNUcmlnZ2VyKCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBVcGRhdGUgdGhlIGJvdW5kaW5nIHJhZGl1cyBvZiB0aGUgYm9keS4gU2hvdWxkIGJlIGRvbmUgaWYgYW55IG9mIHRoZSBzaGFwZXMgYXJlIGNoYW5nZWQuXHJcbiAqIEBtZXRob2QgdXBkYXRlQm91bmRpbmdSYWRpdXNcclxuICovXHJcbkJvZHkucHJvdG90eXBlLnVwZGF0ZUJvdW5kaW5nUmFkaXVzID0gZnVuY3Rpb24oKXtcclxuICAgIHZhciBzaGFwZXMgPSB0aGlzLnNoYXBlcyxcclxuICAgICAgICBzaGFwZU9mZnNldHMgPSB0aGlzLnNoYXBlT2Zmc2V0cyxcclxuICAgICAgICBOID0gc2hhcGVzLmxlbmd0aCxcclxuICAgICAgICByYWRpdXMgPSAwO1xyXG5cclxuICAgIGZvcih2YXIgaT0wOyBpIT09TjsgaSsrKXtcclxuICAgICAgICB2YXIgc2hhcGUgPSBzaGFwZXNbaV07XHJcbiAgICAgICAgc2hhcGUudXBkYXRlQm91bmRpbmdTcGhlcmVSYWRpdXMoKTtcclxuICAgICAgICB2YXIgb2Zmc2V0ID0gc2hhcGVPZmZzZXRzW2ldLm5vcm0oKSxcclxuICAgICAgICAgICAgciA9IHNoYXBlLmJvdW5kaW5nU3BoZXJlUmFkaXVzO1xyXG4gICAgICAgIGlmKG9mZnNldCArIHIgPiByYWRpdXMpe1xyXG4gICAgICAgICAgICByYWRpdXMgPSBvZmZzZXQgKyByO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmJvdW5kaW5nUmFkaXVzID0gcmFkaXVzO1xyXG59O1xyXG5cclxudmFyIGNvbXB1dGVBQUJCX3NoYXBlQUFCQiA9IG5ldyBBQUJCKCk7XHJcblxyXG4vKipcclxuICogVXBkYXRlcyB0aGUgLmFhYmJcclxuICogQG1ldGhvZCBjb21wdXRlQUFCQlxyXG4gKiBAdG9kbyByZW5hbWUgdG8gdXBkYXRlQUFCQigpXHJcbiAqL1xyXG5Cb2R5LnByb3RvdHlwZS5jb21wdXRlQUFCQiA9IGZ1bmN0aW9uKCl7XHJcbiAgICB2YXIgc2hhcGVzID0gdGhpcy5zaGFwZXMsXHJcbiAgICAgICAgc2hhcGVPZmZzZXRzID0gdGhpcy5zaGFwZU9mZnNldHMsXHJcbiAgICAgICAgc2hhcGVPcmllbnRhdGlvbnMgPSB0aGlzLnNoYXBlT3JpZW50YXRpb25zLFxyXG4gICAgICAgIE4gPSBzaGFwZXMubGVuZ3RoLFxyXG4gICAgICAgIG9mZnNldCA9IHRtcFZlYyxcclxuICAgICAgICBvcmllbnRhdGlvbiA9IHRtcFF1YXQsXHJcbiAgICAgICAgYm9keVF1YXQgPSB0aGlzLnF1YXRlcm5pb24sXHJcbiAgICAgICAgYWFiYiA9IHRoaXMuYWFiYixcclxuICAgICAgICBzaGFwZUFBQkIgPSBjb21wdXRlQUFCQl9zaGFwZUFBQkI7XHJcblxyXG4gICAgZm9yKHZhciBpPTA7IGkhPT1OOyBpKyspe1xyXG4gICAgICAgIHZhciBzaGFwZSA9IHNoYXBlc1tpXTtcclxuXHJcbiAgICAgICAgLy8gR2V0IHNoYXBlIHdvcmxkIHBvc2l0aW9uXHJcbiAgICAgICAgYm9keVF1YXQudm11bHQoc2hhcGVPZmZzZXRzW2ldLCBvZmZzZXQpO1xyXG4gICAgICAgIG9mZnNldC52YWRkKHRoaXMucG9zaXRpb24sIG9mZnNldCk7XHJcblxyXG4gICAgICAgIC8vIEdldCBzaGFwZSB3b3JsZCBxdWF0ZXJuaW9uXHJcbiAgICAgICAgc2hhcGVPcmllbnRhdGlvbnNbaV0ubXVsdChib2R5UXVhdCwgb3JpZW50YXRpb24pO1xyXG5cclxuICAgICAgICAvLyBHZXQgc2hhcGUgQUFCQlxyXG4gICAgICAgIHNoYXBlLmNhbGN1bGF0ZVdvcmxkQUFCQihvZmZzZXQsIG9yaWVudGF0aW9uLCBzaGFwZUFBQkIubG93ZXJCb3VuZCwgc2hhcGVBQUJCLnVwcGVyQm91bmQpO1xyXG5cclxuICAgICAgICBpZihpID09PSAwKXtcclxuICAgICAgICAgICAgYWFiYi5jb3B5KHNoYXBlQUFCQik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgYWFiYi5leHRlbmQoc2hhcGVBQUJCKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5hYWJiTmVlZHNVcGRhdGUgPSBmYWxzZTtcclxufTtcclxuXHJcbnZhciB1aXdfbTEgPSBuZXcgTWF0MygpLFxyXG4gICAgdWl3X20yID0gbmV3IE1hdDMoKSxcclxuICAgIHVpd19tMyA9IG5ldyBNYXQzKCk7XHJcblxyXG4vKipcclxuICogVXBkYXRlIC5pbmVydGlhV29ybGQgYW5kIC5pbnZJbmVydGlhV29ybGRcclxuICogQG1ldGhvZCB1cGRhdGVJbmVydGlhV29ybGRcclxuICovXHJcbkJvZHkucHJvdG90eXBlLnVwZGF0ZUluZXJ0aWFXb3JsZCA9IGZ1bmN0aW9uKGZvcmNlKXtcclxuICAgIHZhciBJID0gdGhpcy5pbnZJbmVydGlhO1xyXG4gICAgaWYgKEkueCA9PT0gSS55ICYmIEkueSA9PT0gSS56ICYmICFmb3JjZSkge1xyXG4gICAgICAgIC8vIElmIGluZXJ0aWEgTSA9IHMqSSwgd2hlcmUgSSBpcyBpZGVudGl0eSBhbmQgcyBhIHNjYWxhciwgdGhlblxyXG4gICAgICAgIC8vICAgIFIqTSpSJyA9IFIqKHMqSSkqUicgPSBzKlIqSSpSJyA9IHMqUipSJyA9IHMqSSA9IE1cclxuICAgICAgICAvLyB3aGVyZSBSIGlzIHRoZSByb3RhdGlvbiBtYXRyaXguXHJcbiAgICAgICAgLy8gSW4gb3RoZXIgd29yZHMsIHdlIGRvbid0IGhhdmUgdG8gdHJhbnNmb3JtIHRoZSBpbmVydGlhIGlmIGFsbFxyXG4gICAgICAgIC8vIGluZXJ0aWEgZGlhZ29uYWwgZW50cmllcyBhcmUgZXF1YWwuXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHZhciBtMSA9IHVpd19tMSxcclxuICAgICAgICAgICAgbTIgPSB1aXdfbTIsXHJcbiAgICAgICAgICAgIG0zID0gdWl3X20zO1xyXG4gICAgICAgIG0xLnNldFJvdGF0aW9uRnJvbVF1YXRlcm5pb24odGhpcy5xdWF0ZXJuaW9uKTtcclxuICAgICAgICBtMS50cmFuc3Bvc2UobTIpO1xyXG4gICAgICAgIG0xLnNjYWxlKEksbTEpO1xyXG4gICAgICAgIG0xLm1tdWx0KG0yLHRoaXMuaW52SW5lcnRpYVdvcmxkKTtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBBcHBseSBmb3JjZSB0byBhIHdvcmxkIHBvaW50LiBUaGlzIGNvdWxkIGZvciBleGFtcGxlIGJlIGEgcG9pbnQgb24gdGhlIEJvZHkgc3VyZmFjZS4gQXBwbHlpbmcgZm9yY2UgdGhpcyB3YXkgd2lsbCBhZGQgdG8gQm9keS5mb3JjZSBhbmQgQm9keS50b3JxdWUuXHJcbiAqIEBtZXRob2QgYXBwbHlGb3JjZVxyXG4gKiBAcGFyYW0gIHtWZWMzfSBmb3JjZSBUaGUgYW1vdW50IG9mIGZvcmNlIHRvIGFkZC5cclxuICogQHBhcmFtICB7VmVjM30gcmVsYXRpdmVQb2ludCBBIHBvaW50IHJlbGF0aXZlIHRvIHRoZSBjZW50ZXIgb2YgbWFzcyB0byBhcHBseSB0aGUgZm9yY2Ugb24uXHJcbiAqL1xyXG4vLyB2YXIgQm9keV9hcHBseUZvcmNlX3IgPSBuZXcgVmVjMygpO1xyXG52YXIgQm9keV9hcHBseUZvcmNlX3JvdEZvcmNlID0gbmV3IFZlYzMoKTtcclxuQm9keS5wcm90b3R5cGUuYXBwbHlGb3JjZSA9IGZ1bmN0aW9uKGZvcmNlLHJlbGF0aXZlUG9pbnQpe1xyXG4gICAgaWYodGhpcy50eXBlICE9PSBCb2R5LkRZTkFNSUMpeyAvLyBOZWVkZWQ/XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENvbXB1dGUgcHJvZHVjZWQgcm90YXRpb25hbCBmb3JjZVxyXG4gICAgdmFyIHJvdEZvcmNlID0gQm9keV9hcHBseUZvcmNlX3JvdEZvcmNlO1xyXG4gICAgcmVsYXRpdmVQb2ludC5jcm9zcyhmb3JjZSxyb3RGb3JjZSk7XHJcblxyXG4gICAgLy8gQWRkIGxpbmVhciBmb3JjZVxyXG4gICAgdGhpcy5mb3JjZS52YWRkKGZvcmNlLHRoaXMuZm9yY2UpO1xyXG5cclxuICAgIC8vIEFkZCByb3RhdGlvbmFsIGZvcmNlXHJcbiAgICB0aGlzLnRvcnF1ZS52YWRkKHJvdEZvcmNlLHRoaXMudG9ycXVlKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBcHBseSBmb3JjZSB0byBhIGxvY2FsIHBvaW50IGluIHRoZSBib2R5LlxyXG4gKiBAbWV0aG9kIGFwcGx5TG9jYWxGb3JjZVxyXG4gKiBAcGFyYW0gIHtWZWMzfSBmb3JjZSBUaGUgZm9yY2UgdmVjdG9yIHRvIGFwcGx5LCBkZWZpbmVkIGxvY2FsbHkgaW4gdGhlIGJvZHkgZnJhbWUuXHJcbiAqIEBwYXJhbSAge1ZlYzN9IGxvY2FsUG9pbnQgQSBsb2NhbCBwb2ludCBpbiB0aGUgYm9keSB0byBhcHBseSB0aGUgZm9yY2Ugb24uXHJcbiAqL1xyXG52YXIgQm9keV9hcHBseUxvY2FsRm9yY2Vfd29ybGRGb3JjZSA9IG5ldyBWZWMzKCk7XHJcbnZhciBCb2R5X2FwcGx5TG9jYWxGb3JjZV9yZWxhdGl2ZVBvaW50V29ybGQgPSBuZXcgVmVjMygpO1xyXG5Cb2R5LnByb3RvdHlwZS5hcHBseUxvY2FsRm9yY2UgPSBmdW5jdGlvbihsb2NhbEZvcmNlLCBsb2NhbFBvaW50KXtcclxuICAgIGlmKHRoaXMudHlwZSAhPT0gQm9keS5EWU5BTUlDKXtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHdvcmxkRm9yY2UgPSBCb2R5X2FwcGx5TG9jYWxGb3JjZV93b3JsZEZvcmNlO1xyXG4gICAgdmFyIHJlbGF0aXZlUG9pbnRXb3JsZCA9IEJvZHlfYXBwbHlMb2NhbEZvcmNlX3JlbGF0aXZlUG9pbnRXb3JsZDtcclxuXHJcbiAgICAvLyBUcmFuc2Zvcm0gdGhlIGZvcmNlIHZlY3RvciB0byB3b3JsZCBzcGFjZVxyXG4gICAgdGhpcy52ZWN0b3JUb1dvcmxkRnJhbWUobG9jYWxGb3JjZSwgd29ybGRGb3JjZSk7XHJcbiAgICB0aGlzLnZlY3RvclRvV29ybGRGcmFtZShsb2NhbFBvaW50LCByZWxhdGl2ZVBvaW50V29ybGQpO1xyXG5cclxuICAgIHRoaXMuYXBwbHlGb3JjZSh3b3JsZEZvcmNlLCByZWxhdGl2ZVBvaW50V29ybGQpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFwcGx5IGltcHVsc2UgdG8gYSB3b3JsZCBwb2ludC4gVGhpcyBjb3VsZCBmb3IgZXhhbXBsZSBiZSBhIHBvaW50IG9uIHRoZSBCb2R5IHN1cmZhY2UuIEFuIGltcHVsc2UgaXMgYSBmb3JjZSBhZGRlZCB0byBhIGJvZHkgZHVyaW5nIGEgc2hvcnQgcGVyaW9kIG9mIHRpbWUgKGltcHVsc2UgPSBmb3JjZSAqIHRpbWUpLiBJbXB1bHNlcyB3aWxsIGJlIGFkZGVkIHRvIEJvZHkudmVsb2NpdHkgYW5kIEJvZHkuYW5ndWxhclZlbG9jaXR5LlxyXG4gKiBAbWV0aG9kIGFwcGx5SW1wdWxzZVxyXG4gKiBAcGFyYW0gIHtWZWMzfSBpbXB1bHNlIFRoZSBhbW91bnQgb2YgaW1wdWxzZSB0byBhZGQuXHJcbiAqIEBwYXJhbSAge1ZlYzN9IHJlbGF0aXZlUG9pbnQgQSBwb2ludCByZWxhdGl2ZSB0byB0aGUgY2VudGVyIG9mIG1hc3MgdG8gYXBwbHkgdGhlIGZvcmNlIG9uLlxyXG4gKi9cclxuLy8gdmFyIEJvZHlfYXBwbHlJbXB1bHNlX3IgPSBuZXcgVmVjMygpO1xyXG52YXIgQm9keV9hcHBseUltcHVsc2VfdmVsbyA9IG5ldyBWZWMzKCk7XHJcbnZhciBCb2R5X2FwcGx5SW1wdWxzZV9yb3RWZWxvID0gbmV3IFZlYzMoKTtcclxuQm9keS5wcm90b3R5cGUuYXBwbHlJbXB1bHNlID0gZnVuY3Rpb24oaW1wdWxzZSwgcmVsYXRpdmVQb2ludCl7XHJcbiAgICBpZih0aGlzLnR5cGUgIT09IEJvZHkuRFlOQU1JQyl7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENvbXB1dGUgcG9pbnQgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIGJvZHkgY2VudGVyXHJcbiAgICB2YXIgciA9IHJlbGF0aXZlUG9pbnQ7XHJcblxyXG4gICAgLy8gQ29tcHV0ZSBwcm9kdWNlZCBjZW50cmFsIGltcHVsc2UgdmVsb2NpdHlcclxuICAgIHZhciB2ZWxvID0gQm9keV9hcHBseUltcHVsc2VfdmVsbztcclxuICAgIHZlbG8uY29weShpbXB1bHNlKTtcclxuICAgIHZlbG8ubXVsdCh0aGlzLmludk1hc3MsdmVsbyk7XHJcblxyXG4gICAgLy8gQWRkIGxpbmVhciBpbXB1bHNlXHJcbiAgICB0aGlzLnZlbG9jaXR5LnZhZGQodmVsbywgdGhpcy52ZWxvY2l0eSk7XHJcblxyXG4gICAgLy8gQ29tcHV0ZSBwcm9kdWNlZCByb3RhdGlvbmFsIGltcHVsc2UgdmVsb2NpdHlcclxuICAgIHZhciByb3RWZWxvID0gQm9keV9hcHBseUltcHVsc2Vfcm90VmVsbztcclxuICAgIHIuY3Jvc3MoaW1wdWxzZSxyb3RWZWxvKTtcclxuXHJcbiAgICAvKlxyXG4gICAgcm90VmVsby54ICo9IHRoaXMuaW52SW5lcnRpYS54O1xyXG4gICAgcm90VmVsby55ICo9IHRoaXMuaW52SW5lcnRpYS55O1xyXG4gICAgcm90VmVsby56ICo9IHRoaXMuaW52SW5lcnRpYS56O1xyXG4gICAgKi9cclxuICAgIHRoaXMuaW52SW5lcnRpYVdvcmxkLnZtdWx0KHJvdFZlbG8scm90VmVsbyk7XHJcblxyXG4gICAgLy8gQWRkIHJvdGF0aW9uYWwgSW1wdWxzZVxyXG4gICAgdGhpcy5hbmd1bGFyVmVsb2NpdHkudmFkZChyb3RWZWxvLCB0aGlzLmFuZ3VsYXJWZWxvY2l0eSk7XHJcbn07XHJcblxyXG4vKipcclxuICogQXBwbHkgbG9jYWxseS1kZWZpbmVkIGltcHVsc2UgdG8gYSBsb2NhbCBwb2ludCBpbiB0aGUgYm9keS5cclxuICogQG1ldGhvZCBhcHBseUxvY2FsSW1wdWxzZVxyXG4gKiBAcGFyYW0gIHtWZWMzfSBmb3JjZSBUaGUgZm9yY2UgdmVjdG9yIHRvIGFwcGx5LCBkZWZpbmVkIGxvY2FsbHkgaW4gdGhlIGJvZHkgZnJhbWUuXHJcbiAqIEBwYXJhbSAge1ZlYzN9IGxvY2FsUG9pbnQgQSBsb2NhbCBwb2ludCBpbiB0aGUgYm9keSB0byBhcHBseSB0aGUgZm9yY2Ugb24uXHJcbiAqL1xyXG52YXIgQm9keV9hcHBseUxvY2FsSW1wdWxzZV93b3JsZEltcHVsc2UgPSBuZXcgVmVjMygpO1xyXG52YXIgQm9keV9hcHBseUxvY2FsSW1wdWxzZV9yZWxhdGl2ZVBvaW50ID0gbmV3IFZlYzMoKTtcclxuQm9keS5wcm90b3R5cGUuYXBwbHlMb2NhbEltcHVsc2UgPSBmdW5jdGlvbihsb2NhbEltcHVsc2UsIGxvY2FsUG9pbnQpe1xyXG4gICAgaWYodGhpcy50eXBlICE9PSBCb2R5LkRZTkFNSUMpe1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgd29ybGRJbXB1bHNlID0gQm9keV9hcHBseUxvY2FsSW1wdWxzZV93b3JsZEltcHVsc2U7XHJcbiAgICB2YXIgcmVsYXRpdmVQb2ludFdvcmxkID0gQm9keV9hcHBseUxvY2FsSW1wdWxzZV9yZWxhdGl2ZVBvaW50O1xyXG5cclxuICAgIC8vIFRyYW5zZm9ybSB0aGUgZm9yY2UgdmVjdG9yIHRvIHdvcmxkIHNwYWNlXHJcbiAgICB0aGlzLnZlY3RvclRvV29ybGRGcmFtZShsb2NhbEltcHVsc2UsIHdvcmxkSW1wdWxzZSk7XHJcbiAgICB0aGlzLnZlY3RvclRvV29ybGRGcmFtZShsb2NhbFBvaW50LCByZWxhdGl2ZVBvaW50V29ybGQpO1xyXG5cclxuICAgIHRoaXMuYXBwbHlJbXB1bHNlKHdvcmxkSW1wdWxzZSwgcmVsYXRpdmVQb2ludFdvcmxkKTtcclxufTtcclxuXHJcbnZhciBCb2R5X3VwZGF0ZU1hc3NQcm9wZXJ0aWVzX2hhbGZFeHRlbnRzID0gbmV3IFZlYzMoKTtcclxuXHJcbi8qKlxyXG4gKiBTaG91bGQgYmUgY2FsbGVkIHdoZW5ldmVyIHlvdSBjaGFuZ2UgdGhlIGJvZHkgc2hhcGUgb3IgbWFzcy5cclxuICogQG1ldGhvZCB1cGRhdGVNYXNzUHJvcGVydGllc1xyXG4gKi9cclxuQm9keS5wcm90b3R5cGUudXBkYXRlTWFzc1Byb3BlcnRpZXMgPSBmdW5jdGlvbigpe1xyXG4gICAgdmFyIGhhbGZFeHRlbnRzID0gQm9keV91cGRhdGVNYXNzUHJvcGVydGllc19oYWxmRXh0ZW50cztcclxuXHJcbiAgICB0aGlzLmludk1hc3MgPSB0aGlzLm1hc3MgPiAwID8gMS4wIC8gdGhpcy5tYXNzIDogMDtcclxuICAgIHZhciBJID0gdGhpcy5pbmVydGlhO1xyXG4gICAgdmFyIGZpeGVkID0gdGhpcy5maXhlZFJvdGF0aW9uO1xyXG5cclxuICAgIC8vIEFwcHJveGltYXRlIHdpdGggQUFCQiBib3hcclxuICAgIHRoaXMuY29tcHV0ZUFBQkIoKTtcclxuICAgIGhhbGZFeHRlbnRzLnNldChcclxuICAgICAgICAodGhpcy5hYWJiLnVwcGVyQm91bmQueC10aGlzLmFhYmIubG93ZXJCb3VuZC54KSAvIDIsXHJcbiAgICAgICAgKHRoaXMuYWFiYi51cHBlckJvdW5kLnktdGhpcy5hYWJiLmxvd2VyQm91bmQueSkgLyAyLFxyXG4gICAgICAgICh0aGlzLmFhYmIudXBwZXJCb3VuZC56LXRoaXMuYWFiYi5sb3dlckJvdW5kLnopIC8gMlxyXG4gICAgKTtcclxuICAgIEJveC5jYWxjdWxhdGVJbmVydGlhKGhhbGZFeHRlbnRzLCB0aGlzLm1hc3MsIEkpO1xyXG5cclxuICAgIHRoaXMuaW52SW5lcnRpYS5zZXQoXHJcbiAgICAgICAgSS54ID4gMCAmJiAhZml4ZWQgPyAxLjAgLyBJLnggOiAwLFxyXG4gICAgICAgIEkueSA+IDAgJiYgIWZpeGVkID8gMS4wIC8gSS55IDogMCxcclxuICAgICAgICBJLnogPiAwICYmICFmaXhlZCA/IDEuMCAvIEkueiA6IDBcclxuICAgICk7XHJcbiAgICB0aGlzLnVwZGF0ZUluZXJ0aWFXb3JsZCh0cnVlKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXQgd29ybGQgdmVsb2NpdHkgb2YgYSBwb2ludCBpbiB0aGUgYm9keS5cclxuICogQG1ldGhvZCBnZXRWZWxvY2l0eUF0V29ybGRQb2ludFxyXG4gKiBAcGFyYW0gIHtWZWMzfSB3b3JsZFBvaW50XHJcbiAqIEBwYXJhbSAge1ZlYzN9IHJlc3VsdFxyXG4gKiBAcmV0dXJuIHtWZWMzfSBUaGUgcmVzdWx0IHZlY3Rvci5cclxuICovXHJcbkJvZHkucHJvdG90eXBlLmdldFZlbG9jaXR5QXRXb3JsZFBvaW50ID0gZnVuY3Rpb24od29ybGRQb2ludCwgcmVzdWx0KXtcclxuICAgIHZhciByID0gbmV3IFZlYzMoKTtcclxuICAgIHdvcmxkUG9pbnQudnN1Yih0aGlzLnBvc2l0aW9uLCByKTtcclxuICAgIHRoaXMuYW5ndWxhclZlbG9jaXR5LmNyb3NzKHIsIHJlc3VsdCk7XHJcbiAgICB0aGlzLnZlbG9jaXR5LnZhZGQocmVzdWx0LCByZXN1bHQpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcbi8vIHZhciB0b3JxdWUgPSBuZXcgVmVjMygpO1xyXG4vLyB2YXIgaW52SV90YXVfZHQgPSBuZXcgVmVjMygpO1xyXG4vLyB2YXIgdyA9IG5ldyBRdWF0ZXJuaW9uKCk7XHJcbi8vIHZhciB3cSA9IG5ldyBRdWF0ZXJuaW9uKCk7XHJcblxyXG4vKipcclxuICogTW92ZSB0aGUgYm9keSBmb3J3YXJkIGluIHRpbWUuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBkdCBUaW1lIHN0ZXBcclxuICogQHBhcmFtIHtib29sZWFufSBxdWF0Tm9ybWFsaXplIFNldCB0byB0cnVlIHRvIG5vcm1hbGl6ZSB0aGUgYm9keSBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gcXVhdE5vcm1hbGl6ZUZhc3QgSWYgdGhlIHF1YXRlcm5pb24gc2hvdWxkIGJlIG5vcm1hbGl6ZWQgdXNpbmcgXCJmYXN0XCIgcXVhdGVybmlvbiBub3JtYWxpemF0aW9uXHJcbiAqL1xyXG5Cb2R5LnByb3RvdHlwZS5pbnRlZ3JhdGUgPSBmdW5jdGlvbihkdCwgcXVhdE5vcm1hbGl6ZSwgcXVhdE5vcm1hbGl6ZUZhc3Qpe1xyXG5cclxuICAgIC8vIFNhdmUgcHJldmlvdXMgcG9zaXRpb25cclxuICAgIHRoaXMucHJldmlvdXNQb3NpdGlvbi5jb3B5KHRoaXMucG9zaXRpb24pO1xyXG4gICAgdGhpcy5wcmV2aW91c1F1YXRlcm5pb24uY29weSh0aGlzLnF1YXRlcm5pb24pO1xyXG5cclxuICAgIGlmKCEodGhpcy50eXBlID09PSBCb2R5LkRZTkFNSUMgfHwgdGhpcy50eXBlID09PSBCb2R5LktJTkVNQVRJQykgfHwgdGhpcy5zbGVlcFN0YXRlID09PSBCb2R5LlNMRUVQSU5HKXsgLy8gT25seSBmb3IgZHluYW1pY1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgdmVsbyA9IHRoaXMudmVsb2NpdHksXHJcbiAgICAgICAgYW5ndWxhclZlbG8gPSB0aGlzLmFuZ3VsYXJWZWxvY2l0eSxcclxuICAgICAgICBwb3MgPSB0aGlzLnBvc2l0aW9uLFxyXG4gICAgICAgIGZvcmNlID0gdGhpcy5mb3JjZSxcclxuICAgICAgICB0b3JxdWUgPSB0aGlzLnRvcnF1ZSxcclxuICAgICAgICBxdWF0ID0gdGhpcy5xdWF0ZXJuaW9uLFxyXG4gICAgICAgIGludk1hc3MgPSB0aGlzLmludk1hc3MsXHJcbiAgICAgICAgaW52SW5lcnRpYSA9IHRoaXMuaW52SW5lcnRpYVdvcmxkLFxyXG4gICAgICAgIGxpbmVhckZhY3RvciA9IHRoaXMubGluZWFyRmFjdG9yO1xyXG5cclxuICAgIHZhciBpTWR0ID0gaW52TWFzcyAqIGR0O1xyXG4gICAgdmVsby54ICs9IGZvcmNlLnggKiBpTWR0ICogbGluZWFyRmFjdG9yLng7XHJcbiAgICB2ZWxvLnkgKz0gZm9yY2UueSAqIGlNZHQgKiBsaW5lYXJGYWN0b3IueTtcclxuICAgIHZlbG8ueiArPSBmb3JjZS56ICogaU1kdCAqIGxpbmVhckZhY3Rvci56O1xyXG5cclxuICAgIHZhciBlID0gaW52SW5lcnRpYS5lbGVtZW50cztcclxuICAgIHZhciBhbmd1bGFyRmFjdG9yID0gdGhpcy5hbmd1bGFyRmFjdG9yO1xyXG4gICAgdmFyIHR4ID0gdG9ycXVlLnggKiBhbmd1bGFyRmFjdG9yLng7XHJcbiAgICB2YXIgdHkgPSB0b3JxdWUueSAqIGFuZ3VsYXJGYWN0b3IueTtcclxuICAgIHZhciB0eiA9IHRvcnF1ZS56ICogYW5ndWxhckZhY3Rvci56O1xyXG4gICAgYW5ndWxhclZlbG8ueCArPSBkdCAqIChlWzBdICogdHggKyBlWzFdICogdHkgKyBlWzJdICogdHopO1xyXG4gICAgYW5ndWxhclZlbG8ueSArPSBkdCAqIChlWzNdICogdHggKyBlWzRdICogdHkgKyBlWzVdICogdHopO1xyXG4gICAgYW5ndWxhclZlbG8ueiArPSBkdCAqIChlWzZdICogdHggKyBlWzddICogdHkgKyBlWzhdICogdHopO1xyXG5cclxuICAgIC8vIFVzZSBuZXcgdmVsb2NpdHkgIC0gbGVhcCBmcm9nXHJcbiAgICBwb3MueCArPSB2ZWxvLnggKiBkdDtcclxuICAgIHBvcy55ICs9IHZlbG8ueSAqIGR0O1xyXG4gICAgcG9zLnogKz0gdmVsby56ICogZHQ7XHJcblxyXG4gICAgcXVhdC5pbnRlZ3JhdGUodGhpcy5hbmd1bGFyVmVsb2NpdHksIGR0LCB0aGlzLmFuZ3VsYXJGYWN0b3IsIHF1YXQpO1xyXG5cclxuICAgIGlmKHF1YXROb3JtYWxpemUpe1xyXG4gICAgICAgIGlmKHF1YXROb3JtYWxpemVGYXN0KXtcclxuICAgICAgICAgICAgcXVhdC5ub3JtYWxpemVGYXN0KCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcXVhdC5ub3JtYWxpemUoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5hYWJiTmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuICAgIC8vIFVwZGF0ZSB3b3JsZCBpbmVydGlhXHJcbiAgICB0aGlzLnVwZGF0ZUluZXJ0aWFXb3JsZCgpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIElzIFNsZWVwaW5nXHJcbiAqL1xyXG5Cb2R5LnByb3RvdHlwZS5pc1NsZWVwaW5nID0gZnVuY3Rpb24oKXtcclxuICAgIHJldHVybiB0aGlzLnNsZWVwU3RhdGUgPT09IEJvZHkuU0xFRVBJTkc7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBJcyBTbGVlcHlcclxuICovXHJcbkJvZHkucHJvdG90eXBlLmlzU2xlZXB5ID0gZnVuY3Rpb24oKXtcclxuICAgIHJldHVybiB0aGlzLnNsZWVwU3RhdGUgPT09IEJvZHkuU0xFRVBZO1xyXG59XHJcblxyXG4vKipcclxuICogSXMgQXdha2VcclxuICovXHJcbkJvZHkucHJvdG90eXBlLmlzQXdha2UgPSBmdW5jdGlvbigpe1xyXG4gICAgcmV0dXJuIHRoaXMuc2xlZXBTdGF0ZSA9PT0gQm9keS5BV0FLRTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFVwZGF0ZSBoYXNUcmlnZ2VyXHJcbiAqL1xyXG5Cb2R5LnByb3RvdHlwZS51cGRhdGVIYXNUcmlnZ2VyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgZm9yICh2YXIgaSA9IHRoaXMuc2hhcGVzLmxlbmd0aDsgaS0tOykge1xyXG4gICAgICAgIHRoaXMuaGFzVHJpZ2dlciA9ICF0aGlzLnNoYXBlc1tpXS5jb2xsaXNpb25SZXNwb25zZTtcclxuICAgICAgICBpZiAodGhpcy5oYXNUcmlnZ2VyKSBicmVhaztcclxuICAgIH1cclxufVxyXG5cclxufSx7XCIuLi9jb2xsaXNpb24vQUFCQlwiOjMsXCIuLi9tYXRlcmlhbC9NYXRlcmlhbFwiOjI2LFwiLi4vbWF0aC9NYXQzXCI6MjgsXCIuLi9tYXRoL1F1YXRlcm5pb25cIjoyOSxcIi4uL21hdGgvVmVjM1wiOjMxLFwiLi4vc2hhcGVzL0JveFwiOjM4LFwiLi4vc2hhcGVzL1NoYXBlXCI6NDQsXCIuLi91dGlscy9FdmVudFRhcmdldFwiOjUwLFwiLi4vd29ybGQvV29ybGRcIjo1N31dLDMzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcclxudmFyIEJvZHkgPSBfZGVyZXFfKCcuL0JvZHknKTtcclxudmFyIFZlYzMgPSBfZGVyZXFfKCcuLi9tYXRoL1ZlYzMnKTtcclxudmFyIFF1YXRlcm5pb24gPSBfZGVyZXFfKCcuLi9tYXRoL1F1YXRlcm5pb24nKTtcclxudmFyIFJheWNhc3RSZXN1bHQgPSBfZGVyZXFfKCcuLi9jb2xsaXNpb24vUmF5Y2FzdFJlc3VsdCcpO1xyXG52YXIgUmF5ID0gX2RlcmVxXygnLi4vY29sbGlzaW9uL1JheScpO1xyXG52YXIgV2hlZWxJbmZvID0gX2RlcmVxXygnLi4vb2JqZWN0cy9XaGVlbEluZm8nKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmF5Y2FzdFZlaGljbGU7XHJcblxyXG4vKipcclxuICogVmVoaWNsZSBoZWxwZXIgY2xhc3MgdGhhdCBjYXN0cyByYXlzIGZyb20gdGhlIHdoZWVsIHBvc2l0aW9ucyB0b3dhcmRzIHRoZSBncm91bmQgYW5kIGFwcGxpZXMgZm9yY2VzLlxyXG4gKiBAY2xhc3MgUmF5Y2FzdFZlaGljbGVcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cclxuICogQHBhcmFtIHtCb2R5fSBbb3B0aW9ucy5jaGFzc2lzQm9keV0gVGhlIGNhciBjaGFzc2lzIGJvZHkuXHJcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29wdGlvbnMuaW5kZXhSaWdodEF4aXNdIEF4aXMgdG8gdXNlIGZvciByaWdodC4geD0wLCB5PTEsIHo9MlxyXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtvcHRpb25zLmluZGV4TGVmdEF4aXNdXHJcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29wdGlvbnMuaW5kZXhVcEF4aXNdXHJcbiAqL1xyXG5mdW5jdGlvbiBSYXljYXN0VmVoaWNsZShvcHRpb25zKXtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9keX0gY2hhc3Npc0JvZHlcclxuICAgICAqL1xyXG4gICAgdGhpcy5jaGFzc2lzQm9keSA9IG9wdGlvbnMuY2hhc3Npc0JvZHk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBhcnJheSBvZiBXaGVlbEluZm8gb2JqZWN0cy5cclxuICAgICAqIEBwcm9wZXJ0eSB7YXJyYXl9IHdoZWVsSW5mb3NcclxuICAgICAqL1xyXG4gICAgdGhpcy53aGVlbEluZm9zID0gW107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXaWxsIGJlIHNldCB0byB0cnVlIGlmIHRoZSBjYXIgaXMgc2xpZGluZy5cclxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gc2xpZGluZ1xyXG4gICAgICovXHJcbiAgICB0aGlzLnNsaWRpbmcgPSBmYWxzZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcm9wZXJ0eSB7V29ybGR9IHdvcmxkXHJcbiAgICAgKi9cclxuICAgIHRoaXMud29ybGQgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5kZXggb2YgdGhlIHJpZ2h0IGF4aXMsIDA9eCwgMT15LCAyPXpcclxuICAgICAqIEBwcm9wZXJ0eSB7aW50ZWdlcn0gaW5kZXhSaWdodEF4aXNcclxuICAgICAqIEBkZWZhdWx0IDFcclxuICAgICAqL1xyXG4gICAgdGhpcy5pbmRleFJpZ2h0QXhpcyA9IHR5cGVvZihvcHRpb25zLmluZGV4UmlnaHRBeGlzKSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLmluZGV4UmlnaHRBeGlzIDogMTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEluZGV4IG9mIHRoZSBmb3J3YXJkIGF4aXMsIDA9eCwgMT15LCAyPXpcclxuICAgICAqIEBwcm9wZXJ0eSB7aW50ZWdlcn0gaW5kZXhGb3J3YXJkQXhpc1xyXG4gICAgICogQGRlZmF1bHQgMFxyXG4gICAgICovXHJcbiAgICB0aGlzLmluZGV4Rm9yd2FyZEF4aXMgPSB0eXBlb2Yob3B0aW9ucy5pbmRleEZvcndhcmRBeGlzKSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLmluZGV4Rm9yd2FyZEF4aXMgOiAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5kZXggb2YgdGhlIHVwIGF4aXMsIDA9eCwgMT15LCAyPXpcclxuICAgICAqIEBwcm9wZXJ0eSB7aW50ZWdlcn0gaW5kZXhVcEF4aXNcclxuICAgICAqIEBkZWZhdWx0IDJcclxuICAgICAqL1xyXG4gICAgdGhpcy5pbmRleFVwQXhpcyA9IHR5cGVvZihvcHRpb25zLmluZGV4VXBBeGlzKSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLmluZGV4VXBBeGlzIDogMjtcclxufVxyXG5cclxudmFyIHRtcFZlYzEgPSBuZXcgVmVjMygpO1xyXG52YXIgdG1wVmVjMiA9IG5ldyBWZWMzKCk7XHJcbnZhciB0bXBWZWMzID0gbmV3IFZlYzMoKTtcclxudmFyIHRtcFZlYzQgPSBuZXcgVmVjMygpO1xyXG52YXIgdG1wVmVjNSA9IG5ldyBWZWMzKCk7XHJcbnZhciB0bXBWZWM2ID0gbmV3IFZlYzMoKTtcclxudmFyIHRtcFJheSA9IG5ldyBSYXkoKTtcclxuXHJcbi8qKlxyXG4gKiBBZGQgYSB3aGVlbC4gRm9yIGluZm9ybWF0aW9uIGFib3V0IHRoZSBvcHRpb25zLCBzZWUgV2hlZWxJbmZvLlxyXG4gKiBAbWV0aG9kIGFkZFdoZWVsXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cclxuICovXHJcblJheWNhc3RWZWhpY2xlLnByb3RvdHlwZS5hZGRXaGVlbCA9IGZ1bmN0aW9uKG9wdGlvbnMpe1xyXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG4gICAgdmFyIGluZm8gPSBuZXcgV2hlZWxJbmZvKG9wdGlvbnMpO1xyXG4gICAgdmFyIGluZGV4ID0gdGhpcy53aGVlbEluZm9zLmxlbmd0aDtcclxuICAgIHRoaXMud2hlZWxJbmZvcy5wdXNoKGluZm8pO1xyXG5cclxuICAgIHJldHVybiBpbmRleDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTZXQgdGhlIHN0ZWVyaW5nIHZhbHVlIG9mIGEgd2hlZWwuXHJcbiAqIEBtZXRob2Qgc2V0U3RlZXJpbmdWYWx1ZVxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcclxuICogQHBhcmFtIHtpbnRlZ2VyfSB3aGVlbEluZGV4XHJcbiAqL1xyXG5SYXljYXN0VmVoaWNsZS5wcm90b3R5cGUuc2V0U3RlZXJpbmdWYWx1ZSA9IGZ1bmN0aW9uKHZhbHVlLCB3aGVlbEluZGV4KXtcclxuICAgIHZhciB3aGVlbCA9IHRoaXMud2hlZWxJbmZvc1t3aGVlbEluZGV4XTtcclxuICAgIHdoZWVsLnN0ZWVyaW5nID0gdmFsdWU7XHJcbn07XHJcblxyXG52YXIgdG9ycXVlID0gbmV3IFZlYzMoKTtcclxuXHJcbi8qKlxyXG4gKiBTZXQgdGhlIHdoZWVsIGZvcmNlIHRvIGFwcGx5IG9uIG9uZSBvZiB0aGUgd2hlZWxzIGVhY2ggdGltZSBzdGVwXHJcbiAqIEBtZXRob2QgYXBwbHlFbmdpbmVGb3JjZVxyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHZhbHVlXHJcbiAqIEBwYXJhbSAge2ludGVnZXJ9IHdoZWVsSW5kZXhcclxuICovXHJcblJheWNhc3RWZWhpY2xlLnByb3RvdHlwZS5hcHBseUVuZ2luZUZvcmNlID0gZnVuY3Rpb24odmFsdWUsIHdoZWVsSW5kZXgpe1xyXG4gICAgdGhpcy53aGVlbEluZm9zW3doZWVsSW5kZXhdLmVuZ2luZUZvcmNlID0gdmFsdWU7XHJcbn07XHJcblxyXG4vKipcclxuICogU2V0IHRoZSBicmFraW5nIGZvcmNlIG9mIGEgd2hlZWxcclxuICogQG1ldGhvZCBzZXRCcmFrZVxyXG4gKiBAcGFyYW0ge251bWJlcn0gYnJha2VcclxuICogQHBhcmFtIHtpbnRlZ2VyfSB3aGVlbEluZGV4XHJcbiAqL1xyXG5SYXljYXN0VmVoaWNsZS5wcm90b3R5cGUuc2V0QnJha2UgPSBmdW5jdGlvbihicmFrZSwgd2hlZWxJbmRleCl7XHJcbiAgICB0aGlzLndoZWVsSW5mb3Nbd2hlZWxJbmRleF0uYnJha2UgPSBicmFrZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBZGQgdGhlIHZlaGljbGUgaW5jbHVkaW5nIGl0cyBjb25zdHJhaW50cyB0byB0aGUgd29ybGQuXHJcbiAqIEBtZXRob2QgYWRkVG9Xb3JsZFxyXG4gKiBAcGFyYW0ge1dvcmxkfSB3b3JsZFxyXG4gKi9cclxuUmF5Y2FzdFZlaGljbGUucHJvdG90eXBlLmFkZFRvV29ybGQgPSBmdW5jdGlvbih3b3JsZCl7XHJcbiAgICB2YXIgY29uc3RyYWludHMgPSB0aGlzLmNvbnN0cmFpbnRzO1xyXG4gICAgd29ybGQuYWRkQm9keSh0aGlzLmNoYXNzaXNCb2R5KTtcclxuICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgIHRoaXMucHJlU3RlcENhbGxiYWNrID0gZnVuY3Rpb24oKXtcclxuICAgICAgICB0aGF0LnVwZGF0ZVZlaGljbGUod29ybGQuZHQpO1xyXG4gICAgfTtcclxuICAgIHdvcmxkLmFkZEV2ZW50TGlzdGVuZXIoJ3ByZVN0ZXAnLCB0aGlzLnByZVN0ZXBDYWxsYmFjayk7XHJcbiAgICB0aGlzLndvcmxkID0gd29ybGQ7XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0IG9uZSBvZiB0aGUgd2hlZWwgYXhsZXMsIHdvcmxkLW9yaWVudGVkLlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAbWV0aG9kIGdldFZlaGljbGVBeGlzV29ybGRcclxuICogQHBhcmFtICB7aW50ZWdlcn0gYXhpc0luZGV4XHJcbiAqIEBwYXJhbSAge1ZlYzN9IHJlc3VsdFxyXG4gKi9cclxuUmF5Y2FzdFZlaGljbGUucHJvdG90eXBlLmdldFZlaGljbGVBeGlzV29ybGQgPSBmdW5jdGlvbihheGlzSW5kZXgsIHJlc3VsdCl7XHJcbiAgICByZXN1bHQuc2V0KFxyXG4gICAgICAgIGF4aXNJbmRleCA9PT0gMCA/IDEgOiAwLFxyXG4gICAgICAgIGF4aXNJbmRleCA9PT0gMSA/IDEgOiAwLFxyXG4gICAgICAgIGF4aXNJbmRleCA9PT0gMiA/IDEgOiAwXHJcbiAgICApO1xyXG4gICAgdGhpcy5jaGFzc2lzQm9keS52ZWN0b3JUb1dvcmxkRnJhbWUocmVzdWx0LCByZXN1bHQpO1xyXG59O1xyXG5cclxuUmF5Y2FzdFZlaGljbGUucHJvdG90eXBlLnVwZGF0ZVZlaGljbGUgPSBmdW5jdGlvbih0aW1lU3RlcCl7XHJcbiAgICB2YXIgd2hlZWxJbmZvcyA9IHRoaXMud2hlZWxJbmZvcztcclxuICAgIHZhciBudW1XaGVlbHMgPSB3aGVlbEluZm9zLmxlbmd0aDtcclxuICAgIHZhciBjaGFzc2lzQm9keSA9IHRoaXMuY2hhc3Npc0JvZHk7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1XaGVlbHM7IGkrKykge1xyXG4gICAgICAgIHRoaXMudXBkYXRlV2hlZWxUcmFuc2Zvcm0oaSk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5jdXJyZW50VmVoaWNsZVNwZWVkS21Ib3VyID0gMy42ICogY2hhc3Npc0JvZHkudmVsb2NpdHkubm9ybSgpO1xyXG5cclxuICAgIHZhciBmb3J3YXJkV29ybGQgPSBuZXcgVmVjMygpO1xyXG4gICAgdGhpcy5nZXRWZWhpY2xlQXhpc1dvcmxkKHRoaXMuaW5kZXhGb3J3YXJkQXhpcywgZm9yd2FyZFdvcmxkKTtcclxuXHJcbiAgICBpZiAoZm9yd2FyZFdvcmxkLmRvdChjaGFzc2lzQm9keS52ZWxvY2l0eSkgPCAwKXtcclxuICAgICAgICB0aGlzLmN1cnJlbnRWZWhpY2xlU3BlZWRLbUhvdXIgKj0gLTE7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gc2ltdWxhdGUgc3VzcGVuc2lvblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1XaGVlbHM7IGkrKykge1xyXG4gICAgICAgIHRoaXMuY2FzdFJheSh3aGVlbEluZm9zW2ldKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnVwZGF0ZVN1c3BlbnNpb24odGltZVN0ZXApO1xyXG5cclxuICAgIHZhciBpbXB1bHNlID0gbmV3IFZlYzMoKTtcclxuICAgIHZhciByZWxwb3MgPSBuZXcgVmVjMygpO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1XaGVlbHM7IGkrKykge1xyXG4gICAgICAgIC8vYXBwbHkgc3VzcGVuc2lvbiBmb3JjZVxyXG4gICAgICAgIHZhciB3aGVlbCA9IHdoZWVsSW5mb3NbaV07XHJcbiAgICAgICAgdmFyIHN1c3BlbnNpb25Gb3JjZSA9IHdoZWVsLnN1c3BlbnNpb25Gb3JjZTtcclxuICAgICAgICBpZiAoc3VzcGVuc2lvbkZvcmNlID4gd2hlZWwubWF4U3VzcGVuc2lvbkZvcmNlKSB7XHJcbiAgICAgICAgICAgIHN1c3BlbnNpb25Gb3JjZSA9IHdoZWVsLm1heFN1c3BlbnNpb25Gb3JjZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgd2hlZWwucmF5Y2FzdFJlc3VsdC5oaXROb3JtYWxXb3JsZC5zY2FsZShzdXNwZW5zaW9uRm9yY2UgKiB0aW1lU3RlcCwgaW1wdWxzZSk7XHJcblxyXG4gICAgICAgIHdoZWVsLnJheWNhc3RSZXN1bHQuaGl0UG9pbnRXb3JsZC52c3ViKGNoYXNzaXNCb2R5LnBvc2l0aW9uLCByZWxwb3MpO1xyXG4gICAgICAgIGNoYXNzaXNCb2R5LmFwcGx5SW1wdWxzZShpbXB1bHNlLCByZWxwb3MpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMudXBkYXRlRnJpY3Rpb24odGltZVN0ZXApO1xyXG5cclxuICAgIHZhciBoaXROb3JtYWxXb3JsZFNjYWxlZFdpdGhQcm9qID0gbmV3IFZlYzMoKTtcclxuICAgIHZhciBmd2QgID0gbmV3IFZlYzMoKTtcclxuICAgIHZhciB2ZWwgPSBuZXcgVmVjMygpO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IG51bVdoZWVsczsgaSsrKSB7XHJcbiAgICAgICAgdmFyIHdoZWVsID0gd2hlZWxJbmZvc1tpXTtcclxuICAgICAgICAvL3ZhciByZWxwb3MgPSBuZXcgVmVjMygpO1xyXG4gICAgICAgIC8vd2hlZWwuY2hhc3Npc0Nvbm5lY3Rpb25Qb2ludFdvcmxkLnZzdWIoY2hhc3Npc0JvZHkucG9zaXRpb24sIHJlbHBvcyk7XHJcbiAgICAgICAgY2hhc3Npc0JvZHkuZ2V0VmVsb2NpdHlBdFdvcmxkUG9pbnQod2hlZWwuY2hhc3Npc0Nvbm5lY3Rpb25Qb2ludFdvcmxkLCB2ZWwpO1xyXG5cclxuICAgICAgICAvLyBIYWNrIHRvIGdldCB0aGUgcm90YXRpb24gaW4gdGhlIGNvcnJlY3QgZGlyZWN0aW9uXHJcbiAgICAgICAgdmFyIG0gPSAxO1xyXG4gICAgICAgIHN3aXRjaCh0aGlzLmluZGV4VXBBeGlzKXtcclxuICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgIG0gPSAtMTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAod2hlZWwuaXNJbkNvbnRhY3QpIHtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZ2V0VmVoaWNsZUF4aXNXb3JsZCh0aGlzLmluZGV4Rm9yd2FyZEF4aXMsIGZ3ZCk7XHJcbiAgICAgICAgICAgIHZhciBwcm9qID0gZndkLmRvdCh3aGVlbC5yYXljYXN0UmVzdWx0LmhpdE5vcm1hbFdvcmxkKTtcclxuICAgICAgICAgICAgd2hlZWwucmF5Y2FzdFJlc3VsdC5oaXROb3JtYWxXb3JsZC5zY2FsZShwcm9qLCBoaXROb3JtYWxXb3JsZFNjYWxlZFdpdGhQcm9qKTtcclxuXHJcbiAgICAgICAgICAgIGZ3ZC52c3ViKGhpdE5vcm1hbFdvcmxkU2NhbGVkV2l0aFByb2osIGZ3ZCk7XHJcblxyXG4gICAgICAgICAgICB2YXIgcHJvajIgPSBmd2QuZG90KHZlbCk7XHJcbiAgICAgICAgICAgIHdoZWVsLmRlbHRhUm90YXRpb24gPSBtICogcHJvajIgKiB0aW1lU3RlcCAvIHdoZWVsLnJhZGl1cztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKCh3aGVlbC5zbGlkaW5nIHx8ICF3aGVlbC5pc0luQ29udGFjdCkgJiYgd2hlZWwuZW5naW5lRm9yY2UgIT09IDAgJiYgd2hlZWwudXNlQ3VzdG9tU2xpZGluZ1JvdGF0aW9uYWxTcGVlZCl7XHJcbiAgICAgICAgICAgIC8vIEFwcGx5IGN1c3RvbSByb3RhdGlvbiB3aGVuIGFjY2VsZXJhdGluZyBhbmQgc2xpZGluZ1xyXG4gICAgICAgICAgICB3aGVlbC5kZWx0YVJvdGF0aW9uID0gKHdoZWVsLmVuZ2luZUZvcmNlID4gMCA/IDEgOiAtMSkgKiB3aGVlbC5jdXN0b21TbGlkaW5nUm90YXRpb25hbFNwZWVkICogdGltZVN0ZXA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBMb2NrIHdoZWVsc1xyXG4gICAgICAgIGlmKE1hdGguYWJzKHdoZWVsLmJyYWtlKSA+IE1hdGguYWJzKHdoZWVsLmVuZ2luZUZvcmNlKSl7XHJcbiAgICAgICAgICAgIHdoZWVsLmRlbHRhUm90YXRpb24gPSAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgd2hlZWwucm90YXRpb24gKz0gd2hlZWwuZGVsdGFSb3RhdGlvbjsgLy8gVXNlIHRoZSBvbGQgdmFsdWVcclxuICAgICAgICB3aGVlbC5kZWx0YVJvdGF0aW9uICo9IDAuOTk7IC8vIGRhbXBpbmcgb2Ygcm90YXRpb24gd2hlbiBub3QgaW4gY29udGFjdFxyXG4gICAgfVxyXG59O1xyXG5cclxuUmF5Y2FzdFZlaGljbGUucHJvdG90eXBlLnVwZGF0ZVN1c3BlbnNpb24gPSBmdW5jdGlvbihkZWx0YVRpbWUpIHtcclxuICAgIHZhciBjaGFzc2lzQm9keSA9IHRoaXMuY2hhc3Npc0JvZHk7XHJcbiAgICB2YXIgY2hhc3Npc01hc3MgPSBjaGFzc2lzQm9keS5tYXNzO1xyXG4gICAgdmFyIHdoZWVsSW5mb3MgPSB0aGlzLndoZWVsSW5mb3M7XHJcbiAgICB2YXIgbnVtV2hlZWxzID0gd2hlZWxJbmZvcy5sZW5ndGg7XHJcblxyXG4gICAgZm9yICh2YXIgd19pdCA9IDA7IHdfaXQgPCBudW1XaGVlbHM7IHdfaXQrKyl7XHJcbiAgICAgICAgdmFyIHdoZWVsID0gd2hlZWxJbmZvc1t3X2l0XTtcclxuXHJcbiAgICAgICAgaWYgKHdoZWVsLmlzSW5Db250YWN0KXtcclxuICAgICAgICAgICAgdmFyIGZvcmNlO1xyXG5cclxuICAgICAgICAgICAgLy8gU3ByaW5nXHJcbiAgICAgICAgICAgIHZhciBzdXNwX2xlbmd0aCA9IHdoZWVsLnN1c3BlbnNpb25SZXN0TGVuZ3RoO1xyXG4gICAgICAgICAgICB2YXIgY3VycmVudF9sZW5ndGggPSB3aGVlbC5zdXNwZW5zaW9uTGVuZ3RoO1xyXG4gICAgICAgICAgICB2YXIgbGVuZ3RoX2RpZmYgPSAoc3VzcF9sZW5ndGggLSBjdXJyZW50X2xlbmd0aCk7XHJcblxyXG4gICAgICAgICAgICBmb3JjZSA9IHdoZWVsLnN1c3BlbnNpb25TdGlmZm5lc3MgKiBsZW5ndGhfZGlmZiAqIHdoZWVsLmNsaXBwZWRJbnZDb250YWN0RG90U3VzcGVuc2lvbjtcclxuXHJcbiAgICAgICAgICAgIC8vIERhbXBlclxyXG4gICAgICAgICAgICB2YXIgcHJvamVjdGVkX3JlbF92ZWwgPSB3aGVlbC5zdXNwZW5zaW9uUmVsYXRpdmVWZWxvY2l0eTtcclxuICAgICAgICAgICAgdmFyIHN1c3BfZGFtcGluZztcclxuICAgICAgICAgICAgaWYgKHByb2plY3RlZF9yZWxfdmVsIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgc3VzcF9kYW1waW5nID0gd2hlZWwuZGFtcGluZ0NvbXByZXNzaW9uO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc3VzcF9kYW1waW5nID0gd2hlZWwuZGFtcGluZ1JlbGF4YXRpb247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yY2UgLT0gc3VzcF9kYW1waW5nICogcHJvamVjdGVkX3JlbF92ZWw7XHJcblxyXG4gICAgICAgICAgICB3aGVlbC5zdXNwZW5zaW9uRm9yY2UgPSBmb3JjZSAqIGNoYXNzaXNNYXNzO1xyXG4gICAgICAgICAgICBpZiAod2hlZWwuc3VzcGVuc2lvbkZvcmNlIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgd2hlZWwuc3VzcGVuc2lvbkZvcmNlID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHdoZWVsLnN1c3BlbnNpb25Gb3JjZSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlbW92ZSB0aGUgdmVoaWNsZSBpbmNsdWRpbmcgaXRzIGNvbnN0cmFpbnRzIGZyb20gdGhlIHdvcmxkLlxyXG4gKiBAbWV0aG9kIHJlbW92ZUZyb21Xb3JsZFxyXG4gKiBAcGFyYW0ge1dvcmxkfSB3b3JsZFxyXG4gKi9cclxuUmF5Y2FzdFZlaGljbGUucHJvdG90eXBlLnJlbW92ZUZyb21Xb3JsZCA9IGZ1bmN0aW9uKHdvcmxkKXtcclxuICAgIHZhciBjb25zdHJhaW50cyA9IHRoaXMuY29uc3RyYWludHM7XHJcbiAgICB3b3JsZC5yZW1vdmUodGhpcy5jaGFzc2lzQm9keSk7XHJcbiAgICB3b3JsZC5yZW1vdmVFdmVudExpc3RlbmVyKCdwcmVTdGVwJywgdGhpcy5wcmVTdGVwQ2FsbGJhY2spO1xyXG4gICAgdGhpcy53b3JsZCA9IG51bGw7XHJcbn07XHJcblxyXG52YXIgY2FzdFJheV9yYXl2ZWN0b3IgPSBuZXcgVmVjMygpO1xyXG52YXIgY2FzdFJheV90YXJnZXQgPSBuZXcgVmVjMygpO1xyXG5SYXljYXN0VmVoaWNsZS5wcm90b3R5cGUuY2FzdFJheSA9IGZ1bmN0aW9uKHdoZWVsKSB7XHJcbiAgICB2YXIgcmF5dmVjdG9yID0gY2FzdFJheV9yYXl2ZWN0b3I7XHJcbiAgICB2YXIgdGFyZ2V0ID0gY2FzdFJheV90YXJnZXQ7XHJcblxyXG4gICAgdGhpcy51cGRhdGVXaGVlbFRyYW5zZm9ybVdvcmxkKHdoZWVsKTtcclxuICAgIHZhciBjaGFzc2lzQm9keSA9IHRoaXMuY2hhc3Npc0JvZHk7XHJcblxyXG4gICAgdmFyIGRlcHRoID0gLTE7XHJcblxyXG4gICAgdmFyIHJheWxlbiA9IHdoZWVsLnN1c3BlbnNpb25SZXN0TGVuZ3RoICsgd2hlZWwucmFkaXVzO1xyXG5cclxuICAgIHdoZWVsLmRpcmVjdGlvbldvcmxkLnNjYWxlKHJheWxlbiwgcmF5dmVjdG9yKTtcclxuICAgIHZhciBzb3VyY2UgPSB3aGVlbC5jaGFzc2lzQ29ubmVjdGlvblBvaW50V29ybGQ7XHJcbiAgICBzb3VyY2UudmFkZChyYXl2ZWN0b3IsIHRhcmdldCk7XHJcbiAgICB2YXIgcmF5Y2FzdFJlc3VsdCA9IHdoZWVsLnJheWNhc3RSZXN1bHQ7XHJcblxyXG4gICAgdmFyIHBhcmFtID0gMDtcclxuXHJcbiAgICByYXljYXN0UmVzdWx0LnJlc2V0KCk7XHJcbiAgICAvLyBUdXJuIG9mZiByYXkgY29sbGlzaW9uIHdpdGggdGhlIGNoYXNzaXMgdGVtcG9yYXJpbHlcclxuICAgIHZhciBvbGRTdGF0ZSA9IGNoYXNzaXNCb2R5LmNvbGxpc2lvblJlc3BvbnNlO1xyXG4gICAgY2hhc3Npc0JvZHkuY29sbGlzaW9uUmVzcG9uc2UgPSBmYWxzZTtcclxuXHJcbiAgICAvLyBDYXN0IHJheSBhZ2FpbnN0IHdvcmxkXHJcbiAgICB0aGlzLndvcmxkLnJheVRlc3Qoc291cmNlLCB0YXJnZXQsIHJheWNhc3RSZXN1bHQpO1xyXG4gICAgY2hhc3Npc0JvZHkuY29sbGlzaW9uUmVzcG9uc2UgPSBvbGRTdGF0ZTtcclxuXHJcbiAgICB2YXIgb2JqZWN0ID0gcmF5Y2FzdFJlc3VsdC5ib2R5O1xyXG5cclxuICAgIHdoZWVsLnJheWNhc3RSZXN1bHQuZ3JvdW5kT2JqZWN0ID0gMDtcclxuXHJcbiAgICBpZiAob2JqZWN0KSB7XHJcbiAgICAgICAgZGVwdGggPSByYXljYXN0UmVzdWx0LmRpc3RhbmNlO1xyXG4gICAgICAgIHdoZWVsLnJheWNhc3RSZXN1bHQuaGl0Tm9ybWFsV29ybGQgID0gcmF5Y2FzdFJlc3VsdC5oaXROb3JtYWxXb3JsZDtcclxuICAgICAgICB3aGVlbC5pc0luQ29udGFjdCA9IHRydWU7XHJcblxyXG4gICAgICAgIHZhciBoaXREaXN0YW5jZSA9IHJheWNhc3RSZXN1bHQuZGlzdGFuY2U7XHJcbiAgICAgICAgd2hlZWwuc3VzcGVuc2lvbkxlbmd0aCA9IGhpdERpc3RhbmNlIC0gd2hlZWwucmFkaXVzO1xyXG5cclxuICAgICAgICAvLyBjbGFtcCBvbiBtYXggc3VzcGVuc2lvbiB0cmF2ZWxcclxuICAgICAgICB2YXIgbWluU3VzcGVuc2lvbkxlbmd0aCA9IHdoZWVsLnN1c3BlbnNpb25SZXN0TGVuZ3RoIC0gd2hlZWwubWF4U3VzcGVuc2lvblRyYXZlbDtcclxuICAgICAgICB2YXIgbWF4U3VzcGVuc2lvbkxlbmd0aCA9IHdoZWVsLnN1c3BlbnNpb25SZXN0TGVuZ3RoICsgd2hlZWwubWF4U3VzcGVuc2lvblRyYXZlbDtcclxuICAgICAgICBpZiAod2hlZWwuc3VzcGVuc2lvbkxlbmd0aCA8IG1pblN1c3BlbnNpb25MZW5ndGgpIHtcclxuICAgICAgICAgICAgd2hlZWwuc3VzcGVuc2lvbkxlbmd0aCA9IG1pblN1c3BlbnNpb25MZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh3aGVlbC5zdXNwZW5zaW9uTGVuZ3RoID4gbWF4U3VzcGVuc2lvbkxlbmd0aCkge1xyXG4gICAgICAgICAgICB3aGVlbC5zdXNwZW5zaW9uTGVuZ3RoID0gbWF4U3VzcGVuc2lvbkxlbmd0aDtcclxuICAgICAgICAgICAgd2hlZWwucmF5Y2FzdFJlc3VsdC5yZXNldCgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGRlbm9taW5hdG9yID0gd2hlZWwucmF5Y2FzdFJlc3VsdC5oaXROb3JtYWxXb3JsZC5kb3Qod2hlZWwuZGlyZWN0aW9uV29ybGQpO1xyXG5cclxuICAgICAgICB2YXIgY2hhc3Npc192ZWxvY2l0eV9hdF9jb250YWN0UG9pbnQgPSBuZXcgVmVjMygpO1xyXG4gICAgICAgIGNoYXNzaXNCb2R5LmdldFZlbG9jaXR5QXRXb3JsZFBvaW50KHdoZWVsLnJheWNhc3RSZXN1bHQuaGl0UG9pbnRXb3JsZCwgY2hhc3Npc192ZWxvY2l0eV9hdF9jb250YWN0UG9pbnQpO1xyXG5cclxuICAgICAgICB2YXIgcHJvalZlbCA9IHdoZWVsLnJheWNhc3RSZXN1bHQuaGl0Tm9ybWFsV29ybGQuZG90KCBjaGFzc2lzX3ZlbG9jaXR5X2F0X2NvbnRhY3RQb2ludCApO1xyXG5cclxuICAgICAgICBpZiAoZGVub21pbmF0b3IgPj0gLTAuMSkge1xyXG4gICAgICAgICAgICB3aGVlbC5zdXNwZW5zaW9uUmVsYXRpdmVWZWxvY2l0eSA9IDA7XHJcbiAgICAgICAgICAgIHdoZWVsLmNsaXBwZWRJbnZDb250YWN0RG90U3VzcGVuc2lvbiA9IDEgLyAwLjE7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIGludiA9IC0xIC8gZGVub21pbmF0b3I7XHJcbiAgICAgICAgICAgIHdoZWVsLnN1c3BlbnNpb25SZWxhdGl2ZVZlbG9jaXR5ID0gcHJvalZlbCAqIGludjtcclxuICAgICAgICAgICAgd2hlZWwuY2xpcHBlZEludkNvbnRhY3REb3RTdXNwZW5zaW9uID0gaW52O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAvL3B1dCB3aGVlbCBpbmZvIGFzIGluIHJlc3QgcG9zaXRpb25cclxuICAgICAgICB3aGVlbC5zdXNwZW5zaW9uTGVuZ3RoID0gd2hlZWwuc3VzcGVuc2lvblJlc3RMZW5ndGggKyAwICogd2hlZWwubWF4U3VzcGVuc2lvblRyYXZlbDtcclxuICAgICAgICB3aGVlbC5zdXNwZW5zaW9uUmVsYXRpdmVWZWxvY2l0eSA9IDAuMDtcclxuICAgICAgICB3aGVlbC5kaXJlY3Rpb25Xb3JsZC5zY2FsZSgtMSwgd2hlZWwucmF5Y2FzdFJlc3VsdC5oaXROb3JtYWxXb3JsZCk7XHJcbiAgICAgICAgd2hlZWwuY2xpcHBlZEludkNvbnRhY3REb3RTdXNwZW5zaW9uID0gMS4wO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBkZXB0aDtcclxufTtcclxuXHJcblJheWNhc3RWZWhpY2xlLnByb3RvdHlwZS51cGRhdGVXaGVlbFRyYW5zZm9ybVdvcmxkID0gZnVuY3Rpb24od2hlZWwpe1xyXG4gICAgd2hlZWwuaXNJbkNvbnRhY3QgPSBmYWxzZTtcclxuICAgIHZhciBjaGFzc2lzQm9keSA9IHRoaXMuY2hhc3Npc0JvZHk7XHJcbiAgICBjaGFzc2lzQm9keS5wb2ludFRvV29ybGRGcmFtZSh3aGVlbC5jaGFzc2lzQ29ubmVjdGlvblBvaW50TG9jYWwsIHdoZWVsLmNoYXNzaXNDb25uZWN0aW9uUG9pbnRXb3JsZCk7XHJcbiAgICBjaGFzc2lzQm9keS52ZWN0b3JUb1dvcmxkRnJhbWUod2hlZWwuZGlyZWN0aW9uTG9jYWwsIHdoZWVsLmRpcmVjdGlvbldvcmxkKTtcclxuICAgIGNoYXNzaXNCb2R5LnZlY3RvclRvV29ybGRGcmFtZSh3aGVlbC5heGxlTG9jYWwsIHdoZWVsLmF4bGVXb3JsZCk7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIFVwZGF0ZSBvbmUgb2YgdGhlIHdoZWVsIHRyYW5zZm9ybS5cclxuICogTm90ZSB3aGVuIHJlbmRlcmluZyB3aGVlbHM6IGR1cmluZyBlYWNoIHN0ZXAsIHdoZWVsIHRyYW5zZm9ybXMgYXJlIHVwZGF0ZWQgQkVGT1JFIHRoZSBjaGFzc2lzOyBpZS4gdGhlaXIgcG9zaXRpb24gYmVjb21lcyBpbnZhbGlkIGFmdGVyIHRoZSBzdGVwLiBUaHVzIHdoZW4geW91IHJlbmRlciB3aGVlbHMsIHlvdSBtdXN0IHVwZGF0ZSB3aGVlbCB0cmFuc2Zvcm1zIGJlZm9yZSByZW5kZXJpbmcgdGhlbS4gU2VlIHJheWNhc3RWZWhpY2xlIGRlbW8gZm9yIGFuIGV4YW1wbGUuXHJcbiAqIEBtZXRob2QgdXBkYXRlV2hlZWxUcmFuc2Zvcm1cclxuICogQHBhcmFtIHtpbnRlZ2VyfSB3aGVlbEluZGV4IFRoZSB3aGVlbCBpbmRleCB0byB1cGRhdGUuXHJcbiAqL1xyXG5SYXljYXN0VmVoaWNsZS5wcm90b3R5cGUudXBkYXRlV2hlZWxUcmFuc2Zvcm0gPSBmdW5jdGlvbih3aGVlbEluZGV4KXtcclxuICAgIHZhciB1cCA9IHRtcFZlYzQ7XHJcbiAgICB2YXIgcmlnaHQgPSB0bXBWZWM1O1xyXG4gICAgdmFyIGZ3ZCA9IHRtcFZlYzY7XHJcblxyXG4gICAgdmFyIHdoZWVsID0gdGhpcy53aGVlbEluZm9zW3doZWVsSW5kZXhdO1xyXG4gICAgdGhpcy51cGRhdGVXaGVlbFRyYW5zZm9ybVdvcmxkKHdoZWVsKTtcclxuXHJcbiAgICB3aGVlbC5kaXJlY3Rpb25Mb2NhbC5zY2FsZSgtMSwgdXApO1xyXG4gICAgcmlnaHQuY29weSh3aGVlbC5heGxlTG9jYWwpO1xyXG4gICAgdXAuY3Jvc3MocmlnaHQsIGZ3ZCk7XHJcbiAgICBmd2Qubm9ybWFsaXplKCk7XHJcbiAgICByaWdodC5ub3JtYWxpemUoKTtcclxuXHJcbiAgICAvLyBSb3RhdGUgYXJvdW5kIHN0ZWVyaW5nIG92ZXIgdGhlIHdoZWVsQXhsZVxyXG4gICAgdmFyIHN0ZWVyaW5nID0gd2hlZWwuc3RlZXJpbmc7XHJcbiAgICB2YXIgc3RlZXJpbmdPcm4gPSBuZXcgUXVhdGVybmlvbigpO1xyXG4gICAgc3RlZXJpbmdPcm4uc2V0RnJvbUF4aXNBbmdsZSh1cCwgc3RlZXJpbmcpO1xyXG5cclxuICAgIHZhciByb3RhdGluZ09ybiA9IG5ldyBRdWF0ZXJuaW9uKCk7XHJcbiAgICByb3RhdGluZ09ybi5zZXRGcm9tQXhpc0FuZ2xlKHJpZ2h0LCB3aGVlbC5yb3RhdGlvbik7XHJcblxyXG4gICAgLy8gV29ybGQgcm90YXRpb24gb2YgdGhlIHdoZWVsXHJcbiAgICB2YXIgcSA9IHdoZWVsLndvcmxkVHJhbnNmb3JtLnF1YXRlcm5pb247XHJcbiAgICB0aGlzLmNoYXNzaXNCb2R5LnF1YXRlcm5pb24ubXVsdChzdGVlcmluZ09ybiwgcSk7XHJcbiAgICBxLm11bHQocm90YXRpbmdPcm4sIHEpO1xyXG5cclxuICAgIHEubm9ybWFsaXplKCk7XHJcblxyXG4gICAgLy8gd29ybGQgcG9zaXRpb24gb2YgdGhlIHdoZWVsXHJcbiAgICB2YXIgcCA9IHdoZWVsLndvcmxkVHJhbnNmb3JtLnBvc2l0aW9uO1xyXG4gICAgcC5jb3B5KHdoZWVsLmRpcmVjdGlvbldvcmxkKTtcclxuICAgIHAuc2NhbGUod2hlZWwuc3VzcGVuc2lvbkxlbmd0aCwgcCk7XHJcbiAgICBwLnZhZGQod2hlZWwuY2hhc3Npc0Nvbm5lY3Rpb25Qb2ludFdvcmxkLCBwKTtcclxufTtcclxuXHJcbnZhciBkaXJlY3Rpb25zID0gW1xyXG4gICAgbmV3IFZlYzMoMSwgMCwgMCksXHJcbiAgICBuZXcgVmVjMygwLCAxLCAwKSxcclxuICAgIG5ldyBWZWMzKDAsIDAsIDEpXHJcbl07XHJcblxyXG4vKipcclxuICogR2V0IHRoZSB3b3JsZCB0cmFuc2Zvcm0gb2Ygb25lIG9mIHRoZSB3aGVlbHNcclxuICogQG1ldGhvZCBnZXRXaGVlbFRyYW5zZm9ybVdvcmxkXHJcbiAqIEBwYXJhbSAge2ludGVnZXJ9IHdoZWVsSW5kZXhcclxuICogQHJldHVybiB7VHJhbnNmb3JtfVxyXG4gKi9cclxuUmF5Y2FzdFZlaGljbGUucHJvdG90eXBlLmdldFdoZWVsVHJhbnNmb3JtV29ybGQgPSBmdW5jdGlvbih3aGVlbEluZGV4KSB7XHJcbiAgICByZXR1cm4gdGhpcy53aGVlbEluZm9zW3doZWVsSW5kZXhdLndvcmxkVHJhbnNmb3JtO1xyXG59O1xyXG5cclxuXHJcbnZhciB1cGRhdGVGcmljdGlvbl9zdXJmTm9ybWFsV1Nfc2NhbGVkX3Byb2ogPSBuZXcgVmVjMygpO1xyXG52YXIgdXBkYXRlRnJpY3Rpb25fYXhsZSA9IFtdO1xyXG52YXIgdXBkYXRlRnJpY3Rpb25fZm9yd2FyZFdTID0gW107XHJcbnZhciBzaWRlRnJpY3Rpb25TdGlmZm5lc3MyID0gMTtcclxuUmF5Y2FzdFZlaGljbGUucHJvdG90eXBlLnVwZGF0ZUZyaWN0aW9uID0gZnVuY3Rpb24odGltZVN0ZXApIHtcclxuICAgIHZhciBzdXJmTm9ybWFsV1Nfc2NhbGVkX3Byb2ogPSB1cGRhdGVGcmljdGlvbl9zdXJmTm9ybWFsV1Nfc2NhbGVkX3Byb2o7XHJcblxyXG4gICAgLy9jYWxjdWxhdGUgdGhlIGltcHVsc2UsIHNvIHRoYXQgdGhlIHdoZWVscyBkb24ndCBtb3ZlIHNpZGV3YXJkc1xyXG4gICAgdmFyIHdoZWVsSW5mb3MgPSB0aGlzLndoZWVsSW5mb3M7XHJcbiAgICB2YXIgbnVtV2hlZWxzID0gd2hlZWxJbmZvcy5sZW5ndGg7XHJcbiAgICB2YXIgY2hhc3Npc0JvZHkgPSB0aGlzLmNoYXNzaXNCb2R5O1xyXG4gICAgdmFyIGZvcndhcmRXUyA9IHVwZGF0ZUZyaWN0aW9uX2ZvcndhcmRXUztcclxuICAgIHZhciBheGxlID0gdXBkYXRlRnJpY3Rpb25fYXhsZTtcclxuXHJcbiAgICB2YXIgbnVtV2hlZWxzT25Hcm91bmQgPSAwO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtV2hlZWxzOyBpKyspIHtcclxuICAgICAgICB2YXIgd2hlZWwgPSB3aGVlbEluZm9zW2ldO1xyXG5cclxuICAgICAgICB2YXIgZ3JvdW5kT2JqZWN0ID0gd2hlZWwucmF5Y2FzdFJlc3VsdC5ib2R5O1xyXG4gICAgICAgIGlmIChncm91bmRPYmplY3Qpe1xyXG4gICAgICAgICAgICBudW1XaGVlbHNPbkdyb3VuZCsrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgd2hlZWwuc2lkZUltcHVsc2UgPSAwO1xyXG4gICAgICAgIHdoZWVsLmZvcndhcmRJbXB1bHNlID0gMDtcclxuICAgICAgICBpZighZm9yd2FyZFdTW2ldKXtcclxuICAgICAgICAgICAgZm9yd2FyZFdTW2ldID0gbmV3IFZlYzMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYoIWF4bGVbaV0pe1xyXG4gICAgICAgICAgICBheGxlW2ldID0gbmV3IFZlYzMoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1XaGVlbHM7IGkrKyl7XHJcbiAgICAgICAgdmFyIHdoZWVsID0gd2hlZWxJbmZvc1tpXTtcclxuXHJcbiAgICAgICAgdmFyIGdyb3VuZE9iamVjdCA9IHdoZWVsLnJheWNhc3RSZXN1bHQuYm9keTtcclxuXHJcbiAgICAgICAgaWYgKGdyb3VuZE9iamVjdCkge1xyXG4gICAgICAgICAgICB2YXIgYXhsZWkgPSBheGxlW2ldO1xyXG4gICAgICAgICAgICB2YXIgd2hlZWxUcmFucyA9IHRoaXMuZ2V0V2hlZWxUcmFuc2Zvcm1Xb3JsZChpKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEdldCB3b3JsZCBheGxlXHJcbiAgICAgICAgICAgIHdoZWVsVHJhbnMudmVjdG9yVG9Xb3JsZEZyYW1lKGRpcmVjdGlvbnNbdGhpcy5pbmRleFJpZ2h0QXhpc10sIGF4bGVpKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBzdXJmTm9ybWFsV1MgPSB3aGVlbC5yYXljYXN0UmVzdWx0LmhpdE5vcm1hbFdvcmxkO1xyXG4gICAgICAgICAgICB2YXIgcHJvaiA9IGF4bGVpLmRvdChzdXJmTm9ybWFsV1MpO1xyXG4gICAgICAgICAgICBzdXJmTm9ybWFsV1Muc2NhbGUocHJvaiwgc3VyZk5vcm1hbFdTX3NjYWxlZF9wcm9qKTtcclxuICAgICAgICAgICAgYXhsZWkudnN1YihzdXJmTm9ybWFsV1Nfc2NhbGVkX3Byb2osIGF4bGVpKTtcclxuICAgICAgICAgICAgYXhsZWkubm9ybWFsaXplKCk7XHJcblxyXG4gICAgICAgICAgICBzdXJmTm9ybWFsV1MuY3Jvc3MoYXhsZWksIGZvcndhcmRXU1tpXSk7XHJcbiAgICAgICAgICAgIGZvcndhcmRXU1tpXS5ub3JtYWxpemUoKTtcclxuXHJcbiAgICAgICAgICAgIHdoZWVsLnNpZGVJbXB1bHNlID0gcmVzb2x2ZVNpbmdsZUJpbGF0ZXJhbChcclxuICAgICAgICAgICAgICAgIGNoYXNzaXNCb2R5LFxyXG4gICAgICAgICAgICAgICAgd2hlZWwucmF5Y2FzdFJlc3VsdC5oaXRQb2ludFdvcmxkLFxyXG4gICAgICAgICAgICAgICAgZ3JvdW5kT2JqZWN0LFxyXG4gICAgICAgICAgICAgICAgd2hlZWwucmF5Y2FzdFJlc3VsdC5oaXRQb2ludFdvcmxkLFxyXG4gICAgICAgICAgICAgICAgYXhsZWlcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIHdoZWVsLnNpZGVJbXB1bHNlICo9IHNpZGVGcmljdGlvblN0aWZmbmVzczI7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHZhciBzaWRlRmFjdG9yID0gMTtcclxuICAgIHZhciBmd2RGYWN0b3IgPSAwLjU7XHJcblxyXG4gICAgdGhpcy5zbGlkaW5nID0gZmFsc2U7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVdoZWVsczsgaSsrKSB7XHJcbiAgICAgICAgdmFyIHdoZWVsID0gd2hlZWxJbmZvc1tpXTtcclxuICAgICAgICB2YXIgZ3JvdW5kT2JqZWN0ID0gd2hlZWwucmF5Y2FzdFJlc3VsdC5ib2R5O1xyXG5cclxuICAgICAgICB2YXIgcm9sbGluZ0ZyaWN0aW9uID0gMDtcclxuXHJcbiAgICAgICAgd2hlZWwuc2xpcEluZm8gPSAxO1xyXG4gICAgICAgIGlmIChncm91bmRPYmplY3QpIHtcclxuICAgICAgICAgICAgdmFyIGRlZmF1bHRSb2xsaW5nRnJpY3Rpb25JbXB1bHNlID0gMDtcclxuICAgICAgICAgICAgdmFyIG1heEltcHVsc2UgPSB3aGVlbC5icmFrZSA/IHdoZWVsLmJyYWtlIDogZGVmYXVsdFJvbGxpbmdGcmljdGlvbkltcHVsc2U7XHJcblxyXG4gICAgICAgICAgICAvLyBidFdoZWVsQ29udGFjdFBvaW50IGNvbnRhY3RQdChjaGFzc2lzQm9keSxncm91bmRPYmplY3Qsd2hlZWxJbmZyYXljYXN0SW5mby5oaXRQb2ludFdvcmxkLGZvcndhcmRXU1t3aGVlbF0sbWF4SW1wdWxzZSk7XHJcbiAgICAgICAgICAgIC8vIHJvbGxpbmdGcmljdGlvbiA9IGNhbGNSb2xsaW5nRnJpY3Rpb24oY29udGFjdFB0KTtcclxuICAgICAgICAgICAgcm9sbGluZ0ZyaWN0aW9uID0gY2FsY1JvbGxpbmdGcmljdGlvbihjaGFzc2lzQm9keSwgZ3JvdW5kT2JqZWN0LCB3aGVlbC5yYXljYXN0UmVzdWx0LmhpdFBvaW50V29ybGQsIGZvcndhcmRXU1tpXSwgbWF4SW1wdWxzZSk7XHJcblxyXG4gICAgICAgICAgICByb2xsaW5nRnJpY3Rpb24gKz0gd2hlZWwuZW5naW5lRm9yY2UgKiB0aW1lU3RlcDtcclxuXHJcbiAgICAgICAgICAgIC8vIHJvbGxpbmdGcmljdGlvbiA9IDA7XHJcbiAgICAgICAgICAgIHZhciBmYWN0b3IgPSBtYXhJbXB1bHNlIC8gcm9sbGluZ0ZyaWN0aW9uO1xyXG4gICAgICAgICAgICB3aGVlbC5zbGlwSW5mbyAqPSBmYWN0b3I7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL3N3aXRjaCBiZXR3ZWVuIGFjdGl2ZSByb2xsaW5nICh0aHJvdHRsZSksIGJyYWtpbmcgYW5kIG5vbi1hY3RpdmUgcm9sbGluZyBmcmljdGlvbiAobnRocm90dGxlL2JyZWFrKVxyXG5cclxuICAgICAgICB3aGVlbC5mb3J3YXJkSW1wdWxzZSA9IDA7XHJcbiAgICAgICAgd2hlZWwuc2tpZEluZm8gPSAxO1xyXG5cclxuICAgICAgICBpZiAoZ3JvdW5kT2JqZWN0KSB7XHJcbiAgICAgICAgICAgIHdoZWVsLnNraWRJbmZvID0gMTtcclxuXHJcbiAgICAgICAgICAgIHZhciBtYXhpbXAgPSB3aGVlbC5zdXNwZW5zaW9uRm9yY2UgKiB0aW1lU3RlcCAqIHdoZWVsLmZyaWN0aW9uU2xpcDtcclxuICAgICAgICAgICAgdmFyIG1heGltcFNpZGUgPSBtYXhpbXA7XHJcblxyXG4gICAgICAgICAgICB2YXIgbWF4aW1wU3F1YXJlZCA9IG1heGltcCAqIG1heGltcFNpZGU7XHJcblxyXG4gICAgICAgICAgICB3aGVlbC5mb3J3YXJkSW1wdWxzZSA9IHJvbGxpbmdGcmljdGlvbjsvL3doZWVsSW5mby5lbmdpbmVGb3JjZSogdGltZVN0ZXA7XHJcblxyXG4gICAgICAgICAgICB2YXIgeCA9IHdoZWVsLmZvcndhcmRJbXB1bHNlICogZndkRmFjdG9yO1xyXG4gICAgICAgICAgICB2YXIgeSA9IHdoZWVsLnNpZGVJbXB1bHNlICogc2lkZUZhY3RvcjtcclxuXHJcbiAgICAgICAgICAgIHZhciBpbXB1bHNlU3F1YXJlZCA9IHggKiB4ICsgeSAqIHk7XHJcblxyXG4gICAgICAgICAgICB3aGVlbC5zbGlkaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGlmIChpbXB1bHNlU3F1YXJlZCA+IG1heGltcFNxdWFyZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2xpZGluZyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB3aGVlbC5zbGlkaW5nID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgZmFjdG9yID0gbWF4aW1wIC8gTWF0aC5zcXJ0KGltcHVsc2VTcXVhcmVkKTtcclxuXHJcbiAgICAgICAgICAgICAgICB3aGVlbC5za2lkSW5mbyAqPSBmYWN0b3I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuc2xpZGluZykge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtV2hlZWxzOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHdoZWVsID0gd2hlZWxJbmZvc1tpXTtcclxuICAgICAgICAgICAgaWYgKHdoZWVsLnNpZGVJbXB1bHNlICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAod2hlZWwuc2tpZEluZm8gPCAxKXtcclxuICAgICAgICAgICAgICAgICAgICB3aGVlbC5mb3J3YXJkSW1wdWxzZSAqPSB3aGVlbC5za2lkSW5mbztcclxuICAgICAgICAgICAgICAgICAgICB3aGVlbC5zaWRlSW1wdWxzZSAqPSB3aGVlbC5za2lkSW5mbztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBhcHBseSB0aGUgaW1wdWxzZXNcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtV2hlZWxzOyBpKyspIHtcclxuICAgICAgICB2YXIgd2hlZWwgPSB3aGVlbEluZm9zW2ldO1xyXG5cclxuICAgICAgICB2YXIgcmVsX3BvcyA9IG5ldyBWZWMzKCk7XHJcbiAgICAgICAgd2hlZWwucmF5Y2FzdFJlc3VsdC5oaXRQb2ludFdvcmxkLnZzdWIoY2hhc3Npc0JvZHkucG9zaXRpb24sIHJlbF9wb3MpO1xyXG4gICAgICAgIC8vIGNhbm5vbnMgYXBwbHlpbXB1bHNlIGlzIHVzaW5nIHdvcmxkIGNvb3JkIGZvciB0aGUgcG9zaXRpb25cclxuICAgICAgICAvL3JlbF9wb3MuY29weSh3aGVlbC5yYXljYXN0UmVzdWx0LmhpdFBvaW50V29ybGQpO1xyXG5cclxuICAgICAgICBpZiAod2hlZWwuZm9yd2FyZEltcHVsc2UgIT09IDApIHtcclxuICAgICAgICAgICAgdmFyIGltcHVsc2UgPSBuZXcgVmVjMygpO1xyXG4gICAgICAgICAgICBmb3J3YXJkV1NbaV0uc2NhbGUod2hlZWwuZm9yd2FyZEltcHVsc2UsIGltcHVsc2UpO1xyXG4gICAgICAgICAgICBjaGFzc2lzQm9keS5hcHBseUltcHVsc2UoaW1wdWxzZSwgcmVsX3Bvcyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAod2hlZWwuc2lkZUltcHVsc2UgIT09IDApe1xyXG4gICAgICAgICAgICB2YXIgZ3JvdW5kT2JqZWN0ID0gd2hlZWwucmF5Y2FzdFJlc3VsdC5ib2R5O1xyXG5cclxuICAgICAgICAgICAgdmFyIHJlbF9wb3MyID0gbmV3IFZlYzMoKTtcclxuICAgICAgICAgICAgd2hlZWwucmF5Y2FzdFJlc3VsdC5oaXRQb2ludFdvcmxkLnZzdWIoZ3JvdW5kT2JqZWN0LnBvc2l0aW9uLCByZWxfcG9zMik7XHJcbiAgICAgICAgICAgIC8vcmVsX3BvczIuY29weSh3aGVlbC5yYXljYXN0UmVzdWx0LmhpdFBvaW50V29ybGQpO1xyXG4gICAgICAgICAgICB2YXIgc2lkZUltcCA9IG5ldyBWZWMzKCk7XHJcbiAgICAgICAgICAgIGF4bGVbaV0uc2NhbGUod2hlZWwuc2lkZUltcHVsc2UsIHNpZGVJbXApO1xyXG5cclxuICAgICAgICAgICAgLy8gU2NhbGUgdGhlIHJlbGF0aXZlIHBvc2l0aW9uIGluIHRoZSB1cCBkaXJlY3Rpb24gd2l0aCByb2xsSW5mbHVlbmNlLlxyXG4gICAgICAgICAgICAvLyBJZiByb2xsSW5mbHVlbmNlIGlzIDEsIHRoZSBpbXB1bHNlIHdpbGwgYmUgYXBwbGllZCBvbiB0aGUgaGl0UG9pbnQgKGVhc3kgdG8gcm9sbCBvdmVyKSwgaWYgaXQgaXMgemVybyBpdCB3aWxsIGJlIGFwcGxpZWQgaW4gdGhlIHNhbWUgcGxhbmUgYXMgdGhlIGNlbnRlciBvZiBtYXNzIChub3QgZWFzeSB0byByb2xsIG92ZXIpLlxyXG4gICAgICAgICAgICBjaGFzc2lzQm9keS52ZWN0b3JUb0xvY2FsRnJhbWUocmVsX3BvcywgcmVsX3Bvcyk7XHJcbiAgICAgICAgICAgIHJlbF9wb3NbJ3h5eidbdGhpcy5pbmRleFVwQXhpc11dICo9IHdoZWVsLnJvbGxJbmZsdWVuY2U7XHJcbiAgICAgICAgICAgIGNoYXNzaXNCb2R5LnZlY3RvclRvV29ybGRGcmFtZShyZWxfcG9zLCByZWxfcG9zKTtcclxuICAgICAgICAgICAgY2hhc3Npc0JvZHkuYXBwbHlJbXB1bHNlKHNpZGVJbXAsIHJlbF9wb3MpO1xyXG5cclxuICAgICAgICAgICAgLy9hcHBseSBmcmljdGlvbiBpbXB1bHNlIG9uIHRoZSBncm91bmRcclxuICAgICAgICAgICAgc2lkZUltcC5zY2FsZSgtMSwgc2lkZUltcCk7XHJcbiAgICAgICAgICAgIGdyb3VuZE9iamVjdC5hcHBseUltcHVsc2Uoc2lkZUltcCwgcmVsX3BvczIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbnZhciBjYWxjUm9sbGluZ0ZyaWN0aW9uX3ZlbDEgPSBuZXcgVmVjMygpO1xyXG52YXIgY2FsY1JvbGxpbmdGcmljdGlvbl92ZWwyID0gbmV3IFZlYzMoKTtcclxudmFyIGNhbGNSb2xsaW5nRnJpY3Rpb25fdmVsID0gbmV3IFZlYzMoKTtcclxuXHJcbmZ1bmN0aW9uIGNhbGNSb2xsaW5nRnJpY3Rpb24oYm9keTAsIGJvZHkxLCBmcmljdGlvblBvc1dvcmxkLCBmcmljdGlvbkRpcmVjdGlvbldvcmxkLCBtYXhJbXB1bHNlKSB7XHJcbiAgICB2YXIgajEgPSAwO1xyXG4gICAgdmFyIGNvbnRhY3RQb3NXb3JsZCA9IGZyaWN0aW9uUG9zV29ybGQ7XHJcblxyXG4gICAgLy8gdmFyIHJlbF9wb3MxID0gbmV3IFZlYzMoKTtcclxuICAgIC8vIHZhciByZWxfcG9zMiA9IG5ldyBWZWMzKCk7XHJcbiAgICB2YXIgdmVsMSA9IGNhbGNSb2xsaW5nRnJpY3Rpb25fdmVsMTtcclxuICAgIHZhciB2ZWwyID0gY2FsY1JvbGxpbmdGcmljdGlvbl92ZWwyO1xyXG4gICAgdmFyIHZlbCA9IGNhbGNSb2xsaW5nRnJpY3Rpb25fdmVsO1xyXG4gICAgLy8gY29udGFjdFBvc1dvcmxkLnZzdWIoYm9keTAucG9zaXRpb24sIHJlbF9wb3MxKTtcclxuICAgIC8vIGNvbnRhY3RQb3NXb3JsZC52c3ViKGJvZHkxLnBvc2l0aW9uLCByZWxfcG9zMik7XHJcblxyXG4gICAgYm9keTAuZ2V0VmVsb2NpdHlBdFdvcmxkUG9pbnQoY29udGFjdFBvc1dvcmxkLCB2ZWwxKTtcclxuICAgIGJvZHkxLmdldFZlbG9jaXR5QXRXb3JsZFBvaW50KGNvbnRhY3RQb3NXb3JsZCwgdmVsMik7XHJcbiAgICB2ZWwxLnZzdWIodmVsMiwgdmVsKTtcclxuXHJcbiAgICB2YXIgdnJlbCA9IGZyaWN0aW9uRGlyZWN0aW9uV29ybGQuZG90KHZlbCk7XHJcblxyXG4gICAgdmFyIGRlbm9tMCA9IGNvbXB1dGVJbXB1bHNlRGVub21pbmF0b3IoYm9keTAsIGZyaWN0aW9uUG9zV29ybGQsIGZyaWN0aW9uRGlyZWN0aW9uV29ybGQpO1xyXG4gICAgdmFyIGRlbm9tMSA9IGNvbXB1dGVJbXB1bHNlRGVub21pbmF0b3IoYm9keTEsIGZyaWN0aW9uUG9zV29ybGQsIGZyaWN0aW9uRGlyZWN0aW9uV29ybGQpO1xyXG4gICAgdmFyIHJlbGF4YXRpb24gPSAxO1xyXG4gICAgdmFyIGphY0RpYWdBQkludiA9IHJlbGF4YXRpb24gLyAoZGVub20wICsgZGVub20xKTtcclxuXHJcbiAgICAvLyBjYWxjdWxhdGUgaiB0aGF0IG1vdmVzIHVzIHRvIHplcm8gcmVsYXRpdmUgdmVsb2NpdHlcclxuICAgIGoxID0gLXZyZWwgKiBqYWNEaWFnQUJJbnY7XHJcblxyXG4gICAgaWYgKG1heEltcHVsc2UgPCBqMSkge1xyXG4gICAgICAgIGoxID0gbWF4SW1wdWxzZTtcclxuICAgIH1cclxuICAgIGlmIChqMSA8IC1tYXhJbXB1bHNlKSB7XHJcbiAgICAgICAgajEgPSAtbWF4SW1wdWxzZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gajE7XHJcbn1cclxuXHJcbnZhciBjb21wdXRlSW1wdWxzZURlbm9taW5hdG9yX3IwID0gbmV3IFZlYzMoKTtcclxudmFyIGNvbXB1dGVJbXB1bHNlRGVub21pbmF0b3JfYzAgPSBuZXcgVmVjMygpO1xyXG52YXIgY29tcHV0ZUltcHVsc2VEZW5vbWluYXRvcl92ZWMgPSBuZXcgVmVjMygpO1xyXG52YXIgY29tcHV0ZUltcHVsc2VEZW5vbWluYXRvcl9tID0gbmV3IFZlYzMoKTtcclxuZnVuY3Rpb24gY29tcHV0ZUltcHVsc2VEZW5vbWluYXRvcihib2R5LCBwb3MsIG5vcm1hbCkge1xyXG4gICAgdmFyIHIwID0gY29tcHV0ZUltcHVsc2VEZW5vbWluYXRvcl9yMDtcclxuICAgIHZhciBjMCA9IGNvbXB1dGVJbXB1bHNlRGVub21pbmF0b3JfYzA7XHJcbiAgICB2YXIgdmVjID0gY29tcHV0ZUltcHVsc2VEZW5vbWluYXRvcl92ZWM7XHJcbiAgICB2YXIgbSA9IGNvbXB1dGVJbXB1bHNlRGVub21pbmF0b3JfbTtcclxuXHJcbiAgICBwb3MudnN1Yihib2R5LnBvc2l0aW9uLCByMCk7XHJcbiAgICByMC5jcm9zcyhub3JtYWwsIGMwKTtcclxuICAgIGJvZHkuaW52SW5lcnRpYVdvcmxkLnZtdWx0KGMwLCBtKTtcclxuICAgIG0uY3Jvc3MocjAsIHZlYyk7XHJcblxyXG4gICAgcmV0dXJuIGJvZHkuaW52TWFzcyArIG5vcm1hbC5kb3QodmVjKTtcclxufVxyXG5cclxuXHJcbnZhciByZXNvbHZlU2luZ2xlQmlsYXRlcmFsX3ZlbDEgPSBuZXcgVmVjMygpO1xyXG52YXIgcmVzb2x2ZVNpbmdsZUJpbGF0ZXJhbF92ZWwyID0gbmV3IFZlYzMoKTtcclxudmFyIHJlc29sdmVTaW5nbGVCaWxhdGVyYWxfdmVsID0gbmV3IFZlYzMoKTtcclxuXHJcbi8vYmlsYXRlcmFsIGNvbnN0cmFpbnQgYmV0d2VlbiB0d28gZHluYW1pYyBvYmplY3RzXHJcbmZ1bmN0aW9uIHJlc29sdmVTaW5nbGVCaWxhdGVyYWwoYm9keTEsIHBvczEsIGJvZHkyLCBwb3MyLCBub3JtYWwsIGltcHVsc2Upe1xyXG4gICAgdmFyIG5vcm1hbExlblNxciA9IG5vcm1hbC5ub3JtMigpO1xyXG4gICAgaWYgKG5vcm1hbExlblNxciA+IDEuMSl7XHJcbiAgICAgICAgcmV0dXJuIDA7IC8vIG5vIGltcHVsc2VcclxuICAgIH1cclxuICAgIC8vIHZhciByZWxfcG9zMSA9IG5ldyBWZWMzKCk7XHJcbiAgICAvLyB2YXIgcmVsX3BvczIgPSBuZXcgVmVjMygpO1xyXG4gICAgLy8gcG9zMS52c3ViKGJvZHkxLnBvc2l0aW9uLCByZWxfcG9zMSk7XHJcbiAgICAvLyBwb3MyLnZzdWIoYm9keTIucG9zaXRpb24sIHJlbF9wb3MyKTtcclxuXHJcbiAgICB2YXIgdmVsMSA9IHJlc29sdmVTaW5nbGVCaWxhdGVyYWxfdmVsMTtcclxuICAgIHZhciB2ZWwyID0gcmVzb2x2ZVNpbmdsZUJpbGF0ZXJhbF92ZWwyO1xyXG4gICAgdmFyIHZlbCA9IHJlc29sdmVTaW5nbGVCaWxhdGVyYWxfdmVsO1xyXG4gICAgYm9keTEuZ2V0VmVsb2NpdHlBdFdvcmxkUG9pbnQocG9zMSwgdmVsMSk7XHJcbiAgICBib2R5Mi5nZXRWZWxvY2l0eUF0V29ybGRQb2ludChwb3MyLCB2ZWwyKTtcclxuXHJcbiAgICB2ZWwxLnZzdWIodmVsMiwgdmVsKTtcclxuXHJcbiAgICB2YXIgcmVsX3ZlbCA9IG5vcm1hbC5kb3QodmVsKTtcclxuXHJcbiAgICB2YXIgY29udGFjdERhbXBpbmcgPSAwLjI7XHJcbiAgICB2YXIgbWFzc1Rlcm0gPSAxIC8gKGJvZHkxLmludk1hc3MgKyBib2R5Mi5pbnZNYXNzKTtcclxuICAgIHZhciBpbXB1bHNlID0gLSBjb250YWN0RGFtcGluZyAqIHJlbF92ZWwgKiBtYXNzVGVybTtcclxuXHJcbiAgICByZXR1cm4gaW1wdWxzZTtcclxufVxyXG59LHtcIi4uL2NvbGxpc2lvbi9SYXlcIjoxMCxcIi4uL2NvbGxpc2lvbi9SYXljYXN0UmVzdWx0XCI6MTEsXCIuLi9tYXRoL1F1YXRlcm5pb25cIjoyOSxcIi4uL21hdGgvVmVjM1wiOjMxLFwiLi4vb2JqZWN0cy9XaGVlbEluZm9cIjozNyxcIi4vQm9keVwiOjMyfV0sMzQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xyXG52YXIgQm9keSA9IF9kZXJlcV8oJy4vQm9keScpO1xyXG52YXIgU3BoZXJlID0gX2RlcmVxXygnLi4vc2hhcGVzL1NwaGVyZScpO1xyXG52YXIgQm94ID0gX2RlcmVxXygnLi4vc2hhcGVzL0JveCcpO1xyXG52YXIgVmVjMyA9IF9kZXJlcV8oJy4uL21hdGgvVmVjMycpO1xyXG52YXIgSGluZ2VDb25zdHJhaW50ID0gX2RlcmVxXygnLi4vY29uc3RyYWludHMvSGluZ2VDb25zdHJhaW50Jyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJpZ2lkVmVoaWNsZTtcclxuXHJcbi8qKlxyXG4gKiBTaW1wbGUgdmVoaWNsZSBoZWxwZXIgY2xhc3Mgd2l0aCBzcGhlcmljYWwgcmlnaWQgYm9keSB3aGVlbHMuXHJcbiAqIEBjbGFzcyBSaWdpZFZlaGljbGVcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7Qm9keX0gW29wdGlvbnMuY2hhc3Npc0JvZHldXHJcbiAqL1xyXG5mdW5jdGlvbiBSaWdpZFZlaGljbGUob3B0aW9ucyl7XHJcbiAgICB0aGlzLndoZWVsQm9kaWVzID0gW107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkgY29vcmRpbmF0ZVN5c3RlbVxyXG4gICAgICogQHR5cGUge1ZlYzN9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuY29vcmRpbmF0ZVN5c3RlbSA9IHR5cGVvZihvcHRpb25zLmNvb3JkaW5hdGVTeXN0ZW0pPT09J3VuZGVmaW5lZCcgPyBuZXcgVmVjMygxLCAyLCAzKSA6IG9wdGlvbnMuY29vcmRpbmF0ZVN5c3RlbS5jbG9uZSgpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IHtCb2R5fSBjaGFzc2lzQm9keVxyXG4gICAgICovXHJcbiAgICB0aGlzLmNoYXNzaXNCb2R5ID0gb3B0aW9ucy5jaGFzc2lzQm9keTtcclxuXHJcbiAgICBpZighdGhpcy5jaGFzc2lzQm9keSl7XHJcbiAgICAgICAgLy8gTm8gY2hhc3NpcyBib2R5IGdpdmVuLiBDcmVhdGUgaXQhXHJcbiAgICAgICAgdmFyIGNoYXNzaXNTaGFwZSA9IG5ldyBCb3gobmV3IFZlYzMoNSwgMiwgMC41KSk7XHJcbiAgICAgICAgdGhpcy5jaGFzc2lzQm9keSA9IG5ldyBCb2R5KDEsIGNoYXNzaXNTaGFwZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkgY29uc3RyYWludHNcclxuICAgICAqIEB0eXBlIHtBcnJheX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5jb25zdHJhaW50cyA9IFtdO1xyXG5cclxuICAgIHRoaXMud2hlZWxBeGVzID0gW107XHJcbiAgICB0aGlzLndoZWVsRm9yY2VzID0gW107XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBZGQgYSB3aGVlbFxyXG4gKiBAbWV0aG9kIGFkZFdoZWVsXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuaXNGcm9udFdoZWVsXVxyXG4gKiBAcGFyYW0ge1ZlYzN9IFtvcHRpb25zLnBvc2l0aW9uXSBQb3NpdGlvbiBvZiB0aGUgd2hlZWwsIGxvY2FsbHkgaW4gdGhlIGNoYXNzaXMgYm9keS5cclxuICogQHBhcmFtIHtWZWMzfSBbb3B0aW9ucy5kaXJlY3Rpb25dIFNsaWRlIGRpcmVjdGlvbiBvZiB0aGUgd2hlZWwgYWxvbmcgdGhlIHN1c3BlbnNpb24uXHJcbiAqIEBwYXJhbSB7VmVjM30gW29wdGlvbnMuYXhpc10gQXhpcyBvZiByb3RhdGlvbiBvZiB0aGUgd2hlZWwsIGxvY2FsbHkgZGVmaW5lZCBpbiB0aGUgY2hhc3Npcy5cclxuICogQHBhcmFtIHtCb2R5fSBbb3B0aW9ucy5ib2R5XSBUaGUgd2hlZWwgYm9keS5cclxuICovXHJcblJpZ2lkVmVoaWNsZS5wcm90b3R5cGUuYWRkV2hlZWwgPSBmdW5jdGlvbihvcHRpb25zKXtcclxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgdmFyIHdoZWVsQm9keSA9IG9wdGlvbnMuYm9keTtcclxuICAgIGlmKCF3aGVlbEJvZHkpe1xyXG4gICAgICAgIHdoZWVsQm9keSA9ICBuZXcgQm9keSgxLCBuZXcgU3BoZXJlKDEuMikpO1xyXG4gICAgfVxyXG4gICAgdGhpcy53aGVlbEJvZGllcy5wdXNoKHdoZWVsQm9keSk7XHJcbiAgICB0aGlzLndoZWVsRm9yY2VzLnB1c2goMCk7XHJcblxyXG4gICAgLy8gUG9zaXRpb24gY29uc3RyYWluIHdoZWVsc1xyXG4gICAgdmFyIHplcm8gPSBuZXcgVmVjMygpO1xyXG4gICAgdmFyIHBvc2l0aW9uID0gdHlwZW9mKG9wdGlvbnMucG9zaXRpb24pICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMucG9zaXRpb24uY2xvbmUoKSA6IG5ldyBWZWMzKCk7XHJcblxyXG4gICAgLy8gU2V0IHBvc2l0aW9uIGxvY2FsbHkgdG8gdGhlIGNoYXNzaXNcclxuICAgIHZhciB3b3JsZFBvc2l0aW9uID0gbmV3IFZlYzMoKTtcclxuICAgIHRoaXMuY2hhc3Npc0JvZHkucG9pbnRUb1dvcmxkRnJhbWUocG9zaXRpb24sIHdvcmxkUG9zaXRpb24pO1xyXG4gICAgd2hlZWxCb2R5LnBvc2l0aW9uLnNldCh3b3JsZFBvc2l0aW9uLngsIHdvcmxkUG9zaXRpb24ueSwgd29ybGRQb3NpdGlvbi56KTtcclxuXHJcbiAgICAvLyBDb25zdHJhaW4gd2hlZWxcclxuICAgIHZhciBheGlzID0gdHlwZW9mKG9wdGlvbnMuYXhpcykgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5heGlzLmNsb25lKCkgOiBuZXcgVmVjMygwLCAxLCAwKTtcclxuICAgIHRoaXMud2hlZWxBeGVzLnB1c2goYXhpcyk7XHJcblxyXG4gICAgdmFyIGhpbmdlQ29uc3RyYWludCA9IG5ldyBIaW5nZUNvbnN0cmFpbnQodGhpcy5jaGFzc2lzQm9keSwgd2hlZWxCb2R5LCB7XHJcbiAgICAgICAgcGl2b3RBOiBwb3NpdGlvbixcclxuICAgICAgICBheGlzQTogYXhpcyxcclxuICAgICAgICBwaXZvdEI6IFZlYzMuWkVSTyxcclxuICAgICAgICBheGlzQjogYXhpcyxcclxuICAgICAgICBjb2xsaWRlQ29ubmVjdGVkOiBmYWxzZVxyXG4gICAgfSk7XHJcbiAgICB0aGlzLmNvbnN0cmFpbnRzLnB1c2goaGluZ2VDb25zdHJhaW50KTtcclxuXHJcbiAgICByZXR1cm4gdGhpcy53aGVlbEJvZGllcy5sZW5ndGggLSAxO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFNldCB0aGUgc3RlZXJpbmcgdmFsdWUgb2YgYSB3aGVlbC5cclxuICogQG1ldGhvZCBzZXRTdGVlcmluZ1ZhbHVlXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxyXG4gKiBAcGFyYW0ge2ludGVnZXJ9IHdoZWVsSW5kZXhcclxuICogQHRvZG8gY2hlY2sgY29vcmRpbmF0ZVN5c3RlbVxyXG4gKi9cclxuUmlnaWRWZWhpY2xlLnByb3RvdHlwZS5zZXRTdGVlcmluZ1ZhbHVlID0gZnVuY3Rpb24odmFsdWUsIHdoZWVsSW5kZXgpe1xyXG4gICAgLy8gU2V0IGFuZ2xlIG9mIHRoZSBoaW5nZSBheGlzXHJcbiAgICB2YXIgYXhpcyA9IHRoaXMud2hlZWxBeGVzW3doZWVsSW5kZXhdO1xyXG5cclxuICAgIHZhciBjID0gTWF0aC5jb3ModmFsdWUpLFxyXG4gICAgICAgIHMgPSBNYXRoLnNpbih2YWx1ZSksXHJcbiAgICAgICAgeCA9IGF4aXMueCxcclxuICAgICAgICB5ID0gYXhpcy55O1xyXG4gICAgdGhpcy5jb25zdHJhaW50c1t3aGVlbEluZGV4XS5heGlzQS5zZXQoXHJcbiAgICAgICAgYyp4IC1zKnksXHJcbiAgICAgICAgcyp4ICtjKnksXHJcbiAgICAgICAgMFxyXG4gICAgKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTZXQgdGhlIHRhcmdldCByb3RhdGlvbmFsIHNwZWVkIG9mIHRoZSBoaW5nZSBjb25zdHJhaW50LlxyXG4gKiBAbWV0aG9kIHNldE1vdG9yU3BlZWRcclxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXHJcbiAqIEBwYXJhbSB7aW50ZWdlcn0gd2hlZWxJbmRleFxyXG4gKi9cclxuUmlnaWRWZWhpY2xlLnByb3RvdHlwZS5zZXRNb3RvclNwZWVkID0gZnVuY3Rpb24odmFsdWUsIHdoZWVsSW5kZXgpe1xyXG4gICAgdmFyIGhpbmdlQ29uc3RyYWludCA9IHRoaXMuY29uc3RyYWludHNbd2hlZWxJbmRleF07XHJcbiAgICBoaW5nZUNvbnN0cmFpbnQuZW5hYmxlTW90b3IoKTtcclxuICAgIGhpbmdlQ29uc3RyYWludC5tb3RvclRhcmdldFZlbG9jaXR5ID0gdmFsdWU7XHJcbn07XHJcblxyXG4vKipcclxuICogU2V0IHRoZSB0YXJnZXQgcm90YXRpb25hbCBzcGVlZCBvZiB0aGUgaGluZ2UgY29uc3RyYWludC5cclxuICogQG1ldGhvZCBkaXNhYmxlTW90b3JcclxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXHJcbiAqIEBwYXJhbSB7aW50ZWdlcn0gd2hlZWxJbmRleFxyXG4gKi9cclxuUmlnaWRWZWhpY2xlLnByb3RvdHlwZS5kaXNhYmxlTW90b3IgPSBmdW5jdGlvbih3aGVlbEluZGV4KXtcclxuICAgIHZhciBoaW5nZUNvbnN0cmFpbnQgPSB0aGlzLmNvbnN0cmFpbnRzW3doZWVsSW5kZXhdO1xyXG4gICAgaGluZ2VDb25zdHJhaW50LmRpc2FibGVNb3RvcigpO1xyXG59O1xyXG5cclxudmFyIHRvcnF1ZSA9IG5ldyBWZWMzKCk7XHJcblxyXG4vKipcclxuICogU2V0IHRoZSB3aGVlbCBmb3JjZSB0byBhcHBseSBvbiBvbmUgb2YgdGhlIHdoZWVscyBlYWNoIHRpbWUgc3RlcFxyXG4gKiBAbWV0aG9kIHNldFdoZWVsRm9yY2VcclxuICogQHBhcmFtICB7bnVtYmVyfSB2YWx1ZVxyXG4gKiBAcGFyYW0gIHtpbnRlZ2VyfSB3aGVlbEluZGV4XHJcbiAqL1xyXG5SaWdpZFZlaGljbGUucHJvdG90eXBlLnNldFdoZWVsRm9yY2UgPSBmdW5jdGlvbih2YWx1ZSwgd2hlZWxJbmRleCl7XHJcbiAgICB0aGlzLndoZWVsRm9yY2VzW3doZWVsSW5kZXhdID0gdmFsdWU7XHJcbn07XHJcblxyXG4vKipcclxuICogQXBwbHkgYSB0b3JxdWUgb24gb25lIG9mIHRoZSB3aGVlbHMuXHJcbiAqIEBtZXRob2QgYXBwbHlXaGVlbEZvcmNlXHJcbiAqIEBwYXJhbSAge251bWJlcn0gdmFsdWVcclxuICogQHBhcmFtICB7aW50ZWdlcn0gd2hlZWxJbmRleFxyXG4gKi9cclxuUmlnaWRWZWhpY2xlLnByb3RvdHlwZS5hcHBseVdoZWVsRm9yY2UgPSBmdW5jdGlvbih2YWx1ZSwgd2hlZWxJbmRleCl7XHJcbiAgICB2YXIgYXhpcyA9IHRoaXMud2hlZWxBeGVzW3doZWVsSW5kZXhdO1xyXG4gICAgdmFyIHdoZWVsQm9keSA9IHRoaXMud2hlZWxCb2RpZXNbd2hlZWxJbmRleF07XHJcbiAgICB2YXIgYm9keVRvcnF1ZSA9IHdoZWVsQm9keS50b3JxdWU7XHJcblxyXG4gICAgYXhpcy5zY2FsZSh2YWx1ZSwgdG9ycXVlKTtcclxuICAgIHdoZWVsQm9keS52ZWN0b3JUb1dvcmxkRnJhbWUodG9ycXVlLCB0b3JxdWUpO1xyXG4gICAgYm9keVRvcnF1ZS52YWRkKHRvcnF1ZSwgYm9keVRvcnF1ZSk7XHJcbn07XHJcblxyXG4vKipcclxuICogQWRkIHRoZSB2ZWhpY2xlIGluY2x1ZGluZyBpdHMgY29uc3RyYWludHMgdG8gdGhlIHdvcmxkLlxyXG4gKiBAbWV0aG9kIGFkZFRvV29ybGRcclxuICogQHBhcmFtIHtXb3JsZH0gd29ybGRcclxuICovXHJcblJpZ2lkVmVoaWNsZS5wcm90b3R5cGUuYWRkVG9Xb3JsZCA9IGZ1bmN0aW9uKHdvcmxkKXtcclxuICAgIHZhciBjb25zdHJhaW50cyA9IHRoaXMuY29uc3RyYWludHM7XHJcbiAgICB2YXIgYm9kaWVzID0gdGhpcy53aGVlbEJvZGllcy5jb25jYXQoW3RoaXMuY2hhc3Npc0JvZHldKTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvZGllcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHdvcmxkLmFkZEJvZHkoYm9kaWVzW2ldKTtcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbnN0cmFpbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgd29ybGQuYWRkQ29uc3RyYWludChjb25zdHJhaW50c1tpXSk7XHJcbiAgICB9XHJcblxyXG4gICAgd29ybGQuYWRkRXZlbnRMaXN0ZW5lcigncHJlU3RlcCcsIHRoaXMuX3VwZGF0ZS5iaW5kKHRoaXMpKTtcclxufTtcclxuXHJcblJpZ2lkVmVoaWNsZS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uKCl7XHJcbiAgICB2YXIgd2hlZWxGb3JjZXMgPSB0aGlzLndoZWVsRm9yY2VzO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB3aGVlbEZvcmNlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHRoaXMuYXBwbHlXaGVlbEZvcmNlKHdoZWVsRm9yY2VzW2ldLCBpKTtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZW1vdmUgdGhlIHZlaGljbGUgaW5jbHVkaW5nIGl0cyBjb25zdHJhaW50cyBmcm9tIHRoZSB3b3JsZC5cclxuICogQG1ldGhvZCByZW1vdmVGcm9tV29ybGRcclxuICogQHBhcmFtIHtXb3JsZH0gd29ybGRcclxuICovXHJcblJpZ2lkVmVoaWNsZS5wcm90b3R5cGUucmVtb3ZlRnJvbVdvcmxkID0gZnVuY3Rpb24od29ybGQpe1xyXG4gICAgdmFyIGNvbnN0cmFpbnRzID0gdGhpcy5jb25zdHJhaW50cztcclxuICAgIHZhciBib2RpZXMgPSB0aGlzLndoZWVsQm9kaWVzLmNvbmNhdChbdGhpcy5jaGFzc2lzQm9keV0pO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9kaWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgd29ybGQucmVtb3ZlKGJvZGllc1tpXSk7XHJcbiAgICB9XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb25zdHJhaW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHdvcmxkLnJlbW92ZUNvbnN0cmFpbnQoY29uc3RyYWludHNbaV0pO1xyXG4gICAgfVxyXG59O1xyXG5cclxudmFyIHdvcmxkQXhpcyA9IG5ldyBWZWMzKCk7XHJcblxyXG4vKipcclxuICogR2V0IGN1cnJlbnQgcm90YXRpb25hbCB2ZWxvY2l0eSBvZiBhIHdoZWVsXHJcbiAqIEBtZXRob2QgZ2V0V2hlZWxTcGVlZFxyXG4gKiBAcGFyYW0ge2ludGVnZXJ9IHdoZWVsSW5kZXhcclxuICovXHJcblJpZ2lkVmVoaWNsZS5wcm90b3R5cGUuZ2V0V2hlZWxTcGVlZCA9IGZ1bmN0aW9uKHdoZWVsSW5kZXgpe1xyXG4gICAgdmFyIGF4aXMgPSB0aGlzLndoZWVsQXhlc1t3aGVlbEluZGV4XTtcclxuICAgIHZhciB3aGVlbEJvZHkgPSB0aGlzLndoZWVsQm9kaWVzW3doZWVsSW5kZXhdO1xyXG4gICAgdmFyIHcgPSB3aGVlbEJvZHkuYW5ndWxhclZlbG9jaXR5O1xyXG4gICAgdGhpcy5jaGFzc2lzQm9keS52ZWN0b3JUb1dvcmxkRnJhbWUoYXhpcywgd29ybGRBeGlzKTtcclxuICAgIHJldHVybiB3LmRvdCh3b3JsZEF4aXMpO1xyXG59O1xyXG5cclxufSx7XCIuLi9jb25zdHJhaW50cy9IaW5nZUNvbnN0cmFpbnRcIjoxNixcIi4uL21hdGgvVmVjM1wiOjMxLFwiLi4vc2hhcGVzL0JveFwiOjM4LFwiLi4vc2hhcGVzL1NwaGVyZVwiOjQ1LFwiLi9Cb2R5XCI6MzJ9XSwzNTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XHJcbm1vZHVsZS5leHBvcnRzID0gU1BIU3lzdGVtO1xyXG5cclxudmFyIFNoYXBlID0gX2RlcmVxXygnLi4vc2hhcGVzL1NoYXBlJyk7XHJcbnZhciBWZWMzID0gX2RlcmVxXygnLi4vbWF0aC9WZWMzJyk7XHJcbnZhciBRdWF0ZXJuaW9uID0gX2RlcmVxXygnLi4vbWF0aC9RdWF0ZXJuaW9uJyk7XHJcbnZhciBQYXJ0aWNsZSA9IF9kZXJlcV8oJy4uL3NoYXBlcy9QYXJ0aWNsZScpO1xyXG52YXIgQm9keSA9IF9kZXJlcV8oJy4uL29iamVjdHMvQm9keScpO1xyXG52YXIgTWF0ZXJpYWwgPSBfZGVyZXFfKCcuLi9tYXRlcmlhbC9NYXRlcmlhbCcpO1xyXG5cclxuLyoqXHJcbiAqIFNtb290aGVkLXBhcnRpY2xlIGh5ZHJvZHluYW1pY3Mgc3lzdGVtXHJcbiAqIEBjbGFzcyBTUEhTeXN0ZW1cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5mdW5jdGlvbiBTUEhTeXN0ZW0oKXtcclxuICAgIHRoaXMucGFydGljbGVzID0gW107XHJcblx0XHJcbiAgICAvKipcclxuICAgICAqIERlbnNpdHkgb2YgdGhlIHN5c3RlbSAoa2cvbTMpLlxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGRlbnNpdHlcclxuICAgICAqL1xyXG4gICAgdGhpcy5kZW5zaXR5ID0gMTtcclxuXHRcclxuICAgIC8qKlxyXG4gICAgICogRGlzdGFuY2UgYmVsb3cgd2hpY2ggdHdvIHBhcnRpY2xlcyBhcmUgY29uc2lkZXJlZCB0byBiZSBuZWlnaGJvcnMuXHJcbiAgICAgKiBJdCBzaG91bGQgYmUgYWRqdXN0ZWQgc28gdGhlcmUgYXJlIGFib3V0IDE1LTIwIG5laWdoYm9yIHBhcnRpY2xlcyB3aXRoaW4gdGhpcyByYWRpdXMuXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gc21vb3RoaW5nUmFkaXVzXHJcbiAgICAgKi9cclxuICAgIHRoaXMuc21vb3RoaW5nUmFkaXVzID0gMTtcclxuICAgIHRoaXMuc3BlZWRPZlNvdW5kID0gMTtcclxuXHRcclxuICAgIC8qKlxyXG4gICAgICogVmlzY29zaXR5IG9mIHRoZSBzeXN0ZW0uXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gdmlzY29zaXR5XHJcbiAgICAgKi9cclxuICAgIHRoaXMudmlzY29zaXR5ID0gMC4wMTtcclxuICAgIHRoaXMuZXBzID0gMC4wMDAwMDE7XHJcblxyXG4gICAgLy8gU3R1ZmYgQ29tcHV0ZWQgcGVyIHBhcnRpY2xlXHJcbiAgICB0aGlzLnByZXNzdXJlcyA9IFtdO1xyXG4gICAgdGhpcy5kZW5zaXRpZXMgPSBbXTtcclxuICAgIHRoaXMubmVpZ2hib3JzID0gW107XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBZGQgYSBwYXJ0aWNsZSB0byB0aGUgc3lzdGVtLlxyXG4gKiBAbWV0aG9kIGFkZFxyXG4gKiBAcGFyYW0ge0JvZHl9IHBhcnRpY2xlXHJcbiAqL1xyXG5TUEhTeXN0ZW0ucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKHBhcnRpY2xlKXtcclxuICAgIHRoaXMucGFydGljbGVzLnB1c2gocGFydGljbGUpO1xyXG4gICAgaWYodGhpcy5uZWlnaGJvcnMubGVuZ3RoIDwgdGhpcy5wYXJ0aWNsZXMubGVuZ3RoKXtcclxuICAgICAgICB0aGlzLm5laWdoYm9ycy5wdXNoKFtdKTtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZW1vdmUgYSBwYXJ0aWNsZSBmcm9tIHRoZSBzeXN0ZW0uXHJcbiAqIEBtZXRob2QgcmVtb3ZlXHJcbiAqIEBwYXJhbSB7Qm9keX0gcGFydGljbGVcclxuICovXHJcblNQSFN5c3RlbS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24ocGFydGljbGUpe1xyXG4gICAgdmFyIGlkeCA9IHRoaXMucGFydGljbGVzLmluZGV4T2YocGFydGljbGUpO1xyXG4gICAgaWYoaWR4ICE9PSAtMSl7XHJcbiAgICAgICAgdGhpcy5wYXJ0aWNsZXMuc3BsaWNlKGlkeCwxKTtcclxuICAgICAgICBpZih0aGlzLm5laWdoYm9ycy5sZW5ndGggPiB0aGlzLnBhcnRpY2xlcy5sZW5ndGgpe1xyXG4gICAgICAgICAgICB0aGlzLm5laWdoYm9ycy5wb3AoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0IG5laWdoYm9ycyB3aXRoaW4gc21vb3RoaW5nIHZvbHVtZSwgc2F2ZSBpbiB0aGUgYXJyYXkgbmVpZ2hib3JzXHJcbiAqIEBtZXRob2QgZ2V0TmVpZ2hib3JzXHJcbiAqIEBwYXJhbSB7Qm9keX0gcGFydGljbGVcclxuICogQHBhcmFtIHtBcnJheX0gbmVpZ2hib3JzXHJcbiAqL1xyXG52YXIgU1BIU3lzdGVtX2dldE5laWdoYm9yc19kaXN0ID0gbmV3IFZlYzMoKTtcclxuU1BIU3lzdGVtLnByb3RvdHlwZS5nZXROZWlnaGJvcnMgPSBmdW5jdGlvbihwYXJ0aWNsZSxuZWlnaGJvcnMpe1xyXG4gICAgdmFyIE4gPSB0aGlzLnBhcnRpY2xlcy5sZW5ndGgsXHJcbiAgICAgICAgaWQgPSBwYXJ0aWNsZS5pZCxcclxuICAgICAgICBSMiA9IHRoaXMuc21vb3RoaW5nUmFkaXVzICogdGhpcy5zbW9vdGhpbmdSYWRpdXMsXHJcbiAgICAgICAgZGlzdCA9IFNQSFN5c3RlbV9nZXROZWlnaGJvcnNfZGlzdDtcclxuICAgIGZvcih2YXIgaT0wOyBpIT09TjsgaSsrKXtcclxuICAgICAgICB2YXIgcCA9IHRoaXMucGFydGljbGVzW2ldO1xyXG4gICAgICAgIHAucG9zaXRpb24udnN1YihwYXJ0aWNsZS5wb3NpdGlvbixkaXN0KTtcclxuICAgICAgICBpZihpZCE9PXAuaWQgJiYgZGlzdC5ub3JtMigpIDwgUjIpe1xyXG4gICAgICAgICAgICBuZWlnaGJvcnMucHVzaChwKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG4vLyBUZW1wIHZlY3RvcnMgZm9yIGNhbGN1bGF0aW9uXHJcbnZhciBTUEhTeXN0ZW1fdXBkYXRlX2Rpc3QgPSBuZXcgVmVjMygpLFxyXG4gICAgU1BIU3lzdGVtX3VwZGF0ZV9hX3ByZXNzdXJlID0gbmV3IFZlYzMoKSxcclxuICAgIFNQSFN5c3RlbV91cGRhdGVfYV92aXNjID0gbmV3IFZlYzMoKSxcclxuICAgIFNQSFN5c3RlbV91cGRhdGVfZ3JhZFcgPSBuZXcgVmVjMygpLFxyXG4gICAgU1BIU3lzdGVtX3VwZGF0ZV9yX3ZlYyA9IG5ldyBWZWMzKCksXHJcbiAgICBTUEhTeXN0ZW1fdXBkYXRlX3UgPSBuZXcgVmVjMygpOyAvLyBSZWxhdGl2ZSB2ZWxvY2l0eVxyXG5TUEhTeXN0ZW0ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCl7XHJcbiAgICB2YXIgTiA9IHRoaXMucGFydGljbGVzLmxlbmd0aCxcclxuICAgICAgICBkaXN0ID0gU1BIU3lzdGVtX3VwZGF0ZV9kaXN0LFxyXG4gICAgICAgIGNzID0gdGhpcy5zcGVlZE9mU291bmQsXHJcbiAgICAgICAgZXBzID0gdGhpcy5lcHM7XHJcblxyXG4gICAgZm9yKHZhciBpPTA7IGkhPT1OOyBpKyspe1xyXG4gICAgICAgIHZhciBwID0gdGhpcy5wYXJ0aWNsZXNbaV07IC8vIEN1cnJlbnQgcGFydGljbGVcclxuICAgICAgICB2YXIgbmVpZ2hib3JzID0gdGhpcy5uZWlnaGJvcnNbaV07XHJcblxyXG4gICAgICAgIC8vIEdldCBuZWlnaGJvcnNcclxuICAgICAgICBuZWlnaGJvcnMubGVuZ3RoID0gMDtcclxuICAgICAgICB0aGlzLmdldE5laWdoYm9ycyhwLG5laWdoYm9ycyk7XHJcbiAgICAgICAgbmVpZ2hib3JzLnB1c2godGhpcy5wYXJ0aWNsZXNbaV0pOyAvLyBBZGQgY3VycmVudCB0b29cclxuICAgICAgICB2YXIgbnVtTmVpZ2hib3JzID0gbmVpZ2hib3JzLmxlbmd0aDtcclxuXHJcbiAgICAgICAgLy8gQWNjdW11bGF0ZSBkZW5zaXR5IGZvciB0aGUgcGFydGljbGVcclxuICAgICAgICB2YXIgc3VtID0gMC4wO1xyXG4gICAgICAgIGZvcih2YXIgaj0wOyBqIT09bnVtTmVpZ2hib3JzOyBqKyspe1xyXG5cclxuICAgICAgICAgICAgLy9wcmludGYoXCJDdXJyZW50IHBhcnRpY2xlIGhhcyBwb3NpdGlvbiAlZiAlZiAlZlxcblwiLG9iamVjdHNbaWRdLnBvcy54KCksb2JqZWN0c1tpZF0ucG9zLnkoKSxvYmplY3RzW2lkXS5wb3MueigpKTtcclxuICAgICAgICAgICAgcC5wb3NpdGlvbi52c3ViKG5laWdoYm9yc1tqXS5wb3NpdGlvbiwgZGlzdCk7XHJcbiAgICAgICAgICAgIHZhciBsZW4gPSBkaXN0Lm5vcm0oKTtcclxuXHJcbiAgICAgICAgICAgIHZhciB3ZWlnaHQgPSB0aGlzLncobGVuKTtcclxuICAgICAgICAgICAgc3VtICs9IG5laWdoYm9yc1tqXS5tYXNzICogd2VpZ2h0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gU2F2ZVxyXG4gICAgICAgIHRoaXMuZGVuc2l0aWVzW2ldID0gc3VtO1xyXG4gICAgICAgIHRoaXMucHJlc3N1cmVzW2ldID0gY3MgKiBjcyAqICh0aGlzLmRlbnNpdGllc1tpXSAtIHRoaXMuZGVuc2l0eSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQWRkIGZvcmNlc1xyXG5cclxuICAgIC8vIFN1bSB0byB0aGVzZSBhY2NlbGVyYXRpb25zXHJcbiAgICB2YXIgYV9wcmVzc3VyZT0gU1BIU3lzdGVtX3VwZGF0ZV9hX3ByZXNzdXJlO1xyXG4gICAgdmFyIGFfdmlzYyA9ICAgIFNQSFN5c3RlbV91cGRhdGVfYV92aXNjO1xyXG4gICAgdmFyIGdyYWRXID0gICAgIFNQSFN5c3RlbV91cGRhdGVfZ3JhZFc7XHJcbiAgICB2YXIgcl92ZWMgPSAgICAgU1BIU3lzdGVtX3VwZGF0ZV9yX3ZlYztcclxuICAgIHZhciB1ID0gICAgICAgICBTUEhTeXN0ZW1fdXBkYXRlX3U7XHJcblxyXG4gICAgZm9yKHZhciBpPTA7IGkhPT1OOyBpKyspe1xyXG5cclxuICAgICAgICB2YXIgcGFydGljbGUgPSB0aGlzLnBhcnRpY2xlc1tpXTtcclxuXHJcbiAgICAgICAgYV9wcmVzc3VyZS5zZXQoMCwwLDApO1xyXG4gICAgICAgIGFfdmlzYy5zZXQoMCwwLDApO1xyXG5cclxuICAgICAgICAvLyBJbml0IHZhcnNcclxuICAgICAgICB2YXIgUGlqO1xyXG4gICAgICAgIHZhciBuYWJsYTtcclxuICAgICAgICB2YXIgVmlqO1xyXG5cclxuICAgICAgICAvLyBTdW0gdXAgZm9yIGFsbCBvdGhlciBuZWlnaGJvcnNcclxuICAgICAgICB2YXIgbmVpZ2hib3JzID0gdGhpcy5uZWlnaGJvcnNbaV07XHJcbiAgICAgICAgdmFyIG51bU5laWdoYm9ycyA9IG5laWdoYm9ycy5sZW5ndGg7XHJcblxyXG4gICAgICAgIC8vcHJpbnRmKFwiTmVpZ2hib3JzOiBcIik7XHJcbiAgICAgICAgZm9yKHZhciBqPTA7IGohPT1udW1OZWlnaGJvcnM7IGorKyl7XHJcblxyXG4gICAgICAgICAgICB2YXIgbmVpZ2hib3IgPSBuZWlnaGJvcnNbal07XHJcbiAgICAgICAgICAgIC8vcHJpbnRmKFwiJWQgXCIsbmopO1xyXG5cclxuICAgICAgICAgICAgLy8gR2V0IHIgb25jZSBmb3IgYWxsLi5cclxuICAgICAgICAgICAgcGFydGljbGUucG9zaXRpb24udnN1YihuZWlnaGJvci5wb3NpdGlvbixyX3ZlYyk7XHJcbiAgICAgICAgICAgIHZhciByID0gcl92ZWMubm9ybSgpO1xyXG5cclxuICAgICAgICAgICAgLy8gUHJlc3N1cmUgY29udHJpYnV0aW9uXHJcbiAgICAgICAgICAgIFBpaiA9IC1uZWlnaGJvci5tYXNzICogKHRoaXMucHJlc3N1cmVzW2ldIC8gKHRoaXMuZGVuc2l0aWVzW2ldKnRoaXMuZGVuc2l0aWVzW2ldICsgZXBzKSArIHRoaXMucHJlc3N1cmVzW2pdIC8gKHRoaXMuZGVuc2l0aWVzW2pdKnRoaXMuZGVuc2l0aWVzW2pdICsgZXBzKSk7XHJcbiAgICAgICAgICAgIHRoaXMuZ3JhZHcocl92ZWMsIGdyYWRXKTtcclxuICAgICAgICAgICAgLy8gQWRkIHRvIHByZXNzdXJlIGFjY2VsZXJhdGlvblxyXG4gICAgICAgICAgICBncmFkVy5tdWx0KFBpaiAsIGdyYWRXKTtcclxuICAgICAgICAgICAgYV9wcmVzc3VyZS52YWRkKGdyYWRXLCBhX3ByZXNzdXJlKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFZpc2Nvc2l0eSBjb250cmlidXRpb25cclxuICAgICAgICAgICAgbmVpZ2hib3IudmVsb2NpdHkudnN1YihwYXJ0aWNsZS52ZWxvY2l0eSwgdSk7XHJcbiAgICAgICAgICAgIHUubXVsdCggMS4wIC8gKDAuMDAwMSt0aGlzLmRlbnNpdGllc1tpXSAqIHRoaXMuZGVuc2l0aWVzW2pdKSAqIHRoaXMudmlzY29zaXR5ICogbmVpZ2hib3IubWFzcyAsIHUgKTtcclxuICAgICAgICAgICAgbmFibGEgPSB0aGlzLm5hYmxhdyhyKTtcclxuICAgICAgICAgICAgdS5tdWx0KG5hYmxhLHUpO1xyXG4gICAgICAgICAgICAvLyBBZGQgdG8gdmlzY29zaXR5IGFjY2VsZXJhdGlvblxyXG4gICAgICAgICAgICBhX3Zpc2MudmFkZCggdSwgYV92aXNjICk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDYWxjdWxhdGUgZm9yY2VcclxuICAgICAgICBhX3Zpc2MubXVsdChwYXJ0aWNsZS5tYXNzLCBhX3Zpc2MpO1xyXG4gICAgICAgIGFfcHJlc3N1cmUubXVsdChwYXJ0aWNsZS5tYXNzLCBhX3ByZXNzdXJlKTtcclxuXHJcbiAgICAgICAgLy8gQWRkIGZvcmNlIHRvIHBhcnRpY2xlc1xyXG4gICAgICAgIHBhcnRpY2xlLmZvcmNlLnZhZGQoYV92aXNjLCBwYXJ0aWNsZS5mb3JjZSk7XHJcbiAgICAgICAgcGFydGljbGUuZm9yY2UudmFkZChhX3ByZXNzdXJlLCBwYXJ0aWNsZS5mb3JjZSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vLyBDYWxjdWxhdGUgdGhlIHdlaWdodCB1c2luZyB0aGUgVyhyKSB3ZWlnaHRmdW5jdGlvblxyXG5TUEhTeXN0ZW0ucHJvdG90eXBlLncgPSBmdW5jdGlvbihyKXtcclxuICAgIC8vIDMxNVxyXG4gICAgdmFyIGggPSB0aGlzLnNtb290aGluZ1JhZGl1cztcclxuICAgIHJldHVybiAzMTUuMC8oNjQuMCpNYXRoLlBJKk1hdGgucG93KGgsOSkpICogTWF0aC5wb3coaCpoLXIqciwzKTtcclxufTtcclxuXHJcbi8vIGNhbGN1bGF0ZSBncmFkaWVudCBvZiB0aGUgd2VpZ2h0IGZ1bmN0aW9uXHJcblNQSFN5c3RlbS5wcm90b3R5cGUuZ3JhZHcgPSBmdW5jdGlvbihyVmVjLHJlc3VsdFZlYyl7XHJcbiAgICB2YXIgciA9IHJWZWMubm9ybSgpLFxyXG4gICAgICAgIGggPSB0aGlzLnNtb290aGluZ1JhZGl1cztcclxuICAgIHJWZWMubXVsdCg5NDUuMC8oMzIuMCpNYXRoLlBJKk1hdGgucG93KGgsOSkpICogTWF0aC5wb3coKGgqaC1yKnIpLDIpICwgcmVzdWx0VmVjKTtcclxufTtcclxuXHJcbi8vIENhbGN1bGF0ZSBuYWJsYShXKVxyXG5TUEhTeXN0ZW0ucHJvdG90eXBlLm5hYmxhdyA9IGZ1bmN0aW9uKHIpe1xyXG4gICAgdmFyIGggPSB0aGlzLnNtb290aGluZ1JhZGl1cztcclxuICAgIHZhciBuYWJsYSA9IDk0NS4wLygzMi4wKk1hdGguUEkqTWF0aC5wb3coaCw5KSkgKiAoaCpoLXIqcikqKDcqcipyIC0gMypoKmgpO1xyXG4gICAgcmV0dXJuIG5hYmxhO1xyXG59O1xyXG5cclxufSx7XCIuLi9tYXRlcmlhbC9NYXRlcmlhbFwiOjI2LFwiLi4vbWF0aC9RdWF0ZXJuaW9uXCI6MjksXCIuLi9tYXRoL1ZlYzNcIjozMSxcIi4uL29iamVjdHMvQm9keVwiOjMyLFwiLi4vc2hhcGVzL1BhcnRpY2xlXCI6NDIsXCIuLi9zaGFwZXMvU2hhcGVcIjo0NH1dLDM2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcclxudmFyIFZlYzMgPSBfZGVyZXFfKCcuLi9tYXRoL1ZlYzMnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU3ByaW5nO1xyXG5cclxuLyoqXHJcbiAqIEEgc3ByaW5nLCBjb25uZWN0aW5nIHR3byBib2RpZXMuXHJcbiAqXHJcbiAqIEBjbGFzcyBTcHJpbmdcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUFcclxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxyXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5yZXN0TGVuZ3RoXSAgIEEgbnVtYmVyID4gMC4gRGVmYXVsdDogMVxyXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuc3RpZmZuZXNzXSAgICBBIG51bWJlciA+PSAwLiBEZWZhdWx0OiAxMDBcclxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmRhbXBpbmddICAgICAgQSBudW1iZXIgPj0gMC4gRGVmYXVsdDogMVxyXG4gKiBAcGFyYW0ge1ZlYzN9ICBbb3B0aW9ucy53b3JsZEFuY2hvckFdIFdoZXJlIHRvIGhvb2sgdGhlIHNwcmluZyB0byBib2R5IEEsIGluIHdvcmxkIGNvb3JkaW5hdGVzLlxyXG4gKiBAcGFyYW0ge1ZlYzN9ICBbb3B0aW9ucy53b3JsZEFuY2hvckJdXHJcbiAqIEBwYXJhbSB7VmVjM30gIFtvcHRpb25zLmxvY2FsQW5jaG9yQV0gV2hlcmUgdG8gaG9vayB0aGUgc3ByaW5nIHRvIGJvZHkgQSwgaW4gbG9jYWwgYm9keSBjb29yZGluYXRlcy5cclxuICogQHBhcmFtIHtWZWMzfSAgW29wdGlvbnMubG9jYWxBbmNob3JCXVxyXG4gKi9cclxuZnVuY3Rpb24gU3ByaW5nKGJvZHlBLGJvZHlCLG9wdGlvbnMpe1xyXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXN0IGxlbmd0aCBvZiB0aGUgc3ByaW5nLlxyXG4gICAgICogQHByb3BlcnR5IHJlc3RMZW5ndGhcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMucmVzdExlbmd0aCA9IHR5cGVvZihvcHRpb25zLnJlc3RMZW5ndGgpID09PSBcIm51bWJlclwiID8gb3B0aW9ucy5yZXN0TGVuZ3RoIDogMTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFN0aWZmbmVzcyBvZiB0aGUgc3ByaW5nLlxyXG4gICAgICogQHByb3BlcnR5IHN0aWZmbmVzc1xyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5zdGlmZm5lc3MgPSBvcHRpb25zLnN0aWZmbmVzcyB8fCAxMDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEYW1waW5nIG9mIHRoZSBzcHJpbmcuXHJcbiAgICAgKiBAcHJvcGVydHkgZGFtcGluZ1xyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5kYW1waW5nID0gb3B0aW9ucy5kYW1waW5nIHx8IDE7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaXJzdCBjb25uZWN0ZWQgYm9keS5cclxuICAgICAqIEBwcm9wZXJ0eSBib2R5QVxyXG4gICAgICogQHR5cGUge0JvZHl9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuYm9keUEgPSBib2R5QTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNlY29uZCBjb25uZWN0ZWQgYm9keS5cclxuICAgICAqIEBwcm9wZXJ0eSBib2R5QlxyXG4gICAgICogQHR5cGUge0JvZHl9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuYm9keUIgPSBib2R5QjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFuY2hvciBmb3IgYm9keUEgaW4gbG9jYWwgYm9keUEgY29vcmRpbmF0ZXMuXHJcbiAgICAgKiBAcHJvcGVydHkgbG9jYWxBbmNob3JBXHJcbiAgICAgKiBAdHlwZSB7VmVjM31cclxuICAgICAqL1xyXG4gICAgdGhpcy5sb2NhbEFuY2hvckEgPSBuZXcgVmVjMygpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQW5jaG9yIGZvciBib2R5QiBpbiBsb2NhbCBib2R5QiBjb29yZGluYXRlcy5cclxuICAgICAqIEBwcm9wZXJ0eSBsb2NhbEFuY2hvckJcclxuICAgICAqIEB0eXBlIHtWZWMzfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmxvY2FsQW5jaG9yQiA9IG5ldyBWZWMzKCk7XHJcblxyXG4gICAgaWYob3B0aW9ucy5sb2NhbEFuY2hvckEpe1xyXG4gICAgICAgIHRoaXMubG9jYWxBbmNob3JBLmNvcHkob3B0aW9ucy5sb2NhbEFuY2hvckEpO1xyXG4gICAgfVxyXG4gICAgaWYob3B0aW9ucy5sb2NhbEFuY2hvckIpe1xyXG4gICAgICAgIHRoaXMubG9jYWxBbmNob3JCLmNvcHkob3B0aW9ucy5sb2NhbEFuY2hvckIpO1xyXG4gICAgfVxyXG4gICAgaWYob3B0aW9ucy53b3JsZEFuY2hvckEpe1xyXG4gICAgICAgIHRoaXMuc2V0V29ybGRBbmNob3JBKG9wdGlvbnMud29ybGRBbmNob3JBKTtcclxuICAgIH1cclxuICAgIGlmKG9wdGlvbnMud29ybGRBbmNob3JCKXtcclxuICAgICAgICB0aGlzLnNldFdvcmxkQW5jaG9yQihvcHRpb25zLndvcmxkQW5jaG9yQik7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTZXQgdGhlIGFuY2hvciBwb2ludCBvbiBib2R5IEEsIHVzaW5nIHdvcmxkIGNvb3JkaW5hdGVzLlxyXG4gKiBAbWV0aG9kIHNldFdvcmxkQW5jaG9yQVxyXG4gKiBAcGFyYW0ge1ZlYzN9IHdvcmxkQW5jaG9yQVxyXG4gKi9cclxuU3ByaW5nLnByb3RvdHlwZS5zZXRXb3JsZEFuY2hvckEgPSBmdW5jdGlvbih3b3JsZEFuY2hvckEpe1xyXG4gICAgdGhpcy5ib2R5QS5wb2ludFRvTG9jYWxGcmFtZSh3b3JsZEFuY2hvckEsdGhpcy5sb2NhbEFuY2hvckEpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFNldCB0aGUgYW5jaG9yIHBvaW50IG9uIGJvZHkgQiwgdXNpbmcgd29ybGQgY29vcmRpbmF0ZXMuXHJcbiAqIEBtZXRob2Qgc2V0V29ybGRBbmNob3JCXHJcbiAqIEBwYXJhbSB7VmVjM30gd29ybGRBbmNob3JCXHJcbiAqL1xyXG5TcHJpbmcucHJvdG90eXBlLnNldFdvcmxkQW5jaG9yQiA9IGZ1bmN0aW9uKHdvcmxkQW5jaG9yQil7XHJcbiAgICB0aGlzLmJvZHlCLnBvaW50VG9Mb2NhbEZyYW1lKHdvcmxkQW5jaG9yQix0aGlzLmxvY2FsQW5jaG9yQik7XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0IHRoZSBhbmNob3IgcG9pbnQgb24gYm9keSBBLCBpbiB3b3JsZCBjb29yZGluYXRlcy5cclxuICogQG1ldGhvZCBnZXRXb3JsZEFuY2hvckFcclxuICogQHBhcmFtIHtWZWMzfSByZXN1bHQgVGhlIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0IGluLlxyXG4gKi9cclxuU3ByaW5nLnByb3RvdHlwZS5nZXRXb3JsZEFuY2hvckEgPSBmdW5jdGlvbihyZXN1bHQpe1xyXG4gICAgdGhpcy5ib2R5QS5wb2ludFRvV29ybGRGcmFtZSh0aGlzLmxvY2FsQW5jaG9yQSxyZXN1bHQpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldCB0aGUgYW5jaG9yIHBvaW50IG9uIGJvZHkgQiwgaW4gd29ybGQgY29vcmRpbmF0ZXMuXHJcbiAqIEBtZXRob2QgZ2V0V29ybGRBbmNob3JCXHJcbiAqIEBwYXJhbSB7VmVjM30gcmVzdWx0IFRoZSB2ZWN0b3IgdG8gc3RvcmUgdGhlIHJlc3VsdCBpbi5cclxuICovXHJcblNwcmluZy5wcm90b3R5cGUuZ2V0V29ybGRBbmNob3JCID0gZnVuY3Rpb24ocmVzdWx0KXtcclxuICAgIHRoaXMuYm9keUIucG9pbnRUb1dvcmxkRnJhbWUodGhpcy5sb2NhbEFuY2hvckIscmVzdWx0KTtcclxufTtcclxuXHJcbnZhciBhcHBseUZvcmNlX3IgPSAgICAgICAgICAgICAgbmV3IFZlYzMoKSxcclxuICAgIGFwcGx5Rm9yY2Vfcl91bml0ID0gICAgICAgICBuZXcgVmVjMygpLFxyXG4gICAgYXBwbHlGb3JjZV91ID0gICAgICAgICAgICAgIG5ldyBWZWMzKCksXHJcbiAgICBhcHBseUZvcmNlX2YgPSAgICAgICAgICAgICAgbmV3IFZlYzMoKSxcclxuICAgIGFwcGx5Rm9yY2Vfd29ybGRBbmNob3JBID0gICBuZXcgVmVjMygpLFxyXG4gICAgYXBwbHlGb3JjZV93b3JsZEFuY2hvckIgPSAgIG5ldyBWZWMzKCksXHJcbiAgICBhcHBseUZvcmNlX3JpID0gICAgICAgICAgICAgbmV3IFZlYzMoKSxcclxuICAgIGFwcGx5Rm9yY2VfcmogPSAgICAgICAgICAgICBuZXcgVmVjMygpLFxyXG4gICAgYXBwbHlGb3JjZV9yaV94X2YgPSAgICAgICAgIG5ldyBWZWMzKCksXHJcbiAgICBhcHBseUZvcmNlX3JqX3hfZiA9ICAgICAgICAgbmV3IFZlYzMoKSxcclxuICAgIGFwcGx5Rm9yY2VfdG1wID0gICAgICAgICAgICBuZXcgVmVjMygpO1xyXG5cclxuLyoqXHJcbiAqIEFwcGx5IHRoZSBzcHJpbmcgZm9yY2UgdG8gdGhlIGNvbm5lY3RlZCBib2RpZXMuXHJcbiAqIEBtZXRob2QgYXBwbHlGb3JjZVxyXG4gKi9cclxuU3ByaW5nLnByb3RvdHlwZS5hcHBseUZvcmNlID0gZnVuY3Rpb24oKXtcclxuICAgIHZhciBrID0gdGhpcy5zdGlmZm5lc3MsXHJcbiAgICAgICAgZCA9IHRoaXMuZGFtcGluZyxcclxuICAgICAgICBsID0gdGhpcy5yZXN0TGVuZ3RoLFxyXG4gICAgICAgIGJvZHlBID0gdGhpcy5ib2R5QSxcclxuICAgICAgICBib2R5QiA9IHRoaXMuYm9keUIsXHJcbiAgICAgICAgciA9IGFwcGx5Rm9yY2VfcixcclxuICAgICAgICByX3VuaXQgPSBhcHBseUZvcmNlX3JfdW5pdCxcclxuICAgICAgICB1ID0gYXBwbHlGb3JjZV91LFxyXG4gICAgICAgIGYgPSBhcHBseUZvcmNlX2YsXHJcbiAgICAgICAgdG1wID0gYXBwbHlGb3JjZV90bXA7XHJcblxyXG4gICAgdmFyIHdvcmxkQW5jaG9yQSA9IGFwcGx5Rm9yY2Vfd29ybGRBbmNob3JBLFxyXG4gICAgICAgIHdvcmxkQW5jaG9yQiA9IGFwcGx5Rm9yY2Vfd29ybGRBbmNob3JCLFxyXG4gICAgICAgIHJpID0gYXBwbHlGb3JjZV9yaSxcclxuICAgICAgICByaiA9IGFwcGx5Rm9yY2VfcmosXHJcbiAgICAgICAgcmlfeF9mID0gYXBwbHlGb3JjZV9yaV94X2YsXHJcbiAgICAgICAgcmpfeF9mID0gYXBwbHlGb3JjZV9yal94X2Y7XHJcblxyXG4gICAgLy8gR2V0IHdvcmxkIGFuY2hvcnNcclxuICAgIHRoaXMuZ2V0V29ybGRBbmNob3JBKHdvcmxkQW5jaG9yQSk7XHJcbiAgICB0aGlzLmdldFdvcmxkQW5jaG9yQih3b3JsZEFuY2hvckIpO1xyXG5cclxuICAgIC8vIEdldCBvZmZzZXQgcG9pbnRzXHJcbiAgICB3b3JsZEFuY2hvckEudnN1Yihib2R5QS5wb3NpdGlvbixyaSk7XHJcbiAgICB3b3JsZEFuY2hvckIudnN1Yihib2R5Qi5wb3NpdGlvbixyaik7XHJcblxyXG4gICAgLy8gQ29tcHV0ZSBkaXN0YW5jZSB2ZWN0b3IgYmV0d2VlbiB3b3JsZCBhbmNob3IgcG9pbnRzXHJcbiAgICB3b3JsZEFuY2hvckIudnN1Yih3b3JsZEFuY2hvckEscik7XHJcbiAgICB2YXIgcmxlbiA9IHIubm9ybSgpO1xyXG4gICAgcl91bml0LmNvcHkocik7XHJcbiAgICByX3VuaXQubm9ybWFsaXplKCk7XHJcblxyXG4gICAgLy8gQ29tcHV0ZSByZWxhdGl2ZSB2ZWxvY2l0eSBvZiB0aGUgYW5jaG9yIHBvaW50cywgdVxyXG4gICAgYm9keUIudmVsb2NpdHkudnN1Yihib2R5QS52ZWxvY2l0eSx1KTtcclxuICAgIC8vIEFkZCByb3RhdGlvbmFsIHZlbG9jaXR5XHJcblxyXG4gICAgYm9keUIuYW5ndWxhclZlbG9jaXR5LmNyb3NzKHJqLHRtcCk7XHJcbiAgICB1LnZhZGQodG1wLHUpO1xyXG4gICAgYm9keUEuYW5ndWxhclZlbG9jaXR5LmNyb3NzKHJpLHRtcCk7XHJcbiAgICB1LnZzdWIodG1wLHUpO1xyXG5cclxuICAgIC8vIEYgPSAtIGsgKiAoIHggLSBMICkgLSBEICogKCB1IClcclxuICAgIHJfdW5pdC5tdWx0KC1rKihybGVuLWwpIC0gZCp1LmRvdChyX3VuaXQpLCBmKTtcclxuXHJcbiAgICAvLyBBZGQgZm9yY2VzIHRvIGJvZGllc1xyXG4gICAgYm9keUEuZm9yY2UudnN1YihmLGJvZHlBLmZvcmNlKTtcclxuICAgIGJvZHlCLmZvcmNlLnZhZGQoZixib2R5Qi5mb3JjZSk7XHJcblxyXG4gICAgLy8gQW5ndWxhciBmb3JjZVxyXG4gICAgcmkuY3Jvc3MoZixyaV94X2YpO1xyXG4gICAgcmouY3Jvc3MoZixyal94X2YpO1xyXG4gICAgYm9keUEudG9ycXVlLnZzdWIocmlfeF9mLGJvZHlBLnRvcnF1ZSk7XHJcbiAgICBib2R5Qi50b3JxdWUudmFkZChyal94X2YsYm9keUIudG9ycXVlKTtcclxufTtcclxuXHJcbn0se1wiLi4vbWF0aC9WZWMzXCI6MzF9XSwzNzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XHJcbnZhciBWZWMzID0gX2RlcmVxXygnLi4vbWF0aC9WZWMzJyk7XHJcbnZhciBUcmFuc2Zvcm0gPSBfZGVyZXFfKCcuLi9tYXRoL1RyYW5zZm9ybScpO1xyXG52YXIgUmF5Y2FzdFJlc3VsdCA9IF9kZXJlcV8oJy4uL2NvbGxpc2lvbi9SYXljYXN0UmVzdWx0Jyk7XHJcbnZhciBVdGlscyA9IF9kZXJlcV8oJy4uL3V0aWxzL1V0aWxzJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFdoZWVsSW5mbztcclxuXHJcbi8qKlxyXG4gKiBAY2xhc3MgV2hlZWxJbmZvXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXHJcbiAqXHJcbiAqIEBwYXJhbSB7VmVjM30gW29wdGlvbnMuY2hhc3Npc0Nvbm5lY3Rpb25Qb2ludExvY2FsXVxyXG4gKiBAcGFyYW0ge1ZlYzN9IFtvcHRpb25zLmNoYXNzaXNDb25uZWN0aW9uUG9pbnRXb3JsZF1cclxuICogQHBhcmFtIHtWZWMzfSBbb3B0aW9ucy5kaXJlY3Rpb25Mb2NhbF1cclxuICogQHBhcmFtIHtWZWMzfSBbb3B0aW9ucy5kaXJlY3Rpb25Xb3JsZF1cclxuICogQHBhcmFtIHtWZWMzfSBbb3B0aW9ucy5heGxlTG9jYWxdXHJcbiAqIEBwYXJhbSB7VmVjM30gW29wdGlvbnMuYXhsZVdvcmxkXVxyXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuc3VzcGVuc2lvblJlc3RMZW5ndGg9MV1cclxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnN1c3BlbnNpb25NYXhMZW5ndGg9Ml1cclxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnJhZGl1cz0xXVxyXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuc3VzcGVuc2lvblN0aWZmbmVzcz0xMDBdXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5kYW1waW5nQ29tcHJlc3Npb249MTBdXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5kYW1waW5nUmVsYXhhdGlvbj0xMF1cclxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmZyaWN0aW9uU2xpcD0xMDAwMF1cclxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnN0ZWVyaW5nPTBdXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5yb3RhdGlvbj0wXVxyXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuZGVsdGFSb3RhdGlvbj0wXVxyXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMucm9sbEluZmx1ZW5jZT0wLjAxXVxyXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4U3VzcGVuc2lvbkZvcmNlXVxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmlzRnJvbnRXaGVlbD10cnVlXVxyXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuY2xpcHBlZEludkNvbnRhY3REb3RTdXNwZW5zaW9uPTFdXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5zdXNwZW5zaW9uUmVsYXRpdmVWZWxvY2l0eT0wXVxyXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuc3VzcGVuc2lvbkZvcmNlPTBdXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5za2lkSW5mbz0wXVxyXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuc3VzcGVuc2lvbkxlbmd0aD0wXVxyXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4U3VzcGVuc2lvblRyYXZlbD0xXVxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnVzZUN1c3RvbVNsaWRpbmdSb3RhdGlvbmFsU3BlZWQ9ZmFsc2VdXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5jdXN0b21TbGlkaW5nUm90YXRpb25hbFNwZWVkPS0wLjFdXHJcbiAqL1xyXG5mdW5jdGlvbiBXaGVlbEluZm8ob3B0aW9ucyl7XHJcbiAgICBvcHRpb25zID0gVXRpbHMuZGVmYXVsdHMob3B0aW9ucywge1xyXG4gICAgICAgIGNoYXNzaXNDb25uZWN0aW9uUG9pbnRMb2NhbDogbmV3IFZlYzMoKSxcclxuICAgICAgICBjaGFzc2lzQ29ubmVjdGlvblBvaW50V29ybGQ6IG5ldyBWZWMzKCksXHJcbiAgICAgICAgZGlyZWN0aW9uTG9jYWw6IG5ldyBWZWMzKCksXHJcbiAgICAgICAgZGlyZWN0aW9uV29ybGQ6IG5ldyBWZWMzKCksXHJcbiAgICAgICAgYXhsZUxvY2FsOiBuZXcgVmVjMygpLFxyXG4gICAgICAgIGF4bGVXb3JsZDogbmV3IFZlYzMoKSxcclxuICAgICAgICBzdXNwZW5zaW9uUmVzdExlbmd0aDogMSxcclxuICAgICAgICBzdXNwZW5zaW9uTWF4TGVuZ3RoOiAyLFxyXG4gICAgICAgIHJhZGl1czogMSxcclxuICAgICAgICBzdXNwZW5zaW9uU3RpZmZuZXNzOiAxMDAsXHJcbiAgICAgICAgZGFtcGluZ0NvbXByZXNzaW9uOiAxMCxcclxuICAgICAgICBkYW1waW5nUmVsYXhhdGlvbjogMTAsXHJcbiAgICAgICAgZnJpY3Rpb25TbGlwOiAxMDAwMCxcclxuICAgICAgICBzdGVlcmluZzogMCxcclxuICAgICAgICByb3RhdGlvbjogMCxcclxuICAgICAgICBkZWx0YVJvdGF0aW9uOiAwLFxyXG4gICAgICAgIHJvbGxJbmZsdWVuY2U6IDAuMDEsXHJcbiAgICAgICAgbWF4U3VzcGVuc2lvbkZvcmNlOiBOdW1iZXIuTUFYX1ZBTFVFLFxyXG4gICAgICAgIGlzRnJvbnRXaGVlbDogdHJ1ZSxcclxuICAgICAgICBjbGlwcGVkSW52Q29udGFjdERvdFN1c3BlbnNpb246IDEsXHJcbiAgICAgICAgc3VzcGVuc2lvblJlbGF0aXZlVmVsb2NpdHk6IDAsXHJcbiAgICAgICAgc3VzcGVuc2lvbkZvcmNlOiAwLFxyXG4gICAgICAgIHNraWRJbmZvOiAwLFxyXG4gICAgICAgIHN1c3BlbnNpb25MZW5ndGg6IDAsXHJcbiAgICAgICAgbWF4U3VzcGVuc2lvblRyYXZlbDogMSxcclxuICAgICAgICB1c2VDdXN0b21TbGlkaW5nUm90YXRpb25hbFNwZWVkOiBmYWxzZSxcclxuICAgICAgICBjdXN0b21TbGlkaW5nUm90YXRpb25hbFNwZWVkOiAtMC4xXHJcbiAgICB9KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1heCB0cmF2ZWwgZGlzdGFuY2Ugb2YgdGhlIHN1c3BlbnNpb24sIGluIG1ldGVycy5cclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtYXhTdXNwZW5zaW9uVHJhdmVsXHJcbiAgICAgKi9cclxuICAgIHRoaXMubWF4U3VzcGVuc2lvblRyYXZlbCA9IG9wdGlvbnMubWF4U3VzcGVuc2lvblRyYXZlbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNwZWVkIHRvIGFwcGx5IHRvIHRoZSB3aGVlbCByb3RhdGlvbiB3aGVuIHRoZSB3aGVlbCBpcyBzbGlkaW5nLlxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGN1c3RvbVNsaWRpbmdSb3RhdGlvbmFsU3BlZWRcclxuICAgICAqL1xyXG4gICAgdGhpcy5jdXN0b21TbGlkaW5nUm90YXRpb25hbFNwZWVkID0gb3B0aW9ucy5jdXN0b21TbGlkaW5nUm90YXRpb25hbFNwZWVkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSWYgdGhlIGN1c3RvbVNsaWRpbmdSb3RhdGlvbmFsU3BlZWQgc2hvdWxkIGJlIHVzZWQuXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IHVzZUN1c3RvbVNsaWRpbmdSb3RhdGlvbmFsU3BlZWRcclxuICAgICAqL1xyXG4gICAgdGhpcy51c2VDdXN0b21TbGlkaW5nUm90YXRpb25hbFNwZWVkID0gb3B0aW9ucy51c2VDdXN0b21TbGlkaW5nUm90YXRpb25hbFNwZWVkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBzbGlkaW5nXHJcbiAgICAgKi9cclxuICAgIHRoaXMuc2xpZGluZyA9IGZhbHNlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29ubmVjdGlvbiBwb2ludCwgZGVmaW5lZCBsb2NhbGx5IGluIHRoZSBjaGFzc2lzIGJvZHkgZnJhbWUuXHJcbiAgICAgKiBAcHJvcGVydHkge1ZlYzN9IGNoYXNzaXNDb25uZWN0aW9uUG9pbnRMb2NhbFxyXG4gICAgICovXHJcbiAgICB0aGlzLmNoYXNzaXNDb25uZWN0aW9uUG9pbnRMb2NhbCA9IG9wdGlvbnMuY2hhc3Npc0Nvbm5lY3Rpb25Qb2ludExvY2FsLmNsb25lKCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkge1ZlYzN9IGNoYXNzaXNDb25uZWN0aW9uUG9pbnRXb3JsZFxyXG4gICAgICovXHJcbiAgICB0aGlzLmNoYXNzaXNDb25uZWN0aW9uUG9pbnRXb3JsZCA9IG9wdGlvbnMuY2hhc3Npc0Nvbm5lY3Rpb25Qb2ludFdvcmxkLmNsb25lKCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkge1ZlYzN9IGRpcmVjdGlvbkxvY2FsXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZGlyZWN0aW9uTG9jYWwgPSBvcHRpb25zLmRpcmVjdGlvbkxvY2FsLmNsb25lKCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkge1ZlYzN9IGRpcmVjdGlvbldvcmxkXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZGlyZWN0aW9uV29ybGQgPSBvcHRpb25zLmRpcmVjdGlvbldvcmxkLmNsb25lKCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkge1ZlYzN9IGF4bGVMb2NhbFxyXG4gICAgICovXHJcbiAgICB0aGlzLmF4bGVMb2NhbCA9IG9wdGlvbnMuYXhsZUxvY2FsLmNsb25lKCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkge1ZlYzN9IGF4bGVXb3JsZFxyXG4gICAgICovXHJcbiAgICB0aGlzLmF4bGVXb3JsZCA9IG9wdGlvbnMuYXhsZVdvcmxkLmNsb25lKCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gc3VzcGVuc2lvblJlc3RMZW5ndGhcclxuICAgICAqL1xyXG4gICAgdGhpcy5zdXNwZW5zaW9uUmVzdExlbmd0aCA9IG9wdGlvbnMuc3VzcGVuc2lvblJlc3RMZW5ndGg7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gc3VzcGVuc2lvbk1heExlbmd0aFxyXG4gICAgICovXHJcbiAgICB0aGlzLnN1c3BlbnNpb25NYXhMZW5ndGggPSBvcHRpb25zLnN1c3BlbnNpb25NYXhMZW5ndGg7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gcmFkaXVzXHJcbiAgICAgKi9cclxuICAgIHRoaXMucmFkaXVzID0gb3B0aW9ucy5yYWRpdXM7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gc3VzcGVuc2lvblN0aWZmbmVzc1xyXG4gICAgICovXHJcbiAgICB0aGlzLnN1c3BlbnNpb25TdGlmZm5lc3MgPSBvcHRpb25zLnN1c3BlbnNpb25TdGlmZm5lc3M7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZGFtcGluZ0NvbXByZXNzaW9uXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZGFtcGluZ0NvbXByZXNzaW9uID0gb3B0aW9ucy5kYW1waW5nQ29tcHJlc3Npb247XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZGFtcGluZ1JlbGF4YXRpb25cclxuICAgICAqL1xyXG4gICAgdGhpcy5kYW1waW5nUmVsYXhhdGlvbiA9IG9wdGlvbnMuZGFtcGluZ1JlbGF4YXRpb247XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZnJpY3Rpb25TbGlwXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZnJpY3Rpb25TbGlwID0gb3B0aW9ucy5mcmljdGlvblNsaXA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gc3RlZXJpbmdcclxuICAgICAqL1xyXG4gICAgdGhpcy5zdGVlcmluZyA9IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSb3RhdGlvbiB2YWx1ZSwgaW4gcmFkaWFucy5cclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSByb3RhdGlvblxyXG4gICAgICovXHJcbiAgICB0aGlzLnJvdGF0aW9uID0gMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkZWx0YVJvdGF0aW9uXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZGVsdGFSb3RhdGlvbiA9IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gcm9sbEluZmx1ZW5jZVxyXG4gICAgICovXHJcbiAgICB0aGlzLnJvbGxJbmZsdWVuY2UgPSBvcHRpb25zLnJvbGxJbmZsdWVuY2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbWF4U3VzcGVuc2lvbkZvcmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMubWF4U3VzcGVuc2lvbkZvcmNlID0gb3B0aW9ucy5tYXhTdXNwZW5zaW9uRm9yY2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZW5naW5lRm9yY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5lbmdpbmVGb3JjZSA9IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gYnJha2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5icmFrZSA9IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gaXNGcm9udFdoZWVsXHJcbiAgICAgKi9cclxuICAgIHRoaXMuaXNGcm9udFdoZWVsID0gb3B0aW9ucy5pc0Zyb250V2hlZWw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gY2xpcHBlZEludkNvbnRhY3REb3RTdXNwZW5zaW9uXHJcbiAgICAgKi9cclxuICAgIHRoaXMuY2xpcHBlZEludkNvbnRhY3REb3RTdXNwZW5zaW9uID0gMTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzdXNwZW5zaW9uUmVsYXRpdmVWZWxvY2l0eVxyXG4gICAgICovXHJcbiAgICB0aGlzLnN1c3BlbnNpb25SZWxhdGl2ZVZlbG9jaXR5ID0gMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzdXNwZW5zaW9uRm9yY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5zdXNwZW5zaW9uRm9yY2UgPSAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHNraWRJbmZvXHJcbiAgICAgKi9cclxuICAgIHRoaXMuc2tpZEluZm8gPSAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHN1c3BlbnNpb25MZW5ndGhcclxuICAgICAqL1xyXG4gICAgdGhpcy5zdXNwZW5zaW9uTGVuZ3RoID0gMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzaWRlSW1wdWxzZVxyXG4gICAgICovXHJcbiAgICB0aGlzLnNpZGVJbXB1bHNlID0gMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBmb3J3YXJkSW1wdWxzZVxyXG4gICAgICovXHJcbiAgICB0aGlzLmZvcndhcmRJbXB1bHNlID0gMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSByZXN1bHQgZnJvbSByYXljYXN0aW5nXHJcbiAgICAgKiBAcHJvcGVydHkge1JheWNhc3RSZXN1bHR9IHJheWNhc3RSZXN1bHRcclxuICAgICAqL1xyXG4gICAgdGhpcy5yYXljYXN0UmVzdWx0ID0gbmV3IFJheWNhc3RSZXN1bHQoKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZWVsIHdvcmxkIHRyYW5zZm9ybVxyXG4gICAgICogQHByb3BlcnR5IHtUcmFuc2Zvcm19IHdvcmxkVHJhbnNmb3JtXHJcbiAgICAgKi9cclxuICAgIHRoaXMud29ybGRUcmFuc2Zvcm0gPSBuZXcgVHJhbnNmb3JtKCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGlzSW5Db250YWN0XHJcbiAgICAgKi9cclxuICAgIHRoaXMuaXNJbkNvbnRhY3QgPSBmYWxzZTtcclxufVxyXG5cclxudmFyIGNoYXNzaXNfdmVsb2NpdHlfYXRfY29udGFjdFBvaW50ID0gbmV3IFZlYzMoKTtcclxudmFyIHJlbHBvcyA9IG5ldyBWZWMzKCk7XHJcbnZhciBjaGFzc2lzX3ZlbG9jaXR5X2F0X2NvbnRhY3RQb2ludCA9IG5ldyBWZWMzKCk7XHJcbldoZWVsSW5mby5wcm90b3R5cGUudXBkYXRlV2hlZWwgPSBmdW5jdGlvbihjaGFzc2lzKXtcclxuICAgIHZhciByYXljYXN0UmVzdWx0ID0gdGhpcy5yYXljYXN0UmVzdWx0O1xyXG5cclxuICAgIGlmICh0aGlzLmlzSW5Db250YWN0KXtcclxuICAgICAgICB2YXIgcHJvamVjdD0gcmF5Y2FzdFJlc3VsdC5oaXROb3JtYWxXb3JsZC5kb3QocmF5Y2FzdFJlc3VsdC5kaXJlY3Rpb25Xb3JsZCk7XHJcbiAgICAgICAgcmF5Y2FzdFJlc3VsdC5oaXRQb2ludFdvcmxkLnZzdWIoY2hhc3Npcy5wb3NpdGlvbiwgcmVscG9zKTtcclxuICAgICAgICBjaGFzc2lzLmdldFZlbG9jaXR5QXRXb3JsZFBvaW50KHJlbHBvcywgY2hhc3Npc192ZWxvY2l0eV9hdF9jb250YWN0UG9pbnQpO1xyXG4gICAgICAgIHZhciBwcm9qVmVsID0gcmF5Y2FzdFJlc3VsdC5oaXROb3JtYWxXb3JsZC5kb3QoIGNoYXNzaXNfdmVsb2NpdHlfYXRfY29udGFjdFBvaW50ICk7XHJcbiAgICAgICAgaWYgKHByb2plY3QgPj0gLTAuMSkge1xyXG4gICAgICAgICAgICB0aGlzLnN1c3BlbnNpb25SZWxhdGl2ZVZlbG9jaXR5ID0gMC4wO1xyXG4gICAgICAgICAgICB0aGlzLmNsaXBwZWRJbnZDb250YWN0RG90U3VzcGVuc2lvbiA9IDEuMCAvIDAuMTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgaW52ID0gLTEgLyBwcm9qZWN0O1xyXG4gICAgICAgICAgICB0aGlzLnN1c3BlbnNpb25SZWxhdGl2ZVZlbG9jaXR5ID0gcHJvalZlbCAqIGludjtcclxuICAgICAgICAgICAgdGhpcy5jbGlwcGVkSW52Q29udGFjdERvdFN1c3BlbnNpb24gPSBpbnY7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gTm90IGluIGNvbnRhY3QgOiBwb3NpdGlvbiB3aGVlbCBpbiBhIG5pY2UgKHJlc3QgbGVuZ3RoKSBwb3NpdGlvblxyXG4gICAgICAgIHJheWNhc3RSZXN1bHQuc3VzcGVuc2lvbkxlbmd0aCA9IHRoaXMuc3VzcGVuc2lvblJlc3RMZW5ndGg7XHJcbiAgICAgICAgdGhpcy5zdXNwZW5zaW9uUmVsYXRpdmVWZWxvY2l0eSA9IDAuMDtcclxuICAgICAgICByYXljYXN0UmVzdWx0LmRpcmVjdGlvbldvcmxkLnNjYWxlKC0xLCByYXljYXN0UmVzdWx0LmhpdE5vcm1hbFdvcmxkKTtcclxuICAgICAgICB0aGlzLmNsaXBwZWRJbnZDb250YWN0RG90U3VzcGVuc2lvbiA9IDEuMDtcclxuICAgIH1cclxufTtcclxufSx7XCIuLi9jb2xsaXNpb24vUmF5Y2FzdFJlc3VsdFwiOjExLFwiLi4vbWF0aC9UcmFuc2Zvcm1cIjozMCxcIi4uL21hdGgvVmVjM1wiOjMxLFwiLi4vdXRpbHMvVXRpbHNcIjo1NH1dLDM4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcclxubW9kdWxlLmV4cG9ydHMgPSBCb3g7XHJcblxyXG52YXIgU2hhcGUgPSBfZGVyZXFfKCcuL1NoYXBlJyk7XHJcbnZhciBWZWMzID0gX2RlcmVxXygnLi4vbWF0aC9WZWMzJyk7XHJcbnZhciBDb252ZXhQb2x5aGVkcm9uID0gX2RlcmVxXygnLi9Db252ZXhQb2x5aGVkcm9uJyk7XHJcblxyXG4vKipcclxuICogQSAzZCBib3ggc2hhcGUuXHJcbiAqIEBjbGFzcyBCb3hcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7VmVjM30gaGFsZkV4dGVudHNcclxuICogQGF1dGhvciBzY2h0ZXBwZVxyXG4gKiBAZXh0ZW5kcyBTaGFwZVxyXG4gKi9cclxuZnVuY3Rpb24gQm94KGhhbGZFeHRlbnRzKXtcclxuICAgIFNoYXBlLmNhbGwodGhpcywge1xyXG4gICAgICAgIHR5cGU6IFNoYXBlLnR5cGVzLkJPWFxyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkgaGFsZkV4dGVudHNcclxuICAgICAqIEB0eXBlIHtWZWMzfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmhhbGZFeHRlbnRzID0gaGFsZkV4dGVudHM7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVc2VkIGJ5IHRoZSBjb250YWN0IGdlbmVyYXRvciB0byBtYWtlIGNvbnRhY3RzIHdpdGggb3RoZXIgY29udmV4IHBvbHloZWRyYSBmb3IgZXhhbXBsZVxyXG4gICAgICogQHByb3BlcnR5IGNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvblxyXG4gICAgICogQHR5cGUge0NvbnZleFBvbHloZWRyb259XHJcbiAgICAgKi9cclxuICAgIHRoaXMuY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uID0gbnVsbDtcclxuXHJcbiAgICB0aGlzLnVwZGF0ZUNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbigpO1xyXG4gICAgdGhpcy51cGRhdGVCb3VuZGluZ1NwaGVyZVJhZGl1cygpO1xyXG59XHJcbkJveC5wcm90b3R5cGUgPSBuZXcgU2hhcGUoKTtcclxuQm94LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEJveDtcclxuXHJcbi8qKlxyXG4gKiBVcGRhdGVzIHRoZSBsb2NhbCBjb252ZXggcG9seWhlZHJvbiByZXByZXNlbnRhdGlvbiB1c2VkIGZvciBzb21lIGNvbGxpc2lvbnMuXHJcbiAqIEBtZXRob2QgdXBkYXRlQ29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uXHJcbiAqL1xyXG5Cb3gucHJvdG90eXBlLnVwZGF0ZUNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbiA9IGZ1bmN0aW9uKCl7XHJcbiAgICB2YXIgc3ggPSB0aGlzLmhhbGZFeHRlbnRzLng7XHJcbiAgICB2YXIgc3kgPSB0aGlzLmhhbGZFeHRlbnRzLnk7XHJcbiAgICB2YXIgc3ogPSB0aGlzLmhhbGZFeHRlbnRzLno7XHJcbiAgICB2YXIgViA9IFZlYzM7XHJcblxyXG4gICAgdmFyIHZlcnRpY2VzID0gW1xyXG4gICAgICAgIG5ldyBWKC1zeCwtc3ksLXN6KSxcclxuICAgICAgICBuZXcgViggc3gsLXN5LC1zeiksXHJcbiAgICAgICAgbmV3IFYoIHN4LCBzeSwtc3opLFxyXG4gICAgICAgIG5ldyBWKC1zeCwgc3ksLXN6KSxcclxuICAgICAgICBuZXcgVigtc3gsLXN5LCBzeiksXHJcbiAgICAgICAgbmV3IFYoIHN4LC1zeSwgc3opLFxyXG4gICAgICAgIG5ldyBWKCBzeCwgc3ksIHN6KSxcclxuICAgICAgICBuZXcgVigtc3gsIHN5LCBzeilcclxuICAgIF07XHJcblxyXG4gICAgdmFyIGluZGljZXMgPSBbXHJcbiAgICAgICAgWzMsMiwxLDBdLCAvLyAtelxyXG4gICAgICAgIFs0LDUsNiw3XSwgLy8gK3pcclxuICAgICAgICBbNSw0LDAsMV0sIC8vIC15XHJcbiAgICAgICAgWzIsMyw3LDZdLCAvLyAreVxyXG4gICAgICAgIFswLDQsNywzXSwgLy8gLXhcclxuICAgICAgICBbMSwyLDYsNV0sIC8vICt4XHJcbiAgICBdO1xyXG5cclxuICAgIHZhciBheGVzID0gW1xyXG4gICAgICAgIG5ldyBWKDAsIDAsIDEpLFxyXG4gICAgICAgIG5ldyBWKDAsIDEsIDApLFxyXG4gICAgICAgIG5ldyBWKDEsIDAsIDApXHJcbiAgICBdO1xyXG5cclxuICAgIHZhciBoID0gbmV3IENvbnZleFBvbHloZWRyb24odmVydGljZXMsIGluZGljZXMpO1xyXG4gICAgdGhpcy5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24gPSBoO1xyXG4gICAgaC5tYXRlcmlhbCA9IHRoaXMubWF0ZXJpYWw7XHJcbn07XHJcblxyXG4vKipcclxuICogQG1ldGhvZCBjYWxjdWxhdGVMb2NhbEluZXJ0aWFcclxuICogQHBhcmFtICB7TnVtYmVyfSBtYXNzXHJcbiAqIEBwYXJhbSAge1ZlYzN9IHRhcmdldFxyXG4gKiBAcmV0dXJuIHtWZWMzfVxyXG4gKi9cclxuQm94LnByb3RvdHlwZS5jYWxjdWxhdGVMb2NhbEluZXJ0aWEgPSBmdW5jdGlvbihtYXNzLHRhcmdldCl7XHJcbiAgICB0YXJnZXQgPSB0YXJnZXQgfHwgbmV3IFZlYzMoKTtcclxuICAgIEJveC5jYWxjdWxhdGVJbmVydGlhKHRoaXMuaGFsZkV4dGVudHMsIG1hc3MsIHRhcmdldCk7XHJcbiAgICByZXR1cm4gdGFyZ2V0O1xyXG59O1xyXG5cclxuQm94LmNhbGN1bGF0ZUluZXJ0aWEgPSBmdW5jdGlvbihoYWxmRXh0ZW50cyxtYXNzLHRhcmdldCl7XHJcbiAgICB2YXIgZSA9IGhhbGZFeHRlbnRzO1xyXG4gICAgaWYgKGUuaXNaZXJvKCkpIHtcclxuICAgICAgICB0YXJnZXQueCA9IDIuMCAvIDEyLjAgKiBtYXNzO1xyXG4gICAgICAgIHRhcmdldC55ID0gMi4wIC8gMTIuMCAqIG1hc3M7XHJcbiAgICAgICAgdGFyZ2V0LnogPSAyLjAgLyAxMi4wICogbWFzcztcclxuICAgIH1lbHNle1xyXG4gICAgICAgIHRhcmdldC54ID0gMS4wIC8gMTIuMCAqIG1hc3MgKiAoICAgMiplLnkqMiplLnkgKyAyKmUueioyKmUueiApO1xyXG4gICAgICAgIHRhcmdldC55ID0gMS4wIC8gMTIuMCAqIG1hc3MgKiAoICAgMiplLngqMiplLnggKyAyKmUueioyKmUueiApO1xyXG4gICAgICAgIHRhcmdldC56ID0gMS4wIC8gMTIuMCAqIG1hc3MgKiAoICAgMiplLnkqMiplLnkgKyAyKmUueCoyKmUueCApO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldCB0aGUgYm94IDYgc2lkZSBub3JtYWxzXHJcbiAqIEBtZXRob2QgZ2V0U2lkZU5vcm1hbHNcclxuICogQHBhcmFtIHthcnJheX0gICAgICBzaXhUYXJnZXRWZWN0b3JzIEFuIGFycmF5IG9mIDYgdmVjdG9ycywgdG8gc3RvcmUgdGhlIHJlc3VsdGluZyBzaWRlIG5vcm1hbHMgaW4uXHJcbiAqIEBwYXJhbSB7UXVhdGVybmlvbn0gcXVhdCAgICAgICAgICAgICBPcmllbnRhdGlvbiB0byBhcHBseSB0byB0aGUgbm9ybWFsIHZlY3RvcnMuIElmIG5vdCBwcm92aWRlZCwgdGhlIHZlY3RvcnMgd2lsbCBiZSBpbiByZXNwZWN0IHRvIHRoZSBsb2NhbCBmcmFtZS5cclxuICogQHJldHVybiB7YXJyYXl9XHJcbiAqL1xyXG5Cb3gucHJvdG90eXBlLmdldFNpZGVOb3JtYWxzID0gZnVuY3Rpb24oc2l4VGFyZ2V0VmVjdG9ycyxxdWF0KXtcclxuICAgIHZhciBzaWRlcyA9IHNpeFRhcmdldFZlY3RvcnM7XHJcbiAgICB2YXIgZXggPSB0aGlzLmhhbGZFeHRlbnRzO1xyXG4gICAgc2lkZXNbMF0uc2V0KCAgZXgueCwgICAgIDAsICAgICAwKTtcclxuICAgIHNpZGVzWzFdLnNldCggICAgIDAsICBleC55LCAgICAgMCk7XHJcbiAgICBzaWRlc1syXS5zZXQoICAgICAwLCAgICAgMCwgIGV4LnopO1xyXG4gICAgc2lkZXNbM10uc2V0KCAtZXgueCwgICAgIDAsICAgICAwKTtcclxuICAgIHNpZGVzWzRdLnNldCggICAgIDAsIC1leC55LCAgICAgMCk7XHJcbiAgICBzaWRlc1s1XS5zZXQoICAgICAwLCAgICAgMCwgLWV4LnopO1xyXG5cclxuICAgIGlmKHF1YXQhPT11bmRlZmluZWQpe1xyXG4gICAgICAgIGZvcih2YXIgaT0wOyBpIT09c2lkZXMubGVuZ3RoOyBpKyspe1xyXG4gICAgICAgICAgICBxdWF0LnZtdWx0KHNpZGVzW2ldLHNpZGVzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHNpZGVzO1xyXG59O1xyXG5cclxuQm94LnByb3RvdHlwZS52b2x1bWUgPSBmdW5jdGlvbigpe1xyXG4gICAgcmV0dXJuIDguMCAqIHRoaXMuaGFsZkV4dGVudHMueCAqIHRoaXMuaGFsZkV4dGVudHMueSAqIHRoaXMuaGFsZkV4dGVudHMuejtcclxufTtcclxuXHJcbkJveC5wcm90b3R5cGUudXBkYXRlQm91bmRpbmdTcGhlcmVSYWRpdXMgPSBmdW5jdGlvbigpe1xyXG4gICAgdGhpcy5ib3VuZGluZ1NwaGVyZVJhZGl1cyA9IHRoaXMuaGFsZkV4dGVudHMubm9ybSgpO1xyXG59O1xyXG5cclxudmFyIHdvcmxkQ29ybmVyVGVtcFBvcyA9IG5ldyBWZWMzKCk7XHJcbnZhciB3b3JsZENvcm5lclRlbXBOZWcgPSBuZXcgVmVjMygpO1xyXG5Cb3gucHJvdG90eXBlLmZvckVhY2hXb3JsZENvcm5lciA9IGZ1bmN0aW9uKHBvcyxxdWF0LGNhbGxiYWNrKXtcclxuXHJcbiAgICB2YXIgZSA9IHRoaXMuaGFsZkV4dGVudHM7XHJcbiAgICB2YXIgY29ybmVycyA9IFtbICBlLngsICBlLnksICBlLnpdLFxyXG4gICAgICAgICAgICAgICAgICAgWyAtZS54LCAgZS55LCAgZS56XSxcclxuICAgICAgICAgICAgICAgICAgIFsgLWUueCwgLWUueSwgIGUuel0sXHJcbiAgICAgICAgICAgICAgICAgICBbIC1lLngsIC1lLnksIC1lLnpdLFxyXG4gICAgICAgICAgICAgICAgICAgWyAgZS54LCAtZS55LCAtZS56XSxcclxuICAgICAgICAgICAgICAgICAgIFsgIGUueCwgIGUueSwgLWUuel0sXHJcbiAgICAgICAgICAgICAgICAgICBbIC1lLngsICBlLnksIC1lLnpdLFxyXG4gICAgICAgICAgICAgICAgICAgWyAgZS54LCAtZS55LCAgZS56XV07XHJcbiAgICBmb3IodmFyIGk9MDsgaTxjb3JuZXJzLmxlbmd0aDsgaSsrKXtcclxuICAgICAgICB3b3JsZENvcm5lclRlbXBQb3Muc2V0KGNvcm5lcnNbaV1bMF0sY29ybmVyc1tpXVsxXSxjb3JuZXJzW2ldWzJdKTtcclxuICAgICAgICBxdWF0LnZtdWx0KHdvcmxkQ29ybmVyVGVtcFBvcyx3b3JsZENvcm5lclRlbXBQb3MpO1xyXG4gICAgICAgIHBvcy52YWRkKHdvcmxkQ29ybmVyVGVtcFBvcyx3b3JsZENvcm5lclRlbXBQb3MpO1xyXG4gICAgICAgIGNhbGxiYWNrKHdvcmxkQ29ybmVyVGVtcFBvcy54LFxyXG4gICAgICAgICAgICAgICAgIHdvcmxkQ29ybmVyVGVtcFBvcy55LFxyXG4gICAgICAgICAgICAgICAgIHdvcmxkQ29ybmVyVGVtcFBvcy56KTtcclxuICAgIH1cclxufTtcclxuXHJcbnZhciB3b3JsZENvcm5lcnNUZW1wID0gW1xyXG4gICAgbmV3IFZlYzMoKSxcclxuICAgIG5ldyBWZWMzKCksXHJcbiAgICBuZXcgVmVjMygpLFxyXG4gICAgbmV3IFZlYzMoKSxcclxuICAgIG5ldyBWZWMzKCksXHJcbiAgICBuZXcgVmVjMygpLFxyXG4gICAgbmV3IFZlYzMoKSxcclxuICAgIG5ldyBWZWMzKClcclxuXTtcclxuQm94LnByb3RvdHlwZS5jYWxjdWxhdGVXb3JsZEFBQkIgPSBmdW5jdGlvbihwb3MscXVhdCxtaW4sbWF4KXtcclxuXHJcbiAgICB2YXIgZSA9IHRoaXMuaGFsZkV4dGVudHM7XHJcbiAgICB3b3JsZENvcm5lcnNUZW1wWzBdLnNldChlLngsIGUueSwgZS56KTtcclxuICAgIHdvcmxkQ29ybmVyc1RlbXBbMV0uc2V0KC1lLngsICBlLnksIGUueik7XHJcbiAgICB3b3JsZENvcm5lcnNUZW1wWzJdLnNldCgtZS54LCAtZS55LCBlLnopO1xyXG4gICAgd29ybGRDb3JuZXJzVGVtcFszXS5zZXQoLWUueCwgLWUueSwgLWUueik7XHJcbiAgICB3b3JsZENvcm5lcnNUZW1wWzRdLnNldChlLngsIC1lLnksIC1lLnopO1xyXG4gICAgd29ybGRDb3JuZXJzVGVtcFs1XS5zZXQoZS54LCAgZS55LCAtZS56KTtcclxuICAgIHdvcmxkQ29ybmVyc1RlbXBbNl0uc2V0KC1lLngsICBlLnksIC1lLnopO1xyXG4gICAgd29ybGRDb3JuZXJzVGVtcFs3XS5zZXQoZS54LCAtZS55LCAgZS56KTtcclxuXHJcbiAgICB2YXIgd2MgPSB3b3JsZENvcm5lcnNUZW1wWzBdO1xyXG4gICAgcXVhdC52bXVsdCh3Yywgd2MpO1xyXG4gICAgcG9zLnZhZGQod2MsIHdjKTtcclxuICAgIG1heC5jb3B5KHdjKTtcclxuICAgIG1pbi5jb3B5KHdjKTtcclxuICAgIGZvcih2YXIgaT0xOyBpPDg7IGkrKyl7XHJcbiAgICAgICAgdmFyIHdjID0gd29ybGRDb3JuZXJzVGVtcFtpXTtcclxuICAgICAgICBxdWF0LnZtdWx0KHdjLCB3Yyk7XHJcbiAgICAgICAgcG9zLnZhZGQod2MsIHdjKTtcclxuICAgICAgICB2YXIgeCA9IHdjLng7XHJcbiAgICAgICAgdmFyIHkgPSB3Yy55O1xyXG4gICAgICAgIHZhciB6ID0gd2MuejtcclxuICAgICAgICBpZih4ID4gbWF4Lngpe1xyXG4gICAgICAgICAgICBtYXgueCA9IHg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKHkgPiBtYXgueSl7XHJcbiAgICAgICAgICAgIG1heC55ID0geTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYoeiA+IG1heC56KXtcclxuICAgICAgICAgICAgbWF4LnogPSB6O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYoeCA8IG1pbi54KXtcclxuICAgICAgICAgICAgbWluLnggPSB4O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZih5IDwgbWluLnkpe1xyXG4gICAgICAgICAgICBtaW4ueSA9IHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKHogPCBtaW4ueil7XHJcbiAgICAgICAgICAgIG1pbi56ID0gejtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gR2V0IGVhY2ggYXhpcyBtYXhcclxuICAgIC8vIG1pbi5zZXQoSW5maW5pdHksSW5maW5pdHksSW5maW5pdHkpO1xyXG4gICAgLy8gbWF4LnNldCgtSW5maW5pdHksLUluZmluaXR5LC1JbmZpbml0eSk7XHJcbiAgICAvLyB0aGlzLmZvckVhY2hXb3JsZENvcm5lcihwb3MscXVhdCxmdW5jdGlvbih4LHkseil7XHJcbiAgICAvLyAgICAgaWYoeCA+IG1heC54KXtcclxuICAgIC8vICAgICAgICAgbWF4LnggPSB4O1xyXG4gICAgLy8gICAgIH1cclxuICAgIC8vICAgICBpZih5ID4gbWF4Lnkpe1xyXG4gICAgLy8gICAgICAgICBtYXgueSA9IHk7XHJcbiAgICAvLyAgICAgfVxyXG4gICAgLy8gICAgIGlmKHogPiBtYXgueil7XHJcbiAgICAvLyAgICAgICAgIG1heC56ID0gejtcclxuICAgIC8vICAgICB9XHJcblxyXG4gICAgLy8gICAgIGlmKHggPCBtaW4ueCl7XHJcbiAgICAvLyAgICAgICAgIG1pbi54ID0geDtcclxuICAgIC8vICAgICB9XHJcbiAgICAvLyAgICAgaWYoeSA8IG1pbi55KXtcclxuICAgIC8vICAgICAgICAgbWluLnkgPSB5O1xyXG4gICAgLy8gICAgIH1cclxuICAgIC8vICAgICBpZih6IDwgbWluLnope1xyXG4gICAgLy8gICAgICAgICBtaW4ueiA9IHo7XHJcbiAgICAvLyAgICAgfVxyXG4gICAgLy8gfSk7XHJcbn07XHJcblxyXG59LHtcIi4uL21hdGgvVmVjM1wiOjMxLFwiLi9Db252ZXhQb2x5aGVkcm9uXCI6MzksXCIuL1NoYXBlXCI6NDR9XSwzOTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XHJcbm1vZHVsZS5leHBvcnRzID0gQ29udmV4UG9seWhlZHJvbjtcclxuXHJcbnZhciBTaGFwZSA9IF9kZXJlcV8oJy4vU2hhcGUnKTtcclxudmFyIFZlYzMgPSBfZGVyZXFfKCcuLi9tYXRoL1ZlYzMnKTtcclxudmFyIFF1YXRlcm5pb24gPSBfZGVyZXFfKCcuLi9tYXRoL1F1YXRlcm5pb24nKTtcclxudmFyIFRyYW5zZm9ybSA9IF9kZXJlcV8oJy4uL21hdGgvVHJhbnNmb3JtJyk7XHJcblxyXG4vKipcclxuICogQSBzZXQgb2YgcG9seWdvbnMgZGVzY3JpYmluZyBhIGNvbnZleCBzaGFwZS5cclxuICogQGNsYXNzIENvbnZleFBvbHloZWRyb25cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBleHRlbmRzIFNoYXBlXHJcbiAqIEBkZXNjcmlwdGlvbiBUaGUgc2hhcGUgTVVTVCBiZSBjb252ZXggZm9yIHRoZSBjb2RlIHRvIHdvcmsgcHJvcGVybHkuIE5vIHBvbHlnb25zIG1heSBiZSBjb3BsYW5hciAoY29udGFpbmVkXHJcbiAqIGluIHRoZSBzYW1lIDNEIHBsYW5lKSwgaW5zdGVhZCB0aGVzZSBzaG91bGQgYmUgbWVyZ2VkIGludG8gb25lIHBvbHlnb24uXHJcbiAqXHJcbiAqIEBwYXJhbSB7YXJyYXl9IHBvaW50cyBBbiBhcnJheSBvZiBWZWMzJ3NcclxuICogQHBhcmFtIHthcnJheX0gZmFjZXMgQXJyYXkgb2YgaW50ZWdlciBhcnJheXMsIGRlc2NyaWJpbmcgd2hpY2ggdmVydGljZXMgdGhhdCBpcyBpbmNsdWRlZCBpbiBlYWNoIGZhY2UuXHJcbiAqXHJcbiAqIEBhdXRob3IgcWlhbyAvIGh0dHBzOi8vZ2l0aHViLmNvbS9xaWFvIChvcmlnaW5hbCBhdXRob3IsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vcWlhby90aHJlZS5qcy9jb21taXQvODUwMjZmMGM3NjllNDAwMDE0OGE2N2Q0NWE5ZTliOWM1MTA4ODM2ZilcclxuICogQGF1dGhvciBzY2h0ZXBwZSAvIGh0dHBzOi8vZ2l0aHViLmNvbS9zY2h0ZXBwZVxyXG4gKiBAc2VlIGh0dHA6Ly93d3cuYWx0ZGV2YmxvZ2FkYXkuY29tLzIwMTEvMDUvMTMvY29udGFjdC1nZW5lcmF0aW9uLWJldHdlZW4tM2QtY29udmV4LW1lc2hlcy9cclxuICogQHNlZSBodHRwOi8vYnVsbGV0Lmdvb2dsZWNvZGUuY29tL3N2bi90cnVuay9zcmMvQnVsbGV0Q29sbGlzaW9uL05hcnJvd1BoYXNlQ29sbGlzaW9uL2J0UG9seWhlZHJhbENvbnRhY3RDbGlwcGluZy5jcHBcclxuICpcclxuICogQHRvZG8gTW92ZSB0aGUgY2xpcHBpbmcgZnVuY3Rpb25zIHRvIENvbnRhY3RHZW5lcmF0b3I/XHJcbiAqIEB0b2RvIEF1dG9tYXRpY2FsbHkgbWVyZ2UgY29wbGFuYXIgcG9seWdvbnMgaW4gY29uc3RydWN0b3IuXHJcbiAqL1xyXG5mdW5jdGlvbiBDb252ZXhQb2x5aGVkcm9uKHBvaW50cywgZmFjZXMsIHVuaXF1ZUF4ZXMpIHtcclxuICAgIFNoYXBlLmNhbGwodGhpcywge1xyXG4gICAgICAgIHR5cGU6IFNoYXBlLnR5cGVzLkNPTlZFWFBPTFlIRURST05cclxuICAgIH0pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXJyYXkgb2YgVmVjM1xyXG4gICAgICogQHByb3BlcnR5IHZlcnRpY2VzXHJcbiAgICAgKiBAdHlwZSB7QXJyYXl9XHJcbiAgICAgKi9cclxuICAgIHRoaXMudmVydGljZXMgPSBwb2ludHN8fFtdO1xyXG5cclxuICAgIHRoaXMud29ybGRWZXJ0aWNlcyA9IFtdOyAvLyBXb3JsZCB0cmFuc2Zvcm1lZCB2ZXJzaW9uIG9mIC52ZXJ0aWNlc1xyXG4gICAgdGhpcy53b3JsZFZlcnRpY2VzTmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXJyYXkgb2YgaW50ZWdlciBhcnJheXMsIGluZGljYXRpbmcgd2hpY2ggdmVydGljZXMgZWFjaCBmYWNlIGNvbnNpc3RzIG9mXHJcbiAgICAgKiBAcHJvcGVydHkgZmFjZXNcclxuICAgICAqIEB0eXBlIHtBcnJheX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5mYWNlcyA9IGZhY2VzfHxbXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFycmF5IG9mIFZlYzNcclxuICAgICAqIEBwcm9wZXJ0eSBmYWNlTm9ybWFsc1xyXG4gICAgICogQHR5cGUge0FycmF5fVxyXG4gICAgICovXHJcbiAgICB0aGlzLmZhY2VOb3JtYWxzID0gW107XHJcbiAgICB0aGlzLmNvbXB1dGVOb3JtYWxzKCk7XHJcblxyXG4gICAgdGhpcy53b3JsZEZhY2VOb3JtYWxzTmVlZHNVcGRhdGUgPSB0cnVlO1xyXG4gICAgdGhpcy53b3JsZEZhY2VOb3JtYWxzID0gW107IC8vIFdvcmxkIHRyYW5zZm9ybWVkIHZlcnNpb24gb2YgLmZhY2VOb3JtYWxzXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBcnJheSBvZiBWZWMzXHJcbiAgICAgKiBAcHJvcGVydHkgdW5pcXVlRWRnZXNcclxuICAgICAqIEB0eXBlIHtBcnJheX1cclxuICAgICAqL1xyXG4gICAgdGhpcy51bmlxdWVFZGdlcyA9IFtdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSWYgZ2l2ZW4sIHRoZXNlIGxvY2FsbHkgZGVmaW5lZCwgbm9ybWFsaXplZCBheGVzIGFyZSB0aGUgb25seSBvbmVzIGJlaW5nIGNoZWNrZWQgd2hlbiBkb2luZyBzZXBhcmF0aW5nIGF4aXMgY2hlY2suXHJcbiAgICAgKiBAcHJvcGVydHkge0FycmF5fSB1bmlxdWVBeGVzXHJcbiAgICAgKi9cclxuICAgIHRoaXMudW5pcXVlQXhlcyA9IHVuaXF1ZUF4ZXMgPyB1bmlxdWVBeGVzLnNsaWNlKCkgOiBudWxsO1xyXG5cclxuICAgIHRoaXMuY29tcHV0ZUVkZ2VzKCk7XHJcbiAgICB0aGlzLnVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzKCk7XHJcbn1cclxuQ29udmV4UG9seWhlZHJvbi5wcm90b3R5cGUgPSBuZXcgU2hhcGUoKTtcclxuQ29udmV4UG9seWhlZHJvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb252ZXhQb2x5aGVkcm9uO1xyXG5cclxudmFyIGNvbXB1dGVFZGdlc190bXBFZGdlID0gbmV3IFZlYzMoKTtcclxuLyoqXHJcbiAqIENvbXB1dGVzIHVuaXF1ZUVkZ2VzXHJcbiAqIEBtZXRob2QgY29tcHV0ZUVkZ2VzXHJcbiAqL1xyXG5Db252ZXhQb2x5aGVkcm9uLnByb3RvdHlwZS5jb21wdXRlRWRnZXMgPSBmdW5jdGlvbigpe1xyXG4gICAgdmFyIGZhY2VzID0gdGhpcy5mYWNlcztcclxuICAgIHZhciB2ZXJ0aWNlcyA9IHRoaXMudmVydGljZXM7XHJcbiAgICB2YXIgbnYgPSB2ZXJ0aWNlcy5sZW5ndGg7XHJcbiAgICB2YXIgZWRnZXMgPSB0aGlzLnVuaXF1ZUVkZ2VzO1xyXG5cclxuICAgIGVkZ2VzLmxlbmd0aCA9IDA7XHJcblxyXG4gICAgdmFyIGVkZ2UgPSBjb21wdXRlRWRnZXNfdG1wRWRnZTtcclxuXHJcbiAgICBmb3IodmFyIGk9MDsgaSAhPT0gZmFjZXMubGVuZ3RoOyBpKyspe1xyXG4gICAgICAgIHZhciBmYWNlID0gZmFjZXNbaV07XHJcbiAgICAgICAgdmFyIG51bVZlcnRpY2VzID0gZmFjZS5sZW5ndGg7XHJcbiAgICAgICAgZm9yKHZhciBqID0gMDsgaiAhPT0gbnVtVmVydGljZXM7IGorKyl7XHJcbiAgICAgICAgICAgIHZhciBrID0gKCBqKzEgKSAlIG51bVZlcnRpY2VzO1xyXG4gICAgICAgICAgICB2ZXJ0aWNlc1tmYWNlW2pdXS52c3ViKHZlcnRpY2VzW2ZhY2Vba11dLCBlZGdlKTtcclxuICAgICAgICAgICAgZWRnZS5ub3JtYWxpemUoKTtcclxuICAgICAgICAgICAgdmFyIGZvdW5kID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGZvcih2YXIgcD0wOyBwICE9PSBlZGdlcy5sZW5ndGg7IHArKyl7XHJcbiAgICAgICAgICAgICAgICBpZiAoZWRnZXNbcF0uYWxtb3N0RXF1YWxzKGVkZ2UpIHx8IGVkZ2VzW3BdLmFsbW9zdEVxdWFscyhlZGdlKSl7XHJcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIWZvdW5kKXtcclxuICAgICAgICAgICAgICAgIGVkZ2VzLnB1c2goZWRnZS5jbG9uZSgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb21wdXRlIHRoZSBub3JtYWxzIG9mIHRoZSBmYWNlcy4gV2lsbCByZXVzZSBleGlzdGluZyBWZWMzIG9iamVjdHMgaW4gdGhlIC5mYWNlTm9ybWFscyBhcnJheSBpZiB0aGV5IGV4aXN0LlxyXG4gKiBAbWV0aG9kIGNvbXB1dGVOb3JtYWxzXHJcbiAqL1xyXG5Db252ZXhQb2x5aGVkcm9uLnByb3RvdHlwZS5jb21wdXRlTm9ybWFscyA9IGZ1bmN0aW9uKCl7XHJcbiAgICB0aGlzLmZhY2VOb3JtYWxzLmxlbmd0aCA9IHRoaXMuZmFjZXMubGVuZ3RoO1xyXG5cclxuICAgIC8vIEdlbmVyYXRlIG5vcm1hbHNcclxuICAgIGZvcih2YXIgaT0wOyBpPHRoaXMuZmFjZXMubGVuZ3RoOyBpKyspe1xyXG5cclxuICAgICAgICAvLyBDaGVjayBzbyBhbGwgdmVydGljZXMgZXhpc3RzIGZvciB0aGlzIGZhY2VcclxuICAgICAgICBmb3IodmFyIGo9MDsgajx0aGlzLmZhY2VzW2ldLmxlbmd0aDsgaisrKXtcclxuICAgICAgICAgICAgaWYoIXRoaXMudmVydGljZXNbdGhpcy5mYWNlc1tpXVtqXV0pe1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmVydGV4IFwiK3RoaXMuZmFjZXNbaV1bal0rXCIgbm90IGZvdW5kIVwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIG4gPSB0aGlzLmZhY2VOb3JtYWxzW2ldIHx8IG5ldyBWZWMzKCk7XHJcbiAgICAgICAgdGhpcy5nZXRGYWNlTm9ybWFsKGksbik7XHJcbiAgICAgICAgbi5uZWdhdGUobik7XHJcbiAgICAgICAgdGhpcy5mYWNlTm9ybWFsc1tpXSA9IG47XHJcbiAgICAgICAgdmFyIHZlcnRleCA9IHRoaXMudmVydGljZXNbdGhpcy5mYWNlc1tpXVswXV07XHJcbiAgICAgICAgaWYobi5kb3QodmVydGV4KSA8IDApe1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiLmZhY2VOb3JtYWxzW1wiICsgaSArIFwiXSA9IFZlYzMoXCIrbi50b1N0cmluZygpK1wiKSBsb29rcyBsaWtlIGl0IHBvaW50cyBpbnRvIHRoZSBzaGFwZT8gVGhlIHZlcnRpY2VzIGZvbGxvdy4gTWFrZSBzdXJlIHRoZXkgYXJlIG9yZGVyZWQgQ0NXIGFyb3VuZCB0aGUgbm9ybWFsLCB1c2luZyB0aGUgcmlnaHQgaGFuZCBydWxlLlwiKTtcclxuICAgICAgICAgICAgZm9yKHZhciBqPTA7IGo8dGhpcy5mYWNlc1tpXS5sZW5ndGg7IGorKyl7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCIudmVydGljZXNbXCIrdGhpcy5mYWNlc1tpXVtqXStcIl0gPSBWZWMzKFwiK3RoaXMudmVydGljZXNbdGhpcy5mYWNlc1tpXVtqXV0udG9TdHJpbmcoKStcIilcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0IGZhY2Ugbm9ybWFsIGdpdmVuIDMgdmVydGljZXNcclxuICogQHN0YXRpY1xyXG4gKiBAbWV0aG9kIGdldEZhY2VOb3JtYWxcclxuICogQHBhcmFtIHtWZWMzfSB2YVxyXG4gKiBAcGFyYW0ge1ZlYzN9IHZiXHJcbiAqIEBwYXJhbSB7VmVjM30gdmNcclxuICogQHBhcmFtIHtWZWMzfSB0YXJnZXRcclxuICovXHJcbnZhciBjYiA9IG5ldyBWZWMzKCk7XHJcbnZhciBhYiA9IG5ldyBWZWMzKCk7XHJcbkNvbnZleFBvbHloZWRyb24uY29tcHV0ZU5vcm1hbCA9IGZ1bmN0aW9uICggdmEsIHZiLCB2YywgdGFyZ2V0ICkge1xyXG4gICAgdmIudnN1Yih2YSxhYik7XHJcbiAgICB2Yy52c3ViKHZiLGNiKTtcclxuICAgIGNiLmNyb3NzKGFiLHRhcmdldCk7XHJcbiAgICBpZiAoICF0YXJnZXQuaXNaZXJvKCkgKSB7XHJcbiAgICAgICAgdGFyZ2V0Lm5vcm1hbGl6ZSgpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbXB1dGUgdGhlIG5vcm1hbCBvZiBhIGZhY2UgZnJvbSBpdHMgdmVydGljZXNcclxuICogQG1ldGhvZCBnZXRGYWNlTm9ybWFsXHJcbiAqIEBwYXJhbSAge051bWJlcn0gaVxyXG4gKiBAcGFyYW0gIHtWZWMzfSB0YXJnZXRcclxuICovXHJcbkNvbnZleFBvbHloZWRyb24ucHJvdG90eXBlLmdldEZhY2VOb3JtYWwgPSBmdW5jdGlvbihpLHRhcmdldCl7XHJcbiAgICB2YXIgZiA9IHRoaXMuZmFjZXNbaV07XHJcbiAgICB2YXIgdmEgPSB0aGlzLnZlcnRpY2VzW2ZbMF1dO1xyXG4gICAgdmFyIHZiID0gdGhpcy52ZXJ0aWNlc1tmWzFdXTtcclxuICAgIHZhciB2YyA9IHRoaXMudmVydGljZXNbZlsyXV07XHJcbiAgICByZXR1cm4gQ29udmV4UG9seWhlZHJvbi5jb21wdXRlTm9ybWFsKHZhLHZiLHZjLHRhcmdldCk7XHJcbn07XHJcblxyXG4vKipcclxuICogQG1ldGhvZCBjbGlwQWdhaW5zdEh1bGxcclxuICogQHBhcmFtIHtWZWMzfSBwb3NBXHJcbiAqIEBwYXJhbSB7UXVhdGVybmlvbn0gcXVhdEFcclxuICogQHBhcmFtIHtDb252ZXhQb2x5aGVkcm9ufSBodWxsQlxyXG4gKiBAcGFyYW0ge1ZlYzN9IHBvc0JcclxuICogQHBhcmFtIHtRdWF0ZXJuaW9ufSBxdWF0QlxyXG4gKiBAcGFyYW0ge1ZlYzN9IHNlcGFyYXRpbmdOb3JtYWxcclxuICogQHBhcmFtIHtOdW1iZXJ9IG1pbkRpc3QgQ2xhbXAgZGlzdGFuY2VcclxuICogQHBhcmFtIHtOdW1iZXJ9IG1heERpc3RcclxuICogQHBhcmFtIHthcnJheX0gcmVzdWx0IFRoZSBhbiBhcnJheSBvZiBjb250YWN0IHBvaW50IG9iamVjdHMsIHNlZSBjbGlwRmFjZUFnYWluc3RIdWxsXHJcbiAqIEBzZWUgaHR0cDovL2J1bGxldC5nb29nbGVjb2RlLmNvbS9zdm4vdHJ1bmsvc3JjL0J1bGxldENvbGxpc2lvbi9OYXJyb3dQaGFzZUNvbGxpc2lvbi9idFBvbHloZWRyYWxDb250YWN0Q2xpcHBpbmcuY3BwXHJcbiAqL1xyXG52YXIgY2FoX1dvcmxkTm9ybWFsID0gbmV3IFZlYzMoKTtcclxuQ29udmV4UG9seWhlZHJvbi5wcm90b3R5cGUuY2xpcEFnYWluc3RIdWxsID0gZnVuY3Rpb24ocG9zQSxxdWF0QSxodWxsQixwb3NCLHF1YXRCLHNlcGFyYXRpbmdOb3JtYWwsbWluRGlzdCxtYXhEaXN0LHJlc3VsdCl7XHJcbiAgICB2YXIgV29ybGROb3JtYWwgPSBjYWhfV29ybGROb3JtYWw7XHJcbiAgICB2YXIgaHVsbEEgPSB0aGlzO1xyXG4gICAgdmFyIGN1ck1heERpc3QgPSBtYXhEaXN0O1xyXG4gICAgdmFyIGNsb3Nlc3RGYWNlQiA9IC0xO1xyXG4gICAgdmFyIGRtYXggPSAtTnVtYmVyLk1BWF9WQUxVRTtcclxuICAgIGZvcih2YXIgZmFjZT0wOyBmYWNlIDwgaHVsbEIuZmFjZXMubGVuZ3RoOyBmYWNlKyspe1xyXG4gICAgICAgIFdvcmxkTm9ybWFsLmNvcHkoaHVsbEIuZmFjZU5vcm1hbHNbZmFjZV0pO1xyXG4gICAgICAgIHF1YXRCLnZtdWx0KFdvcmxkTm9ybWFsLFdvcmxkTm9ybWFsKTtcclxuICAgICAgICAvL3Bvc0IudmFkZChXb3JsZE5vcm1hbCxXb3JsZE5vcm1hbCk7XHJcbiAgICAgICAgdmFyIGQgPSBXb3JsZE5vcm1hbC5kb3Qoc2VwYXJhdGluZ05vcm1hbCk7XHJcbiAgICAgICAgaWYgKGQgPiBkbWF4KXtcclxuICAgICAgICAgICAgZG1heCA9IGQ7XHJcbiAgICAgICAgICAgIGNsb3Nlc3RGYWNlQiA9IGZhY2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdmFyIHdvcmxkVmVydHNCMSA9IFtdO1xyXG4gICAgdmFyIHBvbHlCID0gaHVsbEIuZmFjZXNbY2xvc2VzdEZhY2VCXTtcclxuICAgIHZhciBudW1WZXJ0aWNlcyA9IHBvbHlCLmxlbmd0aDtcclxuICAgIGZvcih2YXIgZTA9MDsgZTA8bnVtVmVydGljZXM7IGUwKyspe1xyXG4gICAgICAgIHZhciBiID0gaHVsbEIudmVydGljZXNbcG9seUJbZTBdXTtcclxuICAgICAgICB2YXIgd29ybGRiID0gbmV3IFZlYzMoKTtcclxuICAgICAgICB3b3JsZGIuY29weShiKTtcclxuICAgICAgICBxdWF0Qi52bXVsdCh3b3JsZGIsd29ybGRiKTtcclxuICAgICAgICBwb3NCLnZhZGQod29ybGRiLHdvcmxkYik7XHJcbiAgICAgICAgd29ybGRWZXJ0c0IxLnB1c2god29ybGRiKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoY2xvc2VzdEZhY2VCPj0wKXtcclxuICAgICAgICB0aGlzLmNsaXBGYWNlQWdhaW5zdEh1bGwoc2VwYXJhdGluZ05vcm1hbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zQSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVhdEEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdvcmxkVmVydHNCMSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluRGlzdCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4RGlzdCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0KTtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBGaW5kIHRoZSBzZXBhcmF0aW5nIGF4aXMgYmV0d2VlbiB0aGlzIGh1bGwgYW5kIGFub3RoZXJcclxuICogQG1ldGhvZCBmaW5kU2VwYXJhdGluZ0F4aXNcclxuICogQHBhcmFtIHtDb252ZXhQb2x5aGVkcm9ufSBodWxsQlxyXG4gKiBAcGFyYW0ge1ZlYzN9IHBvc0FcclxuICogQHBhcmFtIHtRdWF0ZXJuaW9ufSBxdWF0QVxyXG4gKiBAcGFyYW0ge1ZlYzN9IHBvc0JcclxuICogQHBhcmFtIHtRdWF0ZXJuaW9ufSBxdWF0QlxyXG4gKiBAcGFyYW0ge1ZlYzN9IHRhcmdldCBUaGUgdGFyZ2V0IHZlY3RvciB0byBzYXZlIHRoZSBheGlzIGluXHJcbiAqIEByZXR1cm4ge2Jvb2x9IFJldHVybnMgZmFsc2UgaWYgYSBzZXBhcmF0aW9uIGlzIGZvdW5kLCBlbHNlIHRydWVcclxuICovXHJcbnZhciBmc2FfZmFjZUFOb3JtYWxXUzMgPSBuZXcgVmVjMygpLFxyXG4gICAgZnNhX1dvcmxkbm9ybWFsMSA9IG5ldyBWZWMzKCksXHJcbiAgICBmc2FfZGVsdGFDID0gbmV3IFZlYzMoKSxcclxuICAgIGZzYV93b3JsZEVkZ2UwID0gbmV3IFZlYzMoKSxcclxuICAgIGZzYV93b3JsZEVkZ2UxID0gbmV3IFZlYzMoKSxcclxuICAgIGZzYV9Dcm9zcyA9IG5ldyBWZWMzKCk7XHJcbkNvbnZleFBvbHloZWRyb24ucHJvdG90eXBlLmZpbmRTZXBhcmF0aW5nQXhpcyA9IGZ1bmN0aW9uKGh1bGxCLHBvc0EscXVhdEEscG9zQixxdWF0Qix0YXJnZXQsIGZhY2VMaXN0QSwgZmFjZUxpc3RCKXtcclxuICAgIHZhciBmYWNlQU5vcm1hbFdTMyA9IGZzYV9mYWNlQU5vcm1hbFdTMyxcclxuICAgICAgICBXb3JsZG5vcm1hbDEgPSBmc2FfV29ybGRub3JtYWwxLFxyXG4gICAgICAgIGRlbHRhQyA9IGZzYV9kZWx0YUMsXHJcbiAgICAgICAgd29ybGRFZGdlMCA9IGZzYV93b3JsZEVkZ2UwLFxyXG4gICAgICAgIHdvcmxkRWRnZTEgPSBmc2Ffd29ybGRFZGdlMSxcclxuICAgICAgICBDcm9zcyA9IGZzYV9Dcm9zcztcclxuXHJcbiAgICB2YXIgZG1pbiA9IE51bWJlci5NQVhfVkFMVUU7XHJcbiAgICB2YXIgaHVsbEEgPSB0aGlzO1xyXG4gICAgdmFyIGN1clBsYW5lVGVzdHM9MDtcclxuXHJcbiAgICBpZighaHVsbEEudW5pcXVlQXhlcyl7XHJcblxyXG4gICAgICAgIHZhciBudW1GYWNlc0EgPSBmYWNlTGlzdEEgPyBmYWNlTGlzdEEubGVuZ3RoIDogaHVsbEEuZmFjZXMubGVuZ3RoO1xyXG5cclxuICAgICAgICAvLyBUZXN0IGZhY2Ugbm9ybWFscyBmcm9tIGh1bGxBXHJcbiAgICAgICAgZm9yKHZhciBpPTA7IGk8bnVtRmFjZXNBOyBpKyspe1xyXG4gICAgICAgICAgICB2YXIgZmkgPSBmYWNlTGlzdEEgPyBmYWNlTGlzdEFbaV0gOiBpO1xyXG5cclxuICAgICAgICAgICAgLy8gR2V0IHdvcmxkIGZhY2Ugbm9ybWFsXHJcbiAgICAgICAgICAgIGZhY2VBTm9ybWFsV1MzLmNvcHkoaHVsbEEuZmFjZU5vcm1hbHNbZmldKTtcclxuICAgICAgICAgICAgcXVhdEEudm11bHQoZmFjZUFOb3JtYWxXUzMsZmFjZUFOb3JtYWxXUzMpO1xyXG5cclxuICAgICAgICAgICAgdmFyIGQgPSBodWxsQS50ZXN0U2VwQXhpcyhmYWNlQU5vcm1hbFdTMywgaHVsbEIsIHBvc0EsIHF1YXRBLCBwb3NCLCBxdWF0Qik7XHJcbiAgICAgICAgICAgIGlmKGQ9PT1mYWxzZSl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKGQ8ZG1pbil7XHJcbiAgICAgICAgICAgICAgICBkbWluID0gZDtcclxuICAgICAgICAgICAgICAgIHRhcmdldC5jb3B5KGZhY2VBTm9ybWFsV1MzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAvLyBUZXN0IHVuaXF1ZSBheGVzXHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSAhPT0gaHVsbEEudW5pcXVlQXhlcy5sZW5ndGg7IGkrKyl7XHJcblxyXG4gICAgICAgICAgICAvLyBHZXQgd29ybGQgYXhpc1xyXG4gICAgICAgICAgICBxdWF0QS52bXVsdChodWxsQS51bmlxdWVBeGVzW2ldLGZhY2VBTm9ybWFsV1MzKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBkID0gaHVsbEEudGVzdFNlcEF4aXMoZmFjZUFOb3JtYWxXUzMsIGh1bGxCLCBwb3NBLCBxdWF0QSwgcG9zQiwgcXVhdEIpO1xyXG4gICAgICAgICAgICBpZihkPT09ZmFsc2Upe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihkPGRtaW4pe1xyXG4gICAgICAgICAgICAgICAgZG1pbiA9IGQ7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQuY29weShmYWNlQU5vcm1hbFdTMyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYoIWh1bGxCLnVuaXF1ZUF4ZXMpe1xyXG5cclxuICAgICAgICAvLyBUZXN0IGZhY2Ugbm9ybWFscyBmcm9tIGh1bGxCXHJcbiAgICAgICAgdmFyIG51bUZhY2VzQiA9IGZhY2VMaXN0QiA/IGZhY2VMaXN0Qi5sZW5ndGggOiBodWxsQi5mYWNlcy5sZW5ndGg7XHJcbiAgICAgICAgZm9yKHZhciBpPTA7aTxudW1GYWNlc0I7aSsrKXtcclxuXHJcbiAgICAgICAgICAgIHZhciBmaSA9IGZhY2VMaXN0QiA/IGZhY2VMaXN0QltpXSA6IGk7XHJcblxyXG4gICAgICAgICAgICBXb3JsZG5vcm1hbDEuY29weShodWxsQi5mYWNlTm9ybWFsc1tmaV0pO1xyXG4gICAgICAgICAgICBxdWF0Qi52bXVsdChXb3JsZG5vcm1hbDEsV29ybGRub3JtYWwxKTtcclxuICAgICAgICAgICAgY3VyUGxhbmVUZXN0cysrO1xyXG4gICAgICAgICAgICB2YXIgZCA9IGh1bGxBLnRlc3RTZXBBeGlzKFdvcmxkbm9ybWFsMSwgaHVsbEIscG9zQSxxdWF0QSxwb3NCLHF1YXRCKTtcclxuICAgICAgICAgICAgaWYoZD09PWZhbHNlKXtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYoZDxkbWluKXtcclxuICAgICAgICAgICAgICAgIGRtaW4gPSBkO1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LmNvcHkoV29ybGRub3JtYWwxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgIC8vIFRlc3QgdW5pcXVlIGF4ZXMgaW4gQlxyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgIT09IGh1bGxCLnVuaXF1ZUF4ZXMubGVuZ3RoOyBpKyspe1xyXG4gICAgICAgICAgICBxdWF0Qi52bXVsdChodWxsQi51bmlxdWVBeGVzW2ldLFdvcmxkbm9ybWFsMSk7XHJcblxyXG4gICAgICAgICAgICBjdXJQbGFuZVRlc3RzKys7XHJcbiAgICAgICAgICAgIHZhciBkID0gaHVsbEEudGVzdFNlcEF4aXMoV29ybGRub3JtYWwxLCBodWxsQixwb3NBLHF1YXRBLHBvc0IscXVhdEIpO1xyXG4gICAgICAgICAgICBpZihkPT09ZmFsc2Upe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihkPGRtaW4pe1xyXG4gICAgICAgICAgICAgICAgZG1pbiA9IGQ7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQuY29weShXb3JsZG5vcm1hbDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFRlc3QgZWRnZXNcclxuICAgIGZvcih2YXIgZTA9MDsgZTAgIT09IGh1bGxBLnVuaXF1ZUVkZ2VzLmxlbmd0aDsgZTArKyl7XHJcblxyXG4gICAgICAgIC8vIEdldCB3b3JsZCBlZGdlXHJcbiAgICAgICAgcXVhdEEudm11bHQoaHVsbEEudW5pcXVlRWRnZXNbZTBdLHdvcmxkRWRnZTApO1xyXG5cclxuICAgICAgICBmb3IodmFyIGUxPTA7IGUxICE9PSBodWxsQi51bmlxdWVFZGdlcy5sZW5ndGg7IGUxKyspe1xyXG5cclxuICAgICAgICAgICAgLy8gR2V0IHdvcmxkIGVkZ2UgMlxyXG4gICAgICAgICAgICBxdWF0Qi52bXVsdChodWxsQi51bmlxdWVFZGdlc1tlMV0sIHdvcmxkRWRnZTEpO1xyXG4gICAgICAgICAgICB3b3JsZEVkZ2UwLmNyb3NzKHdvcmxkRWRnZTEsQ3Jvc3MpO1xyXG5cclxuICAgICAgICAgICAgaWYoIUNyb3NzLmFsbW9zdFplcm8oKSl7XHJcbiAgICAgICAgICAgICAgICBDcm9zcy5ub3JtYWxpemUoKTtcclxuICAgICAgICAgICAgICAgIHZhciBkaXN0ID0gaHVsbEEudGVzdFNlcEF4aXMoQ3Jvc3MsIGh1bGxCLCBwb3NBLCBxdWF0QSwgcG9zQiwgcXVhdEIpO1xyXG4gICAgICAgICAgICAgICAgaWYoZGlzdCA9PT0gZmFsc2Upe1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmKGRpc3QgPCBkbWluKXtcclxuICAgICAgICAgICAgICAgICAgICBkbWluID0gZGlzdDtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQuY29weShDcm9zcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcG9zQi52c3ViKHBvc0EsZGVsdGFDKTtcclxuICAgIGlmKChkZWx0YUMuZG90KHRhcmdldCkpPjAuMCl7XHJcbiAgICAgICAgdGFyZ2V0Lm5lZ2F0ZSh0YXJnZXQpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0cnVlO1xyXG59O1xyXG5cclxudmFyIG1heG1pbkE9W10sIG1heG1pbkI9W107XHJcblxyXG4vKipcclxuICogVGVzdCBzZXBhcmF0aW5nIGF4aXMgYWdhaW5zdCB0d28gaHVsbHMuIEJvdGggaHVsbHMgYXJlIHByb2plY3RlZCBvbnRvIHRoZSBheGlzIGFuZCB0aGUgb3ZlcmxhcCBzaXplIGlzIHJldHVybmVkIGlmIHRoZXJlIGlzIG9uZS5cclxuICogQG1ldGhvZCB0ZXN0U2VwQXhpc1xyXG4gKiBAcGFyYW0ge1ZlYzN9IGF4aXNcclxuICogQHBhcmFtIHtDb252ZXhQb2x5aGVkcm9ufSBodWxsQlxyXG4gKiBAcGFyYW0ge1ZlYzN9IHBvc0FcclxuICogQHBhcmFtIHtRdWF0ZXJuaW9ufSBxdWF0QVxyXG4gKiBAcGFyYW0ge1ZlYzN9IHBvc0JcclxuICogQHBhcmFtIHtRdWF0ZXJuaW9ufSBxdWF0QlxyXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBvdmVybGFwIGRlcHRoLCBvciBGQUxTRSBpZiBubyBwZW5ldHJhdGlvbi5cclxuICovXHJcbkNvbnZleFBvbHloZWRyb24ucHJvdG90eXBlLnRlc3RTZXBBeGlzID0gZnVuY3Rpb24oYXhpcywgaHVsbEIsIHBvc0EsIHF1YXRBLCBwb3NCLCBxdWF0Qil7XHJcbiAgICB2YXIgaHVsbEE9dGhpcztcclxuICAgIENvbnZleFBvbHloZWRyb24ucHJvamVjdChodWxsQSwgYXhpcywgcG9zQSwgcXVhdEEsIG1heG1pbkEpO1xyXG4gICAgQ29udmV4UG9seWhlZHJvbi5wcm9qZWN0KGh1bGxCLCBheGlzLCBwb3NCLCBxdWF0QiwgbWF4bWluQik7XHJcbiAgICB2YXIgbWF4QSA9IG1heG1pbkFbMF07XHJcbiAgICB2YXIgbWluQSA9IG1heG1pbkFbMV07XHJcbiAgICB2YXIgbWF4QiA9IG1heG1pbkJbMF07XHJcbiAgICB2YXIgbWluQiA9IG1heG1pbkJbMV07XHJcbiAgICBpZihtYXhBPG1pbkIgfHwgbWF4QjxtaW5BKXtcclxuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIFNlcGFyYXRlZFxyXG4gICAgfVxyXG4gICAgdmFyIGQwID0gbWF4QSAtIG1pbkI7XHJcbiAgICB2YXIgZDEgPSBtYXhCIC0gbWluQTtcclxuICAgIHZhciBkZXB0aCA9IGQwPGQxID8gZDA6ZDE7XHJcbiAgICByZXR1cm4gZGVwdGg7XHJcbn07XHJcblxyXG52YXIgY2xpX2FhYmJtaW4gPSBuZXcgVmVjMygpLFxyXG4gICAgY2xpX2FhYmJtYXggPSBuZXcgVmVjMygpO1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgY2FsY3VsYXRlTG9jYWxJbmVydGlhXHJcbiAqIEBwYXJhbSAge051bWJlcn0gbWFzc1xyXG4gKiBAcGFyYW0gIHtWZWMzfSB0YXJnZXRcclxuICovXHJcbkNvbnZleFBvbHloZWRyb24ucHJvdG90eXBlLmNhbGN1bGF0ZUxvY2FsSW5lcnRpYSA9IGZ1bmN0aW9uKG1hc3MsdGFyZ2V0KXtcclxuICAgIC8vIEFwcHJveGltYXRlIHdpdGggYm94IGluZXJ0aWFcclxuICAgIC8vIEV4YWN0IGluZXJ0aWEgY2FsY3VsYXRpb24gaXMgb3ZlcmtpbGwsIGJ1dCBzZWUgaHR0cDovL2dlb21ldHJpY3Rvb2xzLmNvbS9Eb2N1bWVudGF0aW9uL1BvbHloZWRyYWxNYXNzUHJvcGVydGllcy5wZGYgZm9yIHRoZSBjb3JyZWN0IHdheSB0byBkbyBpdFxyXG4gICAgdGhpcy5jb21wdXRlTG9jYWxBQUJCKGNsaV9hYWJibWluLGNsaV9hYWJibWF4KTtcclxuICAgIHZhciB4ID0gY2xpX2FhYmJtYXgueCAtIGNsaV9hYWJibWluLngsXHJcbiAgICAgICAgeSA9IGNsaV9hYWJibWF4LnkgLSBjbGlfYWFiYm1pbi55LFxyXG4gICAgICAgIHogPSBjbGlfYWFiYm1heC56IC0gY2xpX2FhYmJtaW4uejtcclxuICAgIHRhcmdldC54ID0gMS4wIC8gMTIuMCAqIG1hc3MgKiAoIDIqeSoyKnkgKyAyKnoqMip6ICk7XHJcbiAgICB0YXJnZXQueSA9IDEuMCAvIDEyLjAgKiBtYXNzICogKCAyKngqMip4ICsgMip6KjIqeiApO1xyXG4gICAgdGFyZ2V0LnogPSAxLjAgLyAxMi4wICogbWFzcyAqICggMip5KjIqeSArIDIqeCoyKnggKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kIGdldFBsYW5lQ29uc3RhbnRPZkZhY2VcclxuICogQHBhcmFtICB7TnVtYmVyfSBmYWNlX2kgSW5kZXggb2YgdGhlIGZhY2VcclxuICogQHJldHVybiB7TnVtYmVyfVxyXG4gKi9cclxuQ29udmV4UG9seWhlZHJvbi5wcm90b3R5cGUuZ2V0UGxhbmVDb25zdGFudE9mRmFjZSA9IGZ1bmN0aW9uKGZhY2VfaSl7XHJcbiAgICB2YXIgZiA9IHRoaXMuZmFjZXNbZmFjZV9pXTtcclxuICAgIHZhciBuID0gdGhpcy5mYWNlTm9ybWFsc1tmYWNlX2ldO1xyXG4gICAgdmFyIHYgPSB0aGlzLnZlcnRpY2VzW2ZbMF1dO1xyXG4gICAgdmFyIGMgPSAtbi5kb3Qodik7XHJcbiAgICByZXR1cm4gYztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDbGlwIGEgZmFjZSBhZ2FpbnN0IGEgaHVsbC5cclxuICogQG1ldGhvZCBjbGlwRmFjZUFnYWluc3RIdWxsXHJcbiAqIEBwYXJhbSB7VmVjM30gc2VwYXJhdGluZ05vcm1hbFxyXG4gKiBAcGFyYW0ge1ZlYzN9IHBvc0FcclxuICogQHBhcmFtIHtRdWF0ZXJuaW9ufSBxdWF0QVxyXG4gKiBAcGFyYW0ge0FycmF5fSB3b3JsZFZlcnRzQjEgQW4gYXJyYXkgb2YgVmVjMyB3aXRoIHZlcnRpY2VzIGluIHRoZSB3b3JsZCBmcmFtZS5cclxuICogQHBhcmFtIHtOdW1iZXJ9IG1pbkRpc3QgRGlzdGFuY2UgY2xhbXBpbmdcclxuICogQHBhcmFtIHtOdW1iZXJ9IG1heERpc3RcclxuICogQHBhcmFtIEFycmF5IHJlc3VsdCBBcnJheSB0byBzdG9yZSByZXN1bHRpbmcgY29udGFjdCBwb2ludHMgaW4uIFdpbGwgYmUgb2JqZWN0cyB3aXRoIHByb3BlcnRpZXM6IHBvaW50LCBkZXB0aCwgbm9ybWFsLiBUaGVzZSBhcmUgcmVwcmVzZW50ZWQgaW4gd29ybGQgY29vcmRpbmF0ZXMuXHJcbiAqL1xyXG52YXIgY2ZhaF9mYWNlQU5vcm1hbFdTID0gbmV3IFZlYzMoKSxcclxuICAgIGNmYWhfZWRnZTAgPSBuZXcgVmVjMygpLFxyXG4gICAgY2ZhaF9Xb3JsZEVkZ2UwID0gbmV3IFZlYzMoKSxcclxuICAgIGNmYWhfd29ybGRQbGFuZUFub3JtYWwxID0gbmV3IFZlYzMoKSxcclxuICAgIGNmYWhfcGxhbmVOb3JtYWxXUzEgPSBuZXcgVmVjMygpLFxyXG4gICAgY2ZhaF93b3JsZEExID0gbmV3IFZlYzMoKSxcclxuICAgIGNmYWhfbG9jYWxQbGFuZU5vcm1hbCA9IG5ldyBWZWMzKCksXHJcbiAgICBjZmFoX3BsYW5lTm9ybWFsV1MgPSBuZXcgVmVjMygpO1xyXG5Db252ZXhQb2x5aGVkcm9uLnByb3RvdHlwZS5jbGlwRmFjZUFnYWluc3RIdWxsID0gZnVuY3Rpb24oc2VwYXJhdGluZ05vcm1hbCwgcG9zQSwgcXVhdEEsIHdvcmxkVmVydHNCMSwgbWluRGlzdCwgbWF4RGlzdCxyZXN1bHQpe1xyXG4gICAgdmFyIGZhY2VBTm9ybWFsV1MgPSBjZmFoX2ZhY2VBTm9ybWFsV1MsXHJcbiAgICAgICAgZWRnZTAgPSBjZmFoX2VkZ2UwLFxyXG4gICAgICAgIFdvcmxkRWRnZTAgPSBjZmFoX1dvcmxkRWRnZTAsXHJcbiAgICAgICAgd29ybGRQbGFuZUFub3JtYWwxID0gY2ZhaF93b3JsZFBsYW5lQW5vcm1hbDEsXHJcbiAgICAgICAgcGxhbmVOb3JtYWxXUzEgPSBjZmFoX3BsYW5lTm9ybWFsV1MxLFxyXG4gICAgICAgIHdvcmxkQTEgPSBjZmFoX3dvcmxkQTEsXHJcbiAgICAgICAgbG9jYWxQbGFuZU5vcm1hbCA9IGNmYWhfbG9jYWxQbGFuZU5vcm1hbCxcclxuICAgICAgICBwbGFuZU5vcm1hbFdTID0gY2ZhaF9wbGFuZU5vcm1hbFdTO1xyXG5cclxuICAgIHZhciBodWxsQSA9IHRoaXM7XHJcbiAgICB2YXIgd29ybGRWZXJ0c0IyID0gW107XHJcbiAgICB2YXIgcFZ0eEluID0gd29ybGRWZXJ0c0IxO1xyXG4gICAgdmFyIHBWdHhPdXQgPSB3b3JsZFZlcnRzQjI7XHJcbiAgICAvLyBGaW5kIHRoZSBmYWNlIHdpdGggbm9ybWFsIGNsb3Nlc3QgdG8gdGhlIHNlcGFyYXRpbmcgYXhpc1xyXG4gICAgdmFyIGNsb3Nlc3RGYWNlQSA9IC0xO1xyXG4gICAgdmFyIGRtaW4gPSBOdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgZm9yKHZhciBmYWNlPTA7IGZhY2U8aHVsbEEuZmFjZXMubGVuZ3RoOyBmYWNlKyspe1xyXG4gICAgICAgIGZhY2VBTm9ybWFsV1MuY29weShodWxsQS5mYWNlTm9ybWFsc1tmYWNlXSk7XHJcbiAgICAgICAgcXVhdEEudm11bHQoZmFjZUFOb3JtYWxXUyxmYWNlQU5vcm1hbFdTKTtcclxuICAgICAgICAvL3Bvc0EudmFkZChmYWNlQU5vcm1hbFdTLGZhY2VBTm9ybWFsV1MpO1xyXG4gICAgICAgIHZhciBkID0gZmFjZUFOb3JtYWxXUy5kb3Qoc2VwYXJhdGluZ05vcm1hbCk7XHJcbiAgICAgICAgaWYgKGQgPCBkbWluKXtcclxuICAgICAgICAgICAgZG1pbiA9IGQ7XHJcbiAgICAgICAgICAgIGNsb3Nlc3RGYWNlQSA9IGZhY2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGNsb3Nlc3RGYWNlQSA8IDApe1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwiLS0tIGRpZCBub3QgZmluZCBhbnkgY2xvc2VzdCBmYWNlLi4uIC0tLVwiKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICAvL2NvbnNvbGUubG9nKFwiY2xvc2VzdCBBOiBcIixjbG9zZXN0RmFjZUEpO1xyXG4gICAgLy8gR2V0IHRoZSBmYWNlIGFuZCBjb25zdHJ1Y3QgY29ubmVjdGVkIGZhY2VzXHJcbiAgICB2YXIgcG9seUEgPSBodWxsQS5mYWNlc1tjbG9zZXN0RmFjZUFdO1xyXG4gICAgcG9seUEuY29ubmVjdGVkRmFjZXMgPSBbXTtcclxuICAgIGZvcih2YXIgaT0wOyBpPGh1bGxBLmZhY2VzLmxlbmd0aDsgaSsrKXtcclxuICAgICAgICBmb3IodmFyIGo9MDsgajxodWxsQS5mYWNlc1tpXS5sZW5ndGg7IGorKyl7XHJcbiAgICAgICAgICAgIGlmKHBvbHlBLmluZGV4T2YoaHVsbEEuZmFjZXNbaV1bal0pIT09LTEgLyogU2hhcmluZyBhIHZlcnRleCovICYmIGkhPT1jbG9zZXN0RmFjZUEgLyogTm90IHRoZSBvbmUgd2UgYXJlIGxvb2tpbmcgZm9yIGNvbm5lY3Rpb25zIGZyb20gKi8gJiYgcG9seUEuY29ubmVjdGVkRmFjZXMuaW5kZXhPZihpKT09PS0xIC8qIE5vdCBhbHJlYWR5IGFkZGVkICovICl7XHJcbiAgICAgICAgICAgICAgICBwb2x5QS5jb25uZWN0ZWRGYWNlcy5wdXNoKGkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gQ2xpcCB0aGUgcG9seWdvbiB0byB0aGUgYmFjayBvZiB0aGUgcGxhbmVzIG9mIGFsbCBmYWNlcyBvZiBodWxsIEEsIHRoYXQgYXJlIGFkamFjZW50IHRvIHRoZSB3aXRuZXNzIGZhY2VcclxuICAgIHZhciBudW1Db250YWN0cyA9IHBWdHhJbi5sZW5ndGg7XHJcbiAgICB2YXIgbnVtVmVydGljZXNBID0gcG9seUEubGVuZ3RoO1xyXG4gICAgdmFyIHJlcyA9IFtdO1xyXG4gICAgZm9yKHZhciBlMD0wOyBlMDxudW1WZXJ0aWNlc0E7IGUwKyspe1xyXG4gICAgICAgIHZhciBhID0gaHVsbEEudmVydGljZXNbcG9seUFbZTBdXTtcclxuICAgICAgICB2YXIgYiA9IGh1bGxBLnZlcnRpY2VzW3BvbHlBWyhlMCsxKSVudW1WZXJ0aWNlc0FdXTtcclxuICAgICAgICBhLnZzdWIoYixlZGdlMCk7XHJcbiAgICAgICAgV29ybGRFZGdlMC5jb3B5KGVkZ2UwKTtcclxuICAgICAgICBxdWF0QS52bXVsdChXb3JsZEVkZ2UwLFdvcmxkRWRnZTApO1xyXG4gICAgICAgIHBvc0EudmFkZChXb3JsZEVkZ2UwLFdvcmxkRWRnZTApO1xyXG4gICAgICAgIHdvcmxkUGxhbmVBbm9ybWFsMS5jb3B5KHRoaXMuZmFjZU5vcm1hbHNbY2xvc2VzdEZhY2VBXSk7Ly90cmFuc0EuZ2V0QmFzaXMoKSogYnRWZWN0b3IzKHBvbHlBLm1fcGxhbmVbMF0scG9seUEubV9wbGFuZVsxXSxwb2x5QS5tX3BsYW5lWzJdKTtcclxuICAgICAgICBxdWF0QS52bXVsdCh3b3JsZFBsYW5lQW5vcm1hbDEsd29ybGRQbGFuZUFub3JtYWwxKTtcclxuICAgICAgICBwb3NBLnZhZGQod29ybGRQbGFuZUFub3JtYWwxLHdvcmxkUGxhbmVBbm9ybWFsMSk7XHJcbiAgICAgICAgV29ybGRFZGdlMC5jcm9zcyh3b3JsZFBsYW5lQW5vcm1hbDEscGxhbmVOb3JtYWxXUzEpO1xyXG4gICAgICAgIHBsYW5lTm9ybWFsV1MxLm5lZ2F0ZShwbGFuZU5vcm1hbFdTMSk7XHJcbiAgICAgICAgd29ybGRBMS5jb3B5KGEpO1xyXG4gICAgICAgIHF1YXRBLnZtdWx0KHdvcmxkQTEsd29ybGRBMSk7XHJcbiAgICAgICAgcG9zQS52YWRkKHdvcmxkQTEsd29ybGRBMSk7XHJcbiAgICAgICAgdmFyIHBsYW5lRXFXUzEgPSAtd29ybGRBMS5kb3QocGxhbmVOb3JtYWxXUzEpO1xyXG4gICAgICAgIHZhciBwbGFuZUVxV1M7XHJcbiAgICAgICAgaWYodHJ1ZSl7XHJcbiAgICAgICAgICAgIHZhciBvdGhlckZhY2UgPSBwb2x5QS5jb25uZWN0ZWRGYWNlc1tlMF07XHJcbiAgICAgICAgICAgIGxvY2FsUGxhbmVOb3JtYWwuY29weSh0aGlzLmZhY2VOb3JtYWxzW290aGVyRmFjZV0pO1xyXG4gICAgICAgICAgICB2YXIgbG9jYWxQbGFuZUVxID0gdGhpcy5nZXRQbGFuZUNvbnN0YW50T2ZGYWNlKG90aGVyRmFjZSk7XHJcblxyXG4gICAgICAgICAgICBwbGFuZU5vcm1hbFdTLmNvcHkobG9jYWxQbGFuZU5vcm1hbCk7XHJcbiAgICAgICAgICAgIHF1YXRBLnZtdWx0KHBsYW5lTm9ybWFsV1MscGxhbmVOb3JtYWxXUyk7XHJcbiAgICAgICAgICAgIC8vcG9zQS52YWRkKHBsYW5lTm9ybWFsV1MscGxhbmVOb3JtYWxXUyk7XHJcbiAgICAgICAgICAgIHZhciBwbGFuZUVxV1MgPSBsb2NhbFBsYW5lRXEgLSBwbGFuZU5vcm1hbFdTLmRvdChwb3NBKTtcclxuICAgICAgICB9IGVsc2UgIHtcclxuICAgICAgICAgICAgcGxhbmVOb3JtYWxXUy5jb3B5KHBsYW5lTm9ybWFsV1MxKTtcclxuICAgICAgICAgICAgcGxhbmVFcVdTID0gcGxhbmVFcVdTMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENsaXAgZmFjZSBhZ2FpbnN0IG91ciBjb25zdHJ1Y3RlZCBwbGFuZVxyXG4gICAgICAgIHRoaXMuY2xpcEZhY2VBZ2FpbnN0UGxhbmUocFZ0eEluLCBwVnR4T3V0LCBwbGFuZU5vcm1hbFdTLCBwbGFuZUVxV1MpO1xyXG5cclxuICAgICAgICAvLyBUaHJvdyBhd2F5IGFsbCBjbGlwcGVkIHBvaW50cywgYnV0IHNhdmUgdGhlIHJlYW1pbmluZyB1bnRpbCBuZXh0IGNsaXBcclxuICAgICAgICB3aGlsZShwVnR4SW4ubGVuZ3RoKXtcclxuICAgICAgICAgICAgcFZ0eEluLnNoaWZ0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHdoaWxlKHBWdHhPdXQubGVuZ3RoKXtcclxuICAgICAgICAgICAgcFZ0eEluLnB1c2gocFZ0eE91dC5zaGlmdCgpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy9jb25zb2xlLmxvZyhcIlJlc3VsdGluZyBwb2ludHMgYWZ0ZXIgY2xpcDpcIixwVnR4SW4pO1xyXG5cclxuICAgIC8vIG9ubHkga2VlcCBjb250YWN0IHBvaW50cyB0aGF0IGFyZSBiZWhpbmQgdGhlIHdpdG5lc3MgZmFjZVxyXG4gICAgbG9jYWxQbGFuZU5vcm1hbC5jb3B5KHRoaXMuZmFjZU5vcm1hbHNbY2xvc2VzdEZhY2VBXSk7XHJcblxyXG4gICAgdmFyIGxvY2FsUGxhbmVFcSA9IHRoaXMuZ2V0UGxhbmVDb25zdGFudE9mRmFjZShjbG9zZXN0RmFjZUEpO1xyXG4gICAgcGxhbmVOb3JtYWxXUy5jb3B5KGxvY2FsUGxhbmVOb3JtYWwpO1xyXG4gICAgcXVhdEEudm11bHQocGxhbmVOb3JtYWxXUyxwbGFuZU5vcm1hbFdTKTtcclxuXHJcbiAgICB2YXIgcGxhbmVFcVdTID0gbG9jYWxQbGFuZUVxIC0gcGxhbmVOb3JtYWxXUy5kb3QocG9zQSk7XHJcbiAgICBmb3IgKHZhciBpPTA7IGk8cFZ0eEluLmxlbmd0aDsgaSsrKXtcclxuICAgICAgICB2YXIgZGVwdGggPSBwbGFuZU5vcm1hbFdTLmRvdChwVnR4SW5baV0pICsgcGxhbmVFcVdTOyAvLz8/P1xyXG4gICAgICAgIC8qY29uc29sZS5sb2coXCJkZXB0aCBjYWxjIGZyb20gbm9ybWFsPVwiLHBsYW5lTm9ybWFsV1MudG9TdHJpbmcoKSxcIiBhbmQgY29uc3RhbnQgXCIrcGxhbmVFcVdTK1wiIGFuZCB2ZXJ0ZXggXCIscFZ0eEluW2ldLnRvU3RyaW5nKCksXCIgZ2l2ZXMgXCIrZGVwdGgpOyovXHJcbiAgICAgICAgaWYgKGRlcHRoIDw9bWluRGlzdCl7XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiY2xhbXBlZDogZGVwdGg9XCIrZGVwdGgrXCIgdG8gbWluRGlzdD1cIisobWluRGlzdCtcIlwiKSk7XHJcbiAgICAgICAgICAgIGRlcHRoID0gbWluRGlzdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChkZXB0aCA8PW1heERpc3Qpe1xyXG4gICAgICAgICAgICB2YXIgcG9pbnQgPSBwVnR4SW5baV07XHJcbiAgICAgICAgICAgIGlmKGRlcHRoPD0wKXtcclxuICAgICAgICAgICAgICAgIC8qY29uc29sZS5sb2coXCJHb3QgY29udGFjdCBwb2ludCBcIixwb2ludC50b1N0cmluZygpLFxyXG4gICAgICAgICAgICAgICAgICBcIiwgZGVwdGg9XCIsZGVwdGgsXHJcbiAgICAgICAgICAgICAgICAgIFwiY29udGFjdCBub3JtYWw9XCIsc2VwYXJhdGluZ05vcm1hbC50b1N0cmluZygpLFxyXG4gICAgICAgICAgICAgICAgICBcInBsYW5lXCIscGxhbmVOb3JtYWxXUy50b1N0cmluZygpLFxyXG4gICAgICAgICAgICAgICAgICBcInBsYW5lQ29uc3RhbnRcIixwbGFuZUVxV1MpOyovXHJcbiAgICAgICAgICAgICAgICB2YXIgcCA9IHtcclxuICAgICAgICAgICAgICAgICAgICBwb2ludDpwb2ludCxcclxuICAgICAgICAgICAgICAgICAgICBub3JtYWw6cGxhbmVOb3JtYWxXUyxcclxuICAgICAgICAgICAgICAgICAgICBkZXB0aDogZGVwdGgsXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gocCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogQ2xpcCBhIGZhY2UgaW4gYSBodWxsIGFnYWluc3QgdGhlIGJhY2sgb2YgYSBwbGFuZS5cclxuICogQG1ldGhvZCBjbGlwRmFjZUFnYWluc3RQbGFuZVxyXG4gKiBAcGFyYW0ge0FycmF5fSBpblZlcnRpY2VzXHJcbiAqIEBwYXJhbSB7QXJyYXl9IG91dFZlcnRpY2VzXHJcbiAqIEBwYXJhbSB7VmVjM30gcGxhbmVOb3JtYWxcclxuICogQHBhcmFtIHtOdW1iZXJ9IHBsYW5lQ29uc3RhbnQgVGhlIGNvbnN0YW50IGluIHRoZSBtYXRoZW1hdGljYWwgcGxhbmUgZXF1YXRpb25cclxuICovXHJcbkNvbnZleFBvbHloZWRyb24ucHJvdG90eXBlLmNsaXBGYWNlQWdhaW5zdFBsYW5lID0gZnVuY3Rpb24oaW5WZXJ0aWNlcyxvdXRWZXJ0aWNlcywgcGxhbmVOb3JtYWwsIHBsYW5lQ29uc3RhbnQpe1xyXG4gICAgdmFyIG5fZG90X2ZpcnN0LCBuX2RvdF9sYXN0O1xyXG4gICAgdmFyIG51bVZlcnRzID0gaW5WZXJ0aWNlcy5sZW5ndGg7XHJcblxyXG4gICAgaWYobnVtVmVydHMgPCAyKXtcclxuICAgICAgICByZXR1cm4gb3V0VmVydGljZXM7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGZpcnN0VmVydGV4ID0gaW5WZXJ0aWNlc1tpblZlcnRpY2VzLmxlbmd0aC0xXSxcclxuICAgICAgICBsYXN0VmVydGV4ID0gICBpblZlcnRpY2VzWzBdO1xyXG5cclxuICAgIG5fZG90X2ZpcnN0ID0gcGxhbmVOb3JtYWwuZG90KGZpcnN0VmVydGV4KSArIHBsYW5lQ29uc3RhbnQ7XHJcblxyXG4gICAgZm9yKHZhciB2aSA9IDA7IHZpIDwgbnVtVmVydHM7IHZpKyspe1xyXG4gICAgICAgIGxhc3RWZXJ0ZXggPSBpblZlcnRpY2VzW3ZpXTtcclxuICAgICAgICBuX2RvdF9sYXN0ID0gcGxhbmVOb3JtYWwuZG90KGxhc3RWZXJ0ZXgpICsgcGxhbmVDb25zdGFudDtcclxuICAgICAgICBpZihuX2RvdF9maXJzdCA8IDApe1xyXG4gICAgICAgICAgICBpZihuX2RvdF9sYXN0IDwgMCl7XHJcbiAgICAgICAgICAgICAgICAvLyBTdGFydCA8IDAsIGVuZCA8IDAsIHNvIG91dHB1dCBsYXN0VmVydGV4XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV3diA9IG5ldyBWZWMzKCk7XHJcbiAgICAgICAgICAgICAgICBuZXd2LmNvcHkobGFzdFZlcnRleCk7XHJcbiAgICAgICAgICAgICAgICBvdXRWZXJ0aWNlcy5wdXNoKG5ld3YpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gU3RhcnQgPCAwLCBlbmQgPj0gMCwgc28gb3V0cHV0IGludGVyc2VjdGlvblxyXG4gICAgICAgICAgICAgICAgdmFyIG5ld3YgPSBuZXcgVmVjMygpO1xyXG4gICAgICAgICAgICAgICAgZmlyc3RWZXJ0ZXgubGVycChsYXN0VmVydGV4LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuX2RvdF9maXJzdCAvIChuX2RvdF9maXJzdCAtIG5fZG90X2xhc3QpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXd2KTtcclxuICAgICAgICAgICAgICAgIG91dFZlcnRpY2VzLnB1c2gobmV3dik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZihuX2RvdF9sYXN0PDApe1xyXG4gICAgICAgICAgICAgICAgLy8gU3RhcnQgPj0gMCwgZW5kIDwgMCBzbyBvdXRwdXQgaW50ZXJzZWN0aW9uIGFuZCBlbmRcclxuICAgICAgICAgICAgICAgIHZhciBuZXd2ID0gbmV3IFZlYzMoKTtcclxuICAgICAgICAgICAgICAgIGZpcnN0VmVydGV4LmxlcnAobGFzdFZlcnRleCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbl9kb3RfZmlyc3QgLyAobl9kb3RfZmlyc3QgLSBuX2RvdF9sYXN0KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3dik7XHJcbiAgICAgICAgICAgICAgICBvdXRWZXJ0aWNlcy5wdXNoKG5ld3YpO1xyXG4gICAgICAgICAgICAgICAgb3V0VmVydGljZXMucHVzaChsYXN0VmVydGV4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBmaXJzdFZlcnRleCA9IGxhc3RWZXJ0ZXg7XHJcbiAgICAgICAgbl9kb3RfZmlyc3QgPSBuX2RvdF9sYXN0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG91dFZlcnRpY2VzO1xyXG59O1xyXG5cclxuLy8gVXBkYXRlcyAud29ybGRWZXJ0aWNlcyBhbmQgc2V0cyAud29ybGRWZXJ0aWNlc05lZWRzVXBkYXRlIHRvIGZhbHNlLlxyXG5Db252ZXhQb2x5aGVkcm9uLnByb3RvdHlwZS5jb21wdXRlV29ybGRWZXJ0aWNlcyA9IGZ1bmN0aW9uKHBvc2l0aW9uLHF1YXQpe1xyXG4gICAgdmFyIE4gPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDtcclxuICAgIHdoaWxlKHRoaXMud29ybGRWZXJ0aWNlcy5sZW5ndGggPCBOKXtcclxuICAgICAgICB0aGlzLndvcmxkVmVydGljZXMucHVzaCggbmV3IFZlYzMoKSApO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciB2ZXJ0cyA9IHRoaXMudmVydGljZXMsXHJcbiAgICAgICAgd29ybGRWZXJ0cyA9IHRoaXMud29ybGRWZXJ0aWNlcztcclxuICAgIGZvcih2YXIgaT0wOyBpIT09TjsgaSsrKXtcclxuICAgICAgICBxdWF0LnZtdWx0KCB2ZXJ0c1tpXSAsIHdvcmxkVmVydHNbaV0gKTtcclxuICAgICAgICBwb3NpdGlvbi52YWRkKCB3b3JsZFZlcnRzW2ldICwgd29ybGRWZXJ0c1tpXSApO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMud29ybGRWZXJ0aWNlc05lZWRzVXBkYXRlID0gZmFsc2U7XHJcbn07XHJcblxyXG52YXIgY29tcHV0ZUxvY2FsQUFCQl93b3JsZFZlcnQgPSBuZXcgVmVjMygpO1xyXG5Db252ZXhQb2x5aGVkcm9uLnByb3RvdHlwZS5jb21wdXRlTG9jYWxBQUJCID0gZnVuY3Rpb24oYWFiYm1pbixhYWJibWF4KXtcclxuICAgIHZhciBuID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGgsXHJcbiAgICAgICAgdmVydGljZXMgPSB0aGlzLnZlcnRpY2VzLFxyXG4gICAgICAgIHdvcmxkVmVydCA9IGNvbXB1dGVMb2NhbEFBQkJfd29ybGRWZXJ0O1xyXG5cclxuICAgIGFhYmJtaW4uc2V0KE51bWJlci5NQVhfVkFMVUUsIE51bWJlci5NQVhfVkFMVUUsIE51bWJlci5NQVhfVkFMVUUpO1xyXG4gICAgYWFiYm1heC5zZXQoLU51bWJlci5NQVhfVkFMVUUsIC1OdW1iZXIuTUFYX1ZBTFVFLCAtTnVtYmVyLk1BWF9WQUxVRSk7XHJcblxyXG4gICAgZm9yKHZhciBpPTA7IGk8bjsgaSsrKXtcclxuICAgICAgICB2YXIgdiA9IHZlcnRpY2VzW2ldO1xyXG4gICAgICAgIGlmICAgICAodi54IDwgYWFiYm1pbi54KXtcclxuICAgICAgICAgICAgYWFiYm1pbi54ID0gdi54O1xyXG4gICAgICAgIH0gZWxzZSBpZih2LnggPiBhYWJibWF4Lngpe1xyXG4gICAgICAgICAgICBhYWJibWF4LnggPSB2Lng7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICAgICAodi55IDwgYWFiYm1pbi55KXtcclxuICAgICAgICAgICAgYWFiYm1pbi55ID0gdi55O1xyXG4gICAgICAgIH0gZWxzZSBpZih2LnkgPiBhYWJibWF4Lnkpe1xyXG4gICAgICAgICAgICBhYWJibWF4LnkgPSB2Lnk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICAgICAodi56IDwgYWFiYm1pbi56KXtcclxuICAgICAgICAgICAgYWFiYm1pbi56ID0gdi56O1xyXG4gICAgICAgIH0gZWxzZSBpZih2LnogPiBhYWJibWF4Lnope1xyXG4gICAgICAgICAgICBhYWJibWF4LnogPSB2Lno7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFVwZGF0ZXMgLndvcmxkVmVydGljZXMgYW5kIHNldHMgLndvcmxkVmVydGljZXNOZWVkc1VwZGF0ZSB0byBmYWxzZS5cclxuICogQG1ldGhvZCBjb21wdXRlV29ybGRGYWNlTm9ybWFsc1xyXG4gKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSBxdWF0XHJcbiAqL1xyXG5Db252ZXhQb2x5aGVkcm9uLnByb3RvdHlwZS5jb21wdXRlV29ybGRGYWNlTm9ybWFscyA9IGZ1bmN0aW9uKHF1YXQpe1xyXG4gICAgdmFyIE4gPSB0aGlzLmZhY2VOb3JtYWxzLmxlbmd0aDtcclxuICAgIHdoaWxlKHRoaXMud29ybGRGYWNlTm9ybWFscy5sZW5ndGggPCBOKXtcclxuICAgICAgICB0aGlzLndvcmxkRmFjZU5vcm1hbHMucHVzaCggbmV3IFZlYzMoKSApO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBub3JtYWxzID0gdGhpcy5mYWNlTm9ybWFscyxcclxuICAgICAgICB3b3JsZE5vcm1hbHMgPSB0aGlzLndvcmxkRmFjZU5vcm1hbHM7XHJcbiAgICBmb3IodmFyIGk9MDsgaSE9PU47IGkrKyl7XHJcbiAgICAgICAgcXVhdC52bXVsdCggbm9ybWFsc1tpXSAsIHdvcmxkTm9ybWFsc1tpXSApO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMud29ybGRGYWNlTm9ybWFsc05lZWRzVXBkYXRlID0gZmFsc2U7XHJcbn07XHJcblxyXG4vKipcclxuICogQG1ldGhvZCB1cGRhdGVCb3VuZGluZ1NwaGVyZVJhZGl1c1xyXG4gKi9cclxuQ29udmV4UG9seWhlZHJvbi5wcm90b3R5cGUudXBkYXRlQm91bmRpbmdTcGhlcmVSYWRpdXMgPSBmdW5jdGlvbigpe1xyXG4gICAgLy8gQXNzdW1lIHBvaW50cyBhcmUgZGlzdHJpYnV0ZWQgd2l0aCBsb2NhbCAoMCwwLDApIGFzIGNlbnRlclxyXG4gICAgdmFyIG1heDIgPSAwO1xyXG4gICAgdmFyIHZlcnRzID0gdGhpcy52ZXJ0aWNlcztcclxuICAgIGZvcih2YXIgaT0wLCBOPXZlcnRzLmxlbmd0aDsgaSE9PU47IGkrKykge1xyXG4gICAgICAgIHZhciBub3JtMiA9IHZlcnRzW2ldLm5vcm0yKCk7XHJcbiAgICAgICAgaWYobm9ybTIgPiBtYXgyKXtcclxuICAgICAgICAgICAgbWF4MiA9IG5vcm0yO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHRoaXMuYm91bmRpbmdTcGhlcmVSYWRpdXMgPSBNYXRoLnNxcnQobWF4Mik7XHJcbn07XHJcblxyXG52YXIgdGVtcFdvcmxkVmVydGV4ID0gbmV3IFZlYzMoKTtcclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kIGNhbGN1bGF0ZVdvcmxkQUFCQlxyXG4gKiBAcGFyYW0ge1ZlYzN9ICAgICAgICBwb3NcclxuICogQHBhcmFtIHtRdWF0ZXJuaW9ufSAgcXVhdFxyXG4gKiBAcGFyYW0ge1ZlYzN9ICAgICAgICBtaW5cclxuICogQHBhcmFtIHtWZWMzfSAgICAgICAgbWF4XHJcbiAqL1xyXG5Db252ZXhQb2x5aGVkcm9uLnByb3RvdHlwZS5jYWxjdWxhdGVXb3JsZEFBQkIgPSBmdW5jdGlvbihwb3MscXVhdCxtaW4sbWF4KXtcclxuICAgIHZhciBuID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGgsIHZlcnRzID0gdGhpcy52ZXJ0aWNlcztcclxuICAgIHZhciBtaW54LG1pbnksbWlueixtYXh4LG1heHksbWF4ejtcclxuICAgIGZvcih2YXIgaT0wOyBpPG47IGkrKyl7XHJcbiAgICAgICAgdGVtcFdvcmxkVmVydGV4LmNvcHkodmVydHNbaV0pO1xyXG4gICAgICAgIHF1YXQudm11bHQodGVtcFdvcmxkVmVydGV4LHRlbXBXb3JsZFZlcnRleCk7XHJcbiAgICAgICAgcG9zLnZhZGQodGVtcFdvcmxkVmVydGV4LHRlbXBXb3JsZFZlcnRleCk7XHJcbiAgICAgICAgdmFyIHYgPSB0ZW1wV29ybGRWZXJ0ZXg7XHJcbiAgICAgICAgaWYgICAgICh2LnggPCBtaW54IHx8IG1pbng9PT11bmRlZmluZWQpe1xyXG4gICAgICAgICAgICBtaW54ID0gdi54O1xyXG4gICAgICAgIH0gXHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYodi54ID4gbWF4eCB8fCBtYXh4PT09dW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgbWF4eCA9IHYueDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICAgICAodi55IDwgbWlueSB8fCBtaW55PT09dW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgbWlueSA9IHYueTtcclxuICAgICAgICB9IFxyXG4gICAgICAgIFxyXG4gICAgICAgIGlmKHYueSA+IG1heHkgfHwgbWF4eT09PXVuZGVmaW5lZCl7XHJcbiAgICAgICAgICAgIG1heHkgPSB2Lnk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAgICAgKHYueiA8IG1pbnogfHwgbWluej09PXVuZGVmaW5lZCl7XHJcbiAgICAgICAgICAgIG1pbnogPSB2Lno7XHJcbiAgICAgICAgfSAgXHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYodi56ID4gbWF4eiB8fCBtYXh6PT09dW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgbWF4eiA9IHYuejtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBtaW4uc2V0KG1pbngsbWlueSxtaW56KTtcclxuICAgIG1heC5zZXQobWF4eCxtYXh5LG1heHopO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldCBhcHByb3hpbWF0ZSBjb252ZXggdm9sdW1lXHJcbiAqIEBtZXRob2Qgdm9sdW1lXHJcbiAqIEByZXR1cm4ge051bWJlcn1cclxuICovXHJcbkNvbnZleFBvbHloZWRyb24ucHJvdG90eXBlLnZvbHVtZSA9IGZ1bmN0aW9uKCl7XHJcbiAgICByZXR1cm4gNC4wICogTWF0aC5QSSAqIHRoaXMuYm91bmRpbmdTcGhlcmVSYWRpdXMgLyAzLjA7XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0IGFuIGF2ZXJhZ2Ugb2YgYWxsIHRoZSB2ZXJ0aWNlcyBwb3NpdGlvbnNcclxuICogQG1ldGhvZCBnZXRBdmVyYWdlUG9pbnRMb2NhbFxyXG4gKiBAcGFyYW0gIHtWZWMzfSB0YXJnZXRcclxuICogQHJldHVybiB7VmVjM31cclxuICovXHJcbkNvbnZleFBvbHloZWRyb24ucHJvdG90eXBlLmdldEF2ZXJhZ2VQb2ludExvY2FsID0gZnVuY3Rpb24odGFyZ2V0KXtcclxuICAgIHRhcmdldCA9IHRhcmdldCB8fCBuZXcgVmVjMygpO1xyXG4gICAgdmFyIG4gPSB0aGlzLnZlcnRpY2VzLmxlbmd0aCxcclxuICAgICAgICB2ZXJ0cyA9IHRoaXMudmVydGljZXM7XHJcbiAgICBmb3IodmFyIGk9MDsgaTxuOyBpKyspe1xyXG4gICAgICAgIHRhcmdldC52YWRkKHZlcnRzW2ldLHRhcmdldCk7XHJcbiAgICB9XHJcbiAgICB0YXJnZXQubXVsdCgxL24sdGFyZ2V0KTtcclxuICAgIHJldHVybiB0YXJnZXQ7XHJcbn07XHJcblxyXG4vKipcclxuICogVHJhbnNmb3JtIGFsbCBsb2NhbCBwb2ludHMuIFdpbGwgY2hhbmdlIHRoZSAudmVydGljZXNcclxuICogQG1ldGhvZCB0cmFuc2Zvcm1BbGxQb2ludHNcclxuICogQHBhcmFtICB7VmVjM30gb2Zmc2V0XHJcbiAqIEBwYXJhbSAge1F1YXRlcm5pb259IHF1YXRcclxuICovXHJcbkNvbnZleFBvbHloZWRyb24ucHJvdG90eXBlLnRyYW5zZm9ybUFsbFBvaW50cyA9IGZ1bmN0aW9uKG9mZnNldCxxdWF0KXtcclxuICAgIHZhciBuID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGgsXHJcbiAgICAgICAgdmVydHMgPSB0aGlzLnZlcnRpY2VzO1xyXG5cclxuICAgIC8vIEFwcGx5IHJvdGF0aW9uXHJcbiAgICBpZihxdWF0KXtcclxuICAgICAgICAvLyBSb3RhdGUgdmVydGljZXNcclxuICAgICAgICBmb3IodmFyIGk9MDsgaTxuOyBpKyspe1xyXG4gICAgICAgICAgICB2YXIgdiA9IHZlcnRzW2ldO1xyXG4gICAgICAgICAgICBxdWF0LnZtdWx0KHYsdik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFJvdGF0ZSBmYWNlIG5vcm1hbHNcclxuICAgICAgICBmb3IodmFyIGk9MDsgaTx0aGlzLmZhY2VOb3JtYWxzLmxlbmd0aDsgaSsrKXtcclxuICAgICAgICAgICAgdmFyIHYgPSB0aGlzLmZhY2VOb3JtYWxzW2ldO1xyXG4gICAgICAgICAgICBxdWF0LnZtdWx0KHYsdik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgLy8gUm90YXRlIGVkZ2VzXHJcbiAgICAgICAgZm9yKHZhciBpPTA7IGk8dGhpcy51bmlxdWVFZGdlcy5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgICAgIHZhciB2ID0gdGhpcy51bmlxdWVFZGdlc1tpXTtcclxuICAgICAgICAgICAgcXVhdC52bXVsdCh2LHYpO1xyXG4gICAgICAgIH0qL1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEFwcGx5IG9mZnNldFxyXG4gICAgaWYob2Zmc2V0KXtcclxuICAgICAgICBmb3IodmFyIGk9MDsgaTxuOyBpKyspe1xyXG4gICAgICAgICAgICB2YXIgdiA9IHZlcnRzW2ldO1xyXG4gICAgICAgICAgICB2LnZhZGQob2Zmc2V0LHYpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBDaGVja3Mgd2hldGhlciBwIGlzIGluc2lkZSB0aGUgcG9seWhlZHJhLiBNdXN0IGJlIGluIGxvY2FsIGNvb3Jkcy4gVGhlIHBvaW50IGxpZXMgb3V0c2lkZSBvZiB0aGUgY29udmV4IGh1bGwgb2YgdGhlIG90aGVyIHBvaW50cyBpZiBhbmQgb25seSBpZiB0aGUgZGlyZWN0aW9uIG9mIGFsbCB0aGUgdmVjdG9ycyBmcm9tIGl0IHRvIHRob3NlIG90aGVyIHBvaW50cyBhcmUgb24gbGVzcyB0aGFuIG9uZSBoYWxmIG9mIGEgc3BoZXJlIGFyb3VuZCBpdC5cclxuICogQG1ldGhvZCBwb2ludElzSW5zaWRlXHJcbiAqIEBwYXJhbSAge1ZlYzN9IHAgICAgICBBIHBvaW50IGdpdmVuIGluIGxvY2FsIGNvb3JkaW5hdGVzXHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAqL1xyXG52YXIgQ29udmV4UG9seWhlZHJvbl9wb2ludElzSW5zaWRlID0gbmV3IFZlYzMoKTtcclxudmFyIENvbnZleFBvbHloZWRyb25fdlRvUCA9IG5ldyBWZWMzKCk7XHJcbnZhciBDb252ZXhQb2x5aGVkcm9uX3ZUb1BvaW50SW5zaWRlID0gbmV3IFZlYzMoKTtcclxuQ29udmV4UG9seWhlZHJvbi5wcm90b3R5cGUucG9pbnRJc0luc2lkZSA9IGZ1bmN0aW9uKHApe1xyXG4gICAgdmFyIG4gPSB0aGlzLnZlcnRpY2VzLmxlbmd0aCxcclxuICAgICAgICB2ZXJ0cyA9IHRoaXMudmVydGljZXMsXHJcbiAgICAgICAgZmFjZXMgPSB0aGlzLmZhY2VzLFxyXG4gICAgICAgIG5vcm1hbHMgPSB0aGlzLmZhY2VOb3JtYWxzO1xyXG4gICAgdmFyIHBvc2l0aXZlUmVzdWx0ID0gbnVsbDtcclxuICAgIHZhciBOID0gdGhpcy5mYWNlcy5sZW5ndGg7XHJcbiAgICB2YXIgcG9pbnRJbnNpZGUgPSBDb252ZXhQb2x5aGVkcm9uX3BvaW50SXNJbnNpZGU7XHJcbiAgICB0aGlzLmdldEF2ZXJhZ2VQb2ludExvY2FsKHBvaW50SW5zaWRlKTtcclxuICAgIGZvcih2YXIgaT0wOyBpPE47IGkrKyl7XHJcbiAgICAgICAgdmFyIG51bVZlcnRpY2VzID0gdGhpcy5mYWNlc1tpXS5sZW5ndGg7XHJcbiAgICAgICAgdmFyIG4gPSBub3JtYWxzW2ldO1xyXG4gICAgICAgIHZhciB2ID0gdmVydHNbZmFjZXNbaV1bMF1dOyAvLyBXZSBvbmx5IG5lZWQgb25lIHBvaW50IGluIHRoZSBmYWNlXHJcblxyXG4gICAgICAgIC8vIFRoaXMgZG90IHByb2R1Y3QgZGV0ZXJtaW5lcyB3aGljaCBzaWRlIG9mIHRoZSBlZGdlIHRoZSBwb2ludCBpc1xyXG4gICAgICAgIHZhciB2VG9QID0gQ29udmV4UG9seWhlZHJvbl92VG9QO1xyXG4gICAgICAgIHAudnN1Yih2LHZUb1ApO1xyXG4gICAgICAgIHZhciByMSA9IG4uZG90KHZUb1ApO1xyXG5cclxuICAgICAgICB2YXIgdlRvUG9pbnRJbnNpZGUgPSBDb252ZXhQb2x5aGVkcm9uX3ZUb1BvaW50SW5zaWRlO1xyXG4gICAgICAgIHBvaW50SW5zaWRlLnZzdWIodix2VG9Qb2ludEluc2lkZSk7XHJcbiAgICAgICAgdmFyIHIyID0gbi5kb3QodlRvUG9pbnRJbnNpZGUpO1xyXG5cclxuICAgICAgICBpZigocjE8MCAmJiByMj4wKSB8fCAocjE+MCAmJiByMjwwKSl7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gRW5jb3VudGVyZWQgc29tZSBvdGhlciBzaWduLiBFeGl0LlxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIElmIHdlIGdvdCBoZXJlLCBhbGwgZG90IHByb2R1Y3RzIHdlcmUgb2YgdGhlIHNhbWUgc2lnbi5cclxuICAgIHJldHVybiBwb3NpdGl2ZVJlc3VsdCA/IDEgOiAtMTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXQgbWF4IGFuZCBtaW4gZG90IHByb2R1Y3Qgb2YgYSBjb252ZXggaHVsbCBhdCBwb3NpdGlvbiAocG9zLHF1YXQpIHByb2plY3RlZCBvbnRvIGFuIGF4aXMuIFJlc3VsdHMgYXJlIHNhdmVkIGluIHRoZSBhcnJheSBtYXhtaW4uXHJcbiAqIEBzdGF0aWNcclxuICogQG1ldGhvZCBwcm9qZWN0XHJcbiAqIEBwYXJhbSB7Q29udmV4UG9seWhlZHJvbn0gaHVsbFxyXG4gKiBAcGFyYW0ge1ZlYzN9IGF4aXNcclxuICogQHBhcmFtIHtWZWMzfSBwb3NcclxuICogQHBhcmFtIHtRdWF0ZXJuaW9ufSBxdWF0XHJcbiAqIEBwYXJhbSB7YXJyYXl9IHJlc3VsdCByZXN1bHRbMF0gYW5kIHJlc3VsdFsxXSB3aWxsIGJlIHNldCB0byBtYXhpbXVtIGFuZCBtaW5pbXVtLCByZXNwZWN0aXZlbHkuXHJcbiAqL1xyXG52YXIgcHJvamVjdF93b3JsZFZlcnRleCA9IG5ldyBWZWMzKCk7XHJcbnZhciBwcm9qZWN0X2xvY2FsQXhpcyA9IG5ldyBWZWMzKCk7XHJcbnZhciBwcm9qZWN0X2xvY2FsT3JpZ2luID0gbmV3IFZlYzMoKTtcclxuQ29udmV4UG9seWhlZHJvbi5wcm9qZWN0ID0gZnVuY3Rpb24oaHVsbCwgYXhpcywgcG9zLCBxdWF0LCByZXN1bHQpe1xyXG4gICAgdmFyIG4gPSBodWxsLnZlcnRpY2VzLmxlbmd0aCxcclxuICAgICAgICB3b3JsZFZlcnRleCA9IHByb2plY3Rfd29ybGRWZXJ0ZXgsXHJcbiAgICAgICAgbG9jYWxBeGlzID0gcHJvamVjdF9sb2NhbEF4aXMsXHJcbiAgICAgICAgbWF4ID0gMCxcclxuICAgICAgICBtaW4gPSAwLFxyXG4gICAgICAgIGxvY2FsT3JpZ2luID0gcHJvamVjdF9sb2NhbE9yaWdpbixcclxuICAgICAgICB2cyA9IGh1bGwudmVydGljZXM7XHJcblxyXG4gICAgbG9jYWxPcmlnaW4uc2V0WmVybygpO1xyXG5cclxuICAgIC8vIFRyYW5zZm9ybSB0aGUgYXhpcyB0byBsb2NhbFxyXG4gICAgVHJhbnNmb3JtLnZlY3RvclRvTG9jYWxGcmFtZShwb3MsIHF1YXQsIGF4aXMsIGxvY2FsQXhpcyk7XHJcbiAgICBUcmFuc2Zvcm0ucG9pbnRUb0xvY2FsRnJhbWUocG9zLCBxdWF0LCBsb2NhbE9yaWdpbiwgbG9jYWxPcmlnaW4pO1xyXG4gICAgdmFyIGFkZCA9IGxvY2FsT3JpZ2luLmRvdChsb2NhbEF4aXMpO1xyXG5cclxuICAgIG1pbiA9IG1heCA9IHZzWzBdLmRvdChsb2NhbEF4aXMpO1xyXG5cclxuICAgIGZvcih2YXIgaSA9IDE7IGkgPCBuOyBpKyspe1xyXG4gICAgICAgIHZhciB2YWwgPSB2c1tpXS5kb3QobG9jYWxBeGlzKTtcclxuXHJcbiAgICAgICAgaWYodmFsID4gbWF4KXtcclxuICAgICAgICAgICAgbWF4ID0gdmFsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYodmFsIDwgbWluKXtcclxuICAgICAgICAgICAgbWluID0gdmFsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBtaW4gLT0gYWRkO1xyXG4gICAgbWF4IC09IGFkZDtcclxuXHJcbiAgICBpZihtaW4gPiBtYXgpe1xyXG4gICAgICAgIC8vIEluY29uc2lzdGVudCAtIHN3YXBcclxuICAgICAgICB2YXIgdGVtcCA9IG1pbjtcclxuICAgICAgICBtaW4gPSBtYXg7XHJcbiAgICAgICAgbWF4ID0gdGVtcDtcclxuICAgIH1cclxuICAgIC8vIE91dHB1dFxyXG4gICAgcmVzdWx0WzBdID0gbWF4O1xyXG4gICAgcmVzdWx0WzFdID0gbWluO1xyXG59O1xyXG5cclxufSx7XCIuLi9tYXRoL1F1YXRlcm5pb25cIjoyOSxcIi4uL21hdGgvVHJhbnNmb3JtXCI6MzAsXCIuLi9tYXRoL1ZlYzNcIjozMSxcIi4vU2hhcGVcIjo0NH1dLDQwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcclxubW9kdWxlLmV4cG9ydHMgPSBDeWxpbmRlcjtcclxuXHJcbnZhciBTaGFwZSA9IF9kZXJlcV8oJy4vU2hhcGUnKTtcclxudmFyIFZlYzMgPSBfZGVyZXFfKCcuLi9tYXRoL1ZlYzMnKTtcclxudmFyIFF1YXRlcm5pb24gPSBfZGVyZXFfKCcuLi9tYXRoL1F1YXRlcm5pb24nKTtcclxudmFyIENvbnZleFBvbHloZWRyb24gPSBfZGVyZXFfKCcuL0NvbnZleFBvbHloZWRyb24nKTtcclxuXHJcbi8qKlxyXG4gKiBAY2xhc3MgQ3lsaW5kZXJcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBleHRlbmRzIENvbnZleFBvbHloZWRyb25cclxuICogQGF1dGhvciBzY2h0ZXBwZSAvIGh0dHBzOi8vZ2l0aHViLmNvbS9zY2h0ZXBwZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzVG9wXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNCb3R0b21cclxuICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodFxyXG4gKiBAcGFyYW0ge051bWJlcn0gbnVtU2VnbWVudHMgVGhlIG51bWJlciBvZiBzZWdtZW50cyB0byBidWlsZCB0aGUgY3lsaW5kZXIgb3V0IG9mXHJcbiAqL1xyXG5mdW5jdGlvbiBDeWxpbmRlciggcmFkaXVzVG9wLCByYWRpdXNCb3R0b20sIGhlaWdodCAsIG51bVNlZ21lbnRzICkge1xyXG4gICAgdmFyIE4gPSBudW1TZWdtZW50cyxcclxuICAgICAgICB2ZXJ0cyA9IFtdLFxyXG4gICAgICAgIGF4ZXMgPSBbXSxcclxuICAgICAgICBmYWNlcyA9IFtdLFxyXG4gICAgICAgIGJvdHRvbWZhY2UgPSBbXSxcclxuICAgICAgICB0b3BmYWNlID0gW10sXHJcbiAgICAgICAgY29zID0gTWF0aC5jb3MsXHJcbiAgICAgICAgc2luID0gTWF0aC5zaW47XHJcblxyXG4gICAgLy8gRmlyc3QgYm90dG9tIHBvaW50XHJcbiAgICB2ZXJ0cy5wdXNoKG5ldyBWZWMzKHJhZGl1c0JvdHRvbSpjb3MoMCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYWRpdXNCb3R0b20qc2luKDApLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLWhlaWdodCowLjUpKTtcclxuICAgIGJvdHRvbWZhY2UucHVzaCgwKTtcclxuXHJcbiAgICAvLyBGaXJzdCB0b3AgcG9pbnRcclxuICAgIHZlcnRzLnB1c2gobmV3IFZlYzMocmFkaXVzVG9wKmNvcygwKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhZGl1c1RvcCpzaW4oMCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQqMC41KSk7XHJcbiAgICB0b3BmYWNlLnB1c2goMSk7XHJcblxyXG4gICAgZm9yKHZhciBpPTA7IGk8TjsgaSsrKXtcclxuICAgICAgICB2YXIgdGhldGEgPSAyKk1hdGguUEkvTiAqIChpKzEpO1xyXG4gICAgICAgIHZhciB0aGV0YU4gPSAyKk1hdGguUEkvTiAqIChpKzAuNSk7XHJcbiAgICAgICAgaWYoaTxOLTEpe1xyXG4gICAgICAgICAgICAvLyBCb3R0b21cclxuICAgICAgICAgICAgdmVydHMucHVzaChuZXcgVmVjMyhyYWRpdXNCb3R0b20qY29zKHRoZXRhKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFkaXVzQm90dG9tKnNpbih0aGV0YSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC1oZWlnaHQqMC41KSk7XHJcbiAgICAgICAgICAgIGJvdHRvbWZhY2UucHVzaCgyKmkrMik7XHJcbiAgICAgICAgICAgIC8vIFRvcFxyXG4gICAgICAgICAgICB2ZXJ0cy5wdXNoKG5ldyBWZWMzKHJhZGl1c1RvcCpjb3ModGhldGEpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYWRpdXNUb3Aqc2luKHRoZXRhKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0KjAuNSkpO1xyXG4gICAgICAgICAgICB0b3BmYWNlLnB1c2goMippKzMpO1xyXG5cclxuICAgICAgICAgICAgLy8gRmFjZVxyXG4gICAgICAgICAgICBmYWNlcy5wdXNoKFsyKmkrMiwgMippKzMsIDIqaSsxLDIqaV0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGZhY2VzLnB1c2goWzAsMSwgMippKzEsIDIqaV0pOyAvLyBDb25uZWN0XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBBeGlzOiB3ZSBjYW4gY3V0IG9mZiBoYWxmIG9mIHRoZW0gaWYgd2UgaGF2ZSBldmVuIG51bWJlciBvZiBzZWdtZW50c1xyXG4gICAgICAgIGlmKE4gJSAyID09PSAxIHx8IGkgPCBOIC8gMil7XHJcbiAgICAgICAgICAgIGF4ZXMucHVzaChuZXcgVmVjMyhjb3ModGhldGFOKSwgc2luKHRoZXRhTiksIDApKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmYWNlcy5wdXNoKHRvcGZhY2UpO1xyXG4gICAgYXhlcy5wdXNoKG5ldyBWZWMzKDAsMCwxKSk7XHJcblxyXG4gICAgLy8gUmVvcmRlciBib3R0b20gZmFjZVxyXG4gICAgdmFyIHRlbXAgPSBbXTtcclxuICAgIGZvcih2YXIgaT0wOyBpPGJvdHRvbWZhY2UubGVuZ3RoOyBpKyspe1xyXG4gICAgICAgIHRlbXAucHVzaChib3R0b21mYWNlW2JvdHRvbWZhY2UubGVuZ3RoIC0gaSAtIDFdKTtcclxuICAgIH1cclxuICAgIGZhY2VzLnB1c2godGVtcCk7XHJcblxyXG4gICAgQ29udmV4UG9seWhlZHJvbi5jYWxsKCB0aGlzLCB2ZXJ0cywgZmFjZXMsIGF4ZXMgKTtcclxufVxyXG5cclxuQ3lsaW5kZXIucHJvdG90eXBlID0gbmV3IENvbnZleFBvbHloZWRyb24oKTtcclxuXHJcbn0se1wiLi4vbWF0aC9RdWF0ZXJuaW9uXCI6MjksXCIuLi9tYXRoL1ZlYzNcIjozMSxcIi4vQ29udmV4UG9seWhlZHJvblwiOjM5LFwiLi9TaGFwZVwiOjQ0fV0sNDE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xyXG52YXIgU2hhcGUgPSBfZGVyZXFfKCcuL1NoYXBlJyk7XHJcbnZhciBDb252ZXhQb2x5aGVkcm9uID0gX2RlcmVxXygnLi9Db252ZXhQb2x5aGVkcm9uJyk7XHJcbnZhciBWZWMzID0gX2RlcmVxXygnLi4vbWF0aC9WZWMzJyk7XHJcbnZhciBVdGlscyA9IF9kZXJlcV8oJy4uL3V0aWxzL1V0aWxzJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEhlaWdodGZpZWxkO1xyXG5cclxuLyoqXHJcbiAqIEhlaWdodGZpZWxkIHNoYXBlIGNsYXNzLiBIZWlnaHQgZGF0YSBpcyBnaXZlbiBhcyBhbiBhcnJheS4gVGhlc2UgZGF0YSBwb2ludHMgYXJlIHNwcmVhZCBvdXQgZXZlbmx5IHdpdGggYSBnaXZlbiBkaXN0YW5jZS5cclxuICogQGNsYXNzIEhlaWdodGZpZWxkXHJcbiAqIEBleHRlbmRzIFNoYXBlXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge0FycmF5fSBkYXRhIEFuIGFycmF5IG9mIFkgdmFsdWVzIHRoYXQgd2lsbCBiZSB1c2VkIHRvIGNvbnN0cnVjdCB0aGUgdGVycmFpbi5cclxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1pblZhbHVlXSBNaW5pbXVtIHZhbHVlIG9mIHRoZSBkYXRhIHBvaW50cyBpbiB0aGUgZGF0YSBhcnJheS4gV2lsbCBiZSBjb21wdXRlZCBhdXRvbWF0aWNhbGx5IGlmIG5vdCBnaXZlbi5cclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heFZhbHVlXSBNYXhpbXVtIHZhbHVlLlxyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZWxlbWVudFNpemU9MC4xXSBXb3JsZCBzcGFjaW5nIGJldHdlZW4gdGhlIGRhdGEgcG9pbnRzIGluIFggZGlyZWN0aW9uLlxyXG4gKiBAdG9kbyBTaG91bGQgYmUgcG9zc2libGUgdG8gdXNlIGFsb25nIGFsbCBheGVzLCBub3QganVzdCB5XHJcbiAqIEB0b2RvIHNob3VsZCBiZSBwb3NzaWJsZSB0byBzY2FsZSBhbG9uZyBhbGwgYXhlc1xyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiAgICAgLy8gR2VuZXJhdGUgc29tZSBoZWlnaHQgZGF0YSAoeS12YWx1ZXMpLlxyXG4gKiAgICAgdmFyIGRhdGEgPSBbXTtcclxuICogICAgIGZvcih2YXIgaSA9IDA7IGkgPCAxMDAwOyBpKyspe1xyXG4gKiAgICAgICAgIHZhciB5ID0gMC41ICogTWF0aC5jb3MoMC4yICogaSk7XHJcbiAqICAgICAgICAgZGF0YS5wdXNoKHkpO1xyXG4gKiAgICAgfVxyXG4gKlxyXG4gKiAgICAgLy8gQ3JlYXRlIHRoZSBoZWlnaHRmaWVsZCBzaGFwZVxyXG4gKiAgICAgdmFyIGhlaWdodGZpZWxkU2hhcGUgPSBuZXcgSGVpZ2h0ZmllbGQoZGF0YSwge1xyXG4gKiAgICAgICAgIGVsZW1lbnRTaXplOiAxIC8vIERpc3RhbmNlIGJldHdlZW4gdGhlIGRhdGEgcG9pbnRzIGluIFggYW5kIFkgZGlyZWN0aW9uc1xyXG4gKiAgICAgfSk7XHJcbiAqICAgICB2YXIgaGVpZ2h0ZmllbGRCb2R5ID0gbmV3IEJvZHkoKTtcclxuICogICAgIGhlaWdodGZpZWxkQm9keS5hZGRTaGFwZShoZWlnaHRmaWVsZFNoYXBlKTtcclxuICogICAgIHdvcmxkLmFkZEJvZHkoaGVpZ2h0ZmllbGRCb2R5KTtcclxuICovXHJcbmZ1bmN0aW9uIEhlaWdodGZpZWxkKGRhdGEsIG9wdGlvbnMpe1xyXG4gICAgb3B0aW9ucyA9IFV0aWxzLmRlZmF1bHRzKG9wdGlvbnMsIHtcclxuICAgICAgICBtYXhWYWx1ZSA6IG51bGwsXHJcbiAgICAgICAgbWluVmFsdWUgOiBudWxsLFxyXG4gICAgICAgIGVsZW1lbnRTaXplIDogMVxyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBhcnJheSBvZiBudW1iZXJzLCBvciBoZWlnaHQgdmFsdWVzLCB0aGF0IGFyZSBzcHJlYWQgb3V0IGFsb25nIHRoZSB4IGF4aXMuXHJcbiAgICAgKiBAcHJvcGVydHkge2FycmF5fSBkYXRhXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZGF0YSA9IGRhdGE7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXggdmFsdWUgb2YgdGhlIGRhdGFcclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtYXhWYWx1ZVxyXG4gICAgICovXHJcbiAgICB0aGlzLm1heFZhbHVlID0gb3B0aW9ucy5tYXhWYWx1ZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1heCB2YWx1ZSBvZiB0aGUgZGF0YVxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG1pblZhbHVlXHJcbiAgICAgKi9cclxuICAgIHRoaXMubWluVmFsdWUgPSBvcHRpb25zLm1pblZhbHVlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHdpZHRoIG9mIGVhY2ggZWxlbWVudFxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGVsZW1lbnRTaXplXHJcbiAgICAgKiBAdG9kbyBlbGVtZW50U2l6ZVggYW5kIFlcclxuICAgICAqL1xyXG4gICAgdGhpcy5lbGVtZW50U2l6ZSA9IG9wdGlvbnMuZWxlbWVudFNpemU7XHJcblxyXG4gICAgaWYob3B0aW9ucy5taW5WYWx1ZSA9PT0gbnVsbCl7XHJcbiAgICAgICAgdGhpcy51cGRhdGVNaW5WYWx1ZSgpO1xyXG4gICAgfVxyXG4gICAgaWYob3B0aW9ucy5tYXhWYWx1ZSA9PT0gbnVsbCl7XHJcbiAgICAgICAgdGhpcy51cGRhdGVNYXhWYWx1ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuY2FjaGVFbmFibGVkID0gdHJ1ZTtcclxuXHJcbiAgICBTaGFwZS5jYWxsKHRoaXMsIHtcclxuICAgICAgICB0eXBlOiBTaGFwZS50eXBlcy5IRUlHSFRGSUVMRFxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5waWxsYXJDb252ZXggPSBuZXcgQ29udmV4UG9seWhlZHJvbigpO1xyXG4gICAgdGhpcy5waWxsYXJPZmZzZXQgPSBuZXcgVmVjMygpO1xyXG5cclxuICAgIHRoaXMudXBkYXRlQm91bmRpbmdTcGhlcmVSYWRpdXMoKTtcclxuXHJcbiAgICAvLyBcImlfal9pc1VwcGVyXCIgPT4geyBjb252ZXg6IC4uLiwgb2Zmc2V0OiAuLi4gfVxyXG4gICAgLy8gZm9yIGV4YW1wbGU6XHJcbiAgICAvLyBfY2FjaGVkUGlsbGFyc1tcIjBfMl8xXCJdXHJcbiAgICB0aGlzLl9jYWNoZWRQaWxsYXJzID0ge307XHJcbn1cclxuSGVpZ2h0ZmllbGQucHJvdG90eXBlID0gbmV3IFNoYXBlKCk7XHJcblxyXG4vKipcclxuICogQ2FsbCB3aGVuZXZlciB5b3UgY2hhbmdlIHRoZSBkYXRhIGFycmF5LlxyXG4gKiBAbWV0aG9kIHVwZGF0ZVxyXG4gKi9cclxuSGVpZ2h0ZmllbGQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCl7XHJcbiAgICB0aGlzLl9jYWNoZWRQaWxsYXJzID0ge307XHJcbn07XHJcblxyXG4vKipcclxuICogVXBkYXRlIHRoZSAubWluVmFsdWUgcHJvcGVydHlcclxuICogQG1ldGhvZCB1cGRhdGVNaW5WYWx1ZVxyXG4gKi9cclxuSGVpZ2h0ZmllbGQucHJvdG90eXBlLnVwZGF0ZU1pblZhbHVlID0gZnVuY3Rpb24oKXtcclxuICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xyXG4gICAgdmFyIG1pblZhbHVlID0gZGF0YVswXVswXTtcclxuICAgIGZvcih2YXIgaT0wOyBpICE9PSBkYXRhLmxlbmd0aDsgaSsrKXtcclxuICAgICAgICBmb3IodmFyIGo9MDsgaiAhPT0gZGF0YVtpXS5sZW5ndGg7IGorKyl7XHJcbiAgICAgICAgICAgIHZhciB2ID0gZGF0YVtpXVtqXTtcclxuICAgICAgICAgICAgaWYodiA8IG1pblZhbHVlKXtcclxuICAgICAgICAgICAgICAgIG1pblZhbHVlID0gdjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHRoaXMubWluVmFsdWUgPSBtaW5WYWx1ZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBVcGRhdGUgdGhlIC5tYXhWYWx1ZSBwcm9wZXJ0eVxyXG4gKiBAbWV0aG9kIHVwZGF0ZU1heFZhbHVlXHJcbiAqL1xyXG5IZWlnaHRmaWVsZC5wcm90b3R5cGUudXBkYXRlTWF4VmFsdWUgPSBmdW5jdGlvbigpe1xyXG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XHJcbiAgICB2YXIgbWF4VmFsdWUgPSBkYXRhWzBdWzBdO1xyXG4gICAgZm9yKHZhciBpPTA7IGkgIT09IGRhdGEubGVuZ3RoOyBpKyspe1xyXG4gICAgICAgIGZvcih2YXIgaj0wOyBqICE9PSBkYXRhW2ldLmxlbmd0aDsgaisrKXtcclxuICAgICAgICAgICAgdmFyIHYgPSBkYXRhW2ldW2pdO1xyXG4gICAgICAgICAgICBpZih2ID4gbWF4VmFsdWUpe1xyXG4gICAgICAgICAgICAgICAgbWF4VmFsdWUgPSB2O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdGhpcy5tYXhWYWx1ZSA9IG1heFZhbHVlO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFNldCB0aGUgaGVpZ2h0IHZhbHVlIGF0IGFuIGluZGV4LiBEb24ndCBmb3JnZXQgdG8gdXBkYXRlIG1heFZhbHVlIGFuZCBtaW5WYWx1ZSBhZnRlciB5b3UncmUgZG9uZS5cclxuICogQG1ldGhvZCBzZXRIZWlnaHRWYWx1ZUF0SW5kZXhcclxuICogQHBhcmFtIHtpbnRlZ2VyfSB4aVxyXG4gKiBAcGFyYW0ge2ludGVnZXJ9IHlpXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxyXG4gKi9cclxuSGVpZ2h0ZmllbGQucHJvdG90eXBlLnNldEhlaWdodFZhbHVlQXRJbmRleCA9IGZ1bmN0aW9uKHhpLCB5aSwgdmFsdWUpe1xyXG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XHJcbiAgICBkYXRhW3hpXVt5aV0gPSB2YWx1ZTtcclxuXHJcbiAgICAvLyBJbnZhbGlkYXRlIGNhY2hlXHJcbiAgICB0aGlzLmNsZWFyQ2FjaGVkQ29udmV4VHJpYW5nbGVQaWxsYXIoeGksIHlpLCBmYWxzZSk7XHJcbiAgICBpZih4aSA+IDApe1xyXG4gICAgICAgIHRoaXMuY2xlYXJDYWNoZWRDb252ZXhUcmlhbmdsZVBpbGxhcih4aSAtIDEsIHlpLCB0cnVlKTtcclxuICAgICAgICB0aGlzLmNsZWFyQ2FjaGVkQ29udmV4VHJpYW5nbGVQaWxsYXIoeGkgLSAxLCB5aSwgZmFsc2UpO1xyXG4gICAgfVxyXG4gICAgaWYoeWkgPiAwKXtcclxuICAgICAgICB0aGlzLmNsZWFyQ2FjaGVkQ29udmV4VHJpYW5nbGVQaWxsYXIoeGksIHlpIC0gMSwgdHJ1ZSk7XHJcbiAgICAgICAgdGhpcy5jbGVhckNhY2hlZENvbnZleFRyaWFuZ2xlUGlsbGFyKHhpLCB5aSAtIDEsIGZhbHNlKTtcclxuICAgIH1cclxuICAgIGlmKHlpID4gMCAmJiB4aSA+IDApe1xyXG4gICAgICAgIHRoaXMuY2xlYXJDYWNoZWRDb252ZXhUcmlhbmdsZVBpbGxhcih4aSAtIDEsIHlpIC0gMSwgdHJ1ZSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0IG1heC9taW4gaW4gYSByZWN0YW5nbGUgaW4gdGhlIG1hdHJpeCBkYXRhXHJcbiAqIEBtZXRob2QgZ2V0UmVjdE1pbk1heFxyXG4gKiBAcGFyYW0gIHtpbnRlZ2VyfSBpTWluWFxyXG4gKiBAcGFyYW0gIHtpbnRlZ2VyfSBpTWluWVxyXG4gKiBAcGFyYW0gIHtpbnRlZ2VyfSBpTWF4WFxyXG4gKiBAcGFyYW0gIHtpbnRlZ2VyfSBpTWF4WVxyXG4gKiBAcGFyYW0gIHthcnJheX0gW3Jlc3VsdF0gQW4gYXJyYXkgdG8gc3RvcmUgdGhlIHJlc3VsdHMgaW4uXHJcbiAqIEByZXR1cm4ge2FycmF5fSBUaGUgcmVzdWx0IGFycmF5LCBpZiBpdCB3YXMgcGFzc2VkIGluLiBNaW5pbXVtIHdpbGwgYmUgYXQgcG9zaXRpb24gMCBhbmQgbWF4IGF0IDEuXHJcbiAqL1xyXG5IZWlnaHRmaWVsZC5wcm90b3R5cGUuZ2V0UmVjdE1pbk1heCA9IGZ1bmN0aW9uIChpTWluWCwgaU1pblksIGlNYXhYLCBpTWF4WSwgcmVzdWx0KSB7XHJcbiAgICByZXN1bHQgPSByZXN1bHQgfHwgW107XHJcblxyXG4gICAgLy8gR2V0IG1heCBhbmQgbWluIG9mIHRoZSBkYXRhXHJcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YSxcclxuICAgICAgICBtYXggPSB0aGlzLm1pblZhbHVlOyAvLyBTZXQgZmlyc3QgdmFsdWVcclxuICAgIGZvcih2YXIgaSA9IGlNaW5YOyBpIDw9IGlNYXhYOyBpKyspe1xyXG4gICAgICAgIGZvcih2YXIgaiA9IGlNaW5ZOyBqIDw9IGlNYXhZOyBqKyspe1xyXG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gZGF0YVtpXVtqXTtcclxuICAgICAgICAgICAgaWYoaGVpZ2h0ID4gbWF4KXtcclxuICAgICAgICAgICAgICAgIG1heCA9IGhlaWdodDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXN1bHRbMF0gPSB0aGlzLm1pblZhbHVlO1xyXG4gICAgcmVzdWx0WzFdID0gbWF4O1xyXG59O1xyXG5cclxuXHJcblxyXG4vKipcclxuICogR2V0IHRoZSBpbmRleCBvZiBhIGxvY2FsIHBvc2l0aW9uIG9uIHRoZSBoZWlnaHRmaWVsZC4gVGhlIGluZGV4ZXMgaW5kaWNhdGUgdGhlIHJlY3RhbmdsZXMsIHNvIGlmIHlvdXIgdGVycmFpbiBpcyBtYWRlIG9mIE4geCBOIGhlaWdodCBkYXRhIHBvaW50cywgeW91IHdpbGwgaGF2ZSByZWN0YW5nbGUgaW5kZXhlcyByYW5naW5nIGZyb20gMCB0byBOLTEuXHJcbiAqIEBtZXRob2QgZ2V0SW5kZXhPZlBvc2l0aW9uXHJcbiAqIEBwYXJhbSAge251bWJlcn0geFxyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHlcclxuICogQHBhcmFtICB7YXJyYXl9IHJlc3VsdCBUd28tZWxlbWVudCBhcnJheVxyXG4gKiBAcGFyYW0gIHtib29sZWFufSBjbGFtcCBJZiB0aGUgcG9zaXRpb24gc2hvdWxkIGJlIGNsYW1wZWQgdG8gdGhlIGhlaWdodGZpZWxkIGVkZ2UuXHJcbiAqIEByZXR1cm4ge2Jvb2xlYW59XHJcbiAqL1xyXG5IZWlnaHRmaWVsZC5wcm90b3R5cGUuZ2V0SW5kZXhPZlBvc2l0aW9uID0gZnVuY3Rpb24gKHgsIHksIHJlc3VsdCwgY2xhbXApIHtcclxuXHJcbiAgICAvLyBHZXQgdGhlIGluZGV4IG9mIHRoZSBkYXRhIHBvaW50cyB0byB0ZXN0IGFnYWluc3RcclxuICAgIHZhciB3ID0gdGhpcy5lbGVtZW50U2l6ZTtcclxuICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xyXG4gICAgdmFyIHhpID0gTWF0aC5mbG9vcih4IC8gdyk7XHJcbiAgICB2YXIgeWkgPSBNYXRoLmZsb29yKHkgLyB3KTtcclxuXHJcbiAgICByZXN1bHRbMF0gPSB4aTtcclxuICAgIHJlc3VsdFsxXSA9IHlpO1xyXG5cclxuICAgIGlmKGNsYW1wKXtcclxuICAgICAgICAvLyBDbGFtcCBpbmRleCB0byBlZGdlc1xyXG4gICAgICAgIGlmKHhpIDwgMCl7IHhpID0gMDsgfVxyXG4gICAgICAgIGlmKHlpIDwgMCl7IHlpID0gMDsgfVxyXG4gICAgICAgIGlmKHhpID49IGRhdGEubGVuZ3RoIC0gMSl7IHhpID0gZGF0YS5sZW5ndGggLSAxOyB9XHJcbiAgICAgICAgaWYoeWkgPj0gZGF0YVswXS5sZW5ndGggLSAxKXsgeWkgPSBkYXRhWzBdLmxlbmd0aCAtIDE7IH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBCYWlsIG91dCBpZiB3ZSBhcmUgb3V0IG9mIHRoZSB0ZXJyYWluXHJcbiAgICBpZih4aSA8IDAgfHwgeWkgPCAwIHx8IHhpID49IGRhdGEubGVuZ3RoLTEgfHwgeWkgPj0gZGF0YVswXS5sZW5ndGgtMSl7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0cnVlO1xyXG59O1xyXG5cclxuXHJcbnZhciBnZXRIZWlnaHRBdF9pZHggPSBbXTtcclxudmFyIGdldEhlaWdodEF0X3dlaWdodHMgPSBuZXcgVmVjMygpO1xyXG52YXIgZ2V0SGVpZ2h0QXRfYSA9IG5ldyBWZWMzKCk7XHJcbnZhciBnZXRIZWlnaHRBdF9iID0gbmV3IFZlYzMoKTtcclxudmFyIGdldEhlaWdodEF0X2MgPSBuZXcgVmVjMygpO1xyXG5cclxuSGVpZ2h0ZmllbGQucHJvdG90eXBlLmdldFRyaWFuZ2xlQXQgPSBmdW5jdGlvbih4LCB5LCBlZGdlQ2xhbXAsIGEsIGIsIGMpe1xyXG4gICAgdmFyIGlkeCA9IGdldEhlaWdodEF0X2lkeDtcclxuICAgIHRoaXMuZ2V0SW5kZXhPZlBvc2l0aW9uKHgsIHksIGlkeCwgZWRnZUNsYW1wKTtcclxuICAgIHZhciB4aSA9IGlkeFswXTtcclxuICAgIHZhciB5aSA9IGlkeFsxXTtcclxuXHJcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcclxuICAgIGlmKGVkZ2VDbGFtcCl7XHJcbiAgICAgICAgeGkgPSBNYXRoLm1pbihkYXRhLmxlbmd0aCAtIDIsIE1hdGgubWF4KDAsIHhpKSk7XHJcbiAgICAgICAgeWkgPSBNYXRoLm1pbihkYXRhWzBdLmxlbmd0aCAtIDIsIE1hdGgubWF4KDAsIHlpKSk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGVsZW1lbnRTaXplID0gdGhpcy5lbGVtZW50U2l6ZTtcclxuICAgIHZhciBsb3dlckRpc3QyID0gTWF0aC5wb3coeCAvIGVsZW1lbnRTaXplIC0geGksIDIpICsgTWF0aC5wb3coeSAvIGVsZW1lbnRTaXplIC0geWksIDIpO1xyXG4gICAgdmFyIHVwcGVyRGlzdDIgPSBNYXRoLnBvdyh4IC8gZWxlbWVudFNpemUgLSAoeGkgKyAxKSwgMikgKyBNYXRoLnBvdyh5IC8gZWxlbWVudFNpemUgLSAoeWkgKyAxKSwgMik7XHJcbiAgICB2YXIgdXBwZXIgPSBsb3dlckRpc3QyID4gdXBwZXJEaXN0MjtcclxuICAgIHRoaXMuZ2V0VHJpYW5nbGUoeGksIHlpLCB1cHBlciwgYSwgYiwgYyk7XHJcbiAgICByZXR1cm4gdXBwZXI7XHJcbn07XHJcblxyXG52YXIgZ2V0Tm9ybWFsQXRfYSA9IG5ldyBWZWMzKCk7XHJcbnZhciBnZXROb3JtYWxBdF9iID0gbmV3IFZlYzMoKTtcclxudmFyIGdldE5vcm1hbEF0X2MgPSBuZXcgVmVjMygpO1xyXG52YXIgZ2V0Tm9ybWFsQXRfZTAgPSBuZXcgVmVjMygpO1xyXG52YXIgZ2V0Tm9ybWFsQXRfZTEgPSBuZXcgVmVjMygpO1xyXG5IZWlnaHRmaWVsZC5wcm90b3R5cGUuZ2V0Tm9ybWFsQXQgPSBmdW5jdGlvbih4LCB5LCBlZGdlQ2xhbXAsIHJlc3VsdCl7XHJcbiAgICB2YXIgYSA9IGdldE5vcm1hbEF0X2E7XHJcbiAgICB2YXIgYiA9IGdldE5vcm1hbEF0X2I7XHJcbiAgICB2YXIgYyA9IGdldE5vcm1hbEF0X2M7XHJcbiAgICB2YXIgZTAgPSBnZXROb3JtYWxBdF9lMDtcclxuICAgIHZhciBlMSA9IGdldE5vcm1hbEF0X2UxO1xyXG4gICAgdGhpcy5nZXRUcmlhbmdsZUF0KHgsIHksIGVkZ2VDbGFtcCwgYSwgYiwgYyk7XHJcbiAgICBiLnZzdWIoYSwgZTApO1xyXG4gICAgYy52c3ViKGEsIGUxKTtcclxuICAgIGUwLmNyb3NzKGUxLCByZXN1bHQpO1xyXG4gICAgcmVzdWx0Lm5vcm1hbGl6ZSgpO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBHZXQgYW4gQUFCQiBvZiBhIHNxdWFyZSBpbiB0aGUgaGVpZ2h0ZmllbGRcclxuICogQHBhcmFtICB7bnVtYmVyfSB4aVxyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHlpXHJcbiAqIEBwYXJhbSAge0FBQkJ9IHJlc3VsdFxyXG4gKi9cclxuSGVpZ2h0ZmllbGQucHJvdG90eXBlLmdldEFhYmJBdEluZGV4ID0gZnVuY3Rpb24oeGksIHlpLCByZXN1bHQpe1xyXG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XHJcbiAgICB2YXIgZWxlbWVudFNpemUgPSB0aGlzLmVsZW1lbnRTaXplO1xyXG5cclxuICAgIHJlc3VsdC5sb3dlckJvdW5kLnNldChcclxuICAgICAgICB4aSAqIGVsZW1lbnRTaXplLFxyXG4gICAgICAgIHlpICogZWxlbWVudFNpemUsXHJcbiAgICAgICAgZGF0YVt4aV1beWldXHJcbiAgICApO1xyXG4gICAgcmVzdWx0LnVwcGVyQm91bmQuc2V0KFxyXG4gICAgICAgICh4aSArIDEpICogZWxlbWVudFNpemUsXHJcbiAgICAgICAgKHlpICsgMSkgKiBlbGVtZW50U2l6ZSxcclxuICAgICAgICBkYXRhW3hpICsgMV1beWkgKyAxXVxyXG4gICAgKTtcclxufTtcclxuXHJcblxyXG4vKipcclxuICogR2V0IHRoZSBoZWlnaHQgaW4gdGhlIGhlaWdodGZpZWxkIGF0IGEgZ2l2ZW4gcG9zaXRpb25cclxuICogQHBhcmFtICB7bnVtYmVyfSB4XHJcbiAqIEBwYXJhbSAge251bWJlcn0geVxyXG4gKiBAcGFyYW0gIHtib29sZWFufSBlZGdlQ2xhbXBcclxuICogQHJldHVybiB7bnVtYmVyfVxyXG4gKi9cclxuSGVpZ2h0ZmllbGQucHJvdG90eXBlLmdldEhlaWdodEF0ID0gZnVuY3Rpb24oeCwgeSwgZWRnZUNsYW1wKXtcclxuICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xyXG4gICAgdmFyIGEgPSBnZXRIZWlnaHRBdF9hO1xyXG4gICAgdmFyIGIgPSBnZXRIZWlnaHRBdF9iO1xyXG4gICAgdmFyIGMgPSBnZXRIZWlnaHRBdF9jO1xyXG4gICAgdmFyIGlkeCA9IGdldEhlaWdodEF0X2lkeDtcclxuXHJcbiAgICB0aGlzLmdldEluZGV4T2ZQb3NpdGlvbih4LCB5LCBpZHgsIGVkZ2VDbGFtcCk7XHJcbiAgICB2YXIgeGkgPSBpZHhbMF07XHJcbiAgICB2YXIgeWkgPSBpZHhbMV07XHJcbiAgICBpZihlZGdlQ2xhbXApe1xyXG4gICAgICAgIHhpID0gTWF0aC5taW4oZGF0YS5sZW5ndGggLSAyLCBNYXRoLm1heCgwLCB4aSkpO1xyXG4gICAgICAgIHlpID0gTWF0aC5taW4oZGF0YVswXS5sZW5ndGggLSAyLCBNYXRoLm1heCgwLCB5aSkpO1xyXG4gICAgfVxyXG4gICAgdmFyIHVwcGVyID0gdGhpcy5nZXRUcmlhbmdsZUF0KHgsIHksIGVkZ2VDbGFtcCwgYSwgYiwgYyk7XHJcbiAgICBiYXJ5Y2VudHJpY1dlaWdodHMoeCwgeSwgYS54LCBhLnksIGIueCwgYi55LCBjLngsIGMueSwgZ2V0SGVpZ2h0QXRfd2VpZ2h0cyk7XHJcblxyXG4gICAgdmFyIHcgPSBnZXRIZWlnaHRBdF93ZWlnaHRzO1xyXG5cclxuICAgIGlmKHVwcGVyKXtcclxuXHJcbiAgICAgICAgLy8gVG9wIHRyaWFuZ2xlIHZlcnRzXHJcbiAgICAgICAgcmV0dXJuIGRhdGFbeGkgKyAxXVt5aSArIDFdICogdy54ICsgZGF0YVt4aV1beWkgKyAxXSAqIHcueSArIGRhdGFbeGkgKyAxXVt5aV0gKiB3Lno7XHJcblxyXG4gICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgLy8gVG9wIHRyaWFuZ2xlIHZlcnRzXHJcbiAgICAgICAgcmV0dXJuIGRhdGFbeGldW3lpXSAqIHcueCArIGRhdGFbeGkgKyAxXVt5aV0gKiB3LnkgKyBkYXRhW3hpXVt5aSArIDFdICogdy56O1xyXG4gICAgfVxyXG59O1xyXG5cclxuLy8gZnJvbSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYXJ5Y2VudHJpY19jb29yZGluYXRlX3N5c3RlbVxyXG5mdW5jdGlvbiBiYXJ5Y2VudHJpY1dlaWdodHMoeCwgeSwgYXgsIGF5LCBieCwgYnksIGN4LCBjeSwgcmVzdWx0KXtcclxuICAgIHJlc3VsdC54ID0gKChieSAtIGN5KSAqICh4IC0gY3gpICsgKGN4IC0gYngpICogKHkgLSBjeSkpIC8gKChieSAtIGN5KSAqIChheCAtIGN4KSArIChjeCAtIGJ4KSAqIChheSAtIGN5KSk7XHJcbiAgICByZXN1bHQueSA9ICgoY3kgLSBheSkgKiAoeCAtIGN4KSArIChheCAtIGN4KSAqICh5IC0gY3kpKSAvICgoYnkgLSBjeSkgKiAoYXggLSBjeCkgKyAoY3ggLSBieCkgKiAoYXkgLSBjeSkpO1xyXG4gICAgcmVzdWx0LnogPSAxIC0gcmVzdWx0LnggLSByZXN1bHQueTtcclxufVxyXG5cclxuSGVpZ2h0ZmllbGQucHJvdG90eXBlLmdldENhY2hlQ29udmV4VHJpYW5nbGVQaWxsYXJLZXkgPSBmdW5jdGlvbih4aSwgeWksIGdldFVwcGVyVHJpYW5nbGUpe1xyXG4gICAgcmV0dXJuIHhpICsgJ18nICsgeWkgKyAnXycgKyAoZ2V0VXBwZXJUcmlhbmdsZSA/IDEgOiAwKTtcclxufTtcclxuXHJcbkhlaWdodGZpZWxkLnByb3RvdHlwZS5nZXRDYWNoZWRDb252ZXhUcmlhbmdsZVBpbGxhciA9IGZ1bmN0aW9uKHhpLCB5aSwgZ2V0VXBwZXJUcmlhbmdsZSl7XHJcbiAgICByZXR1cm4gdGhpcy5fY2FjaGVkUGlsbGFyc1t0aGlzLmdldENhY2hlQ29udmV4VHJpYW5nbGVQaWxsYXJLZXkoeGksIHlpLCBnZXRVcHBlclRyaWFuZ2xlKV07XHJcbn07XHJcblxyXG5IZWlnaHRmaWVsZC5wcm90b3R5cGUuc2V0Q2FjaGVkQ29udmV4VHJpYW5nbGVQaWxsYXIgPSBmdW5jdGlvbih4aSwgeWksIGdldFVwcGVyVHJpYW5nbGUsIGNvbnZleCwgb2Zmc2V0KXtcclxuICAgIHRoaXMuX2NhY2hlZFBpbGxhcnNbdGhpcy5nZXRDYWNoZUNvbnZleFRyaWFuZ2xlUGlsbGFyS2V5KHhpLCB5aSwgZ2V0VXBwZXJUcmlhbmdsZSldID0ge1xyXG4gICAgICAgIGNvbnZleDogY29udmV4LFxyXG4gICAgICAgIG9mZnNldDogb2Zmc2V0XHJcbiAgICB9O1xyXG59O1xyXG5cclxuSGVpZ2h0ZmllbGQucHJvdG90eXBlLmNsZWFyQ2FjaGVkQ29udmV4VHJpYW5nbGVQaWxsYXIgPSBmdW5jdGlvbih4aSwgeWksIGdldFVwcGVyVHJpYW5nbGUpe1xyXG4gICAgZGVsZXRlIHRoaXMuX2NhY2hlZFBpbGxhcnNbdGhpcy5nZXRDYWNoZUNvbnZleFRyaWFuZ2xlUGlsbGFyS2V5KHhpLCB5aSwgZ2V0VXBwZXJUcmlhbmdsZSldO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldCBhIHRyaWFuZ2xlIGZyb20gdGhlIGhlaWdodGZpZWxkXHJcbiAqIEBwYXJhbSAge251bWJlcn0geGlcclxuICogQHBhcmFtICB7bnVtYmVyfSB5aVxyXG4gKiBAcGFyYW0gIHtib29sZWFufSB1cHBlclxyXG4gKiBAcGFyYW0gIHtWZWMzfSBhXHJcbiAqIEBwYXJhbSAge1ZlYzN9IGJcclxuICogQHBhcmFtICB7VmVjM30gY1xyXG4gKi9cclxuSGVpZ2h0ZmllbGQucHJvdG90eXBlLmdldFRyaWFuZ2xlID0gZnVuY3Rpb24oeGksIHlpLCB1cHBlciwgYSwgYiwgYyl7XHJcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcclxuICAgIHZhciBlbGVtZW50U2l6ZSA9IHRoaXMuZWxlbWVudFNpemU7XHJcblxyXG4gICAgaWYodXBwZXIpe1xyXG5cclxuICAgICAgICAvLyBUb3AgdHJpYW5nbGUgdmVydHNcclxuICAgICAgICBhLnNldChcclxuICAgICAgICAgICAgKHhpICsgMSkgKiBlbGVtZW50U2l6ZSxcclxuICAgICAgICAgICAgKHlpICsgMSkgKiBlbGVtZW50U2l6ZSxcclxuICAgICAgICAgICAgZGF0YVt4aSArIDFdW3lpICsgMV1cclxuICAgICAgICApO1xyXG4gICAgICAgIGIuc2V0KFxyXG4gICAgICAgICAgICB4aSAqIGVsZW1lbnRTaXplLFxyXG4gICAgICAgICAgICAoeWkgKyAxKSAqIGVsZW1lbnRTaXplLFxyXG4gICAgICAgICAgICBkYXRhW3hpXVt5aSArIDFdXHJcbiAgICAgICAgKTtcclxuICAgICAgICBjLnNldChcclxuICAgICAgICAgICAgKHhpICsgMSkgKiBlbGVtZW50U2l6ZSxcclxuICAgICAgICAgICAgeWkgKiBlbGVtZW50U2l6ZSxcclxuICAgICAgICAgICAgZGF0YVt4aSArIDFdW3lpXVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgLy8gVG9wIHRyaWFuZ2xlIHZlcnRzXHJcbiAgICAgICAgYS5zZXQoXHJcbiAgICAgICAgICAgIHhpICogZWxlbWVudFNpemUsXHJcbiAgICAgICAgICAgIHlpICogZWxlbWVudFNpemUsXHJcbiAgICAgICAgICAgIGRhdGFbeGldW3lpXVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgYi5zZXQoXHJcbiAgICAgICAgICAgICh4aSArIDEpICogZWxlbWVudFNpemUsXHJcbiAgICAgICAgICAgIHlpICogZWxlbWVudFNpemUsXHJcbiAgICAgICAgICAgIGRhdGFbeGkgKyAxXVt5aV1cclxuICAgICAgICApO1xyXG4gICAgICAgIGMuc2V0KFxyXG4gICAgICAgICAgICB4aSAqIGVsZW1lbnRTaXplLFxyXG4gICAgICAgICAgICAoeWkgKyAxKSAqIGVsZW1lbnRTaXplLFxyXG4gICAgICAgICAgICBkYXRhW3hpXVt5aSArIDFdXHJcbiAgICAgICAgKTtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXQgYSB0cmlhbmdsZSBpbiB0aGUgdGVycmFpbiBpbiB0aGUgZm9ybSBvZiBhIHRyaWFuZ3VsYXIgY29udmV4IHNoYXBlLlxyXG4gKiBAbWV0aG9kIGdldENvbnZleFRyaWFuZ2xlUGlsbGFyXHJcbiAqIEBwYXJhbSAge2ludGVnZXJ9IGlcclxuICogQHBhcmFtICB7aW50ZWdlcn0galxyXG4gKiBAcGFyYW0gIHtib29sZWFufSBnZXRVcHBlclRyaWFuZ2xlXHJcbiAqL1xyXG5IZWlnaHRmaWVsZC5wcm90b3R5cGUuZ2V0Q29udmV4VHJpYW5nbGVQaWxsYXIgPSBmdW5jdGlvbih4aSwgeWksIGdldFVwcGVyVHJpYW5nbGUpe1xyXG4gICAgdmFyIHJlc3VsdCA9IHRoaXMucGlsbGFyQ29udmV4O1xyXG4gICAgdmFyIG9mZnNldFJlc3VsdCA9IHRoaXMucGlsbGFyT2Zmc2V0O1xyXG5cclxuICAgIGlmKHRoaXMuY2FjaGVFbmFibGVkKXtcclxuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZ2V0Q2FjaGVkQ29udmV4VHJpYW5nbGVQaWxsYXIoeGksIHlpLCBnZXRVcHBlclRyaWFuZ2xlKTtcclxuICAgICAgICBpZihkYXRhKXtcclxuICAgICAgICAgICAgdGhpcy5waWxsYXJDb252ZXggPSBkYXRhLmNvbnZleDtcclxuICAgICAgICAgICAgdGhpcy5waWxsYXJPZmZzZXQgPSBkYXRhLm9mZnNldDtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmVzdWx0ID0gbmV3IENvbnZleFBvbHloZWRyb24oKTtcclxuICAgICAgICBvZmZzZXRSZXN1bHQgPSBuZXcgVmVjMygpO1xyXG5cclxuICAgICAgICB0aGlzLnBpbGxhckNvbnZleCA9IHJlc3VsdDtcclxuICAgICAgICB0aGlzLnBpbGxhck9mZnNldCA9IG9mZnNldFJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcclxuICAgIHZhciBlbGVtZW50U2l6ZSA9IHRoaXMuZWxlbWVudFNpemU7XHJcbiAgICB2YXIgZmFjZXMgPSByZXN1bHQuZmFjZXM7XHJcblxyXG4gICAgLy8gUmV1c2UgdmVydHMgaWYgcG9zc2libGVcclxuICAgIHJlc3VsdC52ZXJ0aWNlcy5sZW5ndGggPSA2O1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA2OyBpKyspIHtcclxuICAgICAgICBpZighcmVzdWx0LnZlcnRpY2VzW2ldKXtcclxuICAgICAgICAgICAgcmVzdWx0LnZlcnRpY2VzW2ldID0gbmV3IFZlYzMoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmV1c2UgZmFjZXMgaWYgcG9zc2libGVcclxuICAgIGZhY2VzLmxlbmd0aCA9IDU7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDU7IGkrKykge1xyXG4gICAgICAgIGlmKCFmYWNlc1tpXSl7XHJcbiAgICAgICAgICAgIGZhY2VzW2ldID0gW107XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHZhciB2ZXJ0cyA9IHJlc3VsdC52ZXJ0aWNlcztcclxuXHJcbiAgICB2YXIgaCA9IChNYXRoLm1pbihcclxuICAgICAgICBkYXRhW3hpXVt5aV0sXHJcbiAgICAgICAgZGF0YVt4aSsxXVt5aV0sXHJcbiAgICAgICAgZGF0YVt4aV1beWkrMV0sXHJcbiAgICAgICAgZGF0YVt4aSsxXVt5aSsxXVxyXG4gICAgKSAtIHRoaXMubWluVmFsdWUgKSAvIDIgKyB0aGlzLm1pblZhbHVlO1xyXG5cclxuICAgIGlmICghZ2V0VXBwZXJUcmlhbmdsZSkge1xyXG5cclxuICAgICAgICAvLyBDZW50ZXIgb2YgdGhlIHRyaWFuZ2xlIHBpbGxhciAtIGFsbCBwb2x5Z29ucyBhcmUgZ2l2ZW4gcmVsYXRpdmUgdG8gdGhpcyBvbmVcclxuICAgICAgICBvZmZzZXRSZXN1bHQuc2V0KFxyXG4gICAgICAgICAgICAoeGkgKyAwLjI1KSAqIGVsZW1lbnRTaXplLCAvLyBzb3J0IG9mIGNlbnRlciBvZiBhIHRyaWFuZ2xlXHJcbiAgICAgICAgICAgICh5aSArIDAuMjUpICogZWxlbWVudFNpemUsXHJcbiAgICAgICAgICAgIGggLy8gdmVydGljYWwgY2VudGVyXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgLy8gVG9wIHRyaWFuZ2xlIHZlcnRzXHJcbiAgICAgICAgdmVydHNbMF0uc2V0KFxyXG4gICAgICAgICAgICAtMC4yNSAqIGVsZW1lbnRTaXplLFxyXG4gICAgICAgICAgICAtMC4yNSAqIGVsZW1lbnRTaXplLFxyXG4gICAgICAgICAgICBkYXRhW3hpXVt5aV0gLSBoXHJcbiAgICAgICAgKTtcclxuICAgICAgICB2ZXJ0c1sxXS5zZXQoXHJcbiAgICAgICAgICAgIDAuNzUgKiBlbGVtZW50U2l6ZSxcclxuICAgICAgICAgICAgLTAuMjUgKiBlbGVtZW50U2l6ZSxcclxuICAgICAgICAgICAgZGF0YVt4aSArIDFdW3lpXSAtIGhcclxuICAgICAgICApO1xyXG4gICAgICAgIHZlcnRzWzJdLnNldChcclxuICAgICAgICAgICAgLTAuMjUgKiBlbGVtZW50U2l6ZSxcclxuICAgICAgICAgICAgMC43NSAqIGVsZW1lbnRTaXplLFxyXG4gICAgICAgICAgICBkYXRhW3hpXVt5aSArIDFdIC0gaFxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIC8vIGJvdHRvbSB0cmlhbmdsZSB2ZXJ0c1xyXG4gICAgICAgIHZlcnRzWzNdLnNldChcclxuICAgICAgICAgICAgLTAuMjUgKiBlbGVtZW50U2l6ZSxcclxuICAgICAgICAgICAgLTAuMjUgKiBlbGVtZW50U2l6ZSxcclxuICAgICAgICAgICAgLWgtMVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgdmVydHNbNF0uc2V0KFxyXG4gICAgICAgICAgICAwLjc1ICogZWxlbWVudFNpemUsXHJcbiAgICAgICAgICAgIC0wLjI1ICogZWxlbWVudFNpemUsXHJcbiAgICAgICAgICAgIC1oLTFcclxuICAgICAgICApO1xyXG4gICAgICAgIHZlcnRzWzVdLnNldChcclxuICAgICAgICAgICAgLTAuMjUgKiBlbGVtZW50U2l6ZSxcclxuICAgICAgICAgICAgMC43NSAgKiBlbGVtZW50U2l6ZSxcclxuICAgICAgICAgICAgLWgtMVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIC8vIHRvcCB0cmlhbmdsZVxyXG4gICAgICAgIGZhY2VzWzBdWzBdID0gMDtcclxuICAgICAgICBmYWNlc1swXVsxXSA9IDE7XHJcbiAgICAgICAgZmFjZXNbMF1bMl0gPSAyO1xyXG5cclxuICAgICAgICAvLyBib3R0b20gdHJpYW5nbGVcclxuICAgICAgICBmYWNlc1sxXVswXSA9IDU7XHJcbiAgICAgICAgZmFjZXNbMV1bMV0gPSA0O1xyXG4gICAgICAgIGZhY2VzWzFdWzJdID0gMztcclxuXHJcbiAgICAgICAgLy8gLXggZmFjaW5nIHF1YWRcclxuICAgICAgICBmYWNlc1syXVswXSA9IDA7XHJcbiAgICAgICAgZmFjZXNbMl1bMV0gPSAyO1xyXG4gICAgICAgIGZhY2VzWzJdWzJdID0gNTtcclxuICAgICAgICBmYWNlc1syXVszXSA9IDM7XHJcblxyXG4gICAgICAgIC8vIC15IGZhY2luZyBxdWFkXHJcbiAgICAgICAgZmFjZXNbM11bMF0gPSAxO1xyXG4gICAgICAgIGZhY2VzWzNdWzFdID0gMDtcclxuICAgICAgICBmYWNlc1szXVsyXSA9IDM7XHJcbiAgICAgICAgZmFjZXNbM11bM10gPSA0O1xyXG5cclxuICAgICAgICAvLyAreHkgZmFjaW5nIHF1YWRcclxuICAgICAgICBmYWNlc1s0XVswXSA9IDQ7XHJcbiAgICAgICAgZmFjZXNbNF1bMV0gPSA1O1xyXG4gICAgICAgIGZhY2VzWzRdWzJdID0gMjtcclxuICAgICAgICBmYWNlc1s0XVszXSA9IDE7XHJcblxyXG5cclxuICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgIC8vIENlbnRlciBvZiB0aGUgdHJpYW5nbGUgcGlsbGFyIC0gYWxsIHBvbHlnb25zIGFyZSBnaXZlbiByZWxhdGl2ZSB0byB0aGlzIG9uZVxyXG4gICAgICAgIG9mZnNldFJlc3VsdC5zZXQoXHJcbiAgICAgICAgICAgICh4aSArIDAuNzUpICogZWxlbWVudFNpemUsIC8vIHNvcnQgb2YgY2VudGVyIG9mIGEgdHJpYW5nbGVcclxuICAgICAgICAgICAgKHlpICsgMC43NSkgKiBlbGVtZW50U2l6ZSxcclxuICAgICAgICAgICAgaCAvLyB2ZXJ0aWNhbCBjZW50ZXJcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICAvLyBUb3AgdHJpYW5nbGUgdmVydHNcclxuICAgICAgICB2ZXJ0c1swXS5zZXQoXHJcbiAgICAgICAgICAgIDAuMjUgKiBlbGVtZW50U2l6ZSxcclxuICAgICAgICAgICAgMC4yNSAqIGVsZW1lbnRTaXplLFxyXG4gICAgICAgICAgICBkYXRhW3hpICsgMV1beWkgKyAxXSAtIGhcclxuICAgICAgICApO1xyXG4gICAgICAgIHZlcnRzWzFdLnNldChcclxuICAgICAgICAgICAgLTAuNzUgKiBlbGVtZW50U2l6ZSxcclxuICAgICAgICAgICAgMC4yNSAqIGVsZW1lbnRTaXplLFxyXG4gICAgICAgICAgICBkYXRhW3hpXVt5aSArIDFdIC0gaFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgdmVydHNbMl0uc2V0KFxyXG4gICAgICAgICAgICAwLjI1ICogZWxlbWVudFNpemUsXHJcbiAgICAgICAgICAgIC0wLjc1ICogZWxlbWVudFNpemUsXHJcbiAgICAgICAgICAgIGRhdGFbeGkgKyAxXVt5aV0gLSBoXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgLy8gYm90dG9tIHRyaWFuZ2xlIHZlcnRzXHJcbiAgICAgICAgdmVydHNbM10uc2V0KFxyXG4gICAgICAgICAgICAwLjI1ICogZWxlbWVudFNpemUsXHJcbiAgICAgICAgICAgIDAuMjUgKiBlbGVtZW50U2l6ZSxcclxuICAgICAgICAgICAgLSBoLTFcclxuICAgICAgICApO1xyXG4gICAgICAgIHZlcnRzWzRdLnNldChcclxuICAgICAgICAgICAgLTAuNzUgKiBlbGVtZW50U2l6ZSxcclxuICAgICAgICAgICAgMC4yNSAqIGVsZW1lbnRTaXplLFxyXG4gICAgICAgICAgICAtIGgtMVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgdmVydHNbNV0uc2V0KFxyXG4gICAgICAgICAgICAwLjI1ICogZWxlbWVudFNpemUsXHJcbiAgICAgICAgICAgIC0wLjc1ICogZWxlbWVudFNpemUsXHJcbiAgICAgICAgICAgIC0gaC0xXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgLy8gVG9wIHRyaWFuZ2xlXHJcbiAgICAgICAgZmFjZXNbMF1bMF0gPSAwO1xyXG4gICAgICAgIGZhY2VzWzBdWzFdID0gMTtcclxuICAgICAgICBmYWNlc1swXVsyXSA9IDI7XHJcblxyXG4gICAgICAgIC8vIGJvdHRvbSB0cmlhbmdsZVxyXG4gICAgICAgIGZhY2VzWzFdWzBdID0gNTtcclxuICAgICAgICBmYWNlc1sxXVsxXSA9IDQ7XHJcbiAgICAgICAgZmFjZXNbMV1bMl0gPSAzO1xyXG5cclxuICAgICAgICAvLyAreCBmYWNpbmcgcXVhZFxyXG4gICAgICAgIGZhY2VzWzJdWzBdID0gMjtcclxuICAgICAgICBmYWNlc1syXVsxXSA9IDU7XHJcbiAgICAgICAgZmFjZXNbMl1bMl0gPSAzO1xyXG4gICAgICAgIGZhY2VzWzJdWzNdID0gMDtcclxuXHJcbiAgICAgICAgLy8gK3kgZmFjaW5nIHF1YWRcclxuICAgICAgICBmYWNlc1szXVswXSA9IDM7XHJcbiAgICAgICAgZmFjZXNbM11bMV0gPSA0O1xyXG4gICAgICAgIGZhY2VzWzNdWzJdID0gMTtcclxuICAgICAgICBmYWNlc1szXVszXSA9IDA7XHJcblxyXG4gICAgICAgIC8vIC14eSBmYWNpbmcgcXVhZFxyXG4gICAgICAgIGZhY2VzWzRdWzBdID0gMTtcclxuICAgICAgICBmYWNlc1s0XVsxXSA9IDQ7XHJcbiAgICAgICAgZmFjZXNbNF1bMl0gPSA1O1xyXG4gICAgICAgIGZhY2VzWzRdWzNdID0gMjtcclxuICAgIH1cclxuXHJcbiAgICByZXN1bHQuY29tcHV0ZU5vcm1hbHMoKTtcclxuICAgIHJlc3VsdC5jb21wdXRlRWRnZXMoKTtcclxuICAgIHJlc3VsdC51cGRhdGVCb3VuZGluZ1NwaGVyZVJhZGl1cygpO1xyXG5cclxuICAgIHRoaXMuc2V0Q2FjaGVkQ29udmV4VHJpYW5nbGVQaWxsYXIoeGksIHlpLCBnZXRVcHBlclRyaWFuZ2xlLCByZXN1bHQsIG9mZnNldFJlc3VsdCk7XHJcbn07XHJcblxyXG5IZWlnaHRmaWVsZC5wcm90b3R5cGUuY2FsY3VsYXRlTG9jYWxJbmVydGlhID0gZnVuY3Rpb24obWFzcywgdGFyZ2V0KXtcclxuICAgIHRhcmdldCA9IHRhcmdldCB8fCBuZXcgVmVjMygpO1xyXG4gICAgdGFyZ2V0LnNldCgwLCAwLCAwKTtcclxuICAgIHJldHVybiB0YXJnZXQ7XHJcbn07XHJcblxyXG5IZWlnaHRmaWVsZC5wcm90b3R5cGUudm9sdW1lID0gZnVuY3Rpb24oKXtcclxuICAgIHJldHVybiBOdW1iZXIuTUFYX1ZBTFVFOyAvLyBUaGUgdGVycmFpbiBpcyBpbmZpbml0ZVxyXG59O1xyXG5cclxuSGVpZ2h0ZmllbGQucHJvdG90eXBlLmNhbGN1bGF0ZVdvcmxkQUFCQiA9IGZ1bmN0aW9uKHBvcywgcXVhdCwgbWluLCBtYXgpe1xyXG4gICAgLy8gVE9ETzogZG8gaXQgcHJvcGVybHlcclxuICAgIG1pbi5zZXQoLU51bWJlci5NQVhfVkFMVUUsIC1OdW1iZXIuTUFYX1ZBTFVFLCAtTnVtYmVyLk1BWF9WQUxVRSk7XHJcbiAgICBtYXguc2V0KE51bWJlci5NQVhfVkFMVUUsIE51bWJlci5NQVhfVkFMVUUsIE51bWJlci5NQVhfVkFMVUUpO1xyXG59O1xyXG5cclxuSGVpZ2h0ZmllbGQucHJvdG90eXBlLnVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzID0gZnVuY3Rpb24oKXtcclxuICAgIC8vIFVzZSB0aGUgYm91bmRpbmcgYm94IG9mIHRoZSBtaW4vbWF4IHZhbHVlc1xyXG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGEsXHJcbiAgICAgICAgcyA9IHRoaXMuZWxlbWVudFNpemU7XHJcbiAgICB0aGlzLmJvdW5kaW5nU3BoZXJlUmFkaXVzID0gbmV3IFZlYzMoZGF0YS5sZW5ndGggKiBzLCBkYXRhWzBdLmxlbmd0aCAqIHMsIE1hdGgubWF4KE1hdGguYWJzKHRoaXMubWF4VmFsdWUpLCBNYXRoLmFicyh0aGlzLm1pblZhbHVlKSkpLm5vcm0oKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTZXRzIHRoZSBoZWlnaHQgdmFsdWVzIGZyb20gYW4gaW1hZ2UuIEN1cnJlbnRseSBvbmx5IHN1cHBvcnRlZCBpbiBicm93c2VyLlxyXG4gKiBAbWV0aG9kIHNldEhlaWdodHNGcm9tSW1hZ2VcclxuICogQHBhcmFtIHtJbWFnZX0gaW1hZ2VcclxuICogQHBhcmFtIHtWZWMzfSBzY2FsZVxyXG4gKi9cclxuSGVpZ2h0ZmllbGQucHJvdG90eXBlLnNldEhlaWdodHNGcm9tSW1hZ2UgPSBmdW5jdGlvbihpbWFnZSwgc2NhbGUpe1xyXG4gICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gICAgY2FudmFzLndpZHRoID0gaW1hZ2Uud2lkdGg7XHJcbiAgICBjYW52YXMuaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xyXG4gICAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcclxuICAgIGNvbnRleHQuZHJhd0ltYWdlKGltYWdlLCAwLCAwKTtcclxuICAgIHZhciBpbWFnZURhdGEgPSBjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0KTtcclxuXHJcbiAgICB2YXIgbWF0cml4ID0gdGhpcy5kYXRhO1xyXG4gICAgbWF0cml4Lmxlbmd0aCA9IDA7XHJcbiAgICB0aGlzLmVsZW1lbnRTaXplID0gTWF0aC5hYnMoc2NhbGUueCkgLyBpbWFnZURhdGEud2lkdGg7XHJcbiAgICBmb3IodmFyIGk9MDsgaTxpbWFnZURhdGEuaGVpZ2h0OyBpKyspe1xyXG4gICAgICAgIHZhciByb3cgPSBbXTtcclxuICAgICAgICBmb3IodmFyIGo9MDsgajxpbWFnZURhdGEud2lkdGg7IGorKyl7XHJcbiAgICAgICAgICAgIHZhciBhID0gaW1hZ2VEYXRhLmRhdGFbKGkqaW1hZ2VEYXRhLmhlaWdodCArIGopICogNF07XHJcbiAgICAgICAgICAgIHZhciBiID0gaW1hZ2VEYXRhLmRhdGFbKGkqaW1hZ2VEYXRhLmhlaWdodCArIGopICogNCArIDFdO1xyXG4gICAgICAgICAgICB2YXIgYyA9IGltYWdlRGF0YS5kYXRhWyhpKmltYWdlRGF0YS5oZWlnaHQgKyBqKSAqIDQgKyAyXTtcclxuICAgICAgICAgICAgdmFyIGhlaWdodCA9IChhICsgYiArIGMpIC8gNCAvIDI1NSAqIHNjYWxlLno7XHJcbiAgICAgICAgICAgIGlmKHNjYWxlLnggPCAwKXtcclxuICAgICAgICAgICAgICAgIHJvdy5wdXNoKGhlaWdodCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByb3cudW5zaGlmdChoZWlnaHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKHNjYWxlLnkgPCAwKXtcclxuICAgICAgICAgICAgbWF0cml4LnVuc2hpZnQocm93KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBtYXRyaXgucHVzaChyb3cpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHRoaXMudXBkYXRlTWF4VmFsdWUoKTtcclxuICAgIHRoaXMudXBkYXRlTWluVmFsdWUoKTtcclxuICAgIHRoaXMudXBkYXRlKCk7XHJcbn07XHJcbn0se1wiLi4vbWF0aC9WZWMzXCI6MzEsXCIuLi91dGlscy9VdGlsc1wiOjU0LFwiLi9Db252ZXhQb2x5aGVkcm9uXCI6MzksXCIuL1NoYXBlXCI6NDR9XSw0MjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XHJcbm1vZHVsZS5leHBvcnRzID0gUGFydGljbGU7XHJcblxyXG52YXIgU2hhcGUgPSBfZGVyZXFfKCcuL1NoYXBlJyk7XHJcbnZhciBWZWMzID0gX2RlcmVxXygnLi4vbWF0aC9WZWMzJyk7XHJcblxyXG4vKipcclxuICogUGFydGljbGUgc2hhcGUuXHJcbiAqIEBjbGFzcyBQYXJ0aWNsZVxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQGF1dGhvciBzY2h0ZXBwZVxyXG4gKiBAZXh0ZW5kcyBTaGFwZVxyXG4gKi9cclxuZnVuY3Rpb24gUGFydGljbGUoKXtcclxuICAgIFNoYXBlLmNhbGwodGhpcywge1xyXG4gICAgICAgIHR5cGU6IFNoYXBlLnR5cGVzLlBBUlRJQ0xFXHJcbiAgICB9KTtcclxufVxyXG5QYXJ0aWNsZS5wcm90b3R5cGUgPSBuZXcgU2hhcGUoKTtcclxuUGFydGljbGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUGFydGljbGU7XHJcblxyXG4vKipcclxuICogQG1ldGhvZCBjYWxjdWxhdGVMb2NhbEluZXJ0aWFcclxuICogQHBhcmFtICB7TnVtYmVyfSBtYXNzXHJcbiAqIEBwYXJhbSAge1ZlYzN9IHRhcmdldFxyXG4gKiBAcmV0dXJuIHtWZWMzfVxyXG4gKi9cclxuUGFydGljbGUucHJvdG90eXBlLmNhbGN1bGF0ZUxvY2FsSW5lcnRpYSA9IGZ1bmN0aW9uKG1hc3MsdGFyZ2V0KXtcclxuICAgIHRhcmdldCA9IHRhcmdldCB8fCBuZXcgVmVjMygpO1xyXG4gICAgdGFyZ2V0LnNldCgwLCAwLCAwKTtcclxuICAgIHJldHVybiB0YXJnZXQ7XHJcbn07XHJcblxyXG5QYXJ0aWNsZS5wcm90b3R5cGUudm9sdW1lID0gZnVuY3Rpb24oKXtcclxuICAgIHJldHVybiAwO1xyXG59O1xyXG5cclxuUGFydGljbGUucHJvdG90eXBlLnVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzID0gZnVuY3Rpb24oKXtcclxuICAgIHRoaXMuYm91bmRpbmdTcGhlcmVSYWRpdXMgPSAwO1xyXG59O1xyXG5cclxuUGFydGljbGUucHJvdG90eXBlLmNhbGN1bGF0ZVdvcmxkQUFCQiA9IGZ1bmN0aW9uKHBvcyxxdWF0LG1pbixtYXgpe1xyXG4gICAgLy8gR2V0IGVhY2ggYXhpcyBtYXhcclxuICAgIG1pbi5jb3B5KHBvcyk7XHJcbiAgICBtYXguY29weShwb3MpO1xyXG59O1xyXG5cclxufSx7XCIuLi9tYXRoL1ZlYzNcIjozMSxcIi4vU2hhcGVcIjo0NH1dLDQzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcclxubW9kdWxlLmV4cG9ydHMgPSBQbGFuZTtcclxuXHJcbnZhciBTaGFwZSA9IF9kZXJlcV8oJy4vU2hhcGUnKTtcclxudmFyIFZlYzMgPSBfZGVyZXFfKCcuLi9tYXRoL1ZlYzMnKTtcclxuXHJcbi8qKlxyXG4gKiBBIHBsYW5lLCBmYWNpbmcgaW4gdGhlIFogZGlyZWN0aW9uLiBUaGUgcGxhbmUgaGFzIGl0cyBzdXJmYWNlIGF0IHo9MCBhbmQgZXZlcnl0aGluZyBiZWxvdyB6PTAgaXMgYXNzdW1lZCB0byBiZSBzb2xpZCBwbGFuZS4gVG8gbWFrZSB0aGUgcGxhbmUgZmFjZSBpbiBzb21lIG90aGVyIGRpcmVjdGlvbiB0aGFuIHosIHlvdSBtdXN0IHB1dCBpdCBpbnNpZGUgYSBCb2R5IGFuZCByb3RhdGUgdGhhdCBib2R5LiBTZWUgdGhlIGRlbW9zLlxyXG4gKiBAY2xhc3MgUGxhbmVcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBleHRlbmRzIFNoYXBlXHJcbiAqIEBhdXRob3Igc2NodGVwcGVcclxuICovXHJcbmZ1bmN0aW9uIFBsYW5lKCl7XHJcbiAgICBTaGFwZS5jYWxsKHRoaXMsIHtcclxuICAgICAgICB0eXBlOiBTaGFwZS50eXBlcy5QTEFORVxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gV29ybGQgb3JpZW50ZWQgbm9ybWFsXHJcbiAgICB0aGlzLndvcmxkTm9ybWFsID0gbmV3IFZlYzMoKTtcclxuICAgIHRoaXMud29ybGROb3JtYWxOZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG4gICAgdGhpcy5ib3VuZGluZ1NwaGVyZVJhZGl1cyA9IE51bWJlci5NQVhfVkFMVUU7XHJcbn1cclxuUGxhbmUucHJvdG90eXBlID0gbmV3IFNoYXBlKCk7XHJcblBsYW5lLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBsYW5lO1xyXG5cclxuUGxhbmUucHJvdG90eXBlLmNvbXB1dGVXb3JsZE5vcm1hbCA9IGZ1bmN0aW9uKHF1YXQpe1xyXG4gICAgdmFyIG4gPSB0aGlzLndvcmxkTm9ybWFsO1xyXG4gICAgbi5zZXQoMCwwLDEpO1xyXG4gICAgcXVhdC52bXVsdChuLG4pO1xyXG4gICAgdGhpcy53b3JsZE5vcm1hbE5lZWRzVXBkYXRlID0gZmFsc2U7XHJcbn07XHJcblxyXG5QbGFuZS5wcm90b3R5cGUuY2FsY3VsYXRlTG9jYWxJbmVydGlhID0gZnVuY3Rpb24obWFzcyx0YXJnZXQpe1xyXG4gICAgdGFyZ2V0ID0gdGFyZ2V0IHx8IG5ldyBWZWMzKCk7XHJcbiAgICByZXR1cm4gdGFyZ2V0O1xyXG59O1xyXG5cclxuUGxhbmUucHJvdG90eXBlLnZvbHVtZSA9IGZ1bmN0aW9uKCl7XHJcbiAgICByZXR1cm4gTnVtYmVyLk1BWF9WQUxVRTsgLy8gVGhlIHBsYW5lIGlzIGluZmluaXRlLi4uXHJcbn07XHJcblxyXG52YXIgdGVtcE5vcm1hbCA9IG5ldyBWZWMzKCk7XHJcblBsYW5lLnByb3RvdHlwZS5jYWxjdWxhdGVXb3JsZEFBQkIgPSBmdW5jdGlvbihwb3MsIHF1YXQsIG1pbiwgbWF4KXtcclxuICAgIC8vIFRoZSBwbGFuZSBBQUJCIGlzIGluZmluaXRlLCBleGNlcHQgaWYgdGhlIG5vcm1hbCBpcyBwb2ludGluZyBhbG9uZyBhbnkgYXhpc1xyXG4gICAgdGVtcE5vcm1hbC5zZXQoMCwwLDEpOyAvLyBEZWZhdWx0IHBsYW5lIG5vcm1hbCBpcyB6XHJcbiAgICBxdWF0LnZtdWx0KHRlbXBOb3JtYWwsdGVtcE5vcm1hbCk7XHJcbiAgICB2YXIgbWF4VmFsID0gTnVtYmVyLk1BWF9WQUxVRTtcclxuICAgIG1pbi5zZXQoLW1heFZhbCwgLW1heFZhbCwgLW1heFZhbCk7XHJcbiAgICBtYXguc2V0KG1heFZhbCwgbWF4VmFsLCBtYXhWYWwpO1xyXG5cclxuICAgIGlmKHRlbXBOb3JtYWwueCA9PT0gMSl7IG1heC54ID0gcG9zLng7IH1cclxuICAgIGlmKHRlbXBOb3JtYWwueSA9PT0gMSl7IG1heC55ID0gcG9zLnk7IH1cclxuICAgIGlmKHRlbXBOb3JtYWwueiA9PT0gMSl7IG1heC56ID0gcG9zLno7IH1cclxuXHJcbiAgICBpZih0ZW1wTm9ybWFsLnggPT09IC0xKXsgbWluLnggPSBwb3MueDsgfVxyXG4gICAgaWYodGVtcE5vcm1hbC55ID09PSAtMSl7IG1pbi55ID0gcG9zLnk7IH1cclxuICAgIGlmKHRlbXBOb3JtYWwueiA9PT0gLTEpeyBtaW4ueiA9IHBvcy56OyB9XHJcbn07XHJcblxyXG5QbGFuZS5wcm90b3R5cGUudXBkYXRlQm91bmRpbmdTcGhlcmVSYWRpdXMgPSBmdW5jdGlvbigpe1xyXG4gICAgdGhpcy5ib3VuZGluZ1NwaGVyZVJhZGl1cyA9IE51bWJlci5NQVhfVkFMVUU7XHJcbn07XHJcbn0se1wiLi4vbWF0aC9WZWMzXCI6MzEsXCIuL1NoYXBlXCI6NDR9XSw0NDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XHJcbm1vZHVsZS5leHBvcnRzID0gU2hhcGU7XHJcblxyXG52YXIgRXZlbnRUYXJnZXQgPSBfZGVyZXFfKCcuLi91dGlscy9FdmVudFRhcmdldCcpO1xyXG52YXIgU2hhcGUgPSBfZGVyZXFfKCcuL1NoYXBlJyk7XHJcbnZhciBWZWMzID0gX2RlcmVxXygnLi4vbWF0aC9WZWMzJyk7XHJcbnZhciBRdWF0ZXJuaW9uID0gX2RlcmVxXygnLi4vbWF0aC9RdWF0ZXJuaW9uJyk7XHJcbnZhciBNYXRlcmlhbCA9IF9kZXJlcV8oJy4uL21hdGVyaWFsL01hdGVyaWFsJyk7XHJcblxyXG4vKipcclxuICogQmFzZSBjbGFzcyBmb3Igc2hhcGVzXHJcbiAqIEBjbGFzcyBTaGFwZVxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxyXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuY29sbGlzaW9uRmlsdGVyR3JvdXA9MV1cclxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmNvbGxpc2lvbkZpbHRlck1hc2s9LTFdXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5jb2xsaXNpb25SZXNwb25zZT10cnVlXVxyXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF0ZXJpYWw9bnVsbF1cclxuICogQGF1dGhvciBzY2h0ZXBwZVxyXG4gKi9cclxuZnVuY3Rpb24gU2hhcGUob3B0aW9ucyl7XHJcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcbiAgICBFdmVudFRhcmdldC5hcHBseSh0aGlzKTtcclxuICAgIC8qKlxyXG4gICAgICogSWRlbnRpZnllciBvZiB0aGUgU2hhcGUuXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gaWRcclxuICAgICAqL1xyXG4gICAgdGhpcy5pZCA9IFNoYXBlLmlkQ291bnRlcisrO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHR5cGUgb2YgdGhpcyBzaGFwZS4gTXVzdCBiZSBzZXQgdG8gYW4gaW50ID4gMCBieSBzdWJjbGFzc2VzLlxyXG4gICAgICogQHByb3BlcnR5IHR5cGVcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAc2VlIFNoYXBlLnR5cGVzXHJcbiAgICAgKi9cclxuICAgIHRoaXMudHlwZSA9IG9wdGlvbnMudHlwZSB8fCAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGxvY2FsIGJvdW5kaW5nIHNwaGVyZSByYWRpdXMgb2YgdGhpcyBzaGFwZS5cclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBib3VuZGluZ1NwaGVyZVJhZGl1c1xyXG4gICAgICovXHJcbiAgICB0aGlzLmJvdW5kaW5nU3BoZXJlUmFkaXVzID0gMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgdG8gcHJvZHVjZSBjb250YWN0IGZvcmNlcyB3aGVuIGluIGNvbnRhY3Qgd2l0aCBvdGhlciBib2RpZXMuIE5vdGUgdGhhdCBjb250YWN0cyB3aWxsIGJlIGdlbmVyYXRlZCwgYnV0IHRoZXkgd2lsbCBiZSBkaXNhYmxlZC5cclxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gY29sbGlzaW9uUmVzcG9uc2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5jb2xsaXNpb25SZXNwb25zZSA9IG9wdGlvbnMuY29sbGlzaW9uUmVzcG9uc2UgPyBvcHRpb25zLmNvbGxpc2lvblJlc3BvbnNlIDogdHJ1ZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBjb2xsaXNpb25GaWx0ZXJHcm91cFxyXG4gICAgICovXHJcbiAgICB0aGlzLmNvbGxpc2lvbkZpbHRlckdyb3VwID0gb3B0aW9ucy5jb2xsaXNpb25GaWx0ZXJHcm91cCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5jb2xsaXNpb25GaWx0ZXJHcm91cCA6IDE7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gY29sbGlzaW9uRmlsdGVyTWFza1xyXG4gICAgICovXHJcbiAgICB0aGlzLmNvbGxpc2lvbkZpbHRlck1hc2sgPSBvcHRpb25zLmNvbGxpc2lvbkZpbHRlck1hc2sgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY29sbGlzaW9uRmlsdGVyTWFzayA6IC0xO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IHtNYXRlcmlhbH0gbWF0ZXJpYWxcclxuICAgICAqL1xyXG4gICAgdGhpcy5tYXRlcmlhbCA9IG9wdGlvbnMubWF0ZXJpYWwgPyBvcHRpb25zLm1hdGVyaWFsIDogbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9keX0gYm9keVxyXG4gICAgICovXHJcbiAgICB0aGlzLmJvZHkgPSBudWxsO1xyXG59XHJcblNoYXBlLnByb3RvdHlwZSA9IG5ldyBFdmVudFRhcmdldCgpO1xyXG5TaGFwZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTaGFwZTtcclxuXHJcbi8qKlxyXG4gKiBDb21wdXRlcyB0aGUgYm91bmRpbmcgc3BoZXJlIHJhZGl1cy4gVGhlIHJlc3VsdCBpcyBzdG9yZWQgaW4gdGhlIHByb3BlcnR5IC5ib3VuZGluZ1NwaGVyZVJhZGl1c1xyXG4gKiBAbWV0aG9kIHVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzXHJcbiAqL1xyXG5TaGFwZS5wcm90b3R5cGUudXBkYXRlQm91bmRpbmdTcGhlcmVSYWRpdXMgPSBmdW5jdGlvbigpe1xyXG4gICAgdGhyb3cgXCJjb21wdXRlQm91bmRpbmdTcGhlcmVSYWRpdXMoKSBub3QgaW1wbGVtZW50ZWQgZm9yIHNoYXBlIHR5cGUgXCIrdGhpcy50eXBlO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldCB0aGUgdm9sdW1lIG9mIHRoaXMgc2hhcGVcclxuICogQG1ldGhvZCB2b2x1bWVcclxuICogQHJldHVybiB7TnVtYmVyfVxyXG4gKi9cclxuU2hhcGUucHJvdG90eXBlLnZvbHVtZSA9IGZ1bmN0aW9uKCl7XHJcbiAgICB0aHJvdyBcInZvbHVtZSgpIG5vdCBpbXBsZW1lbnRlZCBmb3Igc2hhcGUgdHlwZSBcIit0aGlzLnR5cGU7XHJcbn07XHJcblxyXG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgaW5lcnRpYSBpbiB0aGUgbG9jYWwgZnJhbWUgZm9yIHRoaXMgc2hhcGUuXHJcbiAqIEBtZXRob2QgY2FsY3VsYXRlTG9jYWxJbmVydGlhXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtYXNzXHJcbiAqIEBwYXJhbSB7VmVjM30gdGFyZ2V0XHJcbiAqIEBzZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MaXN0X29mX21vbWVudHNfb2ZfaW5lcnRpYVxyXG4gKi9cclxuU2hhcGUucHJvdG90eXBlLmNhbGN1bGF0ZUxvY2FsSW5lcnRpYSA9IGZ1bmN0aW9uKG1hc3MsdGFyZ2V0KXtcclxuICAgIHRocm93IFwiY2FsY3VsYXRlTG9jYWxJbmVydGlhKCkgbm90IGltcGxlbWVudGVkIGZvciBzaGFwZSB0eXBlIFwiK3RoaXMudHlwZTtcclxufTtcclxuXHJcblNoYXBlLmlkQ291bnRlciA9IDA7XHJcblxyXG4vKipcclxuICogVGhlIGF2YWlsYWJsZSBzaGFwZSB0eXBlcy5cclxuICogQHN0YXRpY1xyXG4gKiBAcHJvcGVydHkgdHlwZXNcclxuICogQHR5cGUge09iamVjdH1cclxuICovXHJcblNoYXBlLnR5cGVzID0ge1xyXG4gICAgU1BIRVJFOjEsXHJcbiAgICBQTEFORToyLFxyXG4gICAgQk9YOjQsXHJcbiAgICBDT01QT1VORDo4LFxyXG4gICAgQ09OVkVYUE9MWUhFRFJPTjoxNixcclxuICAgIEhFSUdIVEZJRUxEOjMyLFxyXG4gICAgUEFSVElDTEU6NjQsXHJcbiAgICBDWUxJTkRFUjoxMjgsXHJcbiAgICBUUklNRVNIOjI1NlxyXG59O1xyXG5cclxuXHJcbn0se1wiLi4vbWF0ZXJpYWwvTWF0ZXJpYWxcIjoyNixcIi4uL21hdGgvUXVhdGVybmlvblwiOjI5LFwiLi4vbWF0aC9WZWMzXCI6MzEsXCIuLi91dGlscy9FdmVudFRhcmdldFwiOjUwLFwiLi9TaGFwZVwiOjQ0fV0sNDU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xyXG5tb2R1bGUuZXhwb3J0cyA9IFNwaGVyZTtcclxuXHJcbnZhciBTaGFwZSA9IF9kZXJlcV8oJy4vU2hhcGUnKTtcclxudmFyIFZlYzMgPSBfZGVyZXFfKCcuLi9tYXRoL1ZlYzMnKTtcclxuXHJcbi8qKlxyXG4gKiBTcGhlcmljYWwgc2hhcGVcclxuICogQGNsYXNzIFNwaGVyZVxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQGV4dGVuZHMgU2hhcGVcclxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1cyBUaGUgcmFkaXVzIG9mIHRoZSBzcGhlcmUsIGEgbm9uLW5lZ2F0aXZlIG51bWJlci5cclxuICogQGF1dGhvciBzY2h0ZXBwZSAvIGh0dHA6Ly9naXRodWIuY29tL3NjaHRlcHBlXHJcbiAqL1xyXG5mdW5jdGlvbiBTcGhlcmUocmFkaXVzKXtcclxuICAgIFNoYXBlLmNhbGwodGhpcywge1xyXG4gICAgICAgIHR5cGU6IFNoYXBlLnR5cGVzLlNQSEVSRVxyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gcmFkaXVzXHJcbiAgICAgKi9cclxuICAgIHRoaXMucmFkaXVzID0gcmFkaXVzICE9PSB1bmRlZmluZWQgPyByYWRpdXMgOiAxLjA7XHJcblxyXG4gICAgaWYodGhpcy5yYWRpdXMgPCAwKXtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBzcGhlcmUgcmFkaXVzIGNhbm5vdCBiZSBuZWdhdGl2ZS4nKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzKCk7XHJcbn1cclxuU3BoZXJlLnByb3RvdHlwZSA9IG5ldyBTaGFwZSgpO1xyXG5TcGhlcmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3BoZXJlO1xyXG5cclxuU3BoZXJlLnByb3RvdHlwZS5jYWxjdWxhdGVMb2NhbEluZXJ0aWEgPSBmdW5jdGlvbihtYXNzLHRhcmdldCl7XHJcbiAgICB0YXJnZXQgPSB0YXJnZXQgfHwgbmV3IFZlYzMoKTtcclxuICAgIHZhciBJID0gMi4wKm1hc3MqdGhpcy5yYWRpdXMqdGhpcy5yYWRpdXMvNS4wO1xyXG4gICAgdGFyZ2V0LnggPSBJO1xyXG4gICAgdGFyZ2V0LnkgPSBJO1xyXG4gICAgdGFyZ2V0LnogPSBJO1xyXG4gICAgcmV0dXJuIHRhcmdldDtcclxufTtcclxuXHJcblNwaGVyZS5wcm90b3R5cGUudm9sdW1lID0gZnVuY3Rpb24oKXtcclxuICAgIHJldHVybiA0LjAgKiBNYXRoLlBJICogdGhpcy5yYWRpdXMgLyAzLjA7XHJcbn07XHJcblxyXG5TcGhlcmUucHJvdG90eXBlLnVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzID0gZnVuY3Rpb24oKXtcclxuICAgIHRoaXMuYm91bmRpbmdTcGhlcmVSYWRpdXMgPSB0aGlzLnJhZGl1cztcclxufTtcclxuXHJcblNwaGVyZS5wcm90b3R5cGUuY2FsY3VsYXRlV29ybGRBQUJCID0gZnVuY3Rpb24ocG9zLHF1YXQsbWluLG1heCl7XHJcbiAgICB2YXIgciA9IHRoaXMucmFkaXVzO1xyXG4gICAgdmFyIGF4ZXMgPSBbJ3gnLCd5JywneiddO1xyXG4gICAgZm9yKHZhciBpPTA7IGk8YXhlcy5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgdmFyIGF4ID0gYXhlc1tpXTtcclxuICAgICAgICBtaW5bYXhdID0gcG9zW2F4XSAtIHI7XHJcbiAgICAgICAgbWF4W2F4XSA9IHBvc1theF0gKyByO1xyXG4gICAgfVxyXG59O1xyXG5cclxufSx7XCIuLi9tYXRoL1ZlYzNcIjozMSxcIi4vU2hhcGVcIjo0NH1dLDQ2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcclxubW9kdWxlLmV4cG9ydHMgPSBUcmltZXNoO1xyXG5cclxudmFyIFNoYXBlID0gX2RlcmVxXygnLi9TaGFwZScpO1xyXG52YXIgVmVjMyA9IF9kZXJlcV8oJy4uL21hdGgvVmVjMycpO1xyXG52YXIgUXVhdGVybmlvbiA9IF9kZXJlcV8oJy4uL21hdGgvUXVhdGVybmlvbicpO1xyXG52YXIgVHJhbnNmb3JtID0gX2RlcmVxXygnLi4vbWF0aC9UcmFuc2Zvcm0nKTtcclxudmFyIEFBQkIgPSBfZGVyZXFfKCcuLi9jb2xsaXNpb24vQUFCQicpO1xyXG52YXIgT2N0cmVlID0gX2RlcmVxXygnLi4vdXRpbHMvT2N0cmVlJyk7XHJcblxyXG4vKipcclxuICogQGNsYXNzIFRyaW1lc2hcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7YXJyYXl9IHZlcnRpY2VzXHJcbiAqIEBwYXJhbSB7YXJyYXl9IGluZGljZXNcclxuICogQGV4dGVuZHMgU2hhcGVcclxuICogQGV4YW1wbGVcclxuICogICAgIC8vIEhvdyB0byBtYWtlIGEgbWVzaCB3aXRoIGEgc2luZ2xlIHRyaWFuZ2xlXHJcbiAqICAgICB2YXIgdmVydGljZXMgPSBbXHJcbiAqICAgICAgICAgMCwgMCwgMCwgLy8gdmVydGV4IDBcclxuICogICAgICAgICAxLCAwLCAwLCAvLyB2ZXJ0ZXggMVxyXG4gKiAgICAgICAgIDAsIDEsIDAgIC8vIHZlcnRleCAyXHJcbiAqICAgICBdO1xyXG4gKiAgICAgdmFyIGluZGljZXMgPSBbXHJcbiAqICAgICAgICAgMCwgMSwgMiAgLy8gdHJpYW5nbGUgMFxyXG4gKiAgICAgXTtcclxuICogICAgIHZhciB0cmltZXNoU2hhcGUgPSBuZXcgVHJpbWVzaCh2ZXJ0aWNlcywgaW5kaWNlcyk7XHJcbiAqL1xyXG5mdW5jdGlvbiBUcmltZXNoKHZlcnRpY2VzLCBpbmRpY2VzKSB7XHJcbiAgICBTaGFwZS5jYWxsKHRoaXMsIHtcclxuICAgICAgICB0eXBlOiBTaGFwZS50eXBlcy5UUklNRVNIXHJcbiAgICB9KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcm9wZXJ0eSB2ZXJ0aWNlc1xyXG4gICAgICogQHR5cGUge0FycmF5fVxyXG4gICAgICovXHJcbiAgICB0aGlzLnZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheSh2ZXJ0aWNlcyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBcnJheSBvZiBpbnRlZ2VycywgaW5kaWNhdGluZyB3aGljaCB2ZXJ0aWNlcyBlYWNoIHRyaWFuZ2xlIGNvbnNpc3RzIG9mLiBUaGUgbGVuZ3RoIG9mIHRoaXMgYXJyYXkgaXMgdGh1cyAzIHRpbWVzIHRoZSBudW1iZXIgb2YgdHJpYW5nbGVzLlxyXG4gICAgICogQHByb3BlcnR5IGluZGljZXNcclxuICAgICAqIEB0eXBlIHtBcnJheX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5pbmRpY2VzID0gbmV3IEludDE2QXJyYXkoaW5kaWNlcyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbm9ybWFscyBkYXRhLlxyXG4gICAgICogQHByb3BlcnR5IG5vcm1hbHNcclxuICAgICAqIEB0eXBlIHtBcnJheX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5ub3JtYWxzID0gbmV3IEZsb2F0MzJBcnJheShpbmRpY2VzLmxlbmd0aCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbG9jYWwgQUFCQiBvZiB0aGUgbWVzaC5cclxuICAgICAqIEBwcm9wZXJ0eSBhYWJiXHJcbiAgICAgKiBAdHlwZSB7QXJyYXl9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuYWFiYiA9IG5ldyBBQUJCKCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWZlcmVuY2VzIHRvIHZlcnRleCBwYWlycywgbWFraW5nIHVwIGFsbCB1bmlxdWUgZWRnZXMgaW4gdGhlIHRyaW1lc2guXHJcbiAgICAgKiBAcHJvcGVydHkge2FycmF5fSBlZGdlc1xyXG4gICAgICovXHJcbiAgICB0aGlzLmVkZ2VzID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIExvY2FsIHNjYWxpbmcgb2YgdGhlIG1lc2guIFVzZSAuc2V0U2NhbGUoKSB0byBzZXQgaXQuXHJcbiAgICAgKiBAcHJvcGVydHkge1ZlYzN9IHNjYWxlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuc2NhbGUgPSBuZXcgVmVjMygxLCAxLCAxKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBpbmRleGVkIHRyaWFuZ2xlcy4gVXNlIC51cGRhdGVUcmVlKCkgdG8gdXBkYXRlIGl0LlxyXG4gICAgICogQHByb3BlcnR5IHtPY3RyZWV9IHRyZWVcclxuICAgICAqL1xyXG4gICAgdGhpcy50cmVlID0gbmV3IE9jdHJlZSgpO1xyXG5cclxuICAgIHRoaXMudXBkYXRlRWRnZXMoKTtcclxuICAgIHRoaXMudXBkYXRlTm9ybWFscygpO1xyXG4gICAgdGhpcy51cGRhdGVBQUJCKCk7XHJcbiAgICB0aGlzLnVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzKCk7XHJcbiAgICB0aGlzLnVwZGF0ZVRyZWUoKTtcclxufVxyXG5UcmltZXNoLnByb3RvdHlwZSA9IG5ldyBTaGFwZSgpO1xyXG5UcmltZXNoLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRyaW1lc2g7XHJcblxyXG52YXIgY29tcHV0ZU5vcm1hbHNfbiA9IG5ldyBWZWMzKCk7XHJcblxyXG4vKipcclxuICogQG1ldGhvZCB1cGRhdGVUcmVlXHJcbiAqL1xyXG5UcmltZXNoLnByb3RvdHlwZS51cGRhdGVUcmVlID0gZnVuY3Rpb24oKXtcclxuICAgIHZhciB0cmVlID0gdGhpcy50cmVlO1xyXG5cclxuICAgIHRyZWUucmVzZXQoKTtcclxuICAgIHRyZWUuYWFiYi5jb3B5KHRoaXMuYWFiYik7XHJcbiAgICB2YXIgc2NhbGUgPSB0aGlzLnNjYWxlOyAvLyBUaGUgbG9jYWwgbWVzaCBBQUJCIGlzIHNjYWxlZCwgYnV0IHRoZSBvY3RyZWUgQUFCQiBzaG91bGQgYmUgdW5zY2FsZWRcclxuICAgIHRyZWUuYWFiYi5sb3dlckJvdW5kLnggKj0gMSAvIHNjYWxlLng7XHJcbiAgICB0cmVlLmFhYmIubG93ZXJCb3VuZC55ICo9IDEgLyBzY2FsZS55O1xyXG4gICAgdHJlZS5hYWJiLmxvd2VyQm91bmQueiAqPSAxIC8gc2NhbGUuejtcclxuICAgIHRyZWUuYWFiYi51cHBlckJvdW5kLnggKj0gMSAvIHNjYWxlLng7XHJcbiAgICB0cmVlLmFhYmIudXBwZXJCb3VuZC55ICo9IDEgLyBzY2FsZS55O1xyXG4gICAgdHJlZS5hYWJiLnVwcGVyQm91bmQueiAqPSAxIC8gc2NhbGUuejtcclxuXHJcbiAgICAvLyBJbnNlcnQgYWxsIHRyaWFuZ2xlc1xyXG4gICAgdmFyIHRyaWFuZ2xlQUFCQiA9IG5ldyBBQUJCKCk7XHJcbiAgICB2YXIgYSA9IG5ldyBWZWMzKCk7XHJcbiAgICB2YXIgYiA9IG5ldyBWZWMzKCk7XHJcbiAgICB2YXIgYyA9IG5ldyBWZWMzKCk7XHJcbiAgICB2YXIgcG9pbnRzID0gW2EsIGIsIGNdO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmluZGljZXMubGVuZ3RoIC8gMzsgaSsrKSB7XHJcbiAgICAgICAgLy90aGlzLmdldFRyaWFuZ2xlVmVydGljZXMoaSwgYSwgYiwgYyk7XHJcblxyXG4gICAgICAgIC8vIEdldCB1bnNjYWxlZCB0cmlhbmdsZSB2ZXJ0c1xyXG4gICAgICAgIHZhciBpMyA9IGkgKiAzO1xyXG4gICAgICAgIHRoaXMuX2dldFVuc2NhbGVkVmVydGV4KHRoaXMuaW5kaWNlc1tpM10sIGEpO1xyXG4gICAgICAgIHRoaXMuX2dldFVuc2NhbGVkVmVydGV4KHRoaXMuaW5kaWNlc1tpMyArIDFdLCBiKTtcclxuICAgICAgICB0aGlzLl9nZXRVbnNjYWxlZFZlcnRleCh0aGlzLmluZGljZXNbaTMgKyAyXSwgYyk7XHJcblxyXG4gICAgICAgIHRyaWFuZ2xlQUFCQi5zZXRGcm9tUG9pbnRzKHBvaW50cyk7XHJcbiAgICAgICAgdHJlZS5pbnNlcnQodHJpYW5nbGVBQUJCLCBpKTtcclxuICAgIH1cclxuICAgIHRyZWUucmVtb3ZlRW1wdHlOb2RlcygpO1xyXG59O1xyXG5cclxudmFyIHVuc2NhbGVkQUFCQiA9IG5ldyBBQUJCKCk7XHJcblxyXG4vKipcclxuICogR2V0IHRyaWFuZ2xlcyBpbiBhIGxvY2FsIEFBQkIgZnJvbSB0aGUgdHJpbWVzaC5cclxuICogQG1ldGhvZCBnZXRUcmlhbmdsZXNJbkFBQkJcclxuICogQHBhcmFtICB7QUFCQn0gYWFiYlxyXG4gKiBAcGFyYW0gIHthcnJheX0gcmVzdWx0IEFuIGFycmF5IG9mIGludGVnZXJzLCByZWZlcmVuY2luZyB0aGUgcXVlcmllZCB0cmlhbmdsZXMuXHJcbiAqL1xyXG5UcmltZXNoLnByb3RvdHlwZS5nZXRUcmlhbmdsZXNJbkFBQkIgPSBmdW5jdGlvbihhYWJiLCByZXN1bHQpe1xyXG4gICAgdW5zY2FsZWRBQUJCLmNvcHkoYWFiYik7XHJcblxyXG4gICAgLy8gU2NhbGUgaXQgdG8gbG9jYWxcclxuICAgIHZhciBzY2FsZSA9IHRoaXMuc2NhbGU7XHJcbiAgICB2YXIgaXN4ID0gc2NhbGUueDtcclxuICAgIHZhciBpc3kgPSBzY2FsZS55O1xyXG4gICAgdmFyIGlzeiA9IHNjYWxlLno7XHJcbiAgICB2YXIgbCA9IHVuc2NhbGVkQUFCQi5sb3dlckJvdW5kO1xyXG4gICAgdmFyIHUgPSB1bnNjYWxlZEFBQkIudXBwZXJCb3VuZDtcclxuICAgIGwueCAvPSBpc3g7XHJcbiAgICBsLnkgLz0gaXN5O1xyXG4gICAgbC56IC89IGlzejtcclxuICAgIHUueCAvPSBpc3g7XHJcbiAgICB1LnkgLz0gaXN5O1xyXG4gICAgdS56IC89IGlzejtcclxuXHJcbiAgICByZXR1cm4gdGhpcy50cmVlLmFhYmJRdWVyeSh1bnNjYWxlZEFBQkIsIHJlc3VsdCk7XHJcbn07XHJcblxyXG4vKipcclxuICogQG1ldGhvZCBzZXRTY2FsZVxyXG4gKiBAcGFyYW0ge1ZlYzN9IHNjYWxlXHJcbiAqL1xyXG5UcmltZXNoLnByb3RvdHlwZS5zZXRTY2FsZSA9IGZ1bmN0aW9uKHNjYWxlKXtcclxuICAgIHZhciB3YXNVbmlmb3JtID0gdGhpcy5zY2FsZS54ID09PSB0aGlzLnNjYWxlLnkgPT09IHRoaXMuc2NhbGUuejtcclxuICAgIHZhciBpc1VuaWZvcm0gPSBzY2FsZS54ID09PSBzY2FsZS55ID09PSBzY2FsZS56O1xyXG5cclxuICAgIGlmKCEod2FzVW5pZm9ybSAmJiBpc1VuaWZvcm0pKXtcclxuICAgICAgICAvLyBOb24tdW5pZm9ybSBzY2FsaW5nLiBOZWVkIHRvIHVwZGF0ZSBub3JtYWxzLlxyXG4gICAgICAgIHRoaXMudXBkYXRlTm9ybWFscygpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5zY2FsZS5jb3B5KHNjYWxlKTtcclxuICAgIHRoaXMudXBkYXRlQUFCQigpO1xyXG4gICAgdGhpcy51cGRhdGVCb3VuZGluZ1NwaGVyZVJhZGl1cygpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbXB1dGUgdGhlIG5vcm1hbHMgb2YgdGhlIGZhY2VzLiBXaWxsIHNhdmUgaW4gdGhlIC5ub3JtYWxzIGFycmF5LlxyXG4gKiBAbWV0aG9kIHVwZGF0ZU5vcm1hbHNcclxuICovXHJcblRyaW1lc2gucHJvdG90eXBlLnVwZGF0ZU5vcm1hbHMgPSBmdW5jdGlvbigpe1xyXG4gICAgdmFyIG4gPSBjb21wdXRlTm9ybWFsc19uO1xyXG5cclxuICAgIC8vIEdlbmVyYXRlIG5vcm1hbHNcclxuICAgIHZhciBub3JtYWxzID0gdGhpcy5ub3JtYWxzO1xyXG4gICAgZm9yKHZhciBpPTA7IGkgPCB0aGlzLmluZGljZXMubGVuZ3RoIC8gMzsgaSsrKXtcclxuICAgICAgICB2YXIgaTMgPSBpICogMztcclxuXHJcbiAgICAgICAgdmFyIGEgPSB0aGlzLmluZGljZXNbaTNdLFxyXG4gICAgICAgICAgICBiID0gdGhpcy5pbmRpY2VzW2kzICsgMV0sXHJcbiAgICAgICAgICAgIGMgPSB0aGlzLmluZGljZXNbaTMgKyAyXTtcclxuXHJcbiAgICAgICAgdGhpcy5nZXRWZXJ0ZXgoYSwgdmEpO1xyXG4gICAgICAgIHRoaXMuZ2V0VmVydGV4KGIsIHZiKTtcclxuICAgICAgICB0aGlzLmdldFZlcnRleChjLCB2Yyk7XHJcblxyXG4gICAgICAgIFRyaW1lc2guY29tcHV0ZU5vcm1hbCh2YiwgdmEsIHZjLCBuKTtcclxuXHJcbiAgICAgICAgbm9ybWFsc1tpM10gPSBuLng7XHJcbiAgICAgICAgbm9ybWFsc1tpMyArIDFdID0gbi55O1xyXG4gICAgICAgIG5vcm1hbHNbaTMgKyAyXSA9IG4uejtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBVcGRhdGUgdGhlIC5lZGdlcyBwcm9wZXJ0eVxyXG4gKiBAbWV0aG9kIHVwZGF0ZUVkZ2VzXHJcbiAqL1xyXG5UcmltZXNoLnByb3RvdHlwZS51cGRhdGVFZGdlcyA9IGZ1bmN0aW9uKCl7XHJcbiAgICB2YXIgZWRnZXMgPSB7fTtcclxuICAgIHZhciBhZGQgPSBmdW5jdGlvbihpbmRleEEsIGluZGV4Qil7XHJcbiAgICAgICAgdmFyIGtleSA9IGEgPCBiID8gYSArICdfJyArIGIgOiBiICsgJ18nICsgYTtcclxuICAgICAgICBlZGdlc1trZXldID0gdHJ1ZTtcclxuICAgIH07XHJcbiAgICBmb3IodmFyIGk9MDsgaSA8IHRoaXMuaW5kaWNlcy5sZW5ndGggLyAzOyBpKyspe1xyXG4gICAgICAgIHZhciBpMyA9IGkgKiAzO1xyXG4gICAgICAgIHZhciBhID0gdGhpcy5pbmRpY2VzW2kzXSxcclxuICAgICAgICAgICAgYiA9IHRoaXMuaW5kaWNlc1tpMyArIDFdLFxyXG4gICAgICAgICAgICBjID0gdGhpcy5pbmRpY2VzW2kzICsgMl07XHJcbiAgICAgICAgYWRkKGEsYik7XHJcbiAgICAgICAgYWRkKGIsYyk7XHJcbiAgICAgICAgYWRkKGMsYSk7XHJcbiAgICB9XHJcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGVkZ2VzKTtcclxuICAgIHRoaXMuZWRnZXMgPSBuZXcgSW50MTZBcnJheShrZXlzLmxlbmd0aCAqIDIpO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdmFyIGluZGljZXMgPSBrZXlzW2ldLnNwbGl0KCdfJyk7XHJcbiAgICAgICAgdGhpcy5lZGdlc1syICogaV0gPSBwYXJzZUludChpbmRpY2VzWzBdLCAxMCk7XHJcbiAgICAgICAgdGhpcy5lZGdlc1syICogaSArIDFdID0gcGFyc2VJbnQoaW5kaWNlc1sxXSwgMTApO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldCBhbiBlZGdlIHZlcnRleFxyXG4gKiBAbWV0aG9kIGdldEVkZ2VWZXJ0ZXhcclxuICogQHBhcmFtICB7bnVtYmVyfSBlZGdlSW5kZXhcclxuICogQHBhcmFtICB7bnVtYmVyfSBmaXJzdE9yU2Vjb25kIDAgb3IgMSwgZGVwZW5kaW5nIG9uIHdoaWNoIG9uZSBvZiB0aGUgdmVydGljZXMgeW91IG5lZWQuXHJcbiAqIEBwYXJhbSAge1ZlYzN9IHZlcnRleFN0b3JlIFdoZXJlIHRvIHN0b3JlIHRoZSByZXN1bHRcclxuICovXHJcblRyaW1lc2gucHJvdG90eXBlLmdldEVkZ2VWZXJ0ZXggPSBmdW5jdGlvbihlZGdlSW5kZXgsIGZpcnN0T3JTZWNvbmQsIHZlcnRleFN0b3JlKXtcclxuICAgIHZhciB2ZXJ0ZXhJbmRleCA9IHRoaXMuZWRnZXNbZWRnZUluZGV4ICogMiArIChmaXJzdE9yU2Vjb25kID8gMSA6IDApXTtcclxuICAgIHRoaXMuZ2V0VmVydGV4KHZlcnRleEluZGV4LCB2ZXJ0ZXhTdG9yZSk7XHJcbn07XHJcblxyXG52YXIgZ2V0RWRnZVZlY3Rvcl92YSA9IG5ldyBWZWMzKCk7XHJcbnZhciBnZXRFZGdlVmVjdG9yX3ZiID0gbmV3IFZlYzMoKTtcclxuXHJcbi8qKlxyXG4gKiBHZXQgYSB2ZWN0b3IgYWxvbmcgYW4gZWRnZS5cclxuICogQG1ldGhvZCBnZXRFZGdlVmVjdG9yXHJcbiAqIEBwYXJhbSAge251bWJlcn0gZWRnZUluZGV4XHJcbiAqIEBwYXJhbSAge1ZlYzN9IHZlY3RvclN0b3JlXHJcbiAqL1xyXG5UcmltZXNoLnByb3RvdHlwZS5nZXRFZGdlVmVjdG9yID0gZnVuY3Rpb24oZWRnZUluZGV4LCB2ZWN0b3JTdG9yZSl7XHJcbiAgICB2YXIgdmEgPSBnZXRFZGdlVmVjdG9yX3ZhO1xyXG4gICAgdmFyIHZiID0gZ2V0RWRnZVZlY3Rvcl92YjtcclxuICAgIHRoaXMuZ2V0RWRnZVZlcnRleChlZGdlSW5kZXgsIDAsIHZhKTtcclxuICAgIHRoaXMuZ2V0RWRnZVZlcnRleChlZGdlSW5kZXgsIDEsIHZiKTtcclxuICAgIHZiLnZzdWIodmEsIHZlY3RvclN0b3JlKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXQgZmFjZSBub3JtYWwgZ2l2ZW4gMyB2ZXJ0aWNlc1xyXG4gKiBAc3RhdGljXHJcbiAqIEBtZXRob2QgY29tcHV0ZU5vcm1hbFxyXG4gKiBAcGFyYW0ge1ZlYzN9IHZhXHJcbiAqIEBwYXJhbSB7VmVjM30gdmJcclxuICogQHBhcmFtIHtWZWMzfSB2Y1xyXG4gKiBAcGFyYW0ge1ZlYzN9IHRhcmdldFxyXG4gKi9cclxudmFyIGNiID0gbmV3IFZlYzMoKTtcclxudmFyIGFiID0gbmV3IFZlYzMoKTtcclxuVHJpbWVzaC5jb21wdXRlTm9ybWFsID0gZnVuY3Rpb24gKCB2YSwgdmIsIHZjLCB0YXJnZXQgKSB7XHJcbiAgICB2Yi52c3ViKHZhLGFiKTtcclxuICAgIHZjLnZzdWIodmIsY2IpO1xyXG4gICAgY2IuY3Jvc3MoYWIsdGFyZ2V0KTtcclxuICAgIGlmICggIXRhcmdldC5pc1plcm8oKSApIHtcclxuICAgICAgICB0YXJnZXQubm9ybWFsaXplKCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG52YXIgdmEgPSBuZXcgVmVjMygpO1xyXG52YXIgdmIgPSBuZXcgVmVjMygpO1xyXG52YXIgdmMgPSBuZXcgVmVjMygpO1xyXG5cclxuLyoqXHJcbiAqIEdldCB2ZXJ0ZXggaS5cclxuICogQG1ldGhvZCBnZXRWZXJ0ZXhcclxuICogQHBhcmFtICB7bnVtYmVyfSBpXHJcbiAqIEBwYXJhbSAge1ZlYzN9IG91dFxyXG4gKiBAcmV0dXJuIHtWZWMzfSBUaGUgXCJvdXRcIiB2ZWN0b3Igb2JqZWN0XHJcbiAqL1xyXG5UcmltZXNoLnByb3RvdHlwZS5nZXRWZXJ0ZXggPSBmdW5jdGlvbihpLCBvdXQpe1xyXG4gICAgdmFyIHNjYWxlID0gdGhpcy5zY2FsZTtcclxuICAgIHRoaXMuX2dldFVuc2NhbGVkVmVydGV4KGksIG91dCk7XHJcbiAgICBvdXQueCAqPSBzY2FsZS54O1xyXG4gICAgb3V0LnkgKj0gc2NhbGUueTtcclxuICAgIG91dC56ICo9IHNjYWxlLno7XHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldCByYXcgdmVydGV4IGlcclxuICogQHByaXZhdGVcclxuICogQG1ldGhvZCBfZ2V0VW5zY2FsZWRWZXJ0ZXhcclxuICogQHBhcmFtICB7bnVtYmVyfSBpXHJcbiAqIEBwYXJhbSAge1ZlYzN9IG91dFxyXG4gKiBAcmV0dXJuIHtWZWMzfSBUaGUgXCJvdXRcIiB2ZWN0b3Igb2JqZWN0XHJcbiAqL1xyXG5UcmltZXNoLnByb3RvdHlwZS5fZ2V0VW5zY2FsZWRWZXJ0ZXggPSBmdW5jdGlvbihpLCBvdXQpe1xyXG4gICAgdmFyIGkzID0gaSAqIDM7XHJcbiAgICB2YXIgdmVydGljZXMgPSB0aGlzLnZlcnRpY2VzO1xyXG4gICAgcmV0dXJuIG91dC5zZXQoXHJcbiAgICAgICAgdmVydGljZXNbaTNdLFxyXG4gICAgICAgIHZlcnRpY2VzW2kzICsgMV0sXHJcbiAgICAgICAgdmVydGljZXNbaTMgKyAyXVxyXG4gICAgKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXQgYSB2ZXJ0ZXggZnJvbSB0aGUgdHJpbWVzaCx0cmFuc2Zvcm1lZCBieSB0aGUgZ2l2ZW4gcG9zaXRpb24gYW5kIHF1YXRlcm5pb24uXHJcbiAqIEBtZXRob2QgZ2V0V29ybGRWZXJ0ZXhcclxuICogQHBhcmFtICB7bnVtYmVyfSBpXHJcbiAqIEBwYXJhbSAge1ZlYzN9IHBvc1xyXG4gKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSBxdWF0XHJcbiAqIEBwYXJhbSAge1ZlYzN9IG91dFxyXG4gKiBAcmV0dXJuIHtWZWMzfSBUaGUgXCJvdXRcIiB2ZWN0b3Igb2JqZWN0XHJcbiAqL1xyXG5UcmltZXNoLnByb3RvdHlwZS5nZXRXb3JsZFZlcnRleCA9IGZ1bmN0aW9uKGksIHBvcywgcXVhdCwgb3V0KXtcclxuICAgIHRoaXMuZ2V0VmVydGV4KGksIG91dCk7XHJcbiAgICBUcmFuc2Zvcm0ucG9pbnRUb1dvcmxkRnJhbWUocG9zLCBxdWF0LCBvdXQsIG91dCk7XHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldCB0aGUgdGhyZWUgdmVydGljZXMgZm9yIHRyaWFuZ2xlIGkuXHJcbiAqIEBtZXRob2QgZ2V0VHJpYW5nbGVWZXJ0aWNlc1xyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IGlcclxuICogQHBhcmFtICB7VmVjM30gYVxyXG4gKiBAcGFyYW0gIHtWZWMzfSBiXHJcbiAqIEBwYXJhbSAge1ZlYzN9IGNcclxuICovXHJcblRyaW1lc2gucHJvdG90eXBlLmdldFRyaWFuZ2xlVmVydGljZXMgPSBmdW5jdGlvbihpLCBhLCBiLCBjKXtcclxuICAgIHZhciBpMyA9IGkgKiAzO1xyXG4gICAgdGhpcy5nZXRWZXJ0ZXgodGhpcy5pbmRpY2VzW2kzXSwgYSk7XHJcbiAgICB0aGlzLmdldFZlcnRleCh0aGlzLmluZGljZXNbaTMgKyAxXSwgYik7XHJcbiAgICB0aGlzLmdldFZlcnRleCh0aGlzLmluZGljZXNbaTMgKyAyXSwgYyk7XHJcbn07XHJcblxyXG4vKipcclxuICogQ29tcHV0ZSB0aGUgbm9ybWFsIG9mIHRyaWFuZ2xlIGkuXHJcbiAqIEBtZXRob2QgZ2V0Tm9ybWFsXHJcbiAqIEBwYXJhbSAge051bWJlcn0gaVxyXG4gKiBAcGFyYW0gIHtWZWMzfSB0YXJnZXRcclxuICogQHJldHVybiB7VmVjM30gVGhlIFwidGFyZ2V0XCIgdmVjdG9yIG9iamVjdFxyXG4gKi9cclxuVHJpbWVzaC5wcm90b3R5cGUuZ2V0Tm9ybWFsID0gZnVuY3Rpb24oaSwgdGFyZ2V0KXtcclxuICAgIHZhciBpMyA9IGkgKiAzO1xyXG4gICAgcmV0dXJuIHRhcmdldC5zZXQoXHJcbiAgICAgICAgdGhpcy5ub3JtYWxzW2kzXSxcclxuICAgICAgICB0aGlzLm5vcm1hbHNbaTMgKyAxXSxcclxuICAgICAgICB0aGlzLm5vcm1hbHNbaTMgKyAyXVxyXG4gICAgKTtcclxufTtcclxuXHJcbnZhciBjbGlfYWFiYiA9IG5ldyBBQUJCKCk7XHJcblxyXG4vKipcclxuICogQG1ldGhvZCBjYWxjdWxhdGVMb2NhbEluZXJ0aWFcclxuICogQHBhcmFtICB7TnVtYmVyfSBtYXNzXHJcbiAqIEBwYXJhbSAge1ZlYzN9IHRhcmdldFxyXG4gKiBAcmV0dXJuIHtWZWMzfSBUaGUgXCJ0YXJnZXRcIiB2ZWN0b3Igb2JqZWN0XHJcbiAqL1xyXG5UcmltZXNoLnByb3RvdHlwZS5jYWxjdWxhdGVMb2NhbEluZXJ0aWEgPSBmdW5jdGlvbihtYXNzLHRhcmdldCl7XHJcbiAgICAvLyBBcHByb3hpbWF0ZSB3aXRoIGJveCBpbmVydGlhXHJcbiAgICAvLyBFeGFjdCBpbmVydGlhIGNhbGN1bGF0aW9uIGlzIG92ZXJraWxsLCBidXQgc2VlIGh0dHA6Ly9nZW9tZXRyaWN0b29scy5jb20vRG9jdW1lbnRhdGlvbi9Qb2x5aGVkcmFsTWFzc1Byb3BlcnRpZXMucGRmIGZvciB0aGUgY29ycmVjdCB3YXkgdG8gZG8gaXRcclxuICAgIHRoaXMuY29tcHV0ZUxvY2FsQUFCQihjbGlfYWFiYik7XHJcbiAgICB2YXIgeCA9IGNsaV9hYWJiLnVwcGVyQm91bmQueCAtIGNsaV9hYWJiLmxvd2VyQm91bmQueCxcclxuICAgICAgICB5ID0gY2xpX2FhYmIudXBwZXJCb3VuZC55IC0gY2xpX2FhYmIubG93ZXJCb3VuZC55LFxyXG4gICAgICAgIHogPSBjbGlfYWFiYi51cHBlckJvdW5kLnogLSBjbGlfYWFiYi5sb3dlckJvdW5kLno7XHJcbiAgICByZXR1cm4gdGFyZ2V0LnNldChcclxuICAgICAgICAxLjAgLyAxMi4wICogbWFzcyAqICggMip5KjIqeSArIDIqeioyKnogKSxcclxuICAgICAgICAxLjAgLyAxMi4wICogbWFzcyAqICggMip4KjIqeCArIDIqeioyKnogKSxcclxuICAgICAgICAxLjAgLyAxMi4wICogbWFzcyAqICggMip5KjIqeSArIDIqeCoyKnggKVxyXG4gICAgKTtcclxufTtcclxuXHJcbnZhciBjb21wdXRlTG9jYWxBQUJCX3dvcmxkVmVydCA9IG5ldyBWZWMzKCk7XHJcblxyXG4vKipcclxuICogQ29tcHV0ZSB0aGUgbG9jYWwgQUFCQiBmb3IgdGhlIHRyaW1lc2hcclxuICogQG1ldGhvZCBjb21wdXRlTG9jYWxBQUJCXHJcbiAqIEBwYXJhbSAge0FBQkJ9IGFhYmJcclxuICovXHJcblRyaW1lc2gucHJvdG90eXBlLmNvbXB1dGVMb2NhbEFBQkIgPSBmdW5jdGlvbihhYWJiKXtcclxuICAgIHZhciBsID0gYWFiYi5sb3dlckJvdW5kLFxyXG4gICAgICAgIHUgPSBhYWJiLnVwcGVyQm91bmQsXHJcbiAgICAgICAgbiA9IHRoaXMudmVydGljZXMubGVuZ3RoLFxyXG4gICAgICAgIHZlcnRpY2VzID0gdGhpcy52ZXJ0aWNlcyxcclxuICAgICAgICB2ID0gY29tcHV0ZUxvY2FsQUFCQl93b3JsZFZlcnQ7XHJcblxyXG4gICAgdGhpcy5nZXRWZXJ0ZXgoMCwgdik7XHJcbiAgICBsLmNvcHkodik7XHJcbiAgICB1LmNvcHkodik7XHJcblxyXG4gICAgZm9yKHZhciBpPTA7IGkgIT09IG47IGkrKyl7XHJcbiAgICAgICAgdGhpcy5nZXRWZXJ0ZXgoaSwgdik7XHJcblxyXG4gICAgICAgIGlmKHYueCA8IGwueCl7XHJcbiAgICAgICAgICAgIGwueCA9IHYueDtcclxuICAgICAgICB9IGVsc2UgaWYodi54ID4gdS54KXtcclxuICAgICAgICAgICAgdS54ID0gdi54O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYodi55IDwgbC55KXtcclxuICAgICAgICAgICAgbC55ID0gdi55O1xyXG4gICAgICAgIH0gZWxzZSBpZih2LnkgPiB1Lnkpe1xyXG4gICAgICAgICAgICB1LnkgPSB2Lnk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZih2LnogPCBsLnope1xyXG4gICAgICAgICAgICBsLnogPSB2Lno7XHJcbiAgICAgICAgfSBlbHNlIGlmKHYueiA+IHUueil7XHJcbiAgICAgICAgICAgIHUueiA9IHYuejtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIFVwZGF0ZSB0aGUgLmFhYmIgcHJvcGVydHlcclxuICogQG1ldGhvZCB1cGRhdGVBQUJCXHJcbiAqL1xyXG5UcmltZXNoLnByb3RvdHlwZS51cGRhdGVBQUJCID0gZnVuY3Rpb24oKXtcclxuICAgIHRoaXMuY29tcHV0ZUxvY2FsQUFCQih0aGlzLmFhYmIpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFdpbGwgdXBkYXRlIHRoZSAuYm91bmRpbmdTcGhlcmVSYWRpdXMgcHJvcGVydHlcclxuICogQG1ldGhvZCB1cGRhdGVCb3VuZGluZ1NwaGVyZVJhZGl1c1xyXG4gKi9cclxuVHJpbWVzaC5wcm90b3R5cGUudXBkYXRlQm91bmRpbmdTcGhlcmVSYWRpdXMgPSBmdW5jdGlvbigpe1xyXG4gICAgLy8gQXNzdW1lIHBvaW50cyBhcmUgZGlzdHJpYnV0ZWQgd2l0aCBsb2NhbCAoMCwwLDApIGFzIGNlbnRlclxyXG4gICAgdmFyIG1heDIgPSAwO1xyXG4gICAgdmFyIHZlcnRpY2VzID0gdGhpcy52ZXJ0aWNlcztcclxuICAgIHZhciB2ID0gbmV3IFZlYzMoKTtcclxuICAgIGZvcih2YXIgaT0wLCBOPXZlcnRpY2VzLmxlbmd0aCAvIDM7IGkgIT09IE47IGkrKykge1xyXG4gICAgICAgIHRoaXMuZ2V0VmVydGV4KGksIHYpO1xyXG4gICAgICAgIHZhciBub3JtMiA9IHYubm9ybTIoKTtcclxuICAgICAgICBpZihub3JtMiA+IG1heDIpe1xyXG4gICAgICAgICAgICBtYXgyID0gbm9ybTI7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdGhpcy5ib3VuZGluZ1NwaGVyZVJhZGl1cyA9IE1hdGguc3FydChtYXgyKTtcclxufTtcclxuXHJcbnZhciB0ZW1wV29ybGRWZXJ0ZXggPSBuZXcgVmVjMygpO1xyXG52YXIgY2FsY3VsYXRlV29ybGRBQUJCX2ZyYW1lID0gbmV3IFRyYW5zZm9ybSgpO1xyXG52YXIgY2FsY3VsYXRlV29ybGRBQUJCX2FhYmIgPSBuZXcgQUFCQigpO1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgY2FsY3VsYXRlV29ybGRBQUJCXHJcbiAqIEBwYXJhbSB7VmVjM30gICAgICAgIHBvc1xyXG4gKiBAcGFyYW0ge1F1YXRlcm5pb259ICBxdWF0XHJcbiAqIEBwYXJhbSB7VmVjM30gICAgICAgIG1pblxyXG4gKiBAcGFyYW0ge1ZlYzN9ICAgICAgICBtYXhcclxuICovXHJcblRyaW1lc2gucHJvdG90eXBlLmNhbGN1bGF0ZVdvcmxkQUFCQiA9IGZ1bmN0aW9uKHBvcyxxdWF0LG1pbixtYXgpe1xyXG4gICAgLypcclxuICAgIHZhciBuID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGggLyAzLFxyXG4gICAgICAgIHZlcnRzID0gdGhpcy52ZXJ0aWNlcztcclxuICAgIHZhciBtaW54LG1pbnksbWlueixtYXh4LG1heHksbWF4ejtcclxuXHJcbiAgICB2YXIgdiA9IHRlbXBXb3JsZFZlcnRleDtcclxuICAgIGZvcih2YXIgaT0wOyBpPG47IGkrKyl7XHJcbiAgICAgICAgdGhpcy5nZXRWZXJ0ZXgoaSwgdik7XHJcbiAgICAgICAgcXVhdC52bXVsdCh2LCB2KTtcclxuICAgICAgICBwb3MudmFkZCh2LCB2KTtcclxuICAgICAgICBpZiAodi54IDwgbWlueCB8fCBtaW54PT09dW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgbWlueCA9IHYueDtcclxuICAgICAgICB9IGVsc2UgaWYodi54ID4gbWF4eCB8fCBtYXh4PT09dW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgbWF4eCA9IHYueDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh2LnkgPCBtaW55IHx8IG1pbnk9PT11bmRlZmluZWQpe1xyXG4gICAgICAgICAgICBtaW55ID0gdi55O1xyXG4gICAgICAgIH0gZWxzZSBpZih2LnkgPiBtYXh5IHx8IG1heHk9PT11bmRlZmluZWQpe1xyXG4gICAgICAgICAgICBtYXh5ID0gdi55O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHYueiA8IG1pbnogfHwgbWluej09PXVuZGVmaW5lZCl7XHJcbiAgICAgICAgICAgIG1pbnogPSB2Lno7XHJcbiAgICAgICAgfSBlbHNlIGlmKHYueiA+IG1heHogfHwgbWF4ej09PXVuZGVmaW5lZCl7XHJcbiAgICAgICAgICAgIG1heHogPSB2Lno7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgbWluLnNldChtaW54LG1pbnksbWlueik7XHJcbiAgICBtYXguc2V0KG1heHgsbWF4eSxtYXh6KTtcclxuICAgICovXHJcblxyXG4gICAgLy8gRmFzdGVyIGFwcHJveGltYXRpb24gdXNpbmcgbG9jYWwgQUFCQlxyXG4gICAgdmFyIGZyYW1lID0gY2FsY3VsYXRlV29ybGRBQUJCX2ZyYW1lO1xyXG4gICAgdmFyIHJlc3VsdCA9IGNhbGN1bGF0ZVdvcmxkQUFCQl9hYWJiO1xyXG4gICAgZnJhbWUucG9zaXRpb24gPSBwb3M7XHJcbiAgICBmcmFtZS5xdWF0ZXJuaW9uID0gcXVhdDtcclxuICAgIHRoaXMuYWFiYi50b1dvcmxkRnJhbWUoZnJhbWUsIHJlc3VsdCk7XHJcbiAgICBtaW4uY29weShyZXN1bHQubG93ZXJCb3VuZCk7XHJcbiAgICBtYXguY29weShyZXN1bHQudXBwZXJCb3VuZCk7XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0IGFwcHJveGltYXRlIHZvbHVtZVxyXG4gKiBAbWV0aG9kIHZvbHVtZVxyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XHJcbiAqL1xyXG5UcmltZXNoLnByb3RvdHlwZS52b2x1bWUgPSBmdW5jdGlvbigpe1xyXG4gICAgcmV0dXJuIDQuMCAqIE1hdGguUEkgKiB0aGlzLmJvdW5kaW5nU3BoZXJlUmFkaXVzIC8gMy4wO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZSBhIFRyaW1lc2ggaW5zdGFuY2UsIHNoYXBlZCBhcyBhIHRvcnVzLlxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZXRob2QgY3JlYXRlVG9ydXNcclxuICogQHBhcmFtICB7bnVtYmVyfSBbcmFkaXVzPTFdXHJcbiAqIEBwYXJhbSAge251bWJlcn0gW3R1YmU9MC41XVxyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFtyYWRpYWxTZWdtZW50cz04XVxyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFt0dWJ1bGFyU2VnbWVudHM9Nl1cclxuICogQHBhcmFtICB7bnVtYmVyfSBbYXJjPTYuMjgzMTg1MzA3MTc5NTg2XVxyXG4gKiBAcmV0dXJuIHtUcmltZXNofSBBIHRvcnVzXHJcbiAqL1xyXG5UcmltZXNoLmNyZWF0ZVRvcnVzID0gZnVuY3Rpb24gKHJhZGl1cywgdHViZSwgcmFkaWFsU2VnbWVudHMsIHR1YnVsYXJTZWdtZW50cywgYXJjKSB7XHJcbiAgICByYWRpdXMgPSByYWRpdXMgfHwgMTtcclxuICAgIHR1YmUgPSB0dWJlIHx8IDAuNTtcclxuICAgIHJhZGlhbFNlZ21lbnRzID0gcmFkaWFsU2VnbWVudHMgfHwgODtcclxuICAgIHR1YnVsYXJTZWdtZW50cyA9IHR1YnVsYXJTZWdtZW50cyB8fCA2O1xyXG4gICAgYXJjID0gYXJjIHx8IE1hdGguUEkgKiAyO1xyXG5cclxuICAgIHZhciB2ZXJ0aWNlcyA9IFtdO1xyXG4gICAgdmFyIGluZGljZXMgPSBbXTtcclxuXHJcbiAgICBmb3IgKCB2YXIgaiA9IDA7IGogPD0gcmFkaWFsU2VnbWVudHM7IGogKysgKSB7XHJcbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDw9IHR1YnVsYXJTZWdtZW50czsgaSArKyApIHtcclxuICAgICAgICAgICAgdmFyIHUgPSBpIC8gdHVidWxhclNlZ21lbnRzICogYXJjO1xyXG4gICAgICAgICAgICB2YXIgdiA9IGogLyByYWRpYWxTZWdtZW50cyAqIE1hdGguUEkgKiAyO1xyXG5cclxuICAgICAgICAgICAgdmFyIHggPSAoIHJhZGl1cyArIHR1YmUgKiBNYXRoLmNvcyggdiApICkgKiBNYXRoLmNvcyggdSApO1xyXG4gICAgICAgICAgICB2YXIgeSA9ICggcmFkaXVzICsgdHViZSAqIE1hdGguY29zKCB2ICkgKSAqIE1hdGguc2luKCB1ICk7XHJcbiAgICAgICAgICAgIHZhciB6ID0gdHViZSAqIE1hdGguc2luKCB2ICk7XHJcblxyXG4gICAgICAgICAgICB2ZXJ0aWNlcy5wdXNoKCB4LCB5LCB6ICk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZvciAoIHZhciBqID0gMTsgaiA8PSByYWRpYWxTZWdtZW50czsgaiArKyApIHtcclxuICAgICAgICBmb3IgKCB2YXIgaSA9IDE7IGkgPD0gdHVidWxhclNlZ21lbnRzOyBpICsrICkge1xyXG4gICAgICAgICAgICB2YXIgYSA9ICggdHVidWxhclNlZ21lbnRzICsgMSApICogaiArIGkgLSAxO1xyXG4gICAgICAgICAgICB2YXIgYiA9ICggdHVidWxhclNlZ21lbnRzICsgMSApICogKCBqIC0gMSApICsgaSAtIDE7XHJcbiAgICAgICAgICAgIHZhciBjID0gKCB0dWJ1bGFyU2VnbWVudHMgKyAxICkgKiAoIGogLSAxICkgKyBpO1xyXG4gICAgICAgICAgICB2YXIgZCA9ICggdHVidWxhclNlZ21lbnRzICsgMSApICogaiArIGk7XHJcblxyXG4gICAgICAgICAgICBpbmRpY2VzLnB1c2goYSwgYiwgZCk7XHJcbiAgICAgICAgICAgIGluZGljZXMucHVzaChiLCBjLCBkKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG5ldyBUcmltZXNoKHZlcnRpY2VzLCBpbmRpY2VzKTtcclxufTtcclxuXHJcbn0se1wiLi4vY29sbGlzaW9uL0FBQkJcIjozLFwiLi4vbWF0aC9RdWF0ZXJuaW9uXCI6MjksXCIuLi9tYXRoL1RyYW5zZm9ybVwiOjMwLFwiLi4vbWF0aC9WZWMzXCI6MzEsXCIuLi91dGlscy9PY3RyZWVcIjo1MSxcIi4vU2hhcGVcIjo0NH1dLDQ3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcclxubW9kdWxlLmV4cG9ydHMgPSBHU1NvbHZlcjtcclxuXHJcbnZhciBWZWMzID0gX2RlcmVxXygnLi4vbWF0aC9WZWMzJyk7XHJcbnZhciBRdWF0ZXJuaW9uID0gX2RlcmVxXygnLi4vbWF0aC9RdWF0ZXJuaW9uJyk7XHJcbnZhciBTb2x2ZXIgPSBfZGVyZXFfKCcuL1NvbHZlcicpO1xyXG5cclxuLyoqXHJcbiAqIENvbnN0cmFpbnQgZXF1YXRpb24gR2F1c3MtU2VpZGVsIHNvbHZlci5cclxuICogQGNsYXNzIEdTU29sdmVyXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAdG9kbyBUaGUgc3Bvb2sgcGFyYW1ldGVycyBzaG91bGQgYmUgc3BlY2lmaWVkIGZvciBlYWNoIGNvbnN0cmFpbnQsIG5vdCBnbG9iYWxseS5cclxuICogQGF1dGhvciBzY2h0ZXBwZSAvIGh0dHBzOi8vZ2l0aHViLmNvbS9zY2h0ZXBwZVxyXG4gKiBAc2VlIGh0dHBzOi8vd3d3OC5jcy51bXUuc2Uva3Vyc2VyLzVEVjA1OC9WVDA5L2xlY3R1cmVzL3Nwb29rbm90ZXMucGRmXHJcbiAqIEBleHRlbmRzIFNvbHZlclxyXG4gKi9cclxuZnVuY3Rpb24gR1NTb2x2ZXIoKXtcclxuICAgIFNvbHZlci5jYWxsKHRoaXMpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG51bWJlciBvZiBzb2x2ZXIgaXRlcmF0aW9ucyBkZXRlcm1pbmVzIHF1YWxpdHkgb2YgdGhlIGNvbnN0cmFpbnRzIGluIHRoZSB3b3JsZC4gVGhlIG1vcmUgaXRlcmF0aW9ucywgdGhlIG1vcmUgY29ycmVjdCBzaW11bGF0aW9uLiBNb3JlIGl0ZXJhdGlvbnMgbmVlZCBtb3JlIGNvbXB1dGF0aW9ucyB0aG91Z2guIElmIHlvdSBoYXZlIGEgbGFyZ2UgZ3Jhdml0eSBmb3JjZSBpbiB5b3VyIHdvcmxkLCB5b3Ugd2lsbCBuZWVkIG1vcmUgaXRlcmF0aW9ucy5cclxuICAgICAqIEBwcm9wZXJ0eSBpdGVyYXRpb25zXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQHRvZG8gd3JpdGUgbW9yZSBhYm91dCBzb2x2ZXIgYW5kIGl0ZXJhdGlvbnMgaW4gdGhlIHdpa2lcclxuICAgICAqL1xyXG4gICAgdGhpcy5pdGVyYXRpb25zID0gMTA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGVuIHRvbGVyYW5jZSBpcyByZWFjaGVkLCB0aGUgc3lzdGVtIGlzIGFzc3VtZWQgdG8gYmUgY29udmVyZ2VkLlxyXG4gICAgICogQHByb3BlcnR5IHRvbGVyYW5jZVxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy50b2xlcmFuY2UgPSAxZS03O1xyXG59XHJcbkdTU29sdmVyLnByb3RvdHlwZSA9IG5ldyBTb2x2ZXIoKTtcclxuXHJcbnZhciBHU1NvbHZlcl9zb2x2ZV9sYW1iZGEgPSBbXTsgLy8gSnVzdCB0ZW1wb3JhcnkgbnVtYmVyIGhvbGRlcnMgdGhhdCB3ZSB3YW50IHRvIHJldXNlIGVhY2ggc29sdmUuXHJcbnZhciBHU1NvbHZlcl9zb2x2ZV9pbnZDcyA9IFtdO1xyXG52YXIgR1NTb2x2ZXJfc29sdmVfQnMgPSBbXTtcclxuR1NTb2x2ZXIucHJvdG90eXBlLnNvbHZlID0gZnVuY3Rpb24oZHQsd29ybGQpe1xyXG4gICAgdmFyIGl0ZXIgPSAwLFxyXG4gICAgICAgIG1heEl0ZXIgPSB0aGlzLml0ZXJhdGlvbnMsXHJcbiAgICAgICAgdG9sU3F1YXJlZCA9IHRoaXMudG9sZXJhbmNlKnRoaXMudG9sZXJhbmNlLFxyXG4gICAgICAgIGVxdWF0aW9ucyA9IHRoaXMuZXF1YXRpb25zLFxyXG4gICAgICAgIE5lcSA9IGVxdWF0aW9ucy5sZW5ndGgsXHJcbiAgICAgICAgYm9kaWVzID0gd29ybGQuYm9kaWVzLFxyXG4gICAgICAgIE5ib2RpZXMgPSBib2RpZXMubGVuZ3RoLFxyXG4gICAgICAgIGggPSBkdCxcclxuICAgICAgICBxLCBCLCBpbnZDLCBkZWx0YWxhbWJkYSwgZGVsdGFsYW1iZGFUb3QsIEdXbGFtYmRhLCBsYW1iZGFqO1xyXG5cclxuICAgIC8vIFVwZGF0ZSBzb2x2ZSBtYXNzXHJcbiAgICBpZihOZXEgIT09IDApe1xyXG4gICAgICAgIGZvcih2YXIgaT0wOyBpIT09TmJvZGllczsgaSsrKXtcclxuICAgICAgICAgICAgYm9kaWVzW2ldLnVwZGF0ZVNvbHZlTWFzc1Byb3BlcnRpZXMoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVGhpbmdzIHRoYXQgZG9lcyBub3QgY2hhbmdlIGR1cmluZyBpdGVyYXRpb24gY2FuIGJlIGNvbXB1dGVkIG9uY2VcclxuICAgIHZhciBpbnZDcyA9IEdTU29sdmVyX3NvbHZlX2ludkNzLFxyXG4gICAgICAgIEJzID0gR1NTb2x2ZXJfc29sdmVfQnMsXHJcbiAgICAgICAgbGFtYmRhID0gR1NTb2x2ZXJfc29sdmVfbGFtYmRhO1xyXG4gICAgaW52Q3MubGVuZ3RoID0gTmVxO1xyXG4gICAgQnMubGVuZ3RoID0gTmVxO1xyXG4gICAgbGFtYmRhLmxlbmd0aCA9IE5lcTtcclxuICAgIGZvcih2YXIgaT0wOyBpIT09TmVxOyBpKyspe1xyXG4gICAgICAgIHZhciBjID0gZXF1YXRpb25zW2ldO1xyXG4gICAgICAgIGxhbWJkYVtpXSA9IDAuMDtcclxuICAgICAgICBCc1tpXSA9IGMuY29tcHV0ZUIoaCk7XHJcbiAgICAgICAgaW52Q3NbaV0gPSAxLjAgLyBjLmNvbXB1dGVDKCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYoTmVxICE9PSAwKXtcclxuXHJcbiAgICAgICAgLy8gUmVzZXQgdmxhbWJkYVxyXG4gICAgICAgIGZvcih2YXIgaT0wOyBpIT09TmJvZGllczsgaSsrKXtcclxuICAgICAgICAgICAgdmFyIGI9Ym9kaWVzW2ldLFxyXG4gICAgICAgICAgICAgICAgdmxhbWJkYT1iLnZsYW1iZGEsXHJcbiAgICAgICAgICAgICAgICB3bGFtYmRhPWIud2xhbWJkYTtcclxuICAgICAgICAgICAgdmxhbWJkYS5zZXQoMCwwLDApO1xyXG4gICAgICAgICAgICB3bGFtYmRhLnNldCgwLDAsMCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBJdGVyYXRlIG92ZXIgZXF1YXRpb25zXHJcbiAgICAgICAgZm9yKGl0ZXI9MDsgaXRlciE9PW1heEl0ZXI7IGl0ZXIrKyl7XHJcblxyXG4gICAgICAgICAgICAvLyBBY2N1bXVsYXRlIHRoZSB0b3RhbCBlcnJvciBmb3IgZWFjaCBpdGVyYXRpb24uXHJcbiAgICAgICAgICAgIGRlbHRhbGFtYmRhVG90ID0gMC4wO1xyXG5cclxuICAgICAgICAgICAgZm9yKHZhciBqPTA7IGohPT1OZXE7IGorKyl7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGMgPSBlcXVhdGlvbnNbal07XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ29tcHV0ZSBpdGVyYXRpb25cclxuICAgICAgICAgICAgICAgIEIgPSBCc1tqXTtcclxuICAgICAgICAgICAgICAgIGludkMgPSBpbnZDc1tqXTtcclxuICAgICAgICAgICAgICAgIGxhbWJkYWogPSBsYW1iZGFbal07XHJcbiAgICAgICAgICAgICAgICBHV2xhbWJkYSA9IGMuY29tcHV0ZUdXbGFtYmRhKCk7XHJcbiAgICAgICAgICAgICAgICBkZWx0YWxhbWJkYSA9IGludkMgKiAoIEIgLSBHV2xhbWJkYSAtIGMuZXBzICogbGFtYmRhaiApO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIENsYW1wIGlmIHdlIGFyZSBub3Qgd2l0aGluIHRoZSBtaW4vbWF4IGludGVydmFsXHJcbiAgICAgICAgICAgICAgICBpZihsYW1iZGFqICsgZGVsdGFsYW1iZGEgPCBjLm1pbkZvcmNlKXtcclxuICAgICAgICAgICAgICAgICAgICBkZWx0YWxhbWJkYSA9IGMubWluRm9yY2UgLSBsYW1iZGFqO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmKGxhbWJkYWogKyBkZWx0YWxhbWJkYSA+IGMubWF4Rm9yY2Upe1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbHRhbGFtYmRhID0gYy5tYXhGb3JjZSAtIGxhbWJkYWo7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsYW1iZGFbal0gKz0gZGVsdGFsYW1iZGE7XHJcblxyXG4gICAgICAgICAgICAgICAgZGVsdGFsYW1iZGFUb3QgKz0gZGVsdGFsYW1iZGEgPiAwLjAgPyBkZWx0YWxhbWJkYSA6IC1kZWx0YWxhbWJkYTsgLy8gYWJzKGRlbHRhbGFtYmRhKVxyXG5cclxuICAgICAgICAgICAgICAgIGMuYWRkVG9XbGFtYmRhKGRlbHRhbGFtYmRhKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gSWYgdGhlIHRvdGFsIGVycm9yIGlzIHNtYWxsIGVub3VnaCAtIHN0b3AgaXRlcmF0ZVxyXG4gICAgICAgICAgICBpZihkZWx0YWxhbWJkYVRvdCpkZWx0YWxhbWJkYVRvdCA8IHRvbFNxdWFyZWQpe1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEFkZCByZXN1bHQgdG8gdmVsb2NpdHlcclxuICAgICAgICBmb3IodmFyIGk9MDsgaSE9PU5ib2RpZXM7IGkrKyl7XHJcbiAgICAgICAgICAgIHZhciBiPWJvZGllc1tpXSxcclxuICAgICAgICAgICAgICAgIHY9Yi52ZWxvY2l0eSxcclxuICAgICAgICAgICAgICAgIHc9Yi5hbmd1bGFyVmVsb2NpdHk7XHJcblxyXG4gICAgICAgICAgICBiLnZsYW1iZGEudm11bChiLmxpbmVhckZhY3RvciwgYi52bGFtYmRhKTtcclxuICAgICAgICAgICAgdi52YWRkKGIudmxhbWJkYSwgdik7XHJcblxyXG4gICAgICAgICAgICBiLndsYW1iZGEudm11bChiLmFuZ3VsYXJGYWN0b3IsIGIud2xhbWJkYSk7XHJcbiAgICAgICAgICAgIHcudmFkZChiLndsYW1iZGEsIHcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gU2V0IHRoZSAubXVsdGlwbGllciBwcm9wZXJ0eSBvZiBlYWNoIGVxdWF0aW9uXHJcbiAgICAgICAgdmFyIGwgPSBlcXVhdGlvbnMubGVuZ3RoO1xyXG4gICAgICAgIHZhciBpbnZEdCA9IDEgLyBoO1xyXG4gICAgICAgIHdoaWxlKGwtLSl7XHJcbiAgICAgICAgICAgIGVxdWF0aW9uc1tsXS5tdWx0aXBsaWVyID0gbGFtYmRhW2xdICogaW52RHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBpdGVyO1xyXG59O1xyXG5cclxufSx7XCIuLi9tYXRoL1F1YXRlcm5pb25cIjoyOSxcIi4uL21hdGgvVmVjM1wiOjMxLFwiLi9Tb2x2ZXJcIjo0OH1dLDQ4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcclxubW9kdWxlLmV4cG9ydHMgPSBTb2x2ZXI7XHJcblxyXG4vKipcclxuICogQ29uc3RyYWludCBlcXVhdGlvbiBzb2x2ZXIgYmFzZSBjbGFzcy5cclxuICogQGNsYXNzIFNvbHZlclxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQGF1dGhvciBzY2h0ZXBwZSAvIGh0dHBzOi8vZ2l0aHViLmNvbS9zY2h0ZXBwZVxyXG4gKi9cclxuZnVuY3Rpb24gU29sdmVyKCl7XHJcbiAgICAvKipcclxuICAgICAqIEFsbCBlcXVhdGlvbnMgdG8gYmUgc29sdmVkXHJcbiAgICAgKiBAcHJvcGVydHkge0FycmF5fSBlcXVhdGlvbnNcclxuICAgICAqL1xyXG4gICAgdGhpcy5lcXVhdGlvbnMgPSBbXTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFNob3VsZCBiZSBpbXBsZW1lbnRlZCBpbiBzdWJjbGFzc2VzIVxyXG4gKiBAbWV0aG9kIHNvbHZlXHJcbiAqIEBwYXJhbSAge051bWJlcn0gZHRcclxuICogQHBhcmFtICB7V29ybGR9IHdvcmxkXHJcbiAqL1xyXG5Tb2x2ZXIucHJvdG90eXBlLnNvbHZlID0gZnVuY3Rpb24oZHQsd29ybGQpe1xyXG4gICAgLy8gU2hvdWxkIHJldHVybiB0aGUgbnVtYmVyIG9mIGl0ZXJhdGlvbnMgZG9uZSFcclxuICAgIHJldHVybiAwO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFkZCBhbiBlcXVhdGlvblxyXG4gKiBAbWV0aG9kIGFkZEVxdWF0aW9uXHJcbiAqIEBwYXJhbSB7RXF1YXRpb259IGVxXHJcbiAqL1xyXG5Tb2x2ZXIucHJvdG90eXBlLmFkZEVxdWF0aW9uID0gZnVuY3Rpb24oZXEpe1xyXG4gICAgaWYgKGVxLmVuYWJsZWQpIHtcclxuICAgICAgICB0aGlzLmVxdWF0aW9ucy5wdXNoKGVxKTtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZW1vdmUgYW4gZXF1YXRpb25cclxuICogQG1ldGhvZCByZW1vdmVFcXVhdGlvblxyXG4gKiBAcGFyYW0ge0VxdWF0aW9ufSBlcVxyXG4gKi9cclxuU29sdmVyLnByb3RvdHlwZS5yZW1vdmVFcXVhdGlvbiA9IGZ1bmN0aW9uKGVxKXtcclxuICAgIHZhciBlcXMgPSB0aGlzLmVxdWF0aW9ucztcclxuICAgIHZhciBpID0gZXFzLmluZGV4T2YoZXEpO1xyXG4gICAgaWYoaSAhPT0gLTEpe1xyXG4gICAgICAgIGVxcy5zcGxpY2UoaSwxKTtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBBZGQgYWxsIGVxdWF0aW9uc1xyXG4gKiBAbWV0aG9kIHJlbW92ZUFsbEVxdWF0aW9uc1xyXG4gKi9cclxuU29sdmVyLnByb3RvdHlwZS5yZW1vdmVBbGxFcXVhdGlvbnMgPSBmdW5jdGlvbigpe1xyXG4gICAgdGhpcy5lcXVhdGlvbnMubGVuZ3RoID0gMDtcclxufTtcclxuXHJcblxyXG59LHt9XSw0OTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XHJcbm1vZHVsZS5leHBvcnRzID0gU3BsaXRTb2x2ZXI7XHJcblxyXG52YXIgVmVjMyA9IF9kZXJlcV8oJy4uL21hdGgvVmVjMycpO1xyXG52YXIgUXVhdGVybmlvbiA9IF9kZXJlcV8oJy4uL21hdGgvUXVhdGVybmlvbicpO1xyXG52YXIgU29sdmVyID0gX2RlcmVxXygnLi9Tb2x2ZXInKTtcclxudmFyIEJvZHkgPSBfZGVyZXFfKCcuLi9vYmplY3RzL0JvZHknKTtcclxuXHJcbi8qKlxyXG4gKiBTcGxpdHMgdGhlIGVxdWF0aW9ucyBpbnRvIGlzbGFuZHMgYW5kIHNvbHZlcyB0aGVtIGluZGVwZW5kZW50bHkuIENhbiBpbXByb3ZlIHBlcmZvcm1hbmNlLlxyXG4gKiBAY2xhc3MgU3BsaXRTb2x2ZXJcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBleHRlbmRzIFNvbHZlclxyXG4gKiBAcGFyYW0ge1NvbHZlcn0gc3Vic29sdmVyXHJcbiAqL1xyXG5mdW5jdGlvbiBTcGxpdFNvbHZlcihzdWJzb2x2ZXIpe1xyXG4gICAgU29sdmVyLmNhbGwodGhpcyk7XHJcbiAgICB0aGlzLml0ZXJhdGlvbnMgPSAxMDtcclxuICAgIHRoaXMudG9sZXJhbmNlID0gMWUtNztcclxuICAgIHRoaXMuc3Vic29sdmVyID0gc3Vic29sdmVyO1xyXG4gICAgdGhpcy5ub2RlcyA9IFtdO1xyXG4gICAgdGhpcy5ub2RlUG9vbCA9IFtdO1xyXG5cclxuICAgIC8vIENyZWF0ZSBuZWVkZWQgbm9kZXMsIHJldXNlIGlmIHBvc3NpYmxlXHJcbiAgICB3aGlsZSh0aGlzLm5vZGVQb29sLmxlbmd0aCA8IDEyOCl7XHJcbiAgICAgICAgdGhpcy5ub2RlUG9vbC5wdXNoKHRoaXMuY3JlYXRlTm9kZSgpKTtcclxuICAgIH1cclxufVxyXG5TcGxpdFNvbHZlci5wcm90b3R5cGUgPSBuZXcgU29sdmVyKCk7XHJcblxyXG4vLyBSZXR1cm5zIHRoZSBudW1iZXIgb2Ygc3Vic3lzdGVtc1xyXG52YXIgU3BsaXRTb2x2ZXJfc29sdmVfbm9kZXMgPSBbXTsgLy8gQWxsIGFsbG9jYXRlZCBub2RlIG9iamVjdHNcclxudmFyIFNwbGl0U29sdmVyX3NvbHZlX25vZGVQb29sID0gW107IC8vIEFsbCBhbGxvY2F0ZWQgbm9kZSBvYmplY3RzXHJcbnZhciBTcGxpdFNvbHZlcl9zb2x2ZV9lcXMgPSBbXTsgICAvLyBUZW1wIGFycmF5XHJcbnZhciBTcGxpdFNvbHZlcl9zb2x2ZV9iZHMgPSBbXTsgICAvLyBUZW1wIGFycmF5XHJcbnZhciBTcGxpdFNvbHZlcl9zb2x2ZV9kdW1teVdvcmxkID0ge2JvZGllczpbXX07IC8vIFRlbXAgb2JqZWN0XHJcblxyXG52YXIgU1RBVElDID0gQm9keS5TVEFUSUM7XHJcbmZ1bmN0aW9uIGdldFVudmlzaXRlZE5vZGUobm9kZXMpe1xyXG4gICAgdmFyIE5ub2RlcyA9IG5vZGVzLmxlbmd0aDtcclxuICAgIGZvcih2YXIgaT0wOyBpIT09Tm5vZGVzOyBpKyspe1xyXG4gICAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XHJcbiAgICAgICAgaWYoIW5vZGUudmlzaXRlZCAmJiAhKG5vZGUuYm9keS50eXBlICYgU1RBVElDKSl7XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5cclxudmFyIHF1ZXVlID0gW107XHJcbmZ1bmN0aW9uIGJmcyhyb290LHZpc2l0RnVuYyxiZHMsZXFzKXtcclxuICAgIHF1ZXVlLnB1c2gocm9vdCk7XHJcbiAgICByb290LnZpc2l0ZWQgPSB0cnVlO1xyXG4gICAgdmlzaXRGdW5jKHJvb3QsYmRzLGVxcyk7XHJcbiAgICB3aGlsZShxdWV1ZS5sZW5ndGgpIHtcclxuICAgICAgICB2YXIgbm9kZSA9IHF1ZXVlLnBvcCgpO1xyXG4gICAgICAgIC8vIExvb3Agb3ZlciB1bnZpc2l0ZWQgY2hpbGQgbm9kZXNcclxuICAgICAgICB2YXIgY2hpbGQ7XHJcbiAgICAgICAgd2hpbGUoKGNoaWxkID0gZ2V0VW52aXNpdGVkTm9kZShub2RlLmNoaWxkcmVuKSkpIHtcclxuICAgICAgICAgICAgY2hpbGQudmlzaXRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIHZpc2l0RnVuYyhjaGlsZCxiZHMsZXFzKTtcclxuICAgICAgICAgICAgcXVldWUucHVzaChjaGlsZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiB2aXNpdEZ1bmMobm9kZSxiZHMsZXFzKXtcclxuICAgIGJkcy5wdXNoKG5vZGUuYm9keSk7XHJcbiAgICB2YXIgTmVxcyA9IG5vZGUuZXFzLmxlbmd0aDtcclxuICAgIGZvcih2YXIgaT0wOyBpIT09TmVxczsgaSsrKXtcclxuICAgICAgICB2YXIgZXEgPSBub2RlLmVxc1tpXTtcclxuICAgICAgICBpZihlcXMuaW5kZXhPZihlcSkgPT09IC0xKXtcclxuICAgICAgICAgICAgZXFzLnB1c2goZXEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuU3BsaXRTb2x2ZXIucHJvdG90eXBlLmNyZWF0ZU5vZGUgPSBmdW5jdGlvbigpe1xyXG4gICAgcmV0dXJuIHsgYm9keTpudWxsLCBjaGlsZHJlbjpbXSwgZXFzOltdLCB2aXNpdGVkOmZhbHNlIH07XHJcbn07XHJcblxyXG4vKipcclxuICogU29sdmUgdGhlIHN1YnN5c3RlbXNcclxuICogQG1ldGhvZCBzb2x2ZVxyXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGR0XHJcbiAqIEBwYXJhbSAge1dvcmxkfSB3b3JsZFxyXG4gKi9cclxuU3BsaXRTb2x2ZXIucHJvdG90eXBlLnNvbHZlID0gZnVuY3Rpb24oZHQsd29ybGQpe1xyXG4gICAgdmFyIG5vZGVzPVNwbGl0U29sdmVyX3NvbHZlX25vZGVzLFxyXG4gICAgICAgIG5vZGVQb29sPXRoaXMubm9kZVBvb2wsXHJcbiAgICAgICAgYm9kaWVzPXdvcmxkLmJvZGllcyxcclxuICAgICAgICBlcXVhdGlvbnM9dGhpcy5lcXVhdGlvbnMsXHJcbiAgICAgICAgTmVxPWVxdWF0aW9ucy5sZW5ndGgsXHJcbiAgICAgICAgTmJvZGllcz1ib2RpZXMubGVuZ3RoLFxyXG4gICAgICAgIHN1YnNvbHZlcj10aGlzLnN1YnNvbHZlcjtcclxuXHJcbiAgICAvLyBDcmVhdGUgbmVlZGVkIG5vZGVzLCByZXVzZSBpZiBwb3NzaWJsZVxyXG4gICAgd2hpbGUobm9kZVBvb2wubGVuZ3RoIDwgTmJvZGllcyl7XHJcbiAgICAgICAgbm9kZVBvb2wucHVzaCh0aGlzLmNyZWF0ZU5vZGUoKSk7XHJcbiAgICB9XHJcbiAgICBub2Rlcy5sZW5ndGggPSBOYm9kaWVzO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOYm9kaWVzOyBpKyspIHtcclxuICAgICAgICBub2Rlc1tpXSA9IG5vZGVQb29sW2ldO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFJlc2V0IG5vZGUgdmFsdWVzXHJcbiAgICBmb3IodmFyIGk9MDsgaSE9PU5ib2RpZXM7IGkrKyl7XHJcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcclxuICAgICAgICBub2RlLmJvZHkgPSBib2RpZXNbaV07XHJcbiAgICAgICAgbm9kZS5jaGlsZHJlbi5sZW5ndGggPSAwO1xyXG4gICAgICAgIG5vZGUuZXFzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgbm9kZS52aXNpdGVkID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBmb3IodmFyIGs9MDsgayE9PU5lcTsgaysrKXtcclxuICAgICAgICB2YXIgZXE9ZXF1YXRpb25zW2tdLFxyXG4gICAgICAgICAgICBpPWJvZGllcy5pbmRleE9mKGVxLmJpKSxcclxuICAgICAgICAgICAgaj1ib2RpZXMuaW5kZXhPZihlcS5iaiksXHJcbiAgICAgICAgICAgIG5pPW5vZGVzW2ldLFxyXG4gICAgICAgICAgICBuaj1ub2Rlc1tqXTtcclxuICAgICAgICBuaS5jaGlsZHJlbi5wdXNoKG5qKTtcclxuICAgICAgICBuaS5lcXMucHVzaChlcSk7XHJcbiAgICAgICAgbmouY2hpbGRyZW4ucHVzaChuaSk7XHJcbiAgICAgICAgbmouZXFzLnB1c2goZXEpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBjaGlsZCwgbj0wLCBlcXM9U3BsaXRTb2x2ZXJfc29sdmVfZXFzO1xyXG5cclxuICAgIHN1YnNvbHZlci50b2xlcmFuY2UgPSB0aGlzLnRvbGVyYW5jZTtcclxuICAgIHN1YnNvbHZlci5pdGVyYXRpb25zID0gdGhpcy5pdGVyYXRpb25zO1xyXG5cclxuICAgIHZhciBkdW1teVdvcmxkID0gU3BsaXRTb2x2ZXJfc29sdmVfZHVtbXlXb3JsZDtcclxuICAgIHdoaWxlKChjaGlsZCA9IGdldFVudmlzaXRlZE5vZGUobm9kZXMpKSl7XHJcbiAgICAgICAgZXFzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgZHVtbXlXb3JsZC5ib2RpZXMubGVuZ3RoID0gMDtcclxuICAgICAgICBiZnMoY2hpbGQsIHZpc2l0RnVuYywgZHVtbXlXb3JsZC5ib2RpZXMsIGVxcyk7XHJcblxyXG4gICAgICAgIHZhciBOZXFzID0gZXFzLmxlbmd0aDtcclxuXHJcbiAgICAgICAgZXFzID0gZXFzLnNvcnQoc29ydEJ5SWQpO1xyXG5cclxuICAgICAgICBmb3IodmFyIGk9MDsgaSE9PU5lcXM7IGkrKyl7XHJcbiAgICAgICAgICAgIHN1YnNvbHZlci5hZGRFcXVhdGlvbihlcXNbaV0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGl0ZXIgPSBzdWJzb2x2ZXIuc29sdmUoZHQsZHVtbXlXb3JsZCk7XHJcbiAgICAgICAgc3Vic29sdmVyLnJlbW92ZUFsbEVxdWF0aW9ucygpO1xyXG4gICAgICAgIG4rKztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbjtcclxufTtcclxuXHJcbmZ1bmN0aW9uIHNvcnRCeUlkKGEsIGIpe1xyXG4gICAgcmV0dXJuIGIuaWQgLSBhLmlkO1xyXG59XHJcbn0se1wiLi4vbWF0aC9RdWF0ZXJuaW9uXCI6MjksXCIuLi9tYXRoL1ZlYzNcIjozMSxcIi4uL29iamVjdHMvQm9keVwiOjMyLFwiLi9Tb2x2ZXJcIjo0OH1dLDUwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcclxuLyoqXHJcbiAqIEJhc2UgY2xhc3MgZm9yIG9iamVjdHMgdGhhdCBkaXNwYXRjaGVzIGV2ZW50cy5cclxuICogQGNsYXNzIEV2ZW50VGFyZ2V0XHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxudmFyIEV2ZW50VGFyZ2V0ID0gZnVuY3Rpb24gKCkge1xyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRXZlbnRUYXJnZXQ7XHJcblxyXG5FdmVudFRhcmdldC5wcm90b3R5cGUgPSB7XHJcbiAgICBjb25zdHJ1Y3RvcjogRXZlbnRUYXJnZXQsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgYW4gZXZlbnQgbGlzdGVuZXJcclxuICAgICAqIEBtZXRob2QgYWRkRXZlbnRMaXN0ZW5lclxyXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSB0eXBlXHJcbiAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gbGlzdGVuZXJcclxuICAgICAqIEByZXR1cm4ge0V2ZW50VGFyZ2V0fSBUaGUgc2VsZiBvYmplY3QsIGZvciBjaGFpbmFiaWxpdHkuXHJcbiAgICAgKi9cclxuICAgIGFkZEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uICggdHlwZSwgbGlzdGVuZXIgKSB7XHJcbiAgICAgICAgaWYgKCB0aGlzLl9saXN0ZW5lcnMgPT09IHVuZGVmaW5lZCApeyB0aGlzLl9saXN0ZW5lcnMgPSB7fTsgfVxyXG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XHJcbiAgICAgICAgaWYgKCBsaXN0ZW5lcnNbIHR5cGUgXSA9PT0gdW5kZWZpbmVkICkge1xyXG4gICAgICAgICAgICBsaXN0ZW5lcnNbIHR5cGUgXSA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIGxpc3RlbmVyc1sgdHlwZSBdLmluZGV4T2YoIGxpc3RlbmVyICkgPT09IC0gMSApIHtcclxuICAgICAgICAgICAgbGlzdGVuZXJzWyB0eXBlIF0ucHVzaCggbGlzdGVuZXIgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2sgaWYgYW4gZXZlbnQgbGlzdGVuZXIgaXMgYWRkZWRcclxuICAgICAqIEBtZXRob2QgaGFzRXZlbnRMaXN0ZW5lclxyXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSB0eXBlXHJcbiAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gbGlzdGVuZXJcclxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIGhhc0V2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uICggdHlwZSwgbGlzdGVuZXIgKSB7XHJcbiAgICAgICAgaWYgKCB0aGlzLl9saXN0ZW5lcnMgPT09IHVuZGVmaW5lZCApeyByZXR1cm4gZmFsc2U7IH1cclxuICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xyXG4gICAgICAgIGlmICggbGlzdGVuZXJzWyB0eXBlIF0gIT09IHVuZGVmaW5lZCAmJiBsaXN0ZW5lcnNbIHR5cGUgXS5pbmRleE9mKCBsaXN0ZW5lciApICE9PSAtIDEgKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2sgaWYgYW55IGV2ZW50IGxpc3RlbmVyIG9mIHRoZSBnaXZlbiB0eXBlIGlzIGFkZGVkXHJcbiAgICAgKiBAbWV0aG9kIGhhc0FueUV2ZW50TGlzdGVuZXJcclxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gdHlwZVxyXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgaGFzQW55RXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gKCB0eXBlICkge1xyXG4gICAgICAgIGlmICggdGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQgKXsgcmV0dXJuIGZhbHNlOyB9XHJcbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcclxuICAgICAgICByZXR1cm4gKCBsaXN0ZW5lcnNbIHR5cGUgXSAhPT0gdW5kZWZpbmVkICk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlIGFuIGV2ZW50IGxpc3RlbmVyXHJcbiAgICAgKiBAbWV0aG9kIHJlbW92ZUV2ZW50TGlzdGVuZXJcclxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gdHlwZVxyXG4gICAgICogQHBhcmFtICB7RnVuY3Rpb259IGxpc3RlbmVyXHJcbiAgICAgKiBAcmV0dXJuIHtFdmVudFRhcmdldH0gVGhlIHNlbGYgb2JqZWN0LCBmb3IgY2hhaW5hYmlsaXR5LlxyXG4gICAgICovXHJcbiAgICByZW1vdmVFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAoIHR5cGUsIGxpc3RlbmVyICkge1xyXG4gICAgICAgIGlmICggdGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQgKXsgcmV0dXJuIHRoaXM7IH1cclxuICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xyXG4gICAgICAgIGlmICggbGlzdGVuZXJzW3R5cGVdID09PSB1bmRlZmluZWQgKXsgcmV0dXJuIHRoaXM7IH1cclxuICAgICAgICB2YXIgaW5kZXggPSBsaXN0ZW5lcnNbIHR5cGUgXS5pbmRleE9mKCBsaXN0ZW5lciApO1xyXG4gICAgICAgIGlmICggaW5kZXggIT09IC0gMSApIHtcclxuICAgICAgICAgICAgbGlzdGVuZXJzWyB0eXBlIF0uc3BsaWNlKCBpbmRleCwgMSApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFbWl0IGFuIGV2ZW50LlxyXG4gICAgICogQG1ldGhvZCBkaXNwYXRjaEV2ZW50XHJcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IGV2ZW50XHJcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGV2ZW50LnR5cGVcclxuICAgICAqIEByZXR1cm4ge0V2ZW50VGFyZ2V0fSBUaGUgc2VsZiBvYmplY3QsIGZvciBjaGFpbmFiaWxpdHkuXHJcbiAgICAgKi9cclxuICAgIGRpc3BhdGNoRXZlbnQ6IGZ1bmN0aW9uICggZXZlbnQgKSB7XHJcbiAgICAgICAgaWYgKCB0aGlzLl9saXN0ZW5lcnMgPT09IHVuZGVmaW5lZCApeyByZXR1cm4gdGhpczsgfVxyXG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XHJcbiAgICAgICAgdmFyIGxpc3RlbmVyQXJyYXkgPSBsaXN0ZW5lcnNbIGV2ZW50LnR5cGUgXTtcclxuICAgICAgICBpZiAoIGxpc3RlbmVyQXJyYXkgIT09IHVuZGVmaW5lZCApIHtcclxuICAgICAgICAgICAgZXZlbnQudGFyZ2V0ID0gdGhpcztcclxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gbGlzdGVuZXJBcnJheS5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG4gICAgICAgICAgICAgICAgbGlzdGVuZXJBcnJheVsgaSBdLmNhbGwoIHRoaXMsIGV2ZW50ICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbn07XHJcblxyXG59LHt9XSw1MTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XHJcbnZhciBBQUJCID0gX2RlcmVxXygnLi4vY29sbGlzaW9uL0FBQkInKTtcclxudmFyIFZlYzMgPSBfZGVyZXFfKCcuLi9tYXRoL1ZlYzMnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gT2N0cmVlO1xyXG5cclxuLyoqXHJcbiAqIEBjbGFzcyBPY3RyZWVOb2RlXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cclxuICogQHBhcmFtIHtPY3RyZWV9IFtvcHRpb25zLnJvb3RdXHJcbiAqIEBwYXJhbSB7QUFCQn0gW29wdGlvbnMuYWFiYl1cclxuICovXHJcbmZ1bmN0aW9uIE9jdHJlZU5vZGUob3B0aW9ucyl7XHJcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSByb290IG5vZGVcclxuICAgICAqIEBwcm9wZXJ0eSB7T2N0cmVlTm9kZX0gcm9vdFxyXG4gICAgICovXHJcbiAgICB0aGlzLnJvb3QgPSBvcHRpb25zLnJvb3QgfHwgbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEJvdW5kYXJ5IG9mIHRoaXMgbm9kZVxyXG4gICAgICogQHByb3BlcnR5IHtBQUJCfSBhYWJiXHJcbiAgICAgKi9cclxuICAgIHRoaXMuYWFiYiA9IG9wdGlvbnMuYWFiYiA/IG9wdGlvbnMuYWFiYi5jbG9uZSgpIDogbmV3IEFBQkIoKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnRhaW5lZCBkYXRhIGF0IHRoZSBjdXJyZW50IG5vZGUgbGV2ZWwuXHJcbiAgICAgKiBAcHJvcGVydHkge0FycmF5fSBkYXRhXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZGF0YSA9IFtdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hpbGRyZW4gdG8gdGhpcyBub2RlXHJcbiAgICAgKiBAcHJvcGVydHkge0FycmF5fSBjaGlsZHJlblxyXG4gICAgICovXHJcbiAgICB0aGlzLmNoaWxkcmVuID0gW107XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAY2xhc3MgT2N0cmVlXHJcbiAqIEBwYXJhbSB7QUFCQn0gYWFiYiBUaGUgdG90YWwgQUFCQiBvZiB0aGUgdHJlZVxyXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhEZXB0aD04XVxyXG4gKiBAZXh0ZW5kcyBPY3RyZWVOb2RlXHJcbiAqL1xyXG5mdW5jdGlvbiBPY3RyZWUoYWFiYiwgb3B0aW9ucyl7XHJcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICAgIG9wdGlvbnMucm9vdCA9IG51bGw7XHJcbiAgICBvcHRpb25zLmFhYmIgPSBhYWJiO1xyXG4gICAgT2N0cmVlTm9kZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWF4aW11bSBzdWJkaXZpc2lvbiBkZXB0aFxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG1heERlcHRoXHJcbiAgICAgKi9cclxuICAgIHRoaXMubWF4RGVwdGggPSB0eXBlb2Yob3B0aW9ucy5tYXhEZXB0aCkgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5tYXhEZXB0aCA6IDg7XHJcbn1cclxuT2N0cmVlLnByb3RvdHlwZSA9IG5ldyBPY3RyZWVOb2RlKCk7XHJcblxyXG5PY3RyZWVOb2RlLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKGFhYmIsIG9wdGlvbnMpe1xyXG4gICAgdGhpcy5jaGlsZHJlbi5sZW5ndGggPSB0aGlzLmRhdGEubGVuZ3RoID0gMDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBJbnNlcnQgZGF0YSBpbnRvIHRoaXMgbm9kZVxyXG4gKiBAbWV0aG9kIGluc2VydFxyXG4gKiBAcGFyYW0gIHtBQUJCfSBhYWJiXHJcbiAqIEBwYXJhbSAge29iamVjdH0gZWxlbWVudERhdGFcclxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBzdWNjZXNzZnVsLCBvdGhlcndpc2UgZmFsc2VcclxuICovXHJcbk9jdHJlZU5vZGUucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uKGFhYmIsIGVsZW1lbnREYXRhLCBsZXZlbCl7XHJcbiAgICB2YXIgbm9kZURhdGEgPSB0aGlzLmRhdGE7XHJcbiAgICBsZXZlbCA9IGxldmVsIHx8IDA7XHJcblxyXG4gICAgLy8gSWdub3JlIG9iamVjdHMgdGhhdCBkbyBub3QgYmVsb25nIGluIHRoaXMgbm9kZVxyXG4gICAgaWYgKCF0aGlzLmFhYmIuY29udGFpbnMoYWFiYikpe1xyXG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gb2JqZWN0IGNhbm5vdCBiZSBhZGRlZFxyXG4gICAgfVxyXG5cclxuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XHJcblxyXG4gICAgaWYobGV2ZWwgPCAodGhpcy5tYXhEZXB0aCB8fCB0aGlzLnJvb3QubWF4RGVwdGgpKXtcclxuICAgICAgICAvLyBTdWJkaXZpZGUgaWYgdGhlcmUgYXJlIG5vIGNoaWxkcmVuIHlldFxyXG4gICAgICAgIHZhciBzdWJkaXZpZGVkID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKCFjaGlsZHJlbi5sZW5ndGgpe1xyXG4gICAgICAgICAgICB0aGlzLnN1YmRpdmlkZSgpO1xyXG4gICAgICAgICAgICBzdWJkaXZpZGVkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGFkZCB0byB3aGljaGV2ZXIgbm9kZSB3aWxsIGFjY2VwdCBpdFxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpICE9PSA4OyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGNoaWxkcmVuW2ldLmluc2VydChhYWJiLCBlbGVtZW50RGF0YSwgbGV2ZWwgKyAxKSl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYoc3ViZGl2aWRlZCl7XHJcbiAgICAgICAgICAgIC8vIE5vIGNoaWxkcmVuIGFjY2VwdGVkISBNaWdodCBhcyB3ZWxsIGp1c3QgcmVtb3ZlIGVtIHNpbmNlIHRoZXkgY29udGFpbiBub25lXHJcbiAgICAgICAgICAgIGNoaWxkcmVuLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFRvbyBkZWVwLCBvciBjaGlsZHJlbiBkaWRudCB3YW50IGl0LiBhZGQgaXQgaW4gY3VycmVudCBub2RlXHJcbiAgICBub2RlRGF0YS5wdXNoKGVsZW1lbnREYXRhKTtcclxuXHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufTtcclxuXHJcbnZhciBoYWxmRGlhZ29uYWwgPSBuZXcgVmVjMygpO1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZSA4IGVxdWFsbHkgc2l6ZWQgY2hpbGRyZW4gbm9kZXMgYW5kIHB1dCB0aGVtIGluIHRoZSAuY2hpbGRyZW4gYXJyYXkuXHJcbiAqIEBtZXRob2Qgc3ViZGl2aWRlXHJcbiAqL1xyXG5PY3RyZWVOb2RlLnByb3RvdHlwZS5zdWJkaXZpZGUgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciBhYWJiID0gdGhpcy5hYWJiO1xyXG4gICAgdmFyIGwgPSBhYWJiLmxvd2VyQm91bmQ7XHJcbiAgICB2YXIgdSA9IGFhYmIudXBwZXJCb3VuZDtcclxuXHJcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xyXG5cclxuICAgIGNoaWxkcmVuLnB1c2goXHJcbiAgICAgICAgbmV3IE9jdHJlZU5vZGUoeyBhYWJiOiBuZXcgQUFCQih7IGxvd2VyQm91bmQ6IG5ldyBWZWMzKDAsMCwwKSB9KSB9KSxcclxuICAgICAgICBuZXcgT2N0cmVlTm9kZSh7IGFhYmI6IG5ldyBBQUJCKHsgbG93ZXJCb3VuZDogbmV3IFZlYzMoMSwwLDApIH0pIH0pLFxyXG4gICAgICAgIG5ldyBPY3RyZWVOb2RlKHsgYWFiYjogbmV3IEFBQkIoeyBsb3dlckJvdW5kOiBuZXcgVmVjMygxLDEsMCkgfSkgfSksXHJcbiAgICAgICAgbmV3IE9jdHJlZU5vZGUoeyBhYWJiOiBuZXcgQUFCQih7IGxvd2VyQm91bmQ6IG5ldyBWZWMzKDEsMSwxKSB9KSB9KSxcclxuICAgICAgICBuZXcgT2N0cmVlTm9kZSh7IGFhYmI6IG5ldyBBQUJCKHsgbG93ZXJCb3VuZDogbmV3IFZlYzMoMCwxLDEpIH0pIH0pLFxyXG4gICAgICAgIG5ldyBPY3RyZWVOb2RlKHsgYWFiYjogbmV3IEFBQkIoeyBsb3dlckJvdW5kOiBuZXcgVmVjMygwLDAsMSkgfSkgfSksXHJcbiAgICAgICAgbmV3IE9jdHJlZU5vZGUoeyBhYWJiOiBuZXcgQUFCQih7IGxvd2VyQm91bmQ6IG5ldyBWZWMzKDEsMCwxKSB9KSB9KSxcclxuICAgICAgICBuZXcgT2N0cmVlTm9kZSh7IGFhYmI6IG5ldyBBQUJCKHsgbG93ZXJCb3VuZDogbmV3IFZlYzMoMCwxLDApIH0pIH0pXHJcbiAgICApO1xyXG5cclxuICAgIHUudnN1YihsLCBoYWxmRGlhZ29uYWwpO1xyXG4gICAgaGFsZkRpYWdvbmFsLnNjYWxlKDAuNSwgaGFsZkRpYWdvbmFsKTtcclxuXHJcbiAgICB2YXIgcm9vdCA9IHRoaXMucm9vdCB8fCB0aGlzO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpICE9PSA4OyBpKyspIHtcclxuICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcclxuXHJcbiAgICAgICAgLy8gU2V0IGN1cnJlbnQgbm9kZSBhcyByb290XHJcbiAgICAgICAgY2hpbGQucm9vdCA9IHJvb3Q7XHJcblxyXG4gICAgICAgIC8vIENvbXB1dGUgYm91bmRzXHJcbiAgICAgICAgdmFyIGxvd2VyQm91bmQgPSBjaGlsZC5hYWJiLmxvd2VyQm91bmQ7XHJcbiAgICAgICAgbG93ZXJCb3VuZC54ICo9IGhhbGZEaWFnb25hbC54O1xyXG4gICAgICAgIGxvd2VyQm91bmQueSAqPSBoYWxmRGlhZ29uYWwueTtcclxuICAgICAgICBsb3dlckJvdW5kLnogKj0gaGFsZkRpYWdvbmFsLno7XHJcblxyXG4gICAgICAgIGxvd2VyQm91bmQudmFkZChsLCBsb3dlckJvdW5kKTtcclxuXHJcbiAgICAgICAgLy8gVXBwZXIgYm91bmQgaXMgYWx3YXlzIGxvd2VyIGJvdW5kICsgaGFsZkRpYWdvbmFsXHJcbiAgICAgICAgbG93ZXJCb3VuZC52YWRkKGhhbGZEaWFnb25hbCwgY2hpbGQuYWFiYi51cHBlckJvdW5kKTtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXQgYWxsIGRhdGEsIHBvdGVudGlhbGx5IHdpdGhpbiBhbiBBQUJCXHJcbiAqIEBtZXRob2QgYWFiYlF1ZXJ5XHJcbiAqIEBwYXJhbSAge0FBQkJ9IGFhYmJcclxuICogQHBhcmFtICB7YXJyYXl9IHJlc3VsdFxyXG4gKiBAcmV0dXJuIHthcnJheX0gVGhlIFwicmVzdWx0XCIgb2JqZWN0XHJcbiAqL1xyXG5PY3RyZWVOb2RlLnByb3RvdHlwZS5hYWJiUXVlcnkgPSBmdW5jdGlvbihhYWJiLCByZXN1bHQpIHtcclxuXHJcbiAgICB2YXIgbm9kZURhdGEgPSB0aGlzLmRhdGE7XHJcblxyXG4gICAgLy8gYWJvcnQgaWYgdGhlIHJhbmdlIGRvZXMgbm90IGludGVyc2VjdCB0aGlzIG5vZGVcclxuICAgIC8vIGlmICghdGhpcy5hYWJiLm92ZXJsYXBzKGFhYmIpKXtcclxuICAgIC8vICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgLy8gfVxyXG5cclxuICAgIC8vIEFkZCBvYmplY3RzIGF0IHRoaXMgbGV2ZWxcclxuICAgIC8vIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHJlc3VsdCwgbm9kZURhdGEpO1xyXG5cclxuICAgIC8vIEFkZCBjaGlsZCBkYXRhXHJcbiAgICAvLyBAdG9kbyB1bndyYXAgcmVjdXJzaW9uIGludG8gYSBxdWV1ZSAvIGxvb3AsIHRoYXQncyBmYXN0ZXIgaW4gSlNcclxuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XHJcblxyXG5cclxuICAgIC8vIGZvciAodmFyIGkgPSAwLCBOID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgIT09IE47IGkrKykge1xyXG4gICAgLy8gICAgIGNoaWxkcmVuW2ldLmFhYmJRdWVyeShhYWJiLCByZXN1bHQpO1xyXG4gICAgLy8gfVxyXG5cclxuICAgIHZhciBxdWV1ZSA9IFt0aGlzXTtcclxuICAgIHdoaWxlIChxdWV1ZS5sZW5ndGgpIHtcclxuICAgICAgICB2YXIgbm9kZSA9IHF1ZXVlLnBvcCgpO1xyXG4gICAgICAgIGlmIChub2RlLmFhYmIub3ZlcmxhcHMoYWFiYikpe1xyXG4gICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShyZXN1bHQsIG5vZGUuZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHF1ZXVlLCBub2RlLmNoaWxkcmVuKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxudmFyIHRtcEFBQkIgPSBuZXcgQUFCQigpO1xyXG5cclxuLyoqXHJcbiAqIEdldCBhbGwgZGF0YSwgcG90ZW50aWFsbHkgaW50ZXJzZWN0ZWQgYnkgYSByYXkuXHJcbiAqIEBtZXRob2QgcmF5UXVlcnlcclxuICogQHBhcmFtICB7UmF5fSByYXlcclxuICogQHBhcmFtICB7VHJhbnNmb3JtfSB0cmVlVHJhbnNmb3JtXHJcbiAqIEBwYXJhbSAge2FycmF5fSByZXN1bHRcclxuICogQHJldHVybiB7YXJyYXl9IFRoZSBcInJlc3VsdFwiIG9iamVjdFxyXG4gKi9cclxuT2N0cmVlTm9kZS5wcm90b3R5cGUucmF5UXVlcnkgPSBmdW5jdGlvbihyYXksIHRyZWVUcmFuc2Zvcm0sIHJlc3VsdCkge1xyXG5cclxuICAgIC8vIFVzZSBhYWJiIHF1ZXJ5IGZvciBub3cuXHJcbiAgICAvLyBAdG9kbyBpbXBsZW1lbnQgcmVhbCByYXkgcXVlcnkgd2hpY2ggbmVlZHMgbGVzcyBsb29rdXBzXHJcbiAgICByYXkuZ2V0QUFCQih0bXBBQUJCKTtcclxuICAgIHRtcEFBQkIudG9Mb2NhbEZyYW1lKHRyZWVUcmFuc2Zvcm0sIHRtcEFBQkIpO1xyXG4gICAgdGhpcy5hYWJiUXVlcnkodG1wQUFCQiwgcmVzdWx0KTtcclxuXHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgcmVtb3ZlRW1wdHlOb2Rlc1xyXG4gKi9cclxuT2N0cmVlTm9kZS5wcm90b3R5cGUucmVtb3ZlRW1wdHlOb2RlcyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgZm9yICh2YXIgaSA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICB0aGlzLmNoaWxkcmVuW2ldLnJlbW92ZUVtcHR5Tm9kZXMoKTtcclxuICAgICAgICBpZighdGhpcy5jaGlsZHJlbltpXS5jaGlsZHJlbi5sZW5ndGggJiYgIXRoaXMuY2hpbGRyZW5baV0uZGF0YS5sZW5ndGgpe1xyXG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuLnNwbGljZShpLCAxKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG59LHtcIi4uL2NvbGxpc2lvbi9BQUJCXCI6MyxcIi4uL21hdGgvVmVjM1wiOjMxfV0sNTI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xyXG5tb2R1bGUuZXhwb3J0cyA9IFBvb2w7XHJcblxyXG4vKipcclxuICogRm9yIHBvb2xpbmcgb2JqZWN0cyB0aGF0IGNhbiBiZSByZXVzZWQuXHJcbiAqIEBjbGFzcyBQb29sXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxuZnVuY3Rpb24gUG9vbCgpe1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgcG9vbGVkIG9iamVjdHNcclxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IG9iamVjdHNcclxuICAgICAqL1xyXG4gICAgdGhpcy5vYmplY3RzID0gW107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb25zdHJ1Y3RvciBvZiB0aGUgb2JqZWN0c1xyXG4gICAgICogQHByb3BlcnR5IHttaXhlZH0gdHlwZVxyXG4gICAgICovXHJcbiAgICB0aGlzLnR5cGUgPSBPYmplY3Q7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZWxlYXNlIGFuIG9iamVjdCBhZnRlciB1c2VcclxuICogQG1ldGhvZCByZWxlYXNlXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcclxuICovXHJcblBvb2wucHJvdG90eXBlLnJlbGVhc2UgPSBmdW5jdGlvbigpe1xyXG4gICAgdmFyIE5hcmdzID0gYXJndW1lbnRzLmxlbmd0aDtcclxuICAgIGZvcih2YXIgaT0wOyBpIT09TmFyZ3M7IGkrKyl7XHJcbiAgICAgICAgdGhpcy5vYmplY3RzLnB1c2goYXJndW1lbnRzW2ldKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldCBhbiBvYmplY3RcclxuICogQG1ldGhvZCBnZXRcclxuICogQHJldHVybiB7bWl4ZWR9XHJcbiAqL1xyXG5Qb29sLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbigpe1xyXG4gICAgaWYodGhpcy5vYmplY3RzLmxlbmd0aD09PTApe1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdE9iamVjdCgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5vYmplY3RzLnBvcCgpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbnN0cnVjdCBhbiBvYmplY3QuIFNob3VsZCBiZSBpbXBsbWVudGVkIGluIGVhY2ggc3ViY2xhc3MuXHJcbiAqIEBtZXRob2QgY29uc3RydWN0T2JqZWN0XHJcbiAqIEByZXR1cm4ge21peGVkfVxyXG4gKi9cclxuUG9vbC5wcm90b3R5cGUuY29uc3RydWN0T2JqZWN0ID0gZnVuY3Rpb24oKXtcclxuICAgIHRocm93IG5ldyBFcnJvcihcImNvbnN0cnVjdE9iamVjdCgpIG5vdCBpbXBsZW1lbnRlZCBpbiB0aGlzIFBvb2wgc3ViY2xhc3MgeWV0IVwiKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kIHJlc2l6ZVxyXG4gKiBAcGFyYW0ge251bWJlcn0gc2l6ZVxyXG4gKiBAcmV0dXJuIHtQb29sfSBTZWxmLCBmb3IgY2hhaW5pbmdcclxuICovXHJcblBvb2wucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uIChzaXplKSB7XHJcbiAgICB2YXIgb2JqZWN0cyA9IHRoaXMub2JqZWN0cztcclxuXHJcbiAgICB3aGlsZSAob2JqZWN0cy5sZW5ndGggPiBzaXplKSB7XHJcbiAgICAgICAgb2JqZWN0cy5wb3AoKTtcclxuICAgIH1cclxuXHJcbiAgICB3aGlsZSAob2JqZWN0cy5sZW5ndGggPCBzaXplKSB7XHJcbiAgICAgICAgb2JqZWN0cy5wdXNoKHRoaXMuY29uc3RydWN0T2JqZWN0KCkpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuXHJcbn0se31dLDUzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcclxubW9kdWxlLmV4cG9ydHMgPSBUdXBsZURpY3Rpb25hcnk7XHJcblxyXG4vKipcclxuICogQGNsYXNzIFR1cGxlRGljdGlvbmFyeVxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbmZ1bmN0aW9uIFR1cGxlRGljdGlvbmFyeSgpIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBkYXRhIHN0b3JhZ2VcclxuICAgICAqIEBwcm9wZXJ0eSBkYXRhXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAgICovXHJcbiAgICB0aGlzLmRhdGEgPSB7IGtleXM6W10gfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgZ2V0XHJcbiAqIEBwYXJhbSAge051bWJlcn0gaVxyXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGpcclxuICogQHJldHVybiB7T2JqZWN0fVxyXG4gKi9cclxuVHVwbGVEaWN0aW9uYXJ5LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihpLCBqKSB7XHJcbiAgICBpZiAoaSA+IGopIHtcclxuICAgICAgICAvLyBzd2FwXHJcbiAgICAgICAgdmFyIHRlbXAgPSBqO1xyXG4gICAgICAgIGogPSBpO1xyXG4gICAgICAgIGkgPSB0ZW1wO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMuZGF0YVtpKyctJytqXTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kIHNldFxyXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGlcclxuICogQHBhcmFtICB7TnVtYmVyfSBqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVxyXG4gKi9cclxuVHVwbGVEaWN0aW9uYXJ5LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihpLCBqLCB2YWx1ZSkge1xyXG4gICAgaWYgKGkgPiBqKSB7XHJcbiAgICAgICAgdmFyIHRlbXAgPSBqO1xyXG4gICAgICAgIGogPSBpO1xyXG4gICAgICAgIGkgPSB0ZW1wO1xyXG4gICAgfVxyXG4gICAgdmFyIGtleSA9IGkrJy0nK2o7XHJcblxyXG4gICAgLy8gQ2hlY2sgaWYga2V5IGFscmVhZHkgZXhpc3RzXHJcbiAgICBpZighdGhpcy5nZXQoaSxqKSl7XHJcbiAgICAgICAgdGhpcy5kYXRhLmtleXMucHVzaChrZXkpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuZGF0YVtrZXldID0gdmFsdWU7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhW2tleV07XHJcbn07XHJcblxyXG4vKipcclxuICogQG1ldGhvZCByZXNldFxyXG4gKi9cclxuVHVwbGVEaWN0aW9uYXJ5LnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGEsXHJcbiAgICAgICAga2V5cyA9IGRhdGEua2V5cztcclxuICAgIHdoaWxlKGtleXMubGVuZ3RoID4gMCl7XHJcbiAgICAgICAgdmFyIGtleSA9IGtleXMucG9wKCk7XHJcbiAgICAgICAgZGVsZXRlIGRhdGFba2V5XTsgICAgICAgIFxyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgZ2V0TGVuZ3RoXHJcbiAqL1xyXG5UdXBsZURpY3Rpb25hcnkucHJvdG90eXBlLmdldExlbmd0aCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuICB0aGlzLmRhdGEua2V5cy5sZW5ndGg7XHJcbn07XHJcblxyXG4vKipcclxuICogQG1ldGhvZCBnZXRLZXlCeUluZGV4XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxyXG4gKi9cclxuVHVwbGVEaWN0aW9uYXJ5LnByb3RvdHlwZS5nZXRLZXlCeUluZGV4ID0gZnVuY3Rpb24oaW5kZXgpIHtcclxuICAgIHJldHVybiAgdGhpcy5kYXRhLmtleXNbaW5kZXhdO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgZ2V0RGF0YUJ5S2V5XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBLZXlcclxuICovXHJcblR1cGxlRGljdGlvbmFyeS5wcm90b3R5cGUuZ2V0RGF0YUJ5S2V5ID0gZnVuY3Rpb24oS2V5KSB7XHJcbiAgICByZXR1cm4gIHRoaXMuZGF0YVtLZXldO1xyXG59O1xyXG59LHt9XSw1NDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XHJcbmZ1bmN0aW9uIFV0aWxzKCl7fVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBVdGlscztcclxuXHJcbi8qKlxyXG4gKiBFeHRlbmQgYW4gb3B0aW9ucyBvYmplY3Qgd2l0aCBkZWZhdWx0IHZhbHVlcy5cclxuICogQHN0YXRpY1xyXG4gKiBAbWV0aG9kIGRlZmF1bHRzXHJcbiAqIEBwYXJhbSAge29iamVjdH0gb3B0aW9ucyBUaGUgb3B0aW9ucyBvYmplY3QuIE1heSBiZSBmYWxzeTogaW4gdGhpcyBjYXNlLCBhIG5ldyBvYmplY3QgaXMgY3JlYXRlZCBhbmQgcmV0dXJuZWQuXHJcbiAqIEBwYXJhbSAge29iamVjdH0gZGVmYXVsdHMgQW4gb2JqZWN0IGNvbnRhaW5pbmcgZGVmYXVsdCB2YWx1ZXMuXHJcbiAqIEByZXR1cm4ge29iamVjdH0gVGhlIG1vZGlmaWVkIG9wdGlvbnMgb2JqZWN0LlxyXG4gKi9cclxuVXRpbHMuZGVmYXVsdHMgPSBmdW5jdGlvbihvcHRpb25zLCBkZWZhdWx0cyl7XHJcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcbiAgICBmb3IodmFyIGtleSBpbiBkZWZhdWx0cyl7XHJcbiAgICAgICAgaWYoIShrZXkgaW4gb3B0aW9ucykpe1xyXG4gICAgICAgICAgICBvcHRpb25zW2tleV0gPSBkZWZhdWx0c1trZXldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gb3B0aW9ucztcclxufTtcclxuXHJcbn0se31dLDU1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcclxubW9kdWxlLmV4cG9ydHMgPSBWZWMzUG9vbDtcclxuXHJcbnZhciBWZWMzID0gX2RlcmVxXygnLi4vbWF0aC9WZWMzJyk7XHJcbnZhciBQb29sID0gX2RlcmVxXygnLi9Qb29sJyk7XHJcblxyXG4vKipcclxuICogQGNsYXNzIFZlYzNQb29sXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAZXh0ZW5kcyBQb29sXHJcbiAqL1xyXG5mdW5jdGlvbiBWZWMzUG9vbCgpe1xyXG4gICAgUG9vbC5jYWxsKHRoaXMpO1xyXG4gICAgdGhpcy50eXBlID0gVmVjMztcclxufVxyXG5WZWMzUG9vbC5wcm90b3R5cGUgPSBuZXcgUG9vbCgpO1xyXG5cclxuLyoqXHJcbiAqIENvbnN0cnVjdCBhIHZlY3RvclxyXG4gKiBAbWV0aG9kIGNvbnN0cnVjdE9iamVjdFxyXG4gKiBAcmV0dXJuIHtWZWMzfVxyXG4gKi9cclxuVmVjM1Bvb2wucHJvdG90eXBlLmNvbnN0cnVjdE9iamVjdCA9IGZ1bmN0aW9uKCl7XHJcbiAgICByZXR1cm4gbmV3IFZlYzMoKTtcclxufTtcclxuXHJcbn0se1wiLi4vbWF0aC9WZWMzXCI6MzEsXCIuL1Bvb2xcIjo1Mn1dLDU2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcclxubW9kdWxlLmV4cG9ydHMgPSBOYXJyb3dwaGFzZTtcclxuXHJcbnZhciBBQUJCID0gX2RlcmVxXygnLi4vY29sbGlzaW9uL0FBQkInKTtcclxudmFyIEJvZHkgPSBfZGVyZXFfKCcuLi9vYmplY3RzL0JvZHknKTtcclxudmFyIFNoYXBlID0gX2RlcmVxXygnLi4vc2hhcGVzL1NoYXBlJyk7XHJcbnZhciBSYXkgPSBfZGVyZXFfKCcuLi9jb2xsaXNpb24vUmF5Jyk7XHJcbnZhciBWZWMzID0gX2RlcmVxXygnLi4vbWF0aC9WZWMzJyk7XHJcbnZhciBUcmFuc2Zvcm0gPSBfZGVyZXFfKCcuLi9tYXRoL1RyYW5zZm9ybScpO1xyXG52YXIgQ29udmV4UG9seWhlZHJvbiA9IF9kZXJlcV8oJy4uL3NoYXBlcy9Db252ZXhQb2x5aGVkcm9uJyk7XHJcbnZhciBRdWF0ZXJuaW9uID0gX2RlcmVxXygnLi4vbWF0aC9RdWF0ZXJuaW9uJyk7XHJcbnZhciBTb2x2ZXIgPSBfZGVyZXFfKCcuLi9zb2x2ZXIvU29sdmVyJyk7XHJcbnZhciBWZWMzUG9vbCA9IF9kZXJlcV8oJy4uL3V0aWxzL1ZlYzNQb29sJyk7XHJcbnZhciBDb250YWN0RXF1YXRpb24gPSBfZGVyZXFfKCcuLi9lcXVhdGlvbnMvQ29udGFjdEVxdWF0aW9uJyk7XHJcbnZhciBGcmljdGlvbkVxdWF0aW9uID0gX2RlcmVxXygnLi4vZXF1YXRpb25zL0ZyaWN0aW9uRXF1YXRpb24nKTtcclxuXHJcbi8qKlxyXG4gKiBIZWxwZXIgY2xhc3MgZm9yIHRoZSBXb3JsZC4gR2VuZXJhdGVzIENvbnRhY3RFcXVhdGlvbnMuXHJcbiAqIEBjbGFzcyBOYXJyb3dwaGFzZVxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHRvZG8gU3BoZXJlLUNvbnZleFBvbHloZWRyb24gY29udGFjdHNcclxuICogQHRvZG8gQ29udGFjdCByZWR1Y3Rpb25cclxuICogQHRvZG8gIHNob3VsZCBtb3ZlIG1ldGhvZHMgdG8gcHJvdG90eXBlXHJcbiAqL1xyXG5mdW5jdGlvbiBOYXJyb3dwaGFzZSh3b3JsZCl7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnRlcm5hbCBzdG9yYWdlIG9mIHBvb2xlZCBjb250YWN0IHBvaW50cy5cclxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IGNvbnRhY3RQb2ludFBvb2xcclxuICAgICAqL1xyXG4gICAgdGhpcy5jb250YWN0UG9pbnRQb29sID0gW107XHJcblxyXG4gICAgdGhpcy5mcmljdGlvbkVxdWF0aW9uUG9vbCA9IFtdO1xyXG5cclxuICAgIHRoaXMucmVzdWx0ID0gW107XHJcbiAgICB0aGlzLmZyaWN0aW9uUmVzdWx0ID0gW107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQb29sZWQgdmVjdG9ycy5cclxuICAgICAqIEBwcm9wZXJ0eSB7VmVjM1Bvb2x9IHYzcG9vbFxyXG4gICAgICovXHJcbiAgICB0aGlzLnYzcG9vbCA9IG5ldyBWZWMzUG9vbCgpO1xyXG5cclxuICAgIHRoaXMud29ybGQgPSB3b3JsZDtcclxuICAgIHRoaXMuY3VycmVudENvbnRhY3RNYXRlcmlhbCA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IGVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb24gPSBmYWxzZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIE1ha2UgYSBjb250YWN0IG9iamVjdCwgYnkgdXNpbmcgdGhlIGludGVybmFsIHBvb2wgb3IgY3JlYXRpbmcgYSBuZXcgb25lLlxyXG4gKiBAbWV0aG9kIGNyZWF0ZUNvbnRhY3RFcXVhdGlvblxyXG4gKiBAcGFyYW0ge0JvZHl9IGJpXHJcbiAqIEBwYXJhbSB7Qm9keX0gYmpcclxuICogQHBhcmFtIHtTaGFwZX0gc2lcclxuICogQHBhcmFtIHtTaGFwZX0gc2pcclxuICogQHBhcmFtIHtTaGFwZX0gb3ZlcnJpZGVTaGFwZUFcclxuICogQHBhcmFtIHtTaGFwZX0gb3ZlcnJpZGVTaGFwZUJcclxuICogQHJldHVybiB7Q29udGFjdEVxdWF0aW9ufVxyXG4gKi9cclxuTmFycm93cGhhc2UucHJvdG90eXBlLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbiA9IGZ1bmN0aW9uKGJpLCBiaiwgc2ksIHNqLCBvdmVycmlkZVNoYXBlQSwgb3ZlcnJpZGVTaGFwZUIpe1xyXG4gICAgdmFyIGM7XHJcbiAgICBpZih0aGlzLmNvbnRhY3RQb2ludFBvb2wubGVuZ3RoKXtcclxuICAgICAgICBjID0gdGhpcy5jb250YWN0UG9pbnRQb29sLnBvcCgpO1xyXG4gICAgICAgIGMuYmkgPSBiaTtcclxuICAgICAgICBjLmJqID0gYmo7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGMgPSBuZXcgQ29udGFjdEVxdWF0aW9uKGJpLCBiaik7XHJcbiAgICB9XHJcbiAgICAvLyBuZWVkID8sIHRyaWdnZXIgaXMgYWxyZWFkeSBmaWx0ZXJcclxuICAgIC8vIGMuZW5hYmxlZCA9IGJpLmNvbGxpc2lvblJlc3BvbnNlICYmIGJqLmNvbGxpc2lvblJlc3BvbnNlICYmIHNpLmNvbGxpc2lvblJlc3BvbnNlICYmIHNqLmNvbGxpc2lvblJlc3BvbnNlO1xyXG4gICAgXHJcbiAgICB2YXIgY20gPSB0aGlzLmN1cnJlbnRDb250YWN0TWF0ZXJpYWw7XHJcblxyXG4gICAgYy5yZXN0aXR1dGlvbiA9IGNtLnJlc3RpdHV0aW9uO1xyXG5cclxuICAgIGMuc2V0U3Bvb2tQYXJhbXMoXHJcbiAgICAgICAgY20uY29udGFjdEVxdWF0aW9uU3RpZmZuZXNzLFxyXG4gICAgICAgIGNtLmNvbnRhY3RFcXVhdGlvblJlbGF4YXRpb24sXHJcbiAgICAgICAgdGhpcy53b3JsZC5kdFxyXG4gICAgKTtcclxuXHJcbiAgICB2YXIgbWF0QSA9IHNpLm1hdGVyaWFsIHx8IGJpLm1hdGVyaWFsO1xyXG4gICAgdmFyIG1hdEIgPSBzai5tYXRlcmlhbCB8fCBiai5tYXRlcmlhbDtcclxuICAgIGlmKG1hdEEgJiYgbWF0QiAmJiBtYXRBLnJlc3RpdHV0aW9uID49IDAgJiYgbWF0Qi5yZXN0aXR1dGlvbiA+PSAwKXtcclxuICAgICAgICBjLnJlc3RpdHV0aW9uID0gbWF0QS5yZXN0aXR1dGlvbiAqIG1hdEIucmVzdGl0dXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgYy5zaSA9IG92ZXJyaWRlU2hhcGVBIHx8IHNpO1xyXG4gICAgYy5zaiA9IG92ZXJyaWRlU2hhcGVCIHx8IHNqO1xyXG5cclxuICAgIHJldHVybiBjO1xyXG59O1xyXG5cclxuTmFycm93cGhhc2UucHJvdG90eXBlLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3QgPSBmdW5jdGlvbihjb250YWN0RXF1YXRpb24sIG91dEFycmF5KXtcclxuICAgIHZhciBib2R5QSA9IGNvbnRhY3RFcXVhdGlvbi5iaTtcclxuICAgIHZhciBib2R5QiA9IGNvbnRhY3RFcXVhdGlvbi5iajtcclxuICAgIHZhciBzaGFwZUEgPSBjb250YWN0RXF1YXRpb24uc2k7XHJcbiAgICB2YXIgc2hhcGVCID0gY29udGFjdEVxdWF0aW9uLnNqO1xyXG5cclxuICAgIHZhciB3b3JsZCA9IHRoaXMud29ybGQ7XHJcbiAgICB2YXIgY20gPSB0aGlzLmN1cnJlbnRDb250YWN0TWF0ZXJpYWw7XHJcblxyXG4gICAgLy8gSWYgZnJpY3Rpb24gb3IgcmVzdGl0dXRpb24gd2VyZSBzcGVjaWZpZWQgaW4gdGhlIG1hdGVyaWFsLCB1c2UgdGhlbVxyXG4gICAgdmFyIGZyaWN0aW9uID0gY20uZnJpY3Rpb247XHJcbiAgICB2YXIgbWF0QSA9IHNoYXBlQS5tYXRlcmlhbCB8fCBib2R5QS5tYXRlcmlhbDtcclxuICAgIHZhciBtYXRCID0gc2hhcGVCLm1hdGVyaWFsIHx8IGJvZHlCLm1hdGVyaWFsO1xyXG4gICAgaWYobWF0QSAmJiBtYXRCICYmIG1hdEEuZnJpY3Rpb24gPj0gMCAmJiBtYXRCLmZyaWN0aW9uID49IDApe1xyXG4gICAgICAgIGZyaWN0aW9uID0gbWF0QS5mcmljdGlvbiAqIG1hdEIuZnJpY3Rpb247XHJcbiAgICB9XHJcblxyXG4gICAgaWYoZnJpY3Rpb24gPiAwKXtcclxuXHJcbiAgICAgICAgLy8gQ3JlYXRlIDIgdGFuZ2VudCBlcXVhdGlvbnNcclxuICAgICAgICB2YXIgbXVnID0gZnJpY3Rpb24gKiB3b3JsZC5ncmF2aXR5Lmxlbmd0aCgpO1xyXG4gICAgICAgIHZhciByZWR1Y2VkTWFzcyA9IChib2R5QS5pbnZNYXNzICsgYm9keUIuaW52TWFzcyk7XHJcbiAgICAgICAgaWYocmVkdWNlZE1hc3MgPiAwKXtcclxuICAgICAgICAgICAgcmVkdWNlZE1hc3MgPSAxL3JlZHVjZWRNYXNzO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcG9vbCA9IHRoaXMuZnJpY3Rpb25FcXVhdGlvblBvb2w7XHJcbiAgICAgICAgdmFyIGMxID0gcG9vbC5sZW5ndGggPyBwb29sLnBvcCgpIDogbmV3IEZyaWN0aW9uRXF1YXRpb24oYm9keUEsYm9keUIsbXVnKnJlZHVjZWRNYXNzKTtcclxuICAgICAgICB2YXIgYzIgPSBwb29sLmxlbmd0aCA/IHBvb2wucG9wKCkgOiBuZXcgRnJpY3Rpb25FcXVhdGlvbihib2R5QSxib2R5QixtdWcqcmVkdWNlZE1hc3MpO1xyXG5cclxuICAgICAgICBjMS5iaSA9IGMyLmJpID0gYm9keUE7XHJcbiAgICAgICAgYzEuYmogPSBjMi5iaiA9IGJvZHlCO1xyXG4gICAgICAgIGMxLm1pbkZvcmNlID0gYzIubWluRm9yY2UgPSAtbXVnKnJlZHVjZWRNYXNzO1xyXG4gICAgICAgIGMxLm1heEZvcmNlID0gYzIubWF4Rm9yY2UgPSBtdWcqcmVkdWNlZE1hc3M7XHJcblxyXG4gICAgICAgIC8vIENvcHkgb3ZlciB0aGUgcmVsYXRpdmUgdmVjdG9yc1xyXG4gICAgICAgIGMxLnJpLmNvcHkoY29udGFjdEVxdWF0aW9uLnJpKTtcclxuICAgICAgICBjMS5yai5jb3B5KGNvbnRhY3RFcXVhdGlvbi5yaik7XHJcbiAgICAgICAgYzIucmkuY29weShjb250YWN0RXF1YXRpb24ucmkpO1xyXG4gICAgICAgIGMyLnJqLmNvcHkoY29udGFjdEVxdWF0aW9uLnJqKTtcclxuXHJcbiAgICAgICAgLy8gQ29uc3RydWN0IHRhbmdlbnRzXHJcbiAgICAgICAgY29udGFjdEVxdWF0aW9uLm5pLnRhbmdlbnRzKGMxLnQsIGMyLnQpO1xyXG5cclxuICAgICAgICAvLyBTZXQgc3Bvb2sgcGFyYW1zXHJcbiAgICAgICAgYzEuc2V0U3Bvb2tQYXJhbXMoY20uZnJpY3Rpb25FcXVhdGlvblN0aWZmbmVzcywgY20uZnJpY3Rpb25FcXVhdGlvblJlbGF4YXRpb24sIHdvcmxkLmR0KTtcclxuICAgICAgICBjMi5zZXRTcG9va1BhcmFtcyhjbS5mcmljdGlvbkVxdWF0aW9uU3RpZmZuZXNzLCBjbS5mcmljdGlvbkVxdWF0aW9uUmVsYXhhdGlvbiwgd29ybGQuZHQpO1xyXG5cclxuICAgICAgICBjMS5lbmFibGVkID0gYzIuZW5hYmxlZCA9IGNvbnRhY3RFcXVhdGlvbi5lbmFibGVkO1xyXG5cclxuICAgICAgICBvdXRBcnJheS5wdXNoKGMxLCBjMik7XHJcblxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmYWxzZTtcclxufTtcclxuXHJcbnZhciBhdmVyYWdlTm9ybWFsID0gbmV3IFZlYzMoKTtcclxudmFyIGF2ZXJhZ2VDb250YWN0UG9pbnRBID0gbmV3IFZlYzMoKTtcclxudmFyIGF2ZXJhZ2VDb250YWN0UG9pbnRCID0gbmV3IFZlYzMoKTtcclxuXHJcbi8vIFRha2UgdGhlIGF2ZXJhZ2UgTiBsYXRlc3QgY29udGFjdCBwb2ludCBvbiB0aGUgcGxhbmUuXHJcbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5jcmVhdGVGcmljdGlvbkZyb21BdmVyYWdlID0gZnVuY3Rpb24obnVtQ29udGFjdHMpe1xyXG4gICAgLy8gVGhlIGxhc3QgY29udGFjdEVxdWF0aW9uXHJcbiAgICB2YXIgYyA9IHRoaXMucmVzdWx0W3RoaXMucmVzdWx0Lmxlbmd0aCAtIDFdO1xyXG5cclxuICAgIC8vIENyZWF0ZSB0aGUgcmVzdWx0OiB0d28gXCJhdmVyYWdlXCIgZnJpY3Rpb24gZXF1YXRpb25zXHJcbiAgICBpZiAoIXRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChjLCB0aGlzLmZyaWN0aW9uUmVzdWx0KSB8fCBudW1Db250YWN0cyA9PT0gMSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZjEgPSB0aGlzLmZyaWN0aW9uUmVzdWx0W3RoaXMuZnJpY3Rpb25SZXN1bHQubGVuZ3RoIC0gMl07XHJcbiAgICB2YXIgZjIgPSB0aGlzLmZyaWN0aW9uUmVzdWx0W3RoaXMuZnJpY3Rpb25SZXN1bHQubGVuZ3RoIC0gMV07XHJcblxyXG4gICAgYXZlcmFnZU5vcm1hbC5zZXRaZXJvKCk7XHJcbiAgICBhdmVyYWdlQ29udGFjdFBvaW50QS5zZXRaZXJvKCk7XHJcbiAgICBhdmVyYWdlQ29udGFjdFBvaW50Qi5zZXRaZXJvKCk7XHJcblxyXG4gICAgdmFyIGJvZHlBID0gYy5iaTtcclxuICAgIHZhciBib2R5QiA9IGMuYmo7XHJcbiAgICBmb3IodmFyIGk9MDsgaSE9PW51bUNvbnRhY3RzOyBpKyspe1xyXG4gICAgICAgIGMgPSB0aGlzLnJlc3VsdFt0aGlzLnJlc3VsdC5sZW5ndGggLSAxIC0gaV07XHJcbiAgICAgICAgaWYoYy5ib2R5QSAhPT0gYm9keUEpe1xyXG4gICAgICAgICAgICBhdmVyYWdlTm9ybWFsLnZhZGQoYy5uaSwgYXZlcmFnZU5vcm1hbCk7XHJcbiAgICAgICAgICAgIGF2ZXJhZ2VDb250YWN0UG9pbnRBLnZhZGQoYy5yaSwgYXZlcmFnZUNvbnRhY3RQb2ludEEpO1xyXG4gICAgICAgICAgICBhdmVyYWdlQ29udGFjdFBvaW50Qi52YWRkKGMucmosIGF2ZXJhZ2VDb250YWN0UG9pbnRCKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBhdmVyYWdlTm9ybWFsLnZzdWIoYy5uaSwgYXZlcmFnZU5vcm1hbCk7XHJcbiAgICAgICAgICAgIGF2ZXJhZ2VDb250YWN0UG9pbnRBLnZhZGQoYy5yaiwgYXZlcmFnZUNvbnRhY3RQb2ludEEpO1xyXG4gICAgICAgICAgICBhdmVyYWdlQ29udGFjdFBvaW50Qi52YWRkKGMucmksIGF2ZXJhZ2VDb250YWN0UG9pbnRCKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGludk51bUNvbnRhY3RzID0gMSAvIG51bUNvbnRhY3RzO1xyXG4gICAgYXZlcmFnZUNvbnRhY3RQb2ludEEuc2NhbGUoaW52TnVtQ29udGFjdHMsIGYxLnJpKTtcclxuICAgIGF2ZXJhZ2VDb250YWN0UG9pbnRCLnNjYWxlKGludk51bUNvbnRhY3RzLCBmMS5yaik7XHJcbiAgICBmMi5yaS5jb3B5KGYxLnJpKTsgLy8gU2hvdWxkIGJlIHRoZSBzYW1lXHJcbiAgICBmMi5yai5jb3B5KGYxLnJqKTtcclxuICAgIGF2ZXJhZ2VOb3JtYWwubm9ybWFsaXplKCk7XHJcbiAgICBhdmVyYWdlTm9ybWFsLnRhbmdlbnRzKGYxLnQsIGYyLnQpO1xyXG4gICAgLy8gcmV0dXJuIGVxO1xyXG59O1xyXG5cclxuXHJcbnZhciB0bXBWZWMxID0gbmV3IFZlYzMoKTtcclxudmFyIHRtcFZlYzIgPSBuZXcgVmVjMygpO1xyXG52YXIgdG1wUXVhdDEgPSBuZXcgUXVhdGVybmlvbigpO1xyXG52YXIgdG1wUXVhdDIgPSBuZXcgUXVhdGVybmlvbigpO1xyXG5cclxuLyoqXHJcbiAqIEdlbmVyYXRlIGFsbCBjb250YWN0cyBiZXR3ZWVuIGEgbGlzdCBvZiBib2R5IHBhaXJzXHJcbiAqIEBtZXRob2QgZ2V0Q29udGFjdHNcclxuICogQHBhcmFtIHthcnJheX0gcDEgQXJyYXkgb2YgYm9keSBpbmRpY2VzXHJcbiAqIEBwYXJhbSB7YXJyYXl9IHAyIEFycmF5IG9mIGJvZHkgaW5kaWNlc1xyXG4gKiBAcGFyYW0ge1dvcmxkfSB3b3JsZFxyXG4gKiBAcGFyYW0ge2FycmF5fSByZXN1bHQgQXJyYXkgdG8gc3RvcmUgZ2VuZXJhdGVkIGNvbnRhY3RzXHJcbiAqIEBwYXJhbSB7YXJyYXl9IG9sZGNvbnRhY3RzIE9wdGlvbmFsLiBBcnJheSBvZiByZXVzYWJsZSBjb250YWN0IG9iamVjdHNcclxuICovXHJcbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5nZXRDb250YWN0cyA9IGZ1bmN0aW9uKHAxLCBwMiwgd29ybGQsIHJlc3VsdCwgb2xkY29udGFjdHMsIGZyaWN0aW9uUmVzdWx0LCBmcmljdGlvblBvb2wpe1xyXG4gICAgLy8gU2F2ZSBvbGQgY29udGFjdCBvYmplY3RzXHJcbiAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25Qb29sID0gZnJpY3Rpb25Qb29sO1xyXG4gICAgdGhpcy5yZXN1bHQgPSByZXN1bHQ7XHJcbiAgICB0aGlzLmZyaWN0aW9uUmVzdWx0ID0gZnJpY3Rpb25SZXN1bHQ7XHJcblxyXG4gICAgdmFyIHFpID0gdG1wUXVhdDE7XHJcbiAgICB2YXIgcWogPSB0bXBRdWF0MjtcclxuICAgIHZhciB4aSA9IHRtcFZlYzE7XHJcbiAgICB2YXIgeGogPSB0bXBWZWMyO1xyXG5cclxuICAgIGZvcih2YXIgaz0wLCBOPXAxLmxlbmd0aDsgayE9PU47IGsrKyl7XHJcblxyXG4gICAgICAgIC8vIEdldCBjdXJyZW50IGNvbGxpc2lvbiBib2RpZXNcclxuICAgICAgICB2YXIgYmkgPSBwMVtrXSxcclxuICAgICAgICAgICAgYmogPSBwMltrXTtcclxuXHJcbiAgICAgICAgLy8gR2V0IGNvbnRhY3QgbWF0ZXJpYWxcclxuICAgICAgICB2YXIgYm9keUNvbnRhY3RNYXRlcmlhbCA9IG51bGw7XHJcbiAgICAgICAgaWYoYmkubWF0ZXJpYWwgJiYgYmoubWF0ZXJpYWwpe1xyXG4gICAgICAgICAgICBib2R5Q29udGFjdE1hdGVyaWFsID0gd29ybGQuZ2V0Q29udGFjdE1hdGVyaWFsKGJpLm1hdGVyaWFsLGJqLm1hdGVyaWFsKSB8fCBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGp1c3RUZXN0ID0gKCBiaS5jb2xsaXNpb25SZXNwb25zZSA9PSBmYWxzZSB8fCBiai5jb2xsaXNpb25SZXNwb25zZSA9PSBmYWxzZSB8fFxyXG4gICAgICAgICAgICAoXHJcbiAgICAgICAgICAgICAgICAoYmkudHlwZSAmIEJvZHkuS0lORU1BVElDKSAmJiAoYmoudHlwZSAmIEJvZHkuU1RBVElDKVxyXG4gICAgICAgICAgICApIHx8IChcclxuICAgICAgICAgICAgICAgIChiaS50eXBlICYgQm9keS5TVEFUSUMpICYmIChiai50eXBlICYgQm9keS5LSU5FTUFUSUMpXHJcbiAgICAgICAgICAgICkgfHwgKFxyXG4gICAgICAgICAgICAgICAgKGJpLnR5cGUgJiBCb2R5LktJTkVNQVRJQykgJiYgKGJqLnR5cGUgJiBCb2R5LktJTkVNQVRJQylcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmkuc2hhcGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGJpLnF1YXRlcm5pb24ubXVsdChiaS5zaGFwZU9yaWVudGF0aW9uc1tpXSwgcWkpO1xyXG4gICAgICAgICAgICBiaS5xdWF0ZXJuaW9uLnZtdWx0KGJpLnNoYXBlT2Zmc2V0c1tpXSwgeGkpO1xyXG4gICAgICAgICAgICB4aS52YWRkKGJpLnBvc2l0aW9uLCB4aSk7XHJcbiAgICAgICAgICAgIHZhciBzaSA9IGJpLnNoYXBlc1tpXTtcclxuXHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYmouc2hhcGVzLmxlbmd0aDsgaisrKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ29tcHV0ZSB3b3JsZCB0cmFuc2Zvcm0gb2Ygc2hhcGVzXHJcbiAgICAgICAgICAgICAgICBiai5xdWF0ZXJuaW9uLm11bHQoYmouc2hhcGVPcmllbnRhdGlvbnNbal0sIHFqKTtcclxuICAgICAgICAgICAgICAgIGJqLnF1YXRlcm5pb24udm11bHQoYmouc2hhcGVPZmZzZXRzW2pdLCB4aik7XHJcbiAgICAgICAgICAgICAgICB4ai52YWRkKGJqLnBvc2l0aW9uLCB4aik7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2ogPSBiai5zaGFwZXNbal07XHJcblxyXG4gICAgICAgICAgICAgICAgaWYoISgoc2kuY29sbGlzaW9uRmlsdGVyTWFzayAmIHNqLmNvbGxpc2lvbkZpbHRlckdyb3VwKSAmJiAoc2ouY29sbGlzaW9uRmlsdGVyTWFzayAmIHNpLmNvbGxpc2lvbkZpbHRlckdyb3VwKSkpe1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmKHhpLmRpc3RhbmNlVG8oeGopID4gc2kuYm91bmRpbmdTcGhlcmVSYWRpdXMgKyBzai5ib3VuZGluZ1NwaGVyZVJhZGl1cyl7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIC8vIGlzIHRyaWdnZXIgPyAsdHJpZ2dlciB0ZXN0IGp1c3Qgb25seVxyXG4gICAgICAgICAgICAgICAganVzdFRlc3QgfD0gKHNpLmNvbGxpc2lvblJlc3BvbnNlID09IGZhbHNlKSB8fCAoc2ouY29sbGlzaW9uUmVzcG9uc2UgPT0gZmFsc2UpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEdldCBjb2xsaXNpb24gbWF0ZXJpYWxcclxuICAgICAgICAgICAgICAgIHZhciBzaGFwZUNvbnRhY3RNYXRlcmlhbCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBpZihzaS5tYXRlcmlhbCAmJiBzai5tYXRlcmlhbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgc2hhcGVDb250YWN0TWF0ZXJpYWwgPSB3b3JsZC5nZXRDb250YWN0TWF0ZXJpYWwoc2kubWF0ZXJpYWwsc2oubWF0ZXJpYWwpIHx8IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50Q29udGFjdE1hdGVyaWFsID0gc2hhcGVDb250YWN0TWF0ZXJpYWwgfHwgYm9keUNvbnRhY3RNYXRlcmlhbCB8fCB3b3JsZC5kZWZhdWx0Q29udGFjdE1hdGVyaWFsO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEdldCBjb250YWN0c1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlc29sdmVyID0gdGhpc1tzaS50eXBlIHwgc2oudHlwZV07XHJcbiAgICAgICAgICAgICAgICBpZihyZXNvbHZlcil7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJldHZhbCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzaS50eXBlIDwgc2oudHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSByZXNvbHZlci5jYWxsKHRoaXMsIHNpLCBzaiwgeGksIHhqLCBxaSwgcWosIGJpLCBiaiwgc2ksIHNqLCBqdXN0VGVzdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gcmVzb2x2ZXIuY2FsbCh0aGlzLCBzaiwgc2ksIHhqLCB4aSwgcWosIHFpLCBiaiwgYmksIHNpLCBzaiwganVzdFRlc3QpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYocmV0dmFsICYmIGp1c3RUZXN0KXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVnaXN0ZXIgb3ZlcmxhcFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JsZC5zaGFwZU92ZXJsYXBLZWVwZXIuc2V0KHNpLmlkLCBzai5pZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmxkLnNoYXBlT3ZlcmxhcEtlZXBlckV4aXQuc2V0KHNpLmlkLCBzai5pZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxudmFyIG51bVdhcm5pbmdzID0gMDtcclxudmFyIG1heFdhcm5pbmdzID0gMTA7XHJcblxyXG5mdW5jdGlvbiB3YXJuKG1zZyl7XHJcbiAgICBpZihudW1XYXJuaW5ncyA+IG1heFdhcm5pbmdzKXtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgbnVtV2FybmluZ3MrKztcclxuXHJcbiAgICBjb25zb2xlLndhcm4obXNnKTtcclxufVxyXG5cclxuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLnR5cGVzLkJPWCB8IFNoYXBlLnR5cGVzLkJPWF0gPVxyXG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuYm94Qm94ID0gZnVuY3Rpb24oc2ksc2oseGkseGoscWkscWosYmksYmoscnNpLHJzaixqdXN0VGVzdCl7XHJcbiAgICBzaS5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24ubWF0ZXJpYWwgPSBzaS5tYXRlcmlhbDtcclxuICAgIHNqLmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbi5tYXRlcmlhbCA9IHNqLm1hdGVyaWFsO1xyXG4gICAgc2kuY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLmNvbGxpc2lvblJlc3BvbnNlID0gc2kuY29sbGlzaW9uUmVzcG9uc2U7XHJcbiAgICBzai5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24uY29sbGlzaW9uUmVzcG9uc2UgPSBzai5jb2xsaXNpb25SZXNwb25zZTtcclxuICAgIHJldHVybiB0aGlzLmNvbnZleENvbnZleChzaS5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24sc2ouY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLHhpLHhqLHFpLHFqLGJpLGJqLHNpLHNqLGp1c3RUZXN0KTtcclxufTtcclxuXHJcbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS50eXBlcy5CT1ggfCBTaGFwZS50eXBlcy5DT05WRVhQT0xZSEVEUk9OXSA9XHJcbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5ib3hDb252ZXggPSBmdW5jdGlvbihzaSxzaix4aSx4aixxaSxxaixiaSxiaixyc2kscnNqLGp1c3RUZXN0KXtcclxuICAgIHNpLmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbi5tYXRlcmlhbCA9IHNpLm1hdGVyaWFsO1xyXG4gICAgc2kuY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLmNvbGxpc2lvblJlc3BvbnNlID0gc2kuY29sbGlzaW9uUmVzcG9uc2U7XHJcbiAgICByZXR1cm4gdGhpcy5jb252ZXhDb252ZXgoc2kuY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLHNqLHhpLHhqLHFpLHFqLGJpLGJqLHNpLHNqLGp1c3RUZXN0KTtcclxufTtcclxuXHJcbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS50eXBlcy5CT1ggfCBTaGFwZS50eXBlcy5QQVJUSUNMRV0gPVxyXG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuYm94UGFydGljbGUgPSBmdW5jdGlvbihzaSxzaix4aSx4aixxaSxxaixiaSxiaixyc2kscnNqLGp1c3RUZXN0KXtcclxuICAgIHNpLmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbi5tYXRlcmlhbCA9IHNpLm1hdGVyaWFsO1xyXG4gICAgc2kuY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLmNvbGxpc2lvblJlc3BvbnNlID0gc2kuY29sbGlzaW9uUmVzcG9uc2U7XHJcbiAgICByZXR1cm4gdGhpcy5jb252ZXhQYXJ0aWNsZShzaS5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24sc2oseGkseGoscWkscWosYmksYmosc2ksc2osanVzdFRlc3QpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2Qgc3BoZXJlU3BoZXJlXHJcbiAqIEBwYXJhbSAge1NoYXBlfSAgICAgIHNpXHJcbiAqIEBwYXJhbSAge1NoYXBlfSAgICAgIHNqXHJcbiAqIEBwYXJhbSAge1ZlYzN9ICAgICAgIHhpXHJcbiAqIEBwYXJhbSAge1ZlYzN9ICAgICAgIHhqXHJcbiAqIEBwYXJhbSAge1F1YXRlcm5pb259IHFpXHJcbiAqIEBwYXJhbSAge1F1YXRlcm5pb259IHFqXHJcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGJpXHJcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGJqXHJcbiAqL1xyXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUudHlwZXMuU1BIRVJFXSA9XHJcbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5zcGhlcmVTcGhlcmUgPSBmdW5jdGlvbihzaSxzaix4aSx4aixxaSxxaixiaSxiaixyc2kscnNqLGp1c3RUZXN0KXtcclxuICAgIGlmKGp1c3RUZXN0KXtcclxuICAgICAgICByZXR1cm4geGkuZGlzdGFuY2VTcXVhcmVkKHhqKSA8IE1hdGgucG93KHNpLnJhZGl1cyArIHNqLnJhZGl1cywgMik7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gV2Ugd2lsbCBoYXZlIG9ubHkgb25lIGNvbnRhY3QgaW4gdGhpcyBjYXNlXHJcbiAgICB2YXIgciA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGJpLGJqLHNpLHNqLHJzaSxyc2opO1xyXG5cclxuICAgIC8vIENvbnRhY3Qgbm9ybWFsXHJcbiAgICB4ai52c3ViKHhpLCByLm5pKTtcclxuICAgIHIubmkubm9ybWFsaXplKCk7XHJcblxyXG4gICAgLy8gQ29udGFjdCBwb2ludCBsb2NhdGlvbnNcclxuICAgIHIucmkuY29weShyLm5pKTtcclxuICAgIHIucmouY29weShyLm5pKTtcclxuICAgIHIucmkubXVsdChzaS5yYWRpdXMsIHIucmkpO1xyXG4gICAgci5yai5tdWx0KC1zai5yYWRpdXMsIHIucmopO1xyXG5cclxuICAgIHIucmkudmFkZCh4aSwgci5yaSk7XHJcbiAgICByLnJpLnZzdWIoYmkucG9zaXRpb24sIHIucmkpO1xyXG5cclxuICAgIHIucmoudmFkZCh4aiwgci5yaik7XHJcbiAgICByLnJqLnZzdWIoYmoucG9zaXRpb24sIHIucmopO1xyXG5cclxuICAgIHRoaXMucmVzdWx0LnB1c2gocik7XHJcblxyXG4gICAgdGhpcy5jcmVhdGVGcmljdGlvbkVxdWF0aW9uc0Zyb21Db250YWN0KHIsIHRoaXMuZnJpY3Rpb25SZXN1bHQpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgcGxhbmVUcmltZXNoXHJcbiAqIEBwYXJhbSAge1NoYXBlfSAgICAgIHNpXHJcbiAqIEBwYXJhbSAge1NoYXBlfSAgICAgIHNqXHJcbiAqIEBwYXJhbSAge1ZlYzN9ICAgICAgIHhpXHJcbiAqIEBwYXJhbSAge1ZlYzN9ICAgICAgIHhqXHJcbiAqIEBwYXJhbSAge1F1YXRlcm5pb259IHFpXHJcbiAqIEBwYXJhbSAge1F1YXRlcm5pb259IHFqXHJcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGJpXHJcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGJqXHJcbiAqL1xyXG52YXIgcGxhbmVUcmltZXNoX25vcm1hbCA9IG5ldyBWZWMzKCk7XHJcbnZhciBwbGFuZVRyaW1lc2hfcmVscG9zID0gbmV3IFZlYzMoKTtcclxudmFyIHBsYW5lVHJpbWVzaF9wcm9qZWN0ZWQgPSBuZXcgVmVjMygpO1xyXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUudHlwZXMuUExBTkUgfCBTaGFwZS50eXBlcy5UUklNRVNIXSA9XHJcbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5wbGFuZVRyaW1lc2ggPSBmdW5jdGlvbihcclxuICAgIHBsYW5lU2hhcGUsXHJcbiAgICB0cmltZXNoU2hhcGUsXHJcbiAgICBwbGFuZVBvcyxcclxuICAgIHRyaW1lc2hQb3MsXHJcbiAgICBwbGFuZVF1YXQsXHJcbiAgICB0cmltZXNoUXVhdCxcclxuICAgIHBsYW5lQm9keSxcclxuICAgIHRyaW1lc2hCb2R5LFxyXG4gICAgcnNpLFxyXG4gICAgcnNqLFxyXG4gICAganVzdFRlc3RcclxuKXtcclxuICAgIC8vIE1ha2UgY29udGFjdHMhXHJcbiAgICB2YXIgdiA9IG5ldyBWZWMzKCk7XHJcblxyXG4gICAgdmFyIG5vcm1hbCA9IHBsYW5lVHJpbWVzaF9ub3JtYWw7XHJcbiAgICBub3JtYWwuc2V0KDAsMCwxKTtcclxuICAgIHBsYW5lUXVhdC52bXVsdChub3JtYWwsbm9ybWFsKTsgLy8gVHVybiBub3JtYWwgYWNjb3JkaW5nIHRvIHBsYW5lXHJcblxyXG4gICAgZm9yKHZhciBpPTA7IGk8dHJpbWVzaFNoYXBlLnZlcnRpY2VzLmxlbmd0aCAvIDM7IGkrKyl7XHJcblxyXG4gICAgICAgIC8vIEdldCB3b3JsZCB2ZXJ0ZXggZnJvbSB0cmltZXNoXHJcbiAgICAgICAgdHJpbWVzaFNoYXBlLmdldFZlcnRleChpLCB2KTtcclxuXHJcbiAgICAgICAgLy8gU2FmZSB1cFxyXG4gICAgICAgIHZhciB2MiA9IG5ldyBWZWMzKCk7XHJcbiAgICAgICAgdjIuY29weSh2KTtcclxuICAgICAgICBUcmFuc2Zvcm0ucG9pbnRUb1dvcmxkRnJhbWUodHJpbWVzaFBvcywgdHJpbWVzaFF1YXQsIHYyLCB2KTtcclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgcGxhbmUgc2lkZVxyXG4gICAgICAgIHZhciByZWxwb3MgPSBwbGFuZVRyaW1lc2hfcmVscG9zO1xyXG4gICAgICAgIHYudnN1YihwbGFuZVBvcywgcmVscG9zKTtcclxuICAgICAgICB2YXIgZG90ID0gbm9ybWFsLmRvdChyZWxwb3MpO1xyXG5cclxuICAgICAgICBpZihkb3QgPD0gMC4wKXtcclxuICAgICAgICAgICAgaWYoanVzdFRlc3Qpe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciByID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24ocGxhbmVCb2R5LHRyaW1lc2hCb2R5LHBsYW5lU2hhcGUsdHJpbWVzaFNoYXBlLHJzaSxyc2opO1xyXG5cclxuICAgICAgICAgICAgci5uaS5jb3B5KG5vcm1hbCk7IC8vIENvbnRhY3Qgbm9ybWFsIGlzIHRoZSBwbGFuZSBub3JtYWxcclxuXHJcbiAgICAgICAgICAgIC8vIEdldCB2ZXJ0ZXggcG9zaXRpb24gcHJvamVjdGVkIG9uIHBsYW5lXHJcbiAgICAgICAgICAgIHZhciBwcm9qZWN0ZWQgPSBwbGFuZVRyaW1lc2hfcHJvamVjdGVkO1xyXG4gICAgICAgICAgICBub3JtYWwuc2NhbGUocmVscG9zLmRvdChub3JtYWwpLCBwcm9qZWN0ZWQpO1xyXG4gICAgICAgICAgICB2LnZzdWIocHJvamVjdGVkLHByb2plY3RlZCk7XHJcblxyXG4gICAgICAgICAgICAvLyByaSBpcyB0aGUgcHJvamVjdGVkIHdvcmxkIHBvc2l0aW9uIG1pbnVzIHBsYW5lIHBvc2l0aW9uXHJcbiAgICAgICAgICAgIHIucmkuY29weShwcm9qZWN0ZWQpO1xyXG4gICAgICAgICAgICByLnJpLnZzdWIocGxhbmVCb2R5LnBvc2l0aW9uLCByLnJpKTtcclxuXHJcbiAgICAgICAgICAgIHIucmouY29weSh2KTtcclxuICAgICAgICAgICAgci5yai52c3ViKHRyaW1lc2hCb2R5LnBvc2l0aW9uLCByLnJqKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFN0b3JlIHJlc3VsdFxyXG4gICAgICAgICAgICB0aGlzLnJlc3VsdC5wdXNoKHIpO1xyXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3QociwgdGhpcy5mcmljdGlvblJlc3VsdCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2Qgc3BoZXJlVHJpbWVzaFxyXG4gKiBAcGFyYW0gIHtTaGFwZX0gICAgICBzcGhlcmVTaGFwZVxyXG4gKiBAcGFyYW0gIHtTaGFwZX0gICAgICB0cmltZXNoU2hhcGVcclxuICogQHBhcmFtICB7VmVjM30gICAgICAgc3BoZXJlUG9zXHJcbiAqIEBwYXJhbSAge1ZlYzN9ICAgICAgIHRyaW1lc2hQb3NcclxuICogQHBhcmFtICB7UXVhdGVybmlvbn0gc3BoZXJlUXVhdFxyXG4gKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSB0cmltZXNoUXVhdFxyXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBzcGhlcmVCb2R5XHJcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIHRyaW1lc2hCb2R5XHJcbiAqL1xyXG52YXIgc3BoZXJlVHJpbWVzaF9ub3JtYWwgPSBuZXcgVmVjMygpO1xyXG52YXIgc3BoZXJlVHJpbWVzaF9yZWxwb3MgPSBuZXcgVmVjMygpO1xyXG52YXIgc3BoZXJlVHJpbWVzaF9wcm9qZWN0ZWQgPSBuZXcgVmVjMygpO1xyXG52YXIgc3BoZXJlVHJpbWVzaF92ID0gbmV3IFZlYzMoKTtcclxudmFyIHNwaGVyZVRyaW1lc2hfdjIgPSBuZXcgVmVjMygpO1xyXG52YXIgc3BoZXJlVHJpbWVzaF9lZGdlVmVydGV4QSA9IG5ldyBWZWMzKCk7XHJcbnZhciBzcGhlcmVUcmltZXNoX2VkZ2VWZXJ0ZXhCID0gbmV3IFZlYzMoKTtcclxudmFyIHNwaGVyZVRyaW1lc2hfZWRnZVZlY3RvciA9IG5ldyBWZWMzKCk7XHJcbnZhciBzcGhlcmVUcmltZXNoX2VkZ2VWZWN0b3JVbml0ID0gbmV3IFZlYzMoKTtcclxudmFyIHNwaGVyZVRyaW1lc2hfbG9jYWxTcGhlcmVQb3MgPSBuZXcgVmVjMygpO1xyXG52YXIgc3BoZXJlVHJpbWVzaF90bXAgPSBuZXcgVmVjMygpO1xyXG52YXIgc3BoZXJlVHJpbWVzaF92YSA9IG5ldyBWZWMzKCk7XHJcbnZhciBzcGhlcmVUcmltZXNoX3ZiID0gbmV3IFZlYzMoKTtcclxudmFyIHNwaGVyZVRyaW1lc2hfdmMgPSBuZXcgVmVjMygpO1xyXG52YXIgc3BoZXJlVHJpbWVzaF9sb2NhbFNwaGVyZUFBQkIgPSBuZXcgQUFCQigpO1xyXG52YXIgc3BoZXJlVHJpbWVzaF90cmlhbmdsZXMgPSBbXTtcclxuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLnR5cGVzLlNQSEVSRSB8IFNoYXBlLnR5cGVzLlRSSU1FU0hdID1cclxuTmFycm93cGhhc2UucHJvdG90eXBlLnNwaGVyZVRyaW1lc2ggPSBmdW5jdGlvbiAoXHJcbiAgICBzcGhlcmVTaGFwZSxcclxuICAgIHRyaW1lc2hTaGFwZSxcclxuICAgIHNwaGVyZVBvcyxcclxuICAgIHRyaW1lc2hQb3MsXHJcbiAgICBzcGhlcmVRdWF0LFxyXG4gICAgdHJpbWVzaFF1YXQsXHJcbiAgICBzcGhlcmVCb2R5LFxyXG4gICAgdHJpbWVzaEJvZHksXHJcbiAgICByc2ksXHJcbiAgICByc2osXHJcbiAgICBqdXN0VGVzdFxyXG4pIHtcclxuXHJcbiAgICB2YXIgZWRnZVZlcnRleEEgPSBzcGhlcmVUcmltZXNoX2VkZ2VWZXJ0ZXhBO1xyXG4gICAgdmFyIGVkZ2VWZXJ0ZXhCID0gc3BoZXJlVHJpbWVzaF9lZGdlVmVydGV4QjtcclxuICAgIHZhciBlZGdlVmVjdG9yID0gc3BoZXJlVHJpbWVzaF9lZGdlVmVjdG9yO1xyXG4gICAgdmFyIGVkZ2VWZWN0b3JVbml0ID0gc3BoZXJlVHJpbWVzaF9lZGdlVmVjdG9yVW5pdDtcclxuICAgIHZhciBsb2NhbFNwaGVyZVBvcyA9IHNwaGVyZVRyaW1lc2hfbG9jYWxTcGhlcmVQb3M7XHJcbiAgICB2YXIgdG1wID0gc3BoZXJlVHJpbWVzaF90bXA7XHJcbiAgICB2YXIgbG9jYWxTcGhlcmVBQUJCID0gc3BoZXJlVHJpbWVzaF9sb2NhbFNwaGVyZUFBQkI7XHJcbiAgICB2YXIgdjIgPSBzcGhlcmVUcmltZXNoX3YyO1xyXG4gICAgdmFyIHJlbHBvcyA9IHNwaGVyZVRyaW1lc2hfcmVscG9zO1xyXG4gICAgdmFyIHRyaWFuZ2xlcyA9IHNwaGVyZVRyaW1lc2hfdHJpYW5nbGVzO1xyXG5cclxuICAgIC8vIENvbnZlcnQgc3BoZXJlIHBvc2l0aW9uIHRvIGxvY2FsIGluIHRoZSB0cmltZXNoXHJcbiAgICBUcmFuc2Zvcm0ucG9pbnRUb0xvY2FsRnJhbWUodHJpbWVzaFBvcywgdHJpbWVzaFF1YXQsIHNwaGVyZVBvcywgbG9jYWxTcGhlcmVQb3MpO1xyXG5cclxuICAgIC8vIEdldCB0aGUgYWFiYiBvZiB0aGUgc3BoZXJlIGxvY2FsbHkgaW4gdGhlIHRyaW1lc2hcclxuICAgIHZhciBzcGhlcmVSYWRpdXMgPSBzcGhlcmVTaGFwZS5yYWRpdXM7XHJcbiAgICBsb2NhbFNwaGVyZUFBQkIubG93ZXJCb3VuZC5zZXQoXHJcbiAgICAgICAgbG9jYWxTcGhlcmVQb3MueCAtIHNwaGVyZVJhZGl1cyxcclxuICAgICAgICBsb2NhbFNwaGVyZVBvcy55IC0gc3BoZXJlUmFkaXVzLFxyXG4gICAgICAgIGxvY2FsU3BoZXJlUG9zLnogLSBzcGhlcmVSYWRpdXNcclxuICAgICk7XHJcbiAgICBsb2NhbFNwaGVyZUFBQkIudXBwZXJCb3VuZC5zZXQoXHJcbiAgICAgICAgbG9jYWxTcGhlcmVQb3MueCArIHNwaGVyZVJhZGl1cyxcclxuICAgICAgICBsb2NhbFNwaGVyZVBvcy55ICsgc3BoZXJlUmFkaXVzLFxyXG4gICAgICAgIGxvY2FsU3BoZXJlUG9zLnogKyBzcGhlcmVSYWRpdXNcclxuICAgICk7XHJcblxyXG4gICAgdHJpbWVzaFNoYXBlLmdldFRyaWFuZ2xlc0luQUFCQihsb2NhbFNwaGVyZUFBQkIsIHRyaWFuZ2xlcyk7XHJcbiAgICAvL2ZvciAodmFyIGkgPSAwOyBpIDwgdHJpbWVzaFNoYXBlLmluZGljZXMubGVuZ3RoIC8gMzsgaSsrKSB0cmlhbmdsZXMucHVzaChpKTsgLy8gQWxsXHJcblxyXG4gICAgLy8gVmVydGljZXNcclxuICAgIHZhciB2ID0gc3BoZXJlVHJpbWVzaF92O1xyXG4gICAgdmFyIHJhZGl1c1NxdWFyZWQgPSBzcGhlcmVTaGFwZS5yYWRpdXMgKiBzcGhlcmVTaGFwZS5yYWRpdXM7XHJcbiAgICBmb3IodmFyIGk9MDsgaTx0cmlhbmdsZXMubGVuZ3RoOyBpKyspe1xyXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgMzsgaisrKSB7XHJcblxyXG4gICAgICAgICAgICB0cmltZXNoU2hhcGUuZ2V0VmVydGV4KHRyaW1lc2hTaGFwZS5pbmRpY2VzW3RyaWFuZ2xlc1tpXSAqIDMgKyBqXSwgdik7XHJcblxyXG4gICAgICAgICAgICAvLyBDaGVjayB2ZXJ0ZXggb3ZlcmxhcCBpbiBzcGhlcmVcclxuICAgICAgICAgICAgdi52c3ViKGxvY2FsU3BoZXJlUG9zLCByZWxwb3MpO1xyXG5cclxuICAgICAgICAgICAgaWYocmVscG9zLm5vcm0yKCkgPD0gcmFkaXVzU3F1YXJlZCl7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU2FmZSB1cFxyXG4gICAgICAgICAgICAgICAgdjIuY29weSh2KTtcclxuICAgICAgICAgICAgICAgIFRyYW5zZm9ybS5wb2ludFRvV29ybGRGcmFtZSh0cmltZXNoUG9zLCB0cmltZXNoUXVhdCwgdjIsIHYpO1xyXG5cclxuICAgICAgICAgICAgICAgIHYudnN1YihzcGhlcmVQb3MsIHJlbHBvcyk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYoanVzdFRlc3Qpe1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciByID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oc3BoZXJlQm9keSx0cmltZXNoQm9keSxzcGhlcmVTaGFwZSx0cmltZXNoU2hhcGUscnNpLHJzaik7XHJcbiAgICAgICAgICAgICAgICByLm5pLmNvcHkocmVscG9zKTtcclxuICAgICAgICAgICAgICAgIHIubmkubm9ybWFsaXplKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gcmkgaXMgdGhlIHZlY3RvciBmcm9tIHNwaGVyZSBjZW50ZXIgdG8gdGhlIHNwaGVyZSBzdXJmYWNlXHJcbiAgICAgICAgICAgICAgICByLnJpLmNvcHkoci5uaSk7XHJcbiAgICAgICAgICAgICAgICByLnJpLnNjYWxlKHNwaGVyZVNoYXBlLnJhZGl1cywgci5yaSk7XHJcbiAgICAgICAgICAgICAgICByLnJpLnZhZGQoc3BoZXJlUG9zLCByLnJpKTtcclxuICAgICAgICAgICAgICAgIHIucmkudnN1YihzcGhlcmVCb2R5LnBvc2l0aW9uLCByLnJpKTtcclxuXHJcbiAgICAgICAgICAgICAgICByLnJqLmNvcHkodik7XHJcbiAgICAgICAgICAgICAgICByLnJqLnZzdWIodHJpbWVzaEJvZHkucG9zaXRpb24sIHIucmopO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFN0b3JlIHJlc3VsdFxyXG4gICAgICAgICAgICAgICAgdGhpcy5yZXN1bHQucHVzaChyKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChyLCB0aGlzLmZyaWN0aW9uUmVzdWx0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBDaGVjayBhbGwgZWRnZXNcclxuICAgIGZvcih2YXIgaT0wOyBpPHRyaWFuZ2xlcy5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCAzOyBqKyspIHtcclxuXHJcbiAgICAgICAgICAgIHRyaW1lc2hTaGFwZS5nZXRWZXJ0ZXgodHJpbWVzaFNoYXBlLmluZGljZXNbdHJpYW5nbGVzW2ldICogMyArIGpdLCBlZGdlVmVydGV4QSk7XHJcbiAgICAgICAgICAgIHRyaW1lc2hTaGFwZS5nZXRWZXJ0ZXgodHJpbWVzaFNoYXBlLmluZGljZXNbdHJpYW5nbGVzW2ldICogMyArICgoaisxKSUzKV0sIGVkZ2VWZXJ0ZXhCKTtcclxuICAgICAgICAgICAgZWRnZVZlcnRleEIudnN1YihlZGdlVmVydGV4QSwgZWRnZVZlY3Rvcik7XHJcblxyXG4gICAgICAgICAgICAvLyBQcm9qZWN0IHNwaGVyZSBwb3NpdGlvbiB0byB0aGUgZWRnZVxyXG4gICAgICAgICAgICBsb2NhbFNwaGVyZVBvcy52c3ViKGVkZ2VWZXJ0ZXhCLCB0bXApO1xyXG4gICAgICAgICAgICB2YXIgcG9zaXRpb25BbG9uZ0VkZ2VCID0gdG1wLmRvdChlZGdlVmVjdG9yKTtcclxuXHJcbiAgICAgICAgICAgIGxvY2FsU3BoZXJlUG9zLnZzdWIoZWRnZVZlcnRleEEsIHRtcCk7XHJcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbkFsb25nRWRnZUEgPSB0bXAuZG90KGVkZ2VWZWN0b3IpO1xyXG5cclxuICAgICAgICAgICAgaWYocG9zaXRpb25BbG9uZ0VkZ2VBID4gMCAmJiBwb3NpdGlvbkFsb25nRWRnZUIgPCAwKXtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBOb3cgY2hlY2sgdGhlIG9ydGhvZ29uYWwgZGlzdGFuY2UgZnJvbSBlZGdlIHRvIHNwaGVyZSBjZW50ZXJcclxuICAgICAgICAgICAgICAgIGxvY2FsU3BoZXJlUG9zLnZzdWIoZWRnZVZlcnRleEEsIHRtcCk7XHJcblxyXG4gICAgICAgICAgICAgICAgZWRnZVZlY3RvclVuaXQuY29weShlZGdlVmVjdG9yKTtcclxuICAgICAgICAgICAgICAgIGVkZ2VWZWN0b3JVbml0Lm5vcm1hbGl6ZSgpO1xyXG4gICAgICAgICAgICAgICAgcG9zaXRpb25BbG9uZ0VkZ2VBID0gdG1wLmRvdChlZGdlVmVjdG9yVW5pdCk7XHJcblxyXG4gICAgICAgICAgICAgICAgZWRnZVZlY3RvclVuaXQuc2NhbGUocG9zaXRpb25BbG9uZ0VkZ2VBLCB0bXApO1xyXG4gICAgICAgICAgICAgICAgdG1wLnZhZGQoZWRnZVZlcnRleEEsIHRtcCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gdG1wIGlzIG5vdyB0aGUgc3BoZXJlIGNlbnRlciBwb3NpdGlvbiBwcm9qZWN0ZWQgdG8gdGhlIGVkZ2UsIGRlZmluZWQgbG9jYWxseSBpbiB0aGUgdHJpbWVzaCBmcmFtZVxyXG4gICAgICAgICAgICAgICAgdmFyIGRpc3QgPSB0bXAuZGlzdGFuY2VUbyhsb2NhbFNwaGVyZVBvcyk7XHJcbiAgICAgICAgICAgICAgICBpZihkaXN0IDwgc3BoZXJlU2hhcGUucmFkaXVzKXtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoanVzdFRlc3Qpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciByID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oc3BoZXJlQm9keSwgdHJpbWVzaEJvZHksIHNwaGVyZVNoYXBlLCB0cmltZXNoU2hhcGUscnNpLHJzaik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRtcC52c3ViKGxvY2FsU3BoZXJlUG9zLCByLm5pKTtcclxuICAgICAgICAgICAgICAgICAgICByLm5pLm5vcm1hbGl6ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHIubmkuc2NhbGUoc3BoZXJlU2hhcGUucmFkaXVzLCByLnJpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgVHJhbnNmb3JtLnBvaW50VG9Xb3JsZEZyYW1lKHRyaW1lc2hQb3MsIHRyaW1lc2hRdWF0LCB0bXAsIHRtcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdG1wLnZzdWIodHJpbWVzaEJvZHkucG9zaXRpb24sIHIucmopO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBUcmFuc2Zvcm0udmVjdG9yVG9Xb3JsZEZyYW1lKHRyaW1lc2hRdWF0LCByLm5pLCByLm5pKTtcclxuICAgICAgICAgICAgICAgICAgICBUcmFuc2Zvcm0udmVjdG9yVG9Xb3JsZEZyYW1lKHRyaW1lc2hRdWF0LCByLnJpLCByLnJpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXN1bHQucHVzaChyKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3QociwgdGhpcy5mcmljdGlvblJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVHJpYW5nbGUgZmFjZXNcclxuICAgIHZhciB2YSA9IHNwaGVyZVRyaW1lc2hfdmE7XHJcbiAgICB2YXIgdmIgPSBzcGhlcmVUcmltZXNoX3ZiO1xyXG4gICAgdmFyIHZjID0gc3BoZXJlVHJpbWVzaF92YztcclxuICAgIHZhciBub3JtYWwgPSBzcGhlcmVUcmltZXNoX25vcm1hbDtcclxuICAgIGZvcih2YXIgaT0wLCBOID0gdHJpYW5nbGVzLmxlbmd0aDsgaSAhPT0gTjsgaSsrKXtcclxuICAgICAgICB0cmltZXNoU2hhcGUuZ2V0VHJpYW5nbGVWZXJ0aWNlcyh0cmlhbmdsZXNbaV0sIHZhLCB2YiwgdmMpO1xyXG4gICAgICAgIHRyaW1lc2hTaGFwZS5nZXROb3JtYWwodHJpYW5nbGVzW2ldLCBub3JtYWwpO1xyXG4gICAgICAgIGxvY2FsU3BoZXJlUG9zLnZzdWIodmEsIHRtcCk7XHJcbiAgICAgICAgdmFyIGRpc3QgPSB0bXAuZG90KG5vcm1hbCk7XHJcbiAgICAgICAgbm9ybWFsLnNjYWxlKGRpc3QsIHRtcCk7XHJcbiAgICAgICAgbG9jYWxTcGhlcmVQb3MudnN1Yih0bXAsIHRtcCk7XHJcblxyXG4gICAgICAgIC8vIHRtcCBpcyBub3cgdGhlIHNwaGVyZSBwb3NpdGlvbiBwcm9qZWN0ZWQgdG8gdGhlIHRyaWFuZ2xlIHBsYW5lXHJcbiAgICAgICAgZGlzdCA9IHRtcC5kaXN0YW5jZVRvKGxvY2FsU3BoZXJlUG9zKTtcclxuICAgICAgICBpZihSYXkucG9pbnRJblRyaWFuZ2xlKHRtcCwgdmEsIHZiLCB2YykgJiYgZGlzdCA8IHNwaGVyZVNoYXBlLnJhZGl1cyl7XHJcbiAgICAgICAgICAgIGlmKGp1c3RUZXN0KXtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciByID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oc3BoZXJlQm9keSwgdHJpbWVzaEJvZHksIHNwaGVyZVNoYXBlLCB0cmltZXNoU2hhcGUscnNpLHJzaik7XHJcblxyXG4gICAgICAgICAgICB0bXAudnN1Yihsb2NhbFNwaGVyZVBvcywgci5uaSk7XHJcbiAgICAgICAgICAgIHIubmkubm9ybWFsaXplKCk7XHJcbiAgICAgICAgICAgIHIubmkuc2NhbGUoc3BoZXJlU2hhcGUucmFkaXVzLCByLnJpKTtcclxuXHJcbiAgICAgICAgICAgIFRyYW5zZm9ybS5wb2ludFRvV29ybGRGcmFtZSh0cmltZXNoUG9zLCB0cmltZXNoUXVhdCwgdG1wLCB0bXApO1xyXG4gICAgICAgICAgICB0bXAudnN1Yih0cmltZXNoQm9keS5wb3NpdGlvbiwgci5yaik7XHJcblxyXG4gICAgICAgICAgICBUcmFuc2Zvcm0udmVjdG9yVG9Xb3JsZEZyYW1lKHRyaW1lc2hRdWF0LCByLm5pLCByLm5pKTtcclxuICAgICAgICAgICAgVHJhbnNmb3JtLnZlY3RvclRvV29ybGRGcmFtZSh0cmltZXNoUXVhdCwgci5yaSwgci5yaSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnJlc3VsdC5wdXNoKHIpO1xyXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3QociwgdGhpcy5mcmljdGlvblJlc3VsdCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHRyaWFuZ2xlcy5sZW5ndGggPSAwO1xyXG59O1xyXG5cclxudmFyIHBvaW50X29uX3BsYW5lX3RvX3NwaGVyZSA9IG5ldyBWZWMzKCk7XHJcbnZhciBwbGFuZV90b19zcGhlcmVfb3J0aG8gPSBuZXcgVmVjMygpO1xyXG52YXIgcF9zX25pID0gbmV3IFZlYzMoKTsgXHJcbnZhciBwX3NfcmkgPSBuZXcgVmVjMygpO1xyXG52YXIgcF9zX3JqID0gbmV3IFZlYzMoKTsgXHJcbi8qKlxyXG4gKiBAbWV0aG9kIHNwaGVyZVBsYW5lXHJcbiAqIEBwYXJhbSAge1NoYXBlfSAgICAgIHNpXHJcbiAqIEBwYXJhbSAge1NoYXBlfSAgICAgIHNqXHJcbiAqIEBwYXJhbSAge1ZlYzN9ICAgICAgIHhpXHJcbiAqIEBwYXJhbSAge1ZlYzN9ICAgICAgIHhqXHJcbiAqIEBwYXJhbSAge1F1YXRlcm5pb259IHFpXHJcbiAqIEBwYXJhbSAge1F1YXRlcm5pb259IHFqXHJcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGJpXHJcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGJqXHJcbiAqL1xyXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUudHlwZXMuU1BIRVJFIHwgU2hhcGUudHlwZXMuUExBTkVdID1cclxuTmFycm93cGhhc2UucHJvdG90eXBlLnNwaGVyZVBsYW5lID0gZnVuY3Rpb24oc2ksc2oseGkseGoscWkscWosYmksYmoscnNpLHJzaixqdXN0VGVzdCl7XHJcbiAgICAvLyBDb250YWN0IG5vcm1hbFxyXG4gICAgcF9zX25pLnNldCgwLDAsMSk7XHJcbiAgICBxai52bXVsdChwX3NfbmksIHBfc19uaSk7XHJcbiAgICBwX3NfbmkubmVnYXRlKHBfc19uaSk7IC8vIGJvZHkgaSBpcyB0aGUgc3BoZXJlLCBmbGlwIG5vcm1hbFxyXG4gICAgcF9zX25pLm5vcm1hbGl6ZSgpOyAvLyBOZWVkZWQ/XHJcblxyXG4gICAgLy8gVmVjdG9yIGZyb20gc3BoZXJlIGNlbnRlciB0byBjb250YWN0IHBvaW50XHJcbiAgICBwX3NfbmkubXVsdChzaS5yYWRpdXMsIHBfc19yaSk7XHJcblxyXG4gICAgLy8gUHJvamVjdCBkb3duIHNwaGVyZSBvbiBwbGFuZVxyXG4gICAgeGkudnN1Yih4aiwgcG9pbnRfb25fcGxhbmVfdG9fc3BoZXJlKTtcclxuICAgIHBfc19uaS5tdWx0KHBfc19uaS5kb3QocG9pbnRfb25fcGxhbmVfdG9fc3BoZXJlKSwgcGxhbmVfdG9fc3BoZXJlX29ydGhvKTtcclxuICAgIHBvaW50X29uX3BsYW5lX3RvX3NwaGVyZS52c3ViKHBsYW5lX3RvX3NwaGVyZV9vcnRobywgcF9zX3JqKTsgLy8gVGhlIHNwaGVyZSBwb3NpdGlvbiBwcm9qZWN0ZWQgdG8gcGxhbmVcclxuXHJcbiAgICBpZigtcG9pbnRfb25fcGxhbmVfdG9fc3BoZXJlLmRvdChwX3NfbmkpIDw9IHNpLnJhZGl1cyl7XHJcblxyXG4gICAgICAgIGlmKGp1c3RUZXN0KXtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBXZSB3aWxsIGhhdmUgb25lIGNvbnRhY3QgaW4gdGhpcyBjYXNlXHJcbiAgICAgICAgdmFyIHIgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihiaSxiaixzaSxzaixyc2kscnNqKTtcclxuICAgICAgICAvLyBNYWtlIGl0IHJlbGF0aXZlIHRvIHRoZSBib2R5XHJcbiAgICAgICAgci5uaS5jb3B5KHBfc19uaSk7XHJcbiAgICAgICAgci5yaS5jb3B5KHBfc19yaSk7XHJcbiAgICAgICAgci5yai5jb3B5KHBfc19yaik7XHJcbiAgICAgICAgdmFyIHJpID0gci5yaTtcclxuICAgICAgICB2YXIgcmogPSByLnJqO1xyXG4gICAgICAgIHJpLnZhZGQoeGksIHJpKTtcclxuICAgICAgICByaS52c3ViKGJpLnBvc2l0aW9uLCByaSk7XHJcbiAgICAgICAgcmoudmFkZCh4aiwgcmopO1xyXG4gICAgICAgIHJqLnZzdWIoYmoucG9zaXRpb24sIHJqKTtcclxuXHJcbiAgICAgICAgdGhpcy5yZXN1bHQucHVzaChyKTtcclxuICAgICAgICB0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3QociwgdGhpcy5mcmljdGlvblJlc3VsdCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vLyBTZWUgaHR0cDovL2J1bGxldHBoeXNpY3MuY29tL0J1bGxldC9CdWxsZXRGdWxsL1NwaGVyZVRyaWFuZ2xlRGV0ZWN0b3JfOGNwcF9zb3VyY2UuaHRtbFxyXG52YXIgcG9pbnRJblBvbHlnb25fZWRnZSA9IG5ldyBWZWMzKCk7XHJcbnZhciBwb2ludEluUG9seWdvbl9lZGdlX3hfbm9ybWFsID0gbmV3IFZlYzMoKTtcclxudmFyIHBvaW50SW5Qb2x5Z29uX3Z0cCA9IG5ldyBWZWMzKCk7XHJcbmZ1bmN0aW9uIHBvaW50SW5Qb2x5Z29uKHZlcnRzLCBub3JtYWwsIHApe1xyXG4gICAgdmFyIHBvc2l0aXZlUmVzdWx0ID0gbnVsbDtcclxuICAgIHZhciBOID0gdmVydHMubGVuZ3RoO1xyXG4gICAgZm9yKHZhciBpPTA7IGkhPT1OOyBpKyspe1xyXG4gICAgICAgIHZhciB2ID0gdmVydHNbaV07XHJcblxyXG4gICAgICAgIC8vIEdldCBlZGdlIHRvIHRoZSBuZXh0IHZlcnRleFxyXG4gICAgICAgIHZhciBlZGdlID0gcG9pbnRJblBvbHlnb25fZWRnZTtcclxuICAgICAgICB2ZXJ0c1soaSsxKSAlIChOKV0udnN1Yih2LGVkZ2UpO1xyXG5cclxuICAgICAgICAvLyBHZXQgY3Jvc3MgcHJvZHVjdCBiZXR3ZWVuIHBvbHlnb24gbm9ybWFsIGFuZCB0aGUgZWRnZVxyXG4gICAgICAgIHZhciBlZGdlX3hfbm9ybWFsID0gcG9pbnRJblBvbHlnb25fZWRnZV94X25vcm1hbDtcclxuICAgICAgICAvL3ZhciBlZGdlX3hfbm9ybWFsID0gbmV3IFZlYzMoKTtcclxuICAgICAgICBlZGdlLmNyb3NzKG5vcm1hbCxlZGdlX3hfbm9ybWFsKTtcclxuXHJcbiAgICAgICAgLy8gR2V0IHZlY3RvciBiZXR3ZWVuIHBvaW50IGFuZCBjdXJyZW50IHZlcnRleFxyXG4gICAgICAgIHZhciB2ZXJ0ZXhfdG9fcCA9IHBvaW50SW5Qb2x5Z29uX3Z0cDtcclxuICAgICAgICBwLnZzdWIodix2ZXJ0ZXhfdG9fcCk7XHJcblxyXG4gICAgICAgIC8vIFRoaXMgZG90IHByb2R1Y3QgZGV0ZXJtaW5lcyB3aGljaCBzaWRlIG9mIHRoZSBlZGdlIHRoZSBwb2ludCBpc1xyXG4gICAgICAgIHZhciByID0gZWRnZV94X25vcm1hbC5kb3QodmVydGV4X3RvX3ApO1xyXG5cclxuICAgICAgICAvLyBJZiBhbGwgc3VjaCBkb3QgcHJvZHVjdHMgaGF2ZSBzYW1lIHNpZ24sIHdlIGFyZSBpbnNpZGUgdGhlIHBvbHlnb24uXHJcbiAgICAgICAgaWYocG9zaXRpdmVSZXN1bHQ9PT1udWxsIHx8IChyPjAgJiYgcG9zaXRpdmVSZXN1bHQ9PT10cnVlKSB8fCAocjw9MCAmJiBwb3NpdGl2ZVJlc3VsdD09PWZhbHNlKSl7XHJcbiAgICAgICAgICAgIGlmKHBvc2l0aXZlUmVzdWx0PT09bnVsbCl7XHJcbiAgICAgICAgICAgICAgICBwb3NpdGl2ZVJlc3VsdCA9IHI+MDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIEVuY291bnRlcmVkIHNvbWUgb3RoZXIgc2lnbi4gRXhpdC5cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSWYgd2UgZ290IGhlcmUsIGFsbCBkb3QgcHJvZHVjdHMgd2VyZSBvZiB0aGUgc2FtZSBzaWduLlxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuXHJcbnZhciBib3hfdG9fc3BoZXJlID0gbmV3IFZlYzMoKTtcclxudmFyIHNwaGVyZUJveF9ucyA9IG5ldyBWZWMzKCk7XHJcbnZhciBzcGhlcmVCb3hfbnMxID0gbmV3IFZlYzMoKTtcclxudmFyIHNwaGVyZUJveF9uczIgPSBuZXcgVmVjMygpO1xyXG52YXIgc3BoZXJlQm94X3NpZGVzID0gW25ldyBWZWMzKCksbmV3IFZlYzMoKSxuZXcgVmVjMygpLG5ldyBWZWMzKCksbmV3IFZlYzMoKSxuZXcgVmVjMygpXTtcclxudmFyIHNwaGVyZUJveF9zcGhlcmVfdG9fY29ybmVyID0gbmV3IFZlYzMoKTtcclxudmFyIHNwaGVyZUJveF9zaWRlX25zID0gbmV3IFZlYzMoKTtcclxudmFyIHNwaGVyZUJveF9zaWRlX25zMSA9IG5ldyBWZWMzKCk7XHJcbnZhciBzcGhlcmVCb3hfc2lkZV9uczIgPSBuZXcgVmVjMygpO1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2Qgc3BoZXJlQm94XHJcbiAqIEBwYXJhbSAge1NoYXBlfSAgICAgIHNpXHJcbiAqIEBwYXJhbSAge1NoYXBlfSAgICAgIHNqXHJcbiAqIEBwYXJhbSAge1ZlYzN9ICAgICAgIHhpXHJcbiAqIEBwYXJhbSAge1ZlYzN9ICAgICAgIHhqXHJcbiAqIEBwYXJhbSAge1F1YXRlcm5pb259IHFpXHJcbiAqIEBwYXJhbSAge1F1YXRlcm5pb259IHFqXHJcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGJpXHJcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGJqXHJcbiAqL1xyXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUudHlwZXMuU1BIRVJFIHwgU2hhcGUudHlwZXMuQk9YXSA9XHJcbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5zcGhlcmVCb3ggPSBmdW5jdGlvbihzaSxzaix4aSx4aixxaSxxaixiaSxiaixyc2kscnNqLGp1c3RUZXN0KXtcclxuICAgIHZhciB2M3Bvb2wgPSB0aGlzLnYzcG9vbDtcclxuXHJcbiAgICAvLyB3ZSByZWZlciB0byB0aGUgYm94IGFzIGJvZHkgalxyXG4gICAgdmFyIHNpZGVzID0gc3BoZXJlQm94X3NpZGVzO1xyXG4gICAgeGkudnN1Yih4aixib3hfdG9fc3BoZXJlKTtcclxuICAgIHNqLmdldFNpZGVOb3JtYWxzKHNpZGVzLHFqKTtcclxuICAgIHZhciBSID0gICAgIHNpLnJhZGl1cztcclxuICAgIHZhciBwZW5ldHJhdGluZ19zaWRlcyA9IFtdO1xyXG5cclxuICAgIC8vIENoZWNrIHNpZGUgKHBsYW5lKSBpbnRlcnNlY3Rpb25zXHJcbiAgICB2YXIgZm91bmQgPSBmYWxzZTtcclxuXHJcbiAgICAvLyBTdG9yZSB0aGUgcmVzdWx0aW5nIHNpZGUgcGVuZXRyYXRpb24gaW5mb1xyXG4gICAgdmFyIHNpZGVfbnMgPSBzcGhlcmVCb3hfc2lkZV9ucztcclxuICAgIHZhciBzaWRlX25zMSA9IHNwaGVyZUJveF9zaWRlX25zMTtcclxuICAgIHZhciBzaWRlX25zMiA9IHNwaGVyZUJveF9zaWRlX25zMjtcclxuICAgIHZhciBzaWRlX2ggPSBudWxsO1xyXG4gICAgdmFyIHNpZGVfcGVuZXRyYXRpb25zID0gMDtcclxuICAgIHZhciBzaWRlX2RvdDEgPSAwO1xyXG4gICAgdmFyIHNpZGVfZG90MiA9IDA7XHJcbiAgICB2YXIgc2lkZV9kaXN0YW5jZSA9IG51bGw7XHJcbiAgICBmb3IodmFyIGlkeD0wLG5zaWRlcz1zaWRlcy5sZW5ndGg7IGlkeCE9PW5zaWRlcyAmJiBmb3VuZD09PWZhbHNlOyBpZHgrKyl7XHJcbiAgICAgICAgLy8gR2V0IHRoZSBwbGFuZSBzaWRlIG5vcm1hbCAobnMpXHJcbiAgICAgICAgdmFyIG5zID0gc3BoZXJlQm94X25zO1xyXG4gICAgICAgIG5zLmNvcHkoc2lkZXNbaWR4XSk7XHJcblxyXG4gICAgICAgIHZhciBoID0gbnMubm9ybSgpO1xyXG4gICAgICAgIG5zLm5vcm1hbGl6ZSgpO1xyXG5cclxuICAgICAgICAvLyBUaGUgbm9ybWFsL2Rpc3RhbmNlIGRvdCBwcm9kdWN0IHRlbGxzIHdoaWNoIHNpZGUgb2YgdGhlIHBsYW5lIHdlIGFyZVxyXG4gICAgICAgIHZhciBkb3QgPSBib3hfdG9fc3BoZXJlLmRvdChucyk7XHJcblxyXG4gICAgICAgIGlmKGRvdDxoK1IgJiYgZG90PjApe1xyXG4gICAgICAgICAgICAvLyBJbnRlcnNlY3RzIHBsYW5lLiBOb3cgY2hlY2sgdGhlIG90aGVyIHR3byBkaW1lbnNpb25zXHJcbiAgICAgICAgICAgIHZhciBuczEgPSBzcGhlcmVCb3hfbnMxO1xyXG4gICAgICAgICAgICB2YXIgbnMyID0gc3BoZXJlQm94X25zMjtcclxuICAgICAgICAgICAgbnMxLmNvcHkoc2lkZXNbKGlkeCsxKSUzXSk7XHJcbiAgICAgICAgICAgIG5zMi5jb3B5KHNpZGVzWyhpZHgrMiklM10pO1xyXG4gICAgICAgICAgICB2YXIgaDEgPSBuczEubm9ybSgpO1xyXG4gICAgICAgICAgICB2YXIgaDIgPSBuczIubm9ybSgpO1xyXG4gICAgICAgICAgICBuczEubm9ybWFsaXplKCk7XHJcbiAgICAgICAgICAgIG5zMi5ub3JtYWxpemUoKTtcclxuICAgICAgICAgICAgdmFyIGRvdDEgPSBib3hfdG9fc3BoZXJlLmRvdChuczEpO1xyXG4gICAgICAgICAgICB2YXIgZG90MiA9IGJveF90b19zcGhlcmUuZG90KG5zMik7XHJcbiAgICAgICAgICAgIGlmKGRvdDE8aDEgJiYgZG90MT4taDEgJiYgZG90MjxoMiAmJiBkb3QyPi1oMil7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGlzdCA9IE1hdGguYWJzKGRvdC1oLVIpO1xyXG4gICAgICAgICAgICAgICAgaWYoc2lkZV9kaXN0YW5jZT09PW51bGwgfHwgZGlzdCA8IHNpZGVfZGlzdGFuY2Upe1xyXG4gICAgICAgICAgICAgICAgICAgIHNpZGVfZGlzdGFuY2UgPSBkaXN0O1xyXG4gICAgICAgICAgICAgICAgICAgIHNpZGVfZG90MSA9IGRvdDE7XHJcbiAgICAgICAgICAgICAgICAgICAgc2lkZV9kb3QyID0gZG90MjtcclxuICAgICAgICAgICAgICAgICAgICBzaWRlX2ggPSBoO1xyXG4gICAgICAgICAgICAgICAgICAgIHNpZGVfbnMuY29weShucyk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2lkZV9uczEuY29weShuczEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNpZGVfbnMyLmNvcHkobnMyKTtcclxuICAgICAgICAgICAgICAgICAgICBzaWRlX3BlbmV0cmF0aW9ucysrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZihqdXN0VGVzdCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmKHNpZGVfcGVuZXRyYXRpb25zKXtcclxuICAgICAgICBmb3VuZCA9IHRydWU7XHJcbiAgICAgICAgdmFyIHIgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihiaSxiaixzaSxzaixyc2kscnNqKTtcclxuICAgICAgICBzaWRlX25zLm11bHQoLVIsci5yaSk7IC8vIFNwaGVyZSByXHJcbiAgICAgICAgci5uaS5jb3B5KHNpZGVfbnMpO1xyXG4gICAgICAgIHIubmkubmVnYXRlKHIubmkpOyAvLyBOb3JtYWwgc2hvdWxkIGJlIG91dCBvZiBzcGhlcmVcclxuICAgICAgICBzaWRlX25zLm11bHQoc2lkZV9oLHNpZGVfbnMpO1xyXG4gICAgICAgIHNpZGVfbnMxLm11bHQoc2lkZV9kb3QxLHNpZGVfbnMxKTtcclxuICAgICAgICBzaWRlX25zLnZhZGQoc2lkZV9uczEsc2lkZV9ucyk7XHJcbiAgICAgICAgc2lkZV9uczIubXVsdChzaWRlX2RvdDIsc2lkZV9uczIpO1xyXG4gICAgICAgIHNpZGVfbnMudmFkZChzaWRlX25zMixyLnJqKTtcclxuXHJcbiAgICAgICAgLy8gTWFrZSByZWxhdGl2ZSB0byBib2RpZXNcclxuICAgICAgICByLnJpLnZhZGQoeGksIHIucmkpO1xyXG4gICAgICAgIHIucmkudnN1YihiaS5wb3NpdGlvbiwgci5yaSk7XHJcbiAgICAgICAgci5yai52YWRkKHhqLCByLnJqKTtcclxuICAgICAgICByLnJqLnZzdWIoYmoucG9zaXRpb24sIHIucmopO1xyXG5cclxuICAgICAgICB0aGlzLnJlc3VsdC5wdXNoKHIpO1xyXG4gICAgICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChyLCB0aGlzLmZyaWN0aW9uUmVzdWx0KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDaGVjayBjb3JuZXJzXHJcbiAgICB2YXIgcmogPSB2M3Bvb2wuZ2V0KCk7XHJcbiAgICB2YXIgc3BoZXJlX3RvX2Nvcm5lciA9IHNwaGVyZUJveF9zcGhlcmVfdG9fY29ybmVyO1xyXG4gICAgZm9yKHZhciBqPTA7IGohPT0yICYmICFmb3VuZDsgaisrKXtcclxuICAgICAgICBmb3IodmFyIGs9MDsgayE9PTIgJiYgIWZvdW5kOyBrKyspe1xyXG4gICAgICAgICAgICBmb3IodmFyIGw9MDsgbCE9PTIgJiYgIWZvdW5kOyBsKyspe1xyXG4gICAgICAgICAgICAgICAgcmouc2V0KDAsMCwwKTtcclxuICAgICAgICAgICAgICAgIGlmKGope1xyXG4gICAgICAgICAgICAgICAgICAgIHJqLnZhZGQoc2lkZXNbMF0scmopO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByai52c3ViKHNpZGVzWzBdLHJqKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmKGspe1xyXG4gICAgICAgICAgICAgICAgICAgIHJqLnZhZGQoc2lkZXNbMV0scmopO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByai52c3ViKHNpZGVzWzFdLHJqKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmKGwpe1xyXG4gICAgICAgICAgICAgICAgICAgIHJqLnZhZGQoc2lkZXNbMl0scmopO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByai52c3ViKHNpZGVzWzJdLHJqKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBXb3JsZCBwb3NpdGlvbiBvZiBjb3JuZXJcclxuICAgICAgICAgICAgICAgIHhqLnZhZGQocmosc3BoZXJlX3RvX2Nvcm5lcik7XHJcbiAgICAgICAgICAgICAgICBzcGhlcmVfdG9fY29ybmVyLnZzdWIoeGksc3BoZXJlX3RvX2Nvcm5lcik7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYoc3BoZXJlX3RvX2Nvcm5lci5ub3JtMigpIDwgUipSKXtcclxuICAgICAgICAgICAgICAgICAgICBpZihqdXN0VGVzdCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihiaSxiaixzaSxzaixyc2kscnNqKTtcclxuICAgICAgICAgICAgICAgICAgICByLnJpLmNvcHkoc3BoZXJlX3RvX2Nvcm5lcik7XHJcbiAgICAgICAgICAgICAgICAgICAgci5yaS5ub3JtYWxpemUoKTtcclxuICAgICAgICAgICAgICAgICAgICByLm5pLmNvcHkoci5yaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgci5yaS5tdWx0KFIsci5yaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgci5yai5jb3B5KHJqKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSByZWxhdGl2ZSB0byBib2RpZXNcclxuICAgICAgICAgICAgICAgICAgICByLnJpLnZhZGQoeGksIHIucmkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHIucmkudnN1YihiaS5wb3NpdGlvbiwgci5yaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgci5yai52YWRkKHhqLCByLnJqKTtcclxuICAgICAgICAgICAgICAgICAgICByLnJqLnZzdWIoYmoucG9zaXRpb24sIHIucmopO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdC5wdXNoKHIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChyLCB0aGlzLmZyaWN0aW9uUmVzdWx0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHYzcG9vbC5yZWxlYXNlKHJqKTtcclxuICAgIHJqID0gbnVsbDtcclxuXHJcbiAgICAvLyBDaGVjayBlZGdlc1xyXG4gICAgdmFyIGVkZ2VUYW5nZW50ID0gdjNwb29sLmdldCgpO1xyXG4gICAgdmFyIGVkZ2VDZW50ZXIgPSB2M3Bvb2wuZ2V0KCk7XHJcbiAgICB2YXIgciA9IHYzcG9vbC5nZXQoKTsgLy8gciA9IGVkZ2UgY2VudGVyIHRvIHNwaGVyZSBjZW50ZXJcclxuICAgIHZhciBvcnRob2dvbmFsID0gdjNwb29sLmdldCgpO1xyXG4gICAgdmFyIGRpc3QgPSB2M3Bvb2wuZ2V0KCk7XHJcbiAgICB2YXIgTnNpZGVzID0gc2lkZXMubGVuZ3RoO1xyXG4gICAgZm9yKHZhciBqPTA7IGohPT1Oc2lkZXMgJiYgIWZvdW5kOyBqKyspe1xyXG4gICAgICAgIGZvcih2YXIgaz0wOyBrIT09TnNpZGVzICYmICFmb3VuZDsgaysrKXtcclxuICAgICAgICAgICAgaWYoaiUzICE9PSBrJTMpe1xyXG4gICAgICAgICAgICAgICAgLy8gR2V0IGVkZ2UgdGFuZ2VudFxyXG4gICAgICAgICAgICAgICAgc2lkZXNba10uY3Jvc3Moc2lkZXNbal0sZWRnZVRhbmdlbnQpO1xyXG4gICAgICAgICAgICAgICAgZWRnZVRhbmdlbnQubm9ybWFsaXplKCk7XHJcbiAgICAgICAgICAgICAgICBzaWRlc1tqXS52YWRkKHNpZGVzW2tdLCBlZGdlQ2VudGVyKTtcclxuICAgICAgICAgICAgICAgIHIuY29weSh4aSk7XHJcbiAgICAgICAgICAgICAgICByLnZzdWIoZWRnZUNlbnRlcixyKTtcclxuICAgICAgICAgICAgICAgIHIudnN1Yih4aixyKTtcclxuICAgICAgICAgICAgICAgIHZhciBvcnRob25vcm0gPSByLmRvdChlZGdlVGFuZ2VudCk7IC8vIGRpc3RhbmNlIGZyb20gZWRnZSBjZW50ZXIgdG8gc3BoZXJlIGNlbnRlciBpbiB0aGUgdGFuZ2VudCBkaXJlY3Rpb25cclxuICAgICAgICAgICAgICAgIGVkZ2VUYW5nZW50Lm11bHQob3J0aG9ub3JtLG9ydGhvZ29uYWwpOyAvLyBWZWN0b3IgZnJvbSBlZGdlIGNlbnRlciB0byBzcGhlcmUgY2VudGVyIGluIHRoZSB0YW5nZW50IGRpcmVjdGlvblxyXG5cclxuICAgICAgICAgICAgICAgIC8vIEZpbmQgdGhlIHRoaXJkIHNpZGUgb3J0aG9nb25hbCB0byB0aGlzIG9uZVxyXG4gICAgICAgICAgICAgICAgdmFyIGwgPSAwO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUobD09PWolMyB8fCBsPT09ayUzKXtcclxuICAgICAgICAgICAgICAgICAgICBsKys7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gdmVjIGZyb20gZWRnZSBjZW50ZXIgdG8gc3BoZXJlIHByb2plY3RlZCB0byB0aGUgcGxhbmUgb3J0aG9nb25hbCB0byB0aGUgZWRnZSB0YW5nZW50XHJcbiAgICAgICAgICAgICAgICBkaXN0LmNvcHkoeGkpO1xyXG4gICAgICAgICAgICAgICAgZGlzdC52c3ViKG9ydGhvZ29uYWwsZGlzdCk7XHJcbiAgICAgICAgICAgICAgICBkaXN0LnZzdWIoZWRnZUNlbnRlcixkaXN0KTtcclxuICAgICAgICAgICAgICAgIGRpc3QudnN1Yih4aixkaXN0KTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBEaXN0YW5jZXMgaW4gdGFuZ2VudCBkaXJlY3Rpb24gYW5kIGRpc3RhbmNlIGluIHRoZSBwbGFuZSBvcnRob2dvbmFsIHRvIGl0XHJcbiAgICAgICAgICAgICAgICB2YXIgdGRpc3QgPSBNYXRoLmFicyhvcnRob25vcm0pO1xyXG4gICAgICAgICAgICAgICAgdmFyIG5kaXN0ID0gZGlzdC5ub3JtKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYodGRpc3QgPCBzaWRlc1tsXS5ub3JtKCkgJiYgbmRpc3Q8Uil7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoanVzdFRlc3Qpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXMgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihiaSxiaixzaSxzaixyc2kscnNqKTtcclxuICAgICAgICAgICAgICAgICAgICBlZGdlQ2VudGVyLnZhZGQob3J0aG9nb25hbCxyZXMucmopOyAvLyBib3ggcmpcclxuICAgICAgICAgICAgICAgICAgICByZXMucmouY29weShyZXMucmopO1xyXG4gICAgICAgICAgICAgICAgICAgIGRpc3QubmVnYXRlKHJlcy5uaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzLm5pLm5vcm1hbGl6ZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXMucmkuY29weShyZXMucmopO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcy5yaS52YWRkKHhqLHJlcy5yaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzLnJpLnZzdWIoeGkscmVzLnJpKTtcclxuICAgICAgICAgICAgICAgICAgICByZXMucmkubm9ybWFsaXplKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzLnJpLm11bHQoUixyZXMucmkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIHJlbGF0aXZlIHRvIGJvZGllc1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcy5yaS52YWRkKHhpLCByZXMucmkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcy5yaS52c3ViKGJpLnBvc2l0aW9uLCByZXMucmkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcy5yai52YWRkKHhqLCByZXMucmopO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcy5yai52c3ViKGJqLnBvc2l0aW9uLCByZXMucmopO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdC5wdXNoKHJlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVGcmljdGlvbkVxdWF0aW9uc0Zyb21Db250YWN0KHJlcywgdGhpcy5mcmljdGlvblJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB2M3Bvb2wucmVsZWFzZShlZGdlVGFuZ2VudCxlZGdlQ2VudGVyLHIsb3J0aG9nb25hbCxkaXN0KTtcclxufTtcclxuXHJcbnZhciBjb252ZXhfdG9fc3BoZXJlID0gbmV3IFZlYzMoKTtcclxudmFyIHNwaGVyZUNvbnZleF9lZGdlID0gbmV3IFZlYzMoKTtcclxudmFyIHNwaGVyZUNvbnZleF9lZGdlVW5pdCA9IG5ldyBWZWMzKCk7XHJcbnZhciBzcGhlcmVDb252ZXhfc3BoZXJlVG9Db3JuZXIgPSBuZXcgVmVjMygpO1xyXG52YXIgc3BoZXJlQ29udmV4X3dvcmxkQ29ybmVyID0gbmV3IFZlYzMoKTtcclxudmFyIHNwaGVyZUNvbnZleF93b3JsZE5vcm1hbCA9IG5ldyBWZWMzKCk7XHJcbnZhciBzcGhlcmVDb252ZXhfd29ybGRQb2ludCA9IG5ldyBWZWMzKCk7XHJcbnZhciBzcGhlcmVDb252ZXhfd29ybGRTcGhlcmVQb2ludENsb3Nlc3RUb1BsYW5lID0gbmV3IFZlYzMoKTtcclxudmFyIHNwaGVyZUNvbnZleF9wZW5ldHJhdGlvblZlYyA9IG5ldyBWZWMzKCk7XHJcbnZhciBzcGhlcmVDb252ZXhfc3BoZXJlVG9Xb3JsZFBvaW50ID0gbmV3IFZlYzMoKTtcclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kIHNwaGVyZUNvbnZleFxyXG4gKiBAcGFyYW0gIHtTaGFwZX0gICAgICBzaVxyXG4gKiBAcGFyYW0gIHtTaGFwZX0gICAgICBzalxyXG4gKiBAcGFyYW0gIHtWZWMzfSAgICAgICB4aVxyXG4gKiBAcGFyYW0gIHtWZWMzfSAgICAgICB4alxyXG4gKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSBxaVxyXG4gKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSBxalxyXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBiaVxyXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBialxyXG4gKi9cclxuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLnR5cGVzLlNQSEVSRSB8IFNoYXBlLnR5cGVzLkNPTlZFWFBPTFlIRURST05dID1cclxuTmFycm93cGhhc2UucHJvdG90eXBlLnNwaGVyZUNvbnZleCA9IGZ1bmN0aW9uKHNpLHNqLHhpLHhqLHFpLHFqLGJpLGJqLHJzaSxyc2osanVzdFRlc3Qpe1xyXG4gICAgdmFyIHYzcG9vbCA9IHRoaXMudjNwb29sO1xyXG4gICAgeGkudnN1Yih4aixjb252ZXhfdG9fc3BoZXJlKTtcclxuICAgIHZhciBub3JtYWxzID0gc2ouZmFjZU5vcm1hbHM7XHJcbiAgICB2YXIgZmFjZXMgPSBzai5mYWNlcztcclxuICAgIHZhciB2ZXJ0cyA9IHNqLnZlcnRpY2VzO1xyXG4gICAgdmFyIFIgPSAgICAgc2kucmFkaXVzO1xyXG4gICAgdmFyIHBlbmV0cmF0aW5nX3NpZGVzID0gW107XHJcblxyXG4gICAgLy8gaWYoY29udmV4X3RvX3NwaGVyZS5ub3JtMigpID4gc2kuYm91bmRpbmdTcGhlcmVSYWRpdXMgKyBzai5ib3VuZGluZ1NwaGVyZVJhZGl1cyl7XHJcbiAgICAvLyAgICAgcmV0dXJuO1xyXG4gICAgLy8gfVxyXG5cclxuICAgIC8vIENoZWNrIGNvcm5lcnNcclxuICAgIGZvcih2YXIgaT0wOyBpIT09dmVydHMubGVuZ3RoOyBpKyspe1xyXG4gICAgICAgIHZhciB2ID0gdmVydHNbaV07XHJcblxyXG4gICAgICAgIC8vIFdvcmxkIHBvc2l0aW9uIG9mIGNvcm5lclxyXG4gICAgICAgIHZhciB3b3JsZENvcm5lciA9IHNwaGVyZUNvbnZleF93b3JsZENvcm5lcjtcclxuICAgICAgICBxai52bXVsdCh2LHdvcmxkQ29ybmVyKTtcclxuICAgICAgICB4ai52YWRkKHdvcmxkQ29ybmVyLHdvcmxkQ29ybmVyKTtcclxuICAgICAgICB2YXIgc3BoZXJlX3RvX2Nvcm5lciA9IHNwaGVyZUNvbnZleF9zcGhlcmVUb0Nvcm5lcjtcclxuICAgICAgICB3b3JsZENvcm5lci52c3ViKHhpLCBzcGhlcmVfdG9fY29ybmVyKTtcclxuICAgICAgICBpZihzcGhlcmVfdG9fY29ybmVyLm5vcm0yKCkgPCBSICogUil7XHJcbiAgICAgICAgICAgIGlmKGp1c3RUZXN0KXtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcclxuICAgICAgICAgICAgdmFyIHIgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihiaSxiaixzaSxzaixyc2kscnNqKTtcclxuICAgICAgICAgICAgci5yaS5jb3B5KHNwaGVyZV90b19jb3JuZXIpO1xyXG4gICAgICAgICAgICByLnJpLm5vcm1hbGl6ZSgpO1xyXG4gICAgICAgICAgICByLm5pLmNvcHkoci5yaSk7XHJcbiAgICAgICAgICAgIHIucmkubXVsdChSLHIucmkpO1xyXG4gICAgICAgICAgICB3b3JsZENvcm5lci52c3ViKHhqLHIucmopO1xyXG5cclxuICAgICAgICAgICAgLy8gU2hvdWxkIGJlIHJlbGF0aXZlIHRvIHRoZSBib2R5LlxyXG4gICAgICAgICAgICByLnJpLnZhZGQoeGksIHIucmkpO1xyXG4gICAgICAgICAgICByLnJpLnZzdWIoYmkucG9zaXRpb24sIHIucmkpO1xyXG5cclxuICAgICAgICAgICAgLy8gU2hvdWxkIGJlIHJlbGF0aXZlIHRvIHRoZSBib2R5LlxyXG4gICAgICAgICAgICByLnJqLnZhZGQoeGosIHIucmopO1xyXG4gICAgICAgICAgICByLnJqLnZzdWIoYmoucG9zaXRpb24sIHIucmopO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5yZXN1bHQucHVzaChyKTtcclxuICAgICAgICAgICAgdGhpcy5jcmVhdGVGcmljdGlvbkVxdWF0aW9uc0Zyb21Db250YWN0KHIsIHRoaXMuZnJpY3Rpb25SZXN1bHQpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIENoZWNrIHNpZGUgKHBsYW5lKSBpbnRlcnNlY3Rpb25zXHJcbiAgICB2YXIgZm91bmQgPSBmYWxzZTtcclxuICAgIGZvcih2YXIgaT0wLCBuZmFjZXM9ZmFjZXMubGVuZ3RoOyBpIT09bmZhY2VzICYmIGZvdW5kPT09ZmFsc2U7IGkrKyl7XHJcbiAgICAgICAgdmFyIG5vcm1hbCA9IG5vcm1hbHNbaV07XHJcbiAgICAgICAgdmFyIGZhY2UgPSBmYWNlc1tpXTtcclxuXHJcbiAgICAgICAgLy8gR2V0IHdvcmxkLXRyYW5zZm9ybWVkIG5vcm1hbCBvZiB0aGUgZmFjZVxyXG4gICAgICAgIHZhciB3b3JsZE5vcm1hbCA9IHNwaGVyZUNvbnZleF93b3JsZE5vcm1hbDtcclxuICAgICAgICBxai52bXVsdChub3JtYWwsd29ybGROb3JtYWwpO1xyXG5cclxuICAgICAgICAvLyBHZXQgYSB3b3JsZCB2ZXJ0ZXggZnJvbSB0aGUgZmFjZVxyXG4gICAgICAgIHZhciB3b3JsZFBvaW50ID0gc3BoZXJlQ29udmV4X3dvcmxkUG9pbnQ7XHJcbiAgICAgICAgcWoudm11bHQodmVydHNbZmFjZVswXV0sd29ybGRQb2ludCk7XHJcbiAgICAgICAgd29ybGRQb2ludC52YWRkKHhqLHdvcmxkUG9pbnQpO1xyXG5cclxuICAgICAgICAvLyBHZXQgYSBwb2ludCBvbiB0aGUgc3BoZXJlLCBjbG9zZXN0IHRvIHRoZSBmYWNlIG5vcm1hbFxyXG4gICAgICAgIHZhciB3b3JsZFNwaGVyZVBvaW50Q2xvc2VzdFRvUGxhbmUgPSBzcGhlcmVDb252ZXhfd29ybGRTcGhlcmVQb2ludENsb3Nlc3RUb1BsYW5lO1xyXG4gICAgICAgIHdvcmxkTm9ybWFsLm11bHQoLVIsIHdvcmxkU3BoZXJlUG9pbnRDbG9zZXN0VG9QbGFuZSk7XHJcbiAgICAgICAgeGkudmFkZCh3b3JsZFNwaGVyZVBvaW50Q2xvc2VzdFRvUGxhbmUsIHdvcmxkU3BoZXJlUG9pbnRDbG9zZXN0VG9QbGFuZSk7XHJcblxyXG4gICAgICAgIC8vIFZlY3RvciBmcm9tIGEgZmFjZSBwb2ludCB0byB0aGUgY2xvc2VzdCBwb2ludCBvbiB0aGUgc3BoZXJlXHJcbiAgICAgICAgdmFyIHBlbmV0cmF0aW9uVmVjID0gc3BoZXJlQ29udmV4X3BlbmV0cmF0aW9uVmVjO1xyXG4gICAgICAgIHdvcmxkU3BoZXJlUG9pbnRDbG9zZXN0VG9QbGFuZS52c3ViKHdvcmxkUG9pbnQscGVuZXRyYXRpb25WZWMpO1xyXG5cclxuICAgICAgICAvLyBUaGUgcGVuZXRyYXRpb24uIE5lZ2F0aXZlIHZhbHVlIG1lYW5zIG92ZXJsYXAuXHJcbiAgICAgICAgdmFyIHBlbmV0cmF0aW9uID0gcGVuZXRyYXRpb25WZWMuZG90KHdvcmxkTm9ybWFsKTtcclxuXHJcbiAgICAgICAgdmFyIHdvcmxkUG9pbnRUb1NwaGVyZSA9IHNwaGVyZUNvbnZleF9zcGhlcmVUb1dvcmxkUG9pbnQ7XHJcbiAgICAgICAgeGkudnN1Yih3b3JsZFBvaW50LCB3b3JsZFBvaW50VG9TcGhlcmUpO1xyXG5cclxuICAgICAgICBpZihwZW5ldHJhdGlvbiA8IDAgJiYgd29ybGRQb2ludFRvU3BoZXJlLmRvdCh3b3JsZE5vcm1hbCk+MCl7XHJcbiAgICAgICAgICAgIC8vIEludGVyc2VjdHMgcGxhbmUuIE5vdyBjaGVjayBpZiB0aGUgc3BoZXJlIGlzIGluc2lkZSB0aGUgZmFjZSBwb2x5Z29uXHJcbiAgICAgICAgICAgIHZhciBmYWNlVmVydHMgPSBbXTsgLy8gRmFjZSB2ZXJ0aWNlcywgaW4gd29ybGQgY29vcmRzXHJcbiAgICAgICAgICAgIGZvcih2YXIgaj0wLCBOdmVydHM9ZmFjZS5sZW5ndGg7IGohPT1OdmVydHM7IGorKyl7XHJcbiAgICAgICAgICAgICAgICB2YXIgd29ybGRWZXJ0ZXggPSB2M3Bvb2wuZ2V0KCk7XHJcbiAgICAgICAgICAgICAgICBxai52bXVsdCh2ZXJ0c1tmYWNlW2pdXSwgd29ybGRWZXJ0ZXgpO1xyXG4gICAgICAgICAgICAgICAgeGoudmFkZCh3b3JsZFZlcnRleCx3b3JsZFZlcnRleCk7XHJcbiAgICAgICAgICAgICAgICBmYWNlVmVydHMucHVzaCh3b3JsZFZlcnRleCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKHBvaW50SW5Qb2x5Z29uKGZhY2VWZXJ0cyx3b3JsZE5vcm1hbCx4aSkpeyAvLyBJcyB0aGUgc3BoZXJlIGNlbnRlciBpbiB0aGUgZmFjZSBwb2x5Z29uP1xyXG4gICAgICAgICAgICAgICAgaWYoanVzdFRlc3Qpe1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdmFyIHIgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihiaSxiaixzaSxzaixyc2kscnNqKTtcclxuXHJcbiAgICAgICAgICAgICAgICB3b3JsZE5vcm1hbC5tdWx0KC1SLCByLnJpKTsgLy8gQ29udGFjdCBvZmZzZXQsIGZyb20gc3BoZXJlIGNlbnRlciB0byBjb250YWN0XHJcbiAgICAgICAgICAgICAgICB3b3JsZE5vcm1hbC5uZWdhdGUoci5uaSk7IC8vIE5vcm1hbCBwb2ludGluZyBvdXQgb2Ygc3BoZXJlXHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHBlbmV0cmF0aW9uVmVjMiA9IHYzcG9vbC5nZXQoKTtcclxuICAgICAgICAgICAgICAgIHdvcmxkTm9ybWFsLm11bHQoLXBlbmV0cmF0aW9uLCBwZW5ldHJhdGlvblZlYzIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHBlbmV0cmF0aW9uU3BoZXJlUG9pbnQgPSB2M3Bvb2wuZ2V0KCk7XHJcbiAgICAgICAgICAgICAgICB3b3JsZE5vcm1hbC5tdWx0KC1SLCBwZW5ldHJhdGlvblNwaGVyZVBvaW50KTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL3hpLnZzdWIoeGopLnZhZGQocGVuZXRyYXRpb25TcGhlcmVQb2ludCkudmFkZChwZW5ldHJhdGlvblZlYzIgLCByLnJqKTtcclxuICAgICAgICAgICAgICAgIHhpLnZzdWIoeGosci5yaik7XHJcbiAgICAgICAgICAgICAgICByLnJqLnZhZGQocGVuZXRyYXRpb25TcGhlcmVQb2ludCxyLnJqKTtcclxuICAgICAgICAgICAgICAgIHIucmoudmFkZChwZW5ldHJhdGlvblZlYzIgLCByLnJqKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTaG91bGQgYmUgcmVsYXRpdmUgdG8gdGhlIGJvZHkuXHJcbiAgICAgICAgICAgICAgICByLnJqLnZhZGQoeGosIHIucmopO1xyXG4gICAgICAgICAgICAgICAgci5yai52c3ViKGJqLnBvc2l0aW9uLCByLnJqKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTaG91bGQgYmUgcmVsYXRpdmUgdG8gdGhlIGJvZHkuXHJcbiAgICAgICAgICAgICAgICByLnJpLnZhZGQoeGksIHIucmkpO1xyXG4gICAgICAgICAgICAgICAgci5yaS52c3ViKGJpLnBvc2l0aW9uLCByLnJpKTtcclxuXHJcbiAgICAgICAgICAgICAgICB2M3Bvb2wucmVsZWFzZShwZW5ldHJhdGlvblZlYzIpO1xyXG4gICAgICAgICAgICAgICAgdjNwb29sLnJlbGVhc2UocGVuZXRyYXRpb25TcGhlcmVQb2ludCk7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5yZXN1bHQucHVzaChyKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChyLCB0aGlzLmZyaWN0aW9uUmVzdWx0KTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBSZWxlYXNlIHdvcmxkIHZlcnRpY2VzXHJcbiAgICAgICAgICAgICAgICBmb3IodmFyIGo9MCwgTmZhY2V2ZXJ0cz1mYWNlVmVydHMubGVuZ3RoOyBqIT09TmZhY2V2ZXJ0czsgaisrKXtcclxuICAgICAgICAgICAgICAgICAgICB2M3Bvb2wucmVsZWFzZShmYWNlVmVydHNbal0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gV2Ugb25seSBleHBlY3QgKm9uZSogZmFjZSBjb250YWN0XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBFZGdlP1xyXG4gICAgICAgICAgICAgICAgZm9yKHZhciBqPTA7IGohPT1mYWNlLmxlbmd0aDsgaisrKXtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHR3byB3b3JsZCB0cmFuc2Zvcm1lZCB2ZXJ0aWNlc1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2MSA9IHYzcG9vbC5nZXQoKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdjIgPSB2M3Bvb2wuZ2V0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcWoudm11bHQodmVydHNbZmFjZVsoaisxKSVmYWNlLmxlbmd0aF1dLCB2MSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcWoudm11bHQodmVydHNbZmFjZVsoaisyKSVmYWNlLmxlbmd0aF1dLCB2Mik7XHJcbiAgICAgICAgICAgICAgICAgICAgeGoudmFkZCh2MSwgdjEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHhqLnZhZGQodjIsIHYyKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29uc3RydWN0IGVkZ2UgdmVjdG9yXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVkZ2UgPSBzcGhlcmVDb252ZXhfZWRnZTtcclxuICAgICAgICAgICAgICAgICAgICB2Mi52c3ViKHYxLGVkZ2UpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBDb25zdHJ1Y3QgdGhlIHNhbWUgdmVjdG9yLCBidXQgbm9ybWFsaXplZFxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlZGdlVW5pdCA9IHNwaGVyZUNvbnZleF9lZGdlVW5pdDtcclxuICAgICAgICAgICAgICAgICAgICBlZGdlLnVuaXQoZWRnZVVuaXQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBwIGlzIHhpIHByb2plY3RlZCBvbnRvIHRoZSBlZGdlXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSB2M3Bvb2wuZ2V0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHYxX3RvX3hpID0gdjNwb29sLmdldCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHhpLnZzdWIodjEsIHYxX3RvX3hpKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZG90ID0gdjFfdG9feGkuZG90KGVkZ2VVbml0KTtcclxuICAgICAgICAgICAgICAgICAgICBlZGdlVW5pdC5tdWx0KGRvdCwgcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcC52YWRkKHYxLCBwKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29tcHV0ZSBhIHZlY3RvciBmcm9tIHAgdG8gdGhlIGNlbnRlciBvZiB0aGUgc3BoZXJlXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHhpX3RvX3AgPSB2M3Bvb2wuZ2V0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcC52c3ViKHhpLCB4aV90b19wKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29sbGlzaW9uIGlmIHRoZSBlZGdlLXNwaGVyZSBkaXN0YW5jZSBpcyBsZXNzIHRoYW4gdGhlIHJhZGl1c1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEFORCBpZiBwIGlzIGluIGJldHdlZW4gdjEgYW5kIHYyXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoZG90ID4gMCAmJiBkb3QqZG90PGVkZ2Uubm9ybTIoKSAmJiB4aV90b19wLm5vcm0yKCkgPCBSKlIpeyAvLyBDb2xsaXNpb24gaWYgdGhlIGVkZ2Utc3BoZXJlIGRpc3RhbmNlIGlzIGxlc3MgdGhhbiB0aGUgcmFkaXVzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVkZ2UgY29udGFjdCFcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoanVzdFRlc3Qpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihiaSxiaixzaSxzaixyc2kscnNqKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcC52c3ViKHhqLHIucmopO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcC52c3ViKHhpLHIubmkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByLm5pLm5vcm1hbGl6ZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgci5uaS5tdWx0KFIsci5yaSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTaG91bGQgYmUgcmVsYXRpdmUgdG8gdGhlIGJvZHkuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHIucmoudmFkZCh4aiwgci5yaik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHIucmoudnN1Yihiai5wb3NpdGlvbiwgci5yaik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTaG91bGQgYmUgcmVsYXRpdmUgdG8gdGhlIGJvZHkuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHIucmkudmFkZCh4aSwgci5yaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHIucmkudnN1YihiaS5wb3NpdGlvbiwgci5yaSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdC5wdXNoKHIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3QociwgdGhpcy5mcmljdGlvblJlc3VsdCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZWxlYXNlIHdvcmxkIHZlcnRpY2VzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaj0wLCBOZmFjZXZlcnRzPWZhY2VWZXJ0cy5sZW5ndGg7IGohPT1OZmFjZXZlcnRzOyBqKyspe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdjNwb29sLnJlbGVhc2UoZmFjZVZlcnRzW2pdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdjNwb29sLnJlbGVhc2UodjEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2M3Bvb2wucmVsZWFzZSh2Mik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHYzcG9vbC5yZWxlYXNlKHApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2M3Bvb2wucmVsZWFzZSh4aV90b19wKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdjNwb29sLnJlbGVhc2UodjFfdG9feGkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdjNwb29sLnJlbGVhc2UodjEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHYzcG9vbC5yZWxlYXNlKHYyKTtcclxuICAgICAgICAgICAgICAgICAgICB2M3Bvb2wucmVsZWFzZShwKTtcclxuICAgICAgICAgICAgICAgICAgICB2M3Bvb2wucmVsZWFzZSh4aV90b19wKTtcclxuICAgICAgICAgICAgICAgICAgICB2M3Bvb2wucmVsZWFzZSh2MV90b194aSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFJlbGVhc2Ugd29ybGQgdmVydGljZXNcclxuICAgICAgICAgICAgZm9yKHZhciBqPTAsIE5mYWNldmVydHM9ZmFjZVZlcnRzLmxlbmd0aDsgaiE9PU5mYWNldmVydHM7IGorKyl7XHJcbiAgICAgICAgICAgICAgICB2M3Bvb2wucmVsZWFzZShmYWNlVmVydHNbal0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxudmFyIHBsYW5lQm94X25vcm1hbCA9IG5ldyBWZWMzKCk7XHJcbnZhciBwbGFuZV90b19jb3JuZXIgPSBuZXcgVmVjMygpO1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgcGxhbmVCb3hcclxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgcmVzdWx0XHJcbiAqIEBwYXJhbSAge1NoYXBlfSAgICAgIHNpXHJcbiAqIEBwYXJhbSAge1NoYXBlfSAgICAgIHNqXHJcbiAqIEBwYXJhbSAge1ZlYzN9ICAgICAgIHhpXHJcbiAqIEBwYXJhbSAge1ZlYzN9ICAgICAgIHhqXHJcbiAqIEBwYXJhbSAge1F1YXRlcm5pb259IHFpXHJcbiAqIEBwYXJhbSAge1F1YXRlcm5pb259IHFqXHJcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGJpXHJcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGJqXHJcbiAqL1xyXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUudHlwZXMuUExBTkUgfCBTaGFwZS50eXBlcy5CT1hdID1cclxuTmFycm93cGhhc2UucHJvdG90eXBlLnBsYW5lQm94ID0gZnVuY3Rpb24oc2ksc2oseGkseGoscWkscWosYmksYmoscnNpLHJzaixqdXN0VGVzdCl7XHJcbiAgICBzai5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24ubWF0ZXJpYWwgPSBzai5tYXRlcmlhbDtcclxuICAgIHNqLmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbi5jb2xsaXNpb25SZXNwb25zZSA9IHNqLmNvbGxpc2lvblJlc3BvbnNlO1xyXG4gICAgc2ouY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLmlkID0gc2ouaWQ7XHJcbiAgICByZXR1cm4gdGhpcy5wbGFuZUNvbnZleChzaSxzai5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24seGkseGoscWkscWosYmksYmosc2ksc2osanVzdFRlc3QpO1xyXG59O1xyXG5cclxudmFyIHBsYW5lQ29udmV4X3YgPSBuZXcgVmVjMygpO1xyXG52YXIgcGxhbmVDb252ZXhfbm9ybWFsID0gbmV3IFZlYzMoKTtcclxudmFyIHBsYW5lQ29udmV4X3JlbHBvcyA9IG5ldyBWZWMzKCk7XHJcbnZhciBwbGFuZUNvbnZleF9wcm9qZWN0ZWQgPSBuZXcgVmVjMygpO1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgcGxhbmVDb252ZXhcclxuICogQHBhcmFtICB7U2hhcGV9ICAgICAgc2lcclxuICogQHBhcmFtICB7U2hhcGV9ICAgICAgc2pcclxuICogQHBhcmFtICB7VmVjM30gICAgICAgeGlcclxuICogQHBhcmFtICB7VmVjM30gICAgICAgeGpcclxuICogQHBhcmFtICB7UXVhdGVybmlvbn0gcWlcclxuICogQHBhcmFtICB7UXVhdGVybmlvbn0gcWpcclxuICogQHBhcmFtICB7Qm9keX0gICAgICAgYmlcclxuICogQHBhcmFtICB7Qm9keX0gICAgICAgYmpcclxuICovXHJcbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS50eXBlcy5QTEFORSB8IFNoYXBlLnR5cGVzLkNPTlZFWFBPTFlIRURST05dID1cclxuTmFycm93cGhhc2UucHJvdG90eXBlLnBsYW5lQ29udmV4ID0gZnVuY3Rpb24oXHJcbiAgICBwbGFuZVNoYXBlLFxyXG4gICAgY29udmV4U2hhcGUsXHJcbiAgICBwbGFuZVBvc2l0aW9uLFxyXG4gICAgY29udmV4UG9zaXRpb24sXHJcbiAgICBwbGFuZVF1YXQsXHJcbiAgICBjb252ZXhRdWF0LFxyXG4gICAgcGxhbmVCb2R5LFxyXG4gICAgY29udmV4Qm9keSxcclxuICAgIHNpLFxyXG4gICAgc2osXHJcbiAgICBqdXN0VGVzdFxyXG4pe1xyXG4gICAgLy8gU2ltcGx5IHJldHVybiB0aGUgcG9pbnRzIGJlaGluZCB0aGUgcGxhbmUuXHJcbiAgICB2YXIgd29ybGRWZXJ0ZXggPSBwbGFuZUNvbnZleF92LFxyXG4gICAgICAgIHdvcmxkTm9ybWFsID0gcGxhbmVDb252ZXhfbm9ybWFsO1xyXG4gICAgd29ybGROb3JtYWwuc2V0KDAsMCwxKTtcclxuICAgIHBsYW5lUXVhdC52bXVsdCh3b3JsZE5vcm1hbCx3b3JsZE5vcm1hbCk7IC8vIFR1cm4gbm9ybWFsIGFjY29yZGluZyB0byBwbGFuZSBvcmllbnRhdGlvblxyXG5cclxuICAgIHZhciBudW1Db250YWN0cyA9IDA7XHJcbiAgICB2YXIgcmVscG9zID0gcGxhbmVDb252ZXhfcmVscG9zO1xyXG4gICAgZm9yKHZhciBpID0gMDsgaSAhPT0gY29udmV4U2hhcGUudmVydGljZXMubGVuZ3RoOyBpKyspe1xyXG5cclxuICAgICAgICAvLyBHZXQgd29ybGQgY29udmV4IHZlcnRleFxyXG4gICAgICAgIHdvcmxkVmVydGV4LmNvcHkoY29udmV4U2hhcGUudmVydGljZXNbaV0pO1xyXG4gICAgICAgIGNvbnZleFF1YXQudm11bHQod29ybGRWZXJ0ZXgsIHdvcmxkVmVydGV4KTtcclxuICAgICAgICBjb252ZXhQb3NpdGlvbi52YWRkKHdvcmxkVmVydGV4LCB3b3JsZFZlcnRleCk7XHJcbiAgICAgICAgd29ybGRWZXJ0ZXgudnN1YihwbGFuZVBvc2l0aW9uLCByZWxwb3MpO1xyXG5cclxuICAgICAgICB2YXIgZG90ID0gd29ybGROb3JtYWwuZG90KHJlbHBvcyk7XHJcbiAgICAgICAgaWYoZG90IDw9IDAuMCl7XHJcbiAgICAgICAgICAgIGlmKGp1c3RUZXN0KXtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgciA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKHBsYW5lQm9keSwgY29udmV4Qm9keSwgcGxhbmVTaGFwZSwgY29udmV4U2hhcGUsIHNpLCBzaik7XHJcblxyXG4gICAgICAgICAgICAvLyBHZXQgdmVydGV4IHBvc2l0aW9uIHByb2plY3RlZCBvbiBwbGFuZVxyXG4gICAgICAgICAgICB2YXIgcHJvamVjdGVkID0gcGxhbmVDb252ZXhfcHJvamVjdGVkO1xyXG4gICAgICAgICAgICB3b3JsZE5vcm1hbC5tdWx0KHdvcmxkTm9ybWFsLmRvdChyZWxwb3MpLHByb2plY3RlZCk7XHJcbiAgICAgICAgICAgIHdvcmxkVmVydGV4LnZzdWIocHJvamVjdGVkLCBwcm9qZWN0ZWQpO1xyXG4gICAgICAgICAgICBwcm9qZWN0ZWQudnN1YihwbGFuZVBvc2l0aW9uLCByLnJpKTsgLy8gRnJvbSBwbGFuZSB0byB2ZXJ0ZXggcHJvamVjdGVkIG9uIHBsYW5lXHJcblxyXG4gICAgICAgICAgICByLm5pLmNvcHkod29ybGROb3JtYWwpOyAvLyBDb250YWN0IG5vcm1hbCBpcyB0aGUgcGxhbmUgbm9ybWFsIG91dCBmcm9tIHBsYW5lXHJcblxyXG4gICAgICAgICAgICAvLyByaiBpcyBub3cganVzdCB0aGUgdmVjdG9yIGZyb20gdGhlIGNvbnZleCBjZW50ZXIgdG8gdGhlIHZlcnRleFxyXG4gICAgICAgICAgICB3b3JsZFZlcnRleC52c3ViKGNvbnZleFBvc2l0aW9uLCByLnJqKTtcclxuXHJcbiAgICAgICAgICAgIC8vIE1ha2UgaXQgcmVsYXRpdmUgdG8gdGhlIGJvZHlcclxuICAgICAgICAgICAgci5yaS52YWRkKHBsYW5lUG9zaXRpb24sIHIucmkpO1xyXG4gICAgICAgICAgICByLnJpLnZzdWIocGxhbmVCb2R5LnBvc2l0aW9uLCByLnJpKTtcclxuICAgICAgICAgICAgci5yai52YWRkKGNvbnZleFBvc2l0aW9uLCByLnJqKTtcclxuICAgICAgICAgICAgci5yai52c3ViKGNvbnZleEJvZHkucG9zaXRpb24sIHIucmopO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5yZXN1bHQucHVzaChyKTtcclxuICAgICAgICAgICAgbnVtQ29udGFjdHMrKztcclxuICAgICAgICAgICAgaWYoIXRoaXMuZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb24pe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVGcmljdGlvbkVxdWF0aW9uc0Zyb21Db250YWN0KHIsIHRoaXMuZnJpY3Rpb25SZXN1bHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb24gJiYgbnVtQ29udGFjdHMpe1xyXG4gICAgICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25Gcm9tQXZlcmFnZShudW1Db250YWN0cyk7XHJcbiAgICB9XHJcbn07XHJcblxyXG52YXIgY29udmV4Q29udmV4X3NlcEF4aXMgPSBuZXcgVmVjMygpO1xyXG52YXIgY29udmV4Q29udmV4X3EgPSBuZXcgVmVjMygpO1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgY29udmV4Q29udmV4XHJcbiAqIEBwYXJhbSAge1NoYXBlfSAgICAgIHNpXHJcbiAqIEBwYXJhbSAge1NoYXBlfSAgICAgIHNqXHJcbiAqIEBwYXJhbSAge1ZlYzN9ICAgICAgIHhpXHJcbiAqIEBwYXJhbSAge1ZlYzN9ICAgICAgIHhqXHJcbiAqIEBwYXJhbSAge1F1YXRlcm5pb259IHFpXHJcbiAqIEBwYXJhbSAge1F1YXRlcm5pb259IHFqXHJcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGJpXHJcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGJqXHJcbiAqL1xyXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUudHlwZXMuQ09OVkVYUE9MWUhFRFJPTl0gPVxyXG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuY29udmV4Q29udmV4ID0gZnVuY3Rpb24oc2ksc2oseGkseGoscWkscWosYmksYmoscnNpLHJzaixqdXN0VGVzdCxmYWNlTGlzdEEsZmFjZUxpc3RCKXtcclxuICAgIHZhciBzZXBBeGlzID0gY29udmV4Q29udmV4X3NlcEF4aXM7XHJcblxyXG4gICAgaWYoeGkuZGlzdGFuY2VUbyh4aikgPiBzaS5ib3VuZGluZ1NwaGVyZVJhZGl1cyArIHNqLmJvdW5kaW5nU3BoZXJlUmFkaXVzKXtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYoc2kuZmluZFNlcGFyYXRpbmdBeGlzKHNqLHhpLHFpLHhqLHFqLHNlcEF4aXMsZmFjZUxpc3RBLGZhY2VMaXN0Qikpe1xyXG4gICAgICAgIHZhciByZXMgPSBbXTtcclxuICAgICAgICB2YXIgcSA9IGNvbnZleENvbnZleF9xO1xyXG4gICAgICAgIHNpLmNsaXBBZ2FpbnN0SHVsbCh4aSxxaSxzaix4aixxaixzZXBBeGlzLC0xMDAsMTAwLHJlcyk7XHJcbiAgICAgICAgdmFyIG51bUNvbnRhY3RzID0gMDtcclxuICAgICAgICBmb3IodmFyIGogPSAwOyBqICE9PSByZXMubGVuZ3RoOyBqKyspe1xyXG4gICAgICAgICAgICBpZihqdXN0VGVzdCl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgciA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGJpLGJqLHNpLHNqLHJzaSxyc2opLFxyXG4gICAgICAgICAgICAgICAgcmkgPSByLnJpLFxyXG4gICAgICAgICAgICAgICAgcmogPSByLnJqO1xyXG4gICAgICAgICAgICBzZXBBeGlzLm5lZ2F0ZShyLm5pKTtcclxuICAgICAgICAgICAgcmVzW2pdLm5vcm1hbC5uZWdhdGUocSk7XHJcbiAgICAgICAgICAgIHEubXVsdChyZXNbal0uZGVwdGgsIHEpO1xyXG4gICAgICAgICAgICByZXNbal0ucG9pbnQudmFkZChxLCByaSk7XHJcbiAgICAgICAgICAgIHJqLmNvcHkocmVzW2pdLnBvaW50KTtcclxuXHJcbiAgICAgICAgICAgIC8vIENvbnRhY3QgcG9pbnRzIGFyZSBpbiB3b3JsZCBjb29yZGluYXRlcy4gVHJhbnNmb3JtIGJhY2sgdG8gcmVsYXRpdmVcclxuICAgICAgICAgICAgcmkudnN1Yih4aSxyaSk7XHJcbiAgICAgICAgICAgIHJqLnZzdWIoeGoscmopO1xyXG5cclxuICAgICAgICAgICAgLy8gTWFrZSByZWxhdGl2ZSB0byBib2RpZXNcclxuICAgICAgICAgICAgcmkudmFkZCh4aSwgcmkpO1xyXG4gICAgICAgICAgICByaS52c3ViKGJpLnBvc2l0aW9uLCByaSk7XHJcbiAgICAgICAgICAgIHJqLnZhZGQoeGosIHJqKTtcclxuICAgICAgICAgICAgcmoudnN1Yihiai5wb3NpdGlvbiwgcmopO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5yZXN1bHQucHVzaChyKTtcclxuICAgICAgICAgICAgbnVtQ29udGFjdHMrKztcclxuICAgICAgICAgICAgaWYoIXRoaXMuZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb24pe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVGcmljdGlvbkVxdWF0aW9uc0Zyb21Db250YWN0KHIsIHRoaXMuZnJpY3Rpb25SZXN1bHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb24gJiYgbnVtQ29udGFjdHMpe1xyXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZUZyaWN0aW9uRnJvbUF2ZXJhZ2UobnVtQ29udGFjdHMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcblxyXG4vKipcclxuICogQG1ldGhvZCBjb252ZXhUcmltZXNoXHJcbiAqIEBwYXJhbSAge0FycmF5fSAgICAgIHJlc3VsdFxyXG4gKiBAcGFyYW0gIHtTaGFwZX0gICAgICBzaVxyXG4gKiBAcGFyYW0gIHtTaGFwZX0gICAgICBzalxyXG4gKiBAcGFyYW0gIHtWZWMzfSAgICAgICB4aVxyXG4gKiBAcGFyYW0gIHtWZWMzfSAgICAgICB4alxyXG4gKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSBxaVxyXG4gKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSBxalxyXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBiaVxyXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBialxyXG4gKi9cclxuLy8gTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLnR5cGVzLkNPTlZFWFBPTFlIRURST04gfCBTaGFwZS50eXBlcy5UUklNRVNIXSA9XHJcbi8vIE5hcnJvd3BoYXNlLnByb3RvdHlwZS5jb252ZXhUcmltZXNoID0gZnVuY3Rpb24oc2ksc2oseGkseGoscWkscWosYmksYmoscnNpLHJzaixmYWNlTGlzdEEsZmFjZUxpc3RCKXtcclxuLy8gICAgIHZhciBzZXBBeGlzID0gY29udmV4Q29udmV4X3NlcEF4aXM7XHJcblxyXG4vLyAgICAgaWYoeGkuZGlzdGFuY2VUbyh4aikgPiBzaS5ib3VuZGluZ1NwaGVyZVJhZGl1cyArIHNqLmJvdW5kaW5nU3BoZXJlUmFkaXVzKXtcclxuLy8gICAgICAgICByZXR1cm47XHJcbi8vICAgICB9XHJcblxyXG4vLyAgICAgLy8gQ29uc3RydWN0IGEgdGVtcCBodWxsIGZvciBlYWNoIHRyaWFuZ2xlXHJcbi8vICAgICB2YXIgaHVsbEIgPSBuZXcgQ29udmV4UG9seWhlZHJvbigpO1xyXG5cclxuLy8gICAgIGh1bGxCLmZhY2VzID0gW1swLDEsMl1dO1xyXG4vLyAgICAgdmFyIHZhID0gbmV3IFZlYzMoKTtcclxuLy8gICAgIHZhciB2YiA9IG5ldyBWZWMzKCk7XHJcbi8vICAgICB2YXIgdmMgPSBuZXcgVmVjMygpO1xyXG4vLyAgICAgaHVsbEIudmVydGljZXMgPSBbXHJcbi8vICAgICAgICAgdmEsXHJcbi8vICAgICAgICAgdmIsXHJcbi8vICAgICAgICAgdmNcclxuLy8gICAgIF07XHJcblxyXG4vLyAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzai5pbmRpY2VzLmxlbmd0aCAvIDM7IGkrKykge1xyXG5cclxuLy8gICAgICAgICB2YXIgdHJpYW5nbGVOb3JtYWwgPSBuZXcgVmVjMygpO1xyXG4vLyAgICAgICAgIHNqLmdldE5vcm1hbChpLCB0cmlhbmdsZU5vcm1hbCk7XHJcbi8vICAgICAgICAgaHVsbEIuZmFjZU5vcm1hbHMgPSBbdHJpYW5nbGVOb3JtYWxdO1xyXG5cclxuLy8gICAgICAgICBzai5nZXRUcmlhbmdsZVZlcnRpY2VzKGksIHZhLCB2YiwgdmMpO1xyXG5cclxuLy8gICAgICAgICB2YXIgZCA9IHNpLnRlc3RTZXBBeGlzKHRyaWFuZ2xlTm9ybWFsLCBodWxsQiwgeGksIHFpLCB4aiwgcWopO1xyXG4vLyAgICAgICAgIGlmKCFkKXtcclxuLy8gICAgICAgICAgICAgdHJpYW5nbGVOb3JtYWwuc2NhbGUoLTEsIHRyaWFuZ2xlTm9ybWFsKTtcclxuLy8gICAgICAgICAgICAgZCA9IHNpLnRlc3RTZXBBeGlzKHRyaWFuZ2xlTm9ybWFsLCBodWxsQiwgeGksIHFpLCB4aiwgcWopO1xyXG5cclxuLy8gICAgICAgICAgICAgaWYoIWQpe1xyXG4vLyAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbi8vICAgICAgICAgICAgIH1cclxuLy8gICAgICAgICB9XHJcblxyXG4vLyAgICAgICAgIHZhciByZXMgPSBbXTtcclxuLy8gICAgICAgICB2YXIgcSA9IGNvbnZleENvbnZleF9xO1xyXG4vLyAgICAgICAgIHNpLmNsaXBBZ2FpbnN0SHVsbCh4aSxxaSxodWxsQix4aixxaix0cmlhbmdsZU5vcm1hbCwtMTAwLDEwMCxyZXMpO1xyXG4vLyAgICAgICAgIGZvcih2YXIgaiA9IDA7IGogIT09IHJlcy5sZW5ndGg7IGorKyl7XHJcbi8vICAgICAgICAgICAgIHZhciByID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oYmksYmosc2ksc2oscnNpLHJzaiksXHJcbi8vICAgICAgICAgICAgICAgICByaSA9IHIucmksXHJcbi8vICAgICAgICAgICAgICAgICByaiA9IHIucmo7XHJcbi8vICAgICAgICAgICAgIHIubmkuY29weSh0cmlhbmdsZU5vcm1hbCk7XHJcbi8vICAgICAgICAgICAgIHIubmkubmVnYXRlKHIubmkpO1xyXG4vLyAgICAgICAgICAgICByZXNbal0ubm9ybWFsLm5lZ2F0ZShxKTtcclxuLy8gICAgICAgICAgICAgcS5tdWx0KHJlc1tqXS5kZXB0aCwgcSk7XHJcbi8vICAgICAgICAgICAgIHJlc1tqXS5wb2ludC52YWRkKHEsIHJpKTtcclxuLy8gICAgICAgICAgICAgcmouY29weShyZXNbal0ucG9pbnQpO1xyXG5cclxuLy8gICAgICAgICAgICAgLy8gQ29udGFjdCBwb2ludHMgYXJlIGluIHdvcmxkIGNvb3JkaW5hdGVzLiBUcmFuc2Zvcm0gYmFjayB0byByZWxhdGl2ZVxyXG4vLyAgICAgICAgICAgICByaS52c3ViKHhpLHJpKTtcclxuLy8gICAgICAgICAgICAgcmoudnN1Yih4aixyaik7XHJcblxyXG4vLyAgICAgICAgICAgICAvLyBNYWtlIHJlbGF0aXZlIHRvIGJvZGllc1xyXG4vLyAgICAgICAgICAgICByaS52YWRkKHhpLCByaSk7XHJcbi8vICAgICAgICAgICAgIHJpLnZzdWIoYmkucG9zaXRpb24sIHJpKTtcclxuLy8gICAgICAgICAgICAgcmoudmFkZCh4aiwgcmopO1xyXG4vLyAgICAgICAgICAgICByai52c3ViKGJqLnBvc2l0aW9uLCByaik7XHJcblxyXG4vLyAgICAgICAgICAgICByZXN1bHQucHVzaChyKTtcclxuLy8gICAgICAgICB9XHJcbi8vICAgICB9XHJcbi8vIH07XHJcblxyXG52YXIgcGFydGljbGVQbGFuZV9ub3JtYWwgPSBuZXcgVmVjMygpO1xyXG52YXIgcGFydGljbGVQbGFuZV9yZWxwb3MgPSBuZXcgVmVjMygpO1xyXG52YXIgcGFydGljbGVQbGFuZV9wcm9qZWN0ZWQgPSBuZXcgVmVjMygpO1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgcGFydGljbGVQbGFuZVxyXG4gKiBAcGFyYW0gIHtBcnJheX0gICAgICByZXN1bHRcclxuICogQHBhcmFtICB7U2hhcGV9ICAgICAgc2lcclxuICogQHBhcmFtICB7U2hhcGV9ICAgICAgc2pcclxuICogQHBhcmFtICB7VmVjM30gICAgICAgeGlcclxuICogQHBhcmFtICB7VmVjM30gICAgICAgeGpcclxuICogQHBhcmFtICB7UXVhdGVybmlvbn0gcWlcclxuICogQHBhcmFtICB7UXVhdGVybmlvbn0gcWpcclxuICogQHBhcmFtICB7Qm9keX0gICAgICAgYmlcclxuICogQHBhcmFtICB7Qm9keX0gICAgICAgYmpcclxuICovXHJcbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS50eXBlcy5QTEFORSB8IFNoYXBlLnR5cGVzLlBBUlRJQ0xFXSA9XHJcbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5wbGFuZVBhcnRpY2xlID0gZnVuY3Rpb24oc2osc2kseGoseGkscWoscWksYmosYmkscnNpLHJzaixqdXN0VGVzdCl7XHJcbiAgICB2YXIgbm9ybWFsID0gcGFydGljbGVQbGFuZV9ub3JtYWw7XHJcbiAgICBub3JtYWwuc2V0KDAsMCwxKTtcclxuICAgIGJqLnF1YXRlcm5pb24udm11bHQobm9ybWFsLG5vcm1hbCk7IC8vIFR1cm4gbm9ybWFsIGFjY29yZGluZyB0byBwbGFuZSBvcmllbnRhdGlvblxyXG4gICAgdmFyIHJlbHBvcyA9IHBhcnRpY2xlUGxhbmVfcmVscG9zO1xyXG4gICAgeGkudnN1Yihiai5wb3NpdGlvbixyZWxwb3MpO1xyXG4gICAgdmFyIGRvdCA9IG5vcm1hbC5kb3QocmVscG9zKTtcclxuICAgIGlmKGRvdCA8PSAwLjApe1xyXG5cclxuICAgICAgICBpZihqdXN0VGVzdCl7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHIgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihiaSxiaixzaSxzaixyc2kscnNqKTtcclxuICAgICAgICByLm5pLmNvcHkobm9ybWFsKTsgLy8gQ29udGFjdCBub3JtYWwgaXMgdGhlIHBsYW5lIG5vcm1hbFxyXG4gICAgICAgIHIubmkubmVnYXRlKHIubmkpO1xyXG4gICAgICAgIHIucmkuc2V0KDAsMCwwKTsgLy8gQ2VudGVyIG9mIHBhcnRpY2xlXHJcblxyXG4gICAgICAgIC8vIEdldCBwYXJ0aWNsZSBwb3NpdGlvbiBwcm9qZWN0ZWQgb24gcGxhbmVcclxuICAgICAgICB2YXIgcHJvamVjdGVkID0gcGFydGljbGVQbGFuZV9wcm9qZWN0ZWQ7XHJcbiAgICAgICAgbm9ybWFsLm11bHQobm9ybWFsLmRvdCh4aSkscHJvamVjdGVkKTtcclxuICAgICAgICB4aS52c3ViKHByb2plY3RlZCxwcm9qZWN0ZWQpO1xyXG4gICAgICAgIC8vcHJvamVjdGVkLnZhZGQoYmoucG9zaXRpb24scHJvamVjdGVkKTtcclxuXHJcbiAgICAgICAgLy8gcmogaXMgbm93IHRoZSBwcm9qZWN0ZWQgd29ybGQgcG9zaXRpb24gbWludXMgcGxhbmUgcG9zaXRpb25cclxuICAgICAgICByLnJqLmNvcHkocHJvamVjdGVkKTtcclxuICAgICAgICB0aGlzLnJlc3VsdC5wdXNoKHIpO1xyXG4gICAgICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChyLCB0aGlzLmZyaWN0aW9uUmVzdWx0KTtcclxuICAgIH1cclxufTtcclxuXHJcbnZhciBwYXJ0aWNsZVNwaGVyZV9ub3JtYWwgPSBuZXcgVmVjMygpO1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgcGFydGljbGVTcGhlcmVcclxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgcmVzdWx0XHJcbiAqIEBwYXJhbSAge1NoYXBlfSAgICAgIHNpXHJcbiAqIEBwYXJhbSAge1NoYXBlfSAgICAgIHNqXHJcbiAqIEBwYXJhbSAge1ZlYzN9ICAgICAgIHhpXHJcbiAqIEBwYXJhbSAge1ZlYzN9ICAgICAgIHhqXHJcbiAqIEBwYXJhbSAge1F1YXRlcm5pb259IHFpXHJcbiAqIEBwYXJhbSAge1F1YXRlcm5pb259IHFqXHJcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGJpXHJcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGJqXHJcbiAqL1xyXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUudHlwZXMuUEFSVElDTEUgfCBTaGFwZS50eXBlcy5TUEhFUkVdID1cclxuTmFycm93cGhhc2UucHJvdG90eXBlLnNwaGVyZVBhcnRpY2xlID0gZnVuY3Rpb24oc2osc2kseGoseGkscWoscWksYmosYmkscnNpLHJzaixqdXN0VGVzdCl7XHJcbiAgICAvLyBUaGUgbm9ybWFsIGlzIHRoZSB1bml0IHZlY3RvciBmcm9tIHNwaGVyZSBjZW50ZXIgdG8gcGFydGljbGUgY2VudGVyXHJcbiAgICB2YXIgbm9ybWFsID0gcGFydGljbGVTcGhlcmVfbm9ybWFsO1xyXG4gICAgbm9ybWFsLnNldCgwLDAsMSk7XHJcbiAgICB4aS52c3ViKHhqLG5vcm1hbCk7XHJcbiAgICB2YXIgbGVuZ3RoU3F1YXJlZCA9IG5vcm1hbC5ub3JtMigpO1xyXG5cclxuICAgIGlmKGxlbmd0aFNxdWFyZWQgPD0gc2oucmFkaXVzICogc2oucmFkaXVzKXtcclxuICAgICAgICBpZihqdXN0VGVzdCl7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgciA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGJpLGJqLHNpLHNqLHJzaSxyc2opO1xyXG4gICAgICAgIG5vcm1hbC5ub3JtYWxpemUoKTtcclxuICAgICAgICByLnJqLmNvcHkobm9ybWFsKTtcclxuICAgICAgICByLnJqLm11bHQoc2oucmFkaXVzLHIucmopO1xyXG4gICAgICAgIHIubmkuY29weShub3JtYWwpOyAvLyBDb250YWN0IG5vcm1hbFxyXG4gICAgICAgIHIubmkubmVnYXRlKHIubmkpO1xyXG4gICAgICAgIHIucmkuc2V0KDAsMCwwKTsgLy8gQ2VudGVyIG9mIHBhcnRpY2xlXHJcbiAgICAgICAgdGhpcy5yZXN1bHQucHVzaChyKTtcclxuICAgICAgICB0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3QociwgdGhpcy5mcmljdGlvblJlc3VsdCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vLyBXSVBcclxudmFyIGNxaiA9IG5ldyBRdWF0ZXJuaW9uKCk7XHJcbnZhciBjb252ZXhQYXJ0aWNsZV9sb2NhbCA9IG5ldyBWZWMzKCk7XHJcbnZhciBjb252ZXhQYXJ0aWNsZV9ub3JtYWwgPSBuZXcgVmVjMygpO1xyXG52YXIgY29udmV4UGFydGljbGVfcGVuZXRyYXRlZEZhY2VOb3JtYWwgPSBuZXcgVmVjMygpO1xyXG52YXIgY29udmV4UGFydGljbGVfdmVydGV4VG9QYXJ0aWNsZSA9IG5ldyBWZWMzKCk7XHJcbnZhciBjb252ZXhQYXJ0aWNsZV93b3JsZFBlbmV0cmF0aW9uVmVjID0gbmV3IFZlYzMoKTtcclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kIGNvbnZleFBhcnRpY2xlXHJcbiAqIEBwYXJhbSAge0FycmF5fSAgICAgIHJlc3VsdFxyXG4gKiBAcGFyYW0gIHtTaGFwZX0gICAgICBzaVxyXG4gKiBAcGFyYW0gIHtTaGFwZX0gICAgICBzalxyXG4gKiBAcGFyYW0gIHtWZWMzfSAgICAgICB4aVxyXG4gKiBAcGFyYW0gIHtWZWMzfSAgICAgICB4alxyXG4gKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSBxaVxyXG4gKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSBxalxyXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBiaVxyXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBialxyXG4gKi9cclxuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLnR5cGVzLlBBUlRJQ0xFIHwgU2hhcGUudHlwZXMuQ09OVkVYUE9MWUhFRFJPTl0gPVxyXG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuY29udmV4UGFydGljbGUgPSBmdW5jdGlvbihzaixzaSx4aix4aSxxaixxaSxiaixiaSxyc2kscnNqLGp1c3RUZXN0KXtcclxuICAgIHZhciBwZW5ldHJhdGVkRmFjZUluZGV4ID0gLTE7XHJcbiAgICB2YXIgcGVuZXRyYXRlZEZhY2VOb3JtYWwgPSBjb252ZXhQYXJ0aWNsZV9wZW5ldHJhdGVkRmFjZU5vcm1hbDtcclxuICAgIHZhciB3b3JsZFBlbmV0cmF0aW9uVmVjID0gY29udmV4UGFydGljbGVfd29ybGRQZW5ldHJhdGlvblZlYztcclxuICAgIHZhciBtaW5QZW5ldHJhdGlvbiA9IG51bGw7XHJcbiAgICB2YXIgbnVtRGV0ZWN0ZWRGYWNlcyA9IDA7XHJcblxyXG4gICAgLy8gQ29udmVydCBwYXJ0aWNsZSBwb3NpdGlvbiB4aSB0byBsb2NhbCBjb29yZHMgaW4gdGhlIGNvbnZleFxyXG4gICAgdmFyIGxvY2FsID0gY29udmV4UGFydGljbGVfbG9jYWw7XHJcbiAgICBsb2NhbC5jb3B5KHhpKTtcclxuICAgIGxvY2FsLnZzdWIoeGosbG9jYWwpOyAvLyBDb252ZXJ0IHBvc2l0aW9uIHRvIHJlbGF0aXZlIHRoZSBjb252ZXggb3JpZ2luXHJcbiAgICBxai5jb25qdWdhdGUoY3FqKTtcclxuICAgIGNxai52bXVsdChsb2NhbCxsb2NhbCk7XHJcblxyXG4gICAgaWYoc2oucG9pbnRJc0luc2lkZShsb2NhbCkpe1xyXG5cclxuICAgICAgICBpZihzai53b3JsZFZlcnRpY2VzTmVlZHNVcGRhdGUpe1xyXG4gICAgICAgICAgICBzai5jb21wdXRlV29ybGRWZXJ0aWNlcyh4aixxaik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKHNqLndvcmxkRmFjZU5vcm1hbHNOZWVkc1VwZGF0ZSl7XHJcbiAgICAgICAgICAgIHNqLmNvbXB1dGVXb3JsZEZhY2VOb3JtYWxzKHFqKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEZvciBlYWNoIHdvcmxkIHBvbHlnb24gaW4gdGhlIHBvbHloZWRyYVxyXG4gICAgICAgIGZvcih2YXIgaT0wLG5mYWNlcz1zai5mYWNlcy5sZW5ndGg7IGkhPT1uZmFjZXM7IGkrKyl7XHJcblxyXG4gICAgICAgICAgICAvLyBDb25zdHJ1Y3Qgd29ybGQgZmFjZSB2ZXJ0aWNlc1xyXG4gICAgICAgICAgICB2YXIgdmVydHMgPSBbIHNqLndvcmxkVmVydGljZXNbIHNqLmZhY2VzW2ldWzBdIF0gXTtcclxuICAgICAgICAgICAgdmFyIG5vcm1hbCA9IHNqLndvcmxkRmFjZU5vcm1hbHNbaV07XHJcblxyXG4gICAgICAgICAgICAvLyBDaGVjayBob3cgbXVjaCB0aGUgcGFydGljbGUgcGVuZXRyYXRlcyB0aGUgcG9seWdvbiBwbGFuZS5cclxuICAgICAgICAgICAgeGkudnN1Yih2ZXJ0c1swXSxjb252ZXhQYXJ0aWNsZV92ZXJ0ZXhUb1BhcnRpY2xlKTtcclxuICAgICAgICAgICAgdmFyIHBlbmV0cmF0aW9uID0gLW5vcm1hbC5kb3QoY29udmV4UGFydGljbGVfdmVydGV4VG9QYXJ0aWNsZSk7XHJcbiAgICAgICAgICAgIGlmKG1pblBlbmV0cmF0aW9uPT09bnVsbCB8fCBNYXRoLmFicyhwZW5ldHJhdGlvbik8TWF0aC5hYnMobWluUGVuZXRyYXRpb24pKXtcclxuXHJcbiAgICAgICAgICAgICAgICBpZihqdXN0VGVzdCl7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgbWluUGVuZXRyYXRpb24gPSBwZW5ldHJhdGlvbjtcclxuICAgICAgICAgICAgICAgIHBlbmV0cmF0ZWRGYWNlSW5kZXggPSBpO1xyXG4gICAgICAgICAgICAgICAgcGVuZXRyYXRlZEZhY2VOb3JtYWwuY29weShub3JtYWwpO1xyXG4gICAgICAgICAgICAgICAgbnVtRGV0ZWN0ZWRGYWNlcysrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZihwZW5ldHJhdGVkRmFjZUluZGV4IT09LTEpe1xyXG4gICAgICAgICAgICAvLyBTZXR1cCBjb250YWN0XHJcbiAgICAgICAgICAgIHZhciByID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oYmksYmosc2ksc2oscnNpLHJzaik7XHJcbiAgICAgICAgICAgIHBlbmV0cmF0ZWRGYWNlTm9ybWFsLm11bHQobWluUGVuZXRyYXRpb24sIHdvcmxkUGVuZXRyYXRpb25WZWMpO1xyXG5cclxuICAgICAgICAgICAgLy8gcmogaXMgdGhlIHBhcnRpY2xlIHBvc2l0aW9uIHByb2plY3RlZCB0byB0aGUgZmFjZVxyXG4gICAgICAgICAgICB3b3JsZFBlbmV0cmF0aW9uVmVjLnZhZGQoeGksd29ybGRQZW5ldHJhdGlvblZlYyk7XHJcbiAgICAgICAgICAgIHdvcmxkUGVuZXRyYXRpb25WZWMudnN1Yih4aix3b3JsZFBlbmV0cmF0aW9uVmVjKTtcclxuICAgICAgICAgICAgci5yai5jb3B5KHdvcmxkUGVuZXRyYXRpb25WZWMpO1xyXG4gICAgICAgICAgICAvL3ZhciBwcm9qZWN0ZWRUb0ZhY2UgPSB4aS52c3ViKHhqKS52YWRkKHdvcmxkUGVuZXRyYXRpb25WZWMpO1xyXG4gICAgICAgICAgICAvL3Byb2plY3RlZFRvRmFjZS5jb3B5KHIucmopO1xyXG5cclxuICAgICAgICAgICAgLy9xai52bXVsdChyLnJqLHIucmopO1xyXG4gICAgICAgICAgICBwZW5ldHJhdGVkRmFjZU5vcm1hbC5uZWdhdGUoIHIubmkgKTsgLy8gQ29udGFjdCBub3JtYWxcclxuICAgICAgICAgICAgci5yaS5zZXQoMCwwLDApOyAvLyBDZW50ZXIgb2YgcGFydGljbGVcclxuXHJcbiAgICAgICAgICAgIHZhciByaSA9IHIucmksXHJcbiAgICAgICAgICAgICAgICByaiA9IHIucmo7XHJcblxyXG4gICAgICAgICAgICAvLyBNYWtlIHJlbGF0aXZlIHRvIGJvZGllc1xyXG4gICAgICAgICAgICByaS52YWRkKHhpLCByaSk7XHJcbiAgICAgICAgICAgIHJpLnZzdWIoYmkucG9zaXRpb24sIHJpKTtcclxuICAgICAgICAgICAgcmoudmFkZCh4aiwgcmopO1xyXG4gICAgICAgICAgICByai52c3ViKGJqLnBvc2l0aW9uLCByaik7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnJlc3VsdC5wdXNoKHIpO1xyXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3QociwgdGhpcy5mcmljdGlvblJlc3VsdCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiUG9pbnQgZm91bmQgaW5zaWRlIGNvbnZleCwgYnV0IGRpZCBub3QgZmluZCBwZW5ldHJhdGluZyBmYWNlIVwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUudHlwZXMuQk9YIHwgU2hhcGUudHlwZXMuSEVJR0hURklFTERdID1cclxuTmFycm93cGhhc2UucHJvdG90eXBlLmJveEhlaWdodGZpZWxkID0gZnVuY3Rpb24gKHNpLHNqLHhpLHhqLHFpLHFqLGJpLGJqLHJzaSxyc2osanVzdFRlc3Qpe1xyXG4gICAgc2kuY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLm1hdGVyaWFsID0gc2kubWF0ZXJpYWw7XHJcbiAgICBzaS5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24uY29sbGlzaW9uUmVzcG9uc2UgPSBzaS5jb2xsaXNpb25SZXNwb25zZTtcclxuICAgIHJldHVybiB0aGlzLmNvbnZleEhlaWdodGZpZWxkKHNpLmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbixzaix4aSx4aixxaSxxaixiaSxiaixzaSxzaixqdXN0VGVzdCk7XHJcbn07XHJcblxyXG52YXIgY29udmV4SGVpZ2h0ZmllbGRfdG1wMSA9IG5ldyBWZWMzKCk7XHJcbnZhciBjb252ZXhIZWlnaHRmaWVsZF90bXAyID0gbmV3IFZlYzMoKTtcclxudmFyIGNvbnZleEhlaWdodGZpZWxkX2ZhY2VMaXN0ID0gWzBdO1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgY29udmV4SGVpZ2h0ZmllbGRcclxuICovXHJcbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS50eXBlcy5DT05WRVhQT0xZSEVEUk9OIHwgU2hhcGUudHlwZXMuSEVJR0hURklFTERdID1cclxuTmFycm93cGhhc2UucHJvdG90eXBlLmNvbnZleEhlaWdodGZpZWxkID0gZnVuY3Rpb24gKFxyXG4gICAgY29udmV4U2hhcGUsXHJcbiAgICBoZlNoYXBlLFxyXG4gICAgY29udmV4UG9zLFxyXG4gICAgaGZQb3MsXHJcbiAgICBjb252ZXhRdWF0LFxyXG4gICAgaGZRdWF0LFxyXG4gICAgY29udmV4Qm9keSxcclxuICAgIGhmQm9keSxcclxuICAgIHJzaSxcclxuICAgIHJzaixcclxuICAgIGp1c3RUZXN0XHJcbil7XHJcbiAgICB2YXIgZGF0YSA9IGhmU2hhcGUuZGF0YSxcclxuICAgICAgICB3ID0gaGZTaGFwZS5lbGVtZW50U2l6ZSxcclxuICAgICAgICByYWRpdXMgPSBjb252ZXhTaGFwZS5ib3VuZGluZ1NwaGVyZVJhZGl1cyxcclxuICAgICAgICB3b3JsZFBpbGxhck9mZnNldCA9IGNvbnZleEhlaWdodGZpZWxkX3RtcDIsXHJcbiAgICAgICAgZmFjZUxpc3QgPSBjb252ZXhIZWlnaHRmaWVsZF9mYWNlTGlzdDtcclxuXHJcbiAgICAvLyBHZXQgc3BoZXJlIHBvc2l0aW9uIHRvIGhlaWdodGZpZWxkIGxvY2FsIVxyXG4gICAgdmFyIGxvY2FsQ29udmV4UG9zID0gY29udmV4SGVpZ2h0ZmllbGRfdG1wMTtcclxuICAgIFRyYW5zZm9ybS5wb2ludFRvTG9jYWxGcmFtZShoZlBvcywgaGZRdWF0LCBjb252ZXhQb3MsIGxvY2FsQ29udmV4UG9zKTtcclxuXHJcbiAgICAvLyBHZXQgdGhlIGluZGV4IG9mIHRoZSBkYXRhIHBvaW50cyB0byB0ZXN0IGFnYWluc3RcclxuICAgIHZhciBpTWluWCA9IE1hdGguZmxvb3IoKGxvY2FsQ29udmV4UG9zLnggLSByYWRpdXMpIC8gdykgLSAxLFxyXG4gICAgICAgIGlNYXhYID0gTWF0aC5jZWlsKChsb2NhbENvbnZleFBvcy54ICsgcmFkaXVzKSAvIHcpICsgMSxcclxuICAgICAgICBpTWluWSA9IE1hdGguZmxvb3IoKGxvY2FsQ29udmV4UG9zLnkgLSByYWRpdXMpIC8gdykgLSAxLFxyXG4gICAgICAgIGlNYXhZID0gTWF0aC5jZWlsKChsb2NhbENvbnZleFBvcy55ICsgcmFkaXVzKSAvIHcpICsgMTtcclxuXHJcbiAgICAvLyBCYWlsIG91dCBpZiB3ZSBhcmUgb3V0IG9mIHRoZSB0ZXJyYWluXHJcbiAgICBpZihpTWF4WCA8IDAgfHwgaU1heFkgPCAwIHx8IGlNaW5YID4gZGF0YS5sZW5ndGggfHwgaU1pblkgPiBkYXRhWzBdLmxlbmd0aCl7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENsYW1wIGluZGV4IHRvIGVkZ2VzXHJcbiAgICBpZihpTWluWCA8IDApeyBpTWluWCA9IDA7IH1cclxuICAgIGlmKGlNYXhYIDwgMCl7IGlNYXhYID0gMDsgfVxyXG4gICAgaWYoaU1pblkgPCAwKXsgaU1pblkgPSAwOyB9XHJcbiAgICBpZihpTWF4WSA8IDApeyBpTWF4WSA9IDA7IH1cclxuICAgIGlmKGlNaW5YID49IGRhdGEubGVuZ3RoKXsgaU1pblggPSBkYXRhLmxlbmd0aCAtIDE7IH1cclxuICAgIGlmKGlNYXhYID49IGRhdGEubGVuZ3RoKXsgaU1heFggPSBkYXRhLmxlbmd0aCAtIDE7IH1cclxuICAgIGlmKGlNYXhZID49IGRhdGFbMF0ubGVuZ3RoKXsgaU1heFkgPSBkYXRhWzBdLmxlbmd0aCAtIDE7IH1cclxuICAgIGlmKGlNaW5ZID49IGRhdGFbMF0ubGVuZ3RoKXsgaU1pblkgPSBkYXRhWzBdLmxlbmd0aCAtIDE7IH1cclxuXHJcbiAgICB2YXIgbWluTWF4ID0gW107XHJcbiAgICBoZlNoYXBlLmdldFJlY3RNaW5NYXgoaU1pblgsIGlNaW5ZLCBpTWF4WCwgaU1heFksIG1pbk1heCk7XHJcbiAgICB2YXIgbWluID0gbWluTWF4WzBdO1xyXG4gICAgdmFyIG1heCA9IG1pbk1heFsxXTtcclxuXHJcbiAgICAvLyBCYWlsIG91dCBpZiB3ZSdyZSBjYW50IHRvdWNoIHRoZSBib3VuZGluZyBoZWlnaHQgYm94XHJcbiAgICBpZihsb2NhbENvbnZleFBvcy56IC0gcmFkaXVzID4gbWF4IHx8IGxvY2FsQ29udmV4UG9zLnogKyByYWRpdXMgPCBtaW4pe1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBmb3IodmFyIGkgPSBpTWluWDsgaSA8IGlNYXhYOyBpKyspe1xyXG4gICAgICAgIGZvcih2YXIgaiA9IGlNaW5ZOyBqIDwgaU1heFk7IGorKyl7XHJcblxyXG4gICAgICAgICAgICB2YXIgaW50ZXJzZWN0aW5nID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICAvLyBMb3dlciB0cmlhbmdsZVxyXG4gICAgICAgICAgICBoZlNoYXBlLmdldENvbnZleFRyaWFuZ2xlUGlsbGFyKGksIGosIGZhbHNlKTtcclxuICAgICAgICAgICAgVHJhbnNmb3JtLnBvaW50VG9Xb3JsZEZyYW1lKGhmUG9zLCBoZlF1YXQsIGhmU2hhcGUucGlsbGFyT2Zmc2V0LCB3b3JsZFBpbGxhck9mZnNldCk7XHJcbiAgICAgICAgICAgIGlmIChjb252ZXhQb3MuZGlzdGFuY2VUbyh3b3JsZFBpbGxhck9mZnNldCkgPCBoZlNoYXBlLnBpbGxhckNvbnZleC5ib3VuZGluZ1NwaGVyZVJhZGl1cyArIGNvbnZleFNoYXBlLmJvdW5kaW5nU3BoZXJlUmFkaXVzKSB7XHJcbiAgICAgICAgICAgICAgICBpbnRlcnNlY3RpbmcgPSB0aGlzLmNvbnZleENvbnZleChjb252ZXhTaGFwZSwgaGZTaGFwZS5waWxsYXJDb252ZXgsIGNvbnZleFBvcywgd29ybGRQaWxsYXJPZmZzZXQsIGNvbnZleFF1YXQsIGhmUXVhdCwgY29udmV4Qm9keSwgaGZCb2R5LCBudWxsLCBudWxsLCBqdXN0VGVzdCwgZmFjZUxpc3QsIG51bGwpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihqdXN0VGVzdCAmJiBpbnRlcnNlY3Rpbmcpe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFVwcGVyIHRyaWFuZ2xlXHJcbiAgICAgICAgICAgIGhmU2hhcGUuZ2V0Q29udmV4VHJpYW5nbGVQaWxsYXIoaSwgaiwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIFRyYW5zZm9ybS5wb2ludFRvV29ybGRGcmFtZShoZlBvcywgaGZRdWF0LCBoZlNoYXBlLnBpbGxhck9mZnNldCwgd29ybGRQaWxsYXJPZmZzZXQpO1xyXG4gICAgICAgICAgICBpZiAoY29udmV4UG9zLmRpc3RhbmNlVG8od29ybGRQaWxsYXJPZmZzZXQpIDwgaGZTaGFwZS5waWxsYXJDb252ZXguYm91bmRpbmdTcGhlcmVSYWRpdXMgKyBjb252ZXhTaGFwZS5ib3VuZGluZ1NwaGVyZVJhZGl1cykge1xyXG4gICAgICAgICAgICAgICAgaW50ZXJzZWN0aW5nID0gdGhpcy5jb252ZXhDb252ZXgoY29udmV4U2hhcGUsIGhmU2hhcGUucGlsbGFyQ29udmV4LCBjb252ZXhQb3MsIHdvcmxkUGlsbGFyT2Zmc2V0LCBjb252ZXhRdWF0LCBoZlF1YXQsIGNvbnZleEJvZHksIGhmQm9keSwgbnVsbCwgbnVsbCwganVzdFRlc3QsIGZhY2VMaXN0LCBudWxsKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYoanVzdFRlc3QgJiYgaW50ZXJzZWN0aW5nKXtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxudmFyIHNwaGVyZUhlaWdodGZpZWxkX3RtcDEgPSBuZXcgVmVjMygpO1xyXG52YXIgc3BoZXJlSGVpZ2h0ZmllbGRfdG1wMiA9IG5ldyBWZWMzKCk7XHJcblxyXG4vKipcclxuICogQG1ldGhvZCBzcGhlcmVIZWlnaHRmaWVsZFxyXG4gKi9cclxuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLnR5cGVzLlNQSEVSRSB8IFNoYXBlLnR5cGVzLkhFSUdIVEZJRUxEXSA9XHJcbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5zcGhlcmVIZWlnaHRmaWVsZCA9IGZ1bmN0aW9uIChcclxuICAgIHNwaGVyZVNoYXBlLFxyXG4gICAgaGZTaGFwZSxcclxuICAgIHNwaGVyZVBvcyxcclxuICAgIGhmUG9zLFxyXG4gICAgc3BoZXJlUXVhdCxcclxuICAgIGhmUXVhdCxcclxuICAgIHNwaGVyZUJvZHksXHJcbiAgICBoZkJvZHksXHJcbiAgICByc2ksXHJcbiAgICByc2osXHJcbiAgICBqdXN0VGVzdFxyXG4pe1xyXG4gICAgdmFyIGRhdGEgPSBoZlNoYXBlLmRhdGEsXHJcbiAgICAgICAgcmFkaXVzID0gc3BoZXJlU2hhcGUucmFkaXVzLFxyXG4gICAgICAgIHcgPSBoZlNoYXBlLmVsZW1lbnRTaXplLFxyXG4gICAgICAgIHdvcmxkUGlsbGFyT2Zmc2V0ID0gc3BoZXJlSGVpZ2h0ZmllbGRfdG1wMjtcclxuXHJcbiAgICAvLyBHZXQgc3BoZXJlIHBvc2l0aW9uIHRvIGhlaWdodGZpZWxkIGxvY2FsIVxyXG4gICAgdmFyIGxvY2FsU3BoZXJlUG9zID0gc3BoZXJlSGVpZ2h0ZmllbGRfdG1wMTtcclxuICAgIFRyYW5zZm9ybS5wb2ludFRvTG9jYWxGcmFtZShoZlBvcywgaGZRdWF0LCBzcGhlcmVQb3MsIGxvY2FsU3BoZXJlUG9zKTtcclxuXHJcbiAgICAvLyBHZXQgdGhlIGluZGV4IG9mIHRoZSBkYXRhIHBvaW50cyB0byB0ZXN0IGFnYWluc3RcclxuICAgIHZhciBpTWluWCA9IE1hdGguZmxvb3IoKGxvY2FsU3BoZXJlUG9zLnggLSByYWRpdXMpIC8gdykgLSAxLFxyXG4gICAgICAgIGlNYXhYID0gTWF0aC5jZWlsKChsb2NhbFNwaGVyZVBvcy54ICsgcmFkaXVzKSAvIHcpICsgMSxcclxuICAgICAgICBpTWluWSA9IE1hdGguZmxvb3IoKGxvY2FsU3BoZXJlUG9zLnkgLSByYWRpdXMpIC8gdykgLSAxLFxyXG4gICAgICAgIGlNYXhZID0gTWF0aC5jZWlsKChsb2NhbFNwaGVyZVBvcy55ICsgcmFkaXVzKSAvIHcpICsgMTtcclxuXHJcbiAgICAvLyBCYWlsIG91dCBpZiB3ZSBhcmUgb3V0IG9mIHRoZSB0ZXJyYWluXHJcbiAgICBpZihpTWF4WCA8IDAgfHwgaU1heFkgPCAwIHx8IGlNaW5YID4gZGF0YS5sZW5ndGggfHwgaU1pblkgPiBkYXRhWzBdLmxlbmd0aCl7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENsYW1wIGluZGV4IHRvIGVkZ2VzXHJcbiAgICBpZihpTWluWCA8IDApeyBpTWluWCA9IDA7IH1cclxuICAgIGlmKGlNYXhYIDwgMCl7IGlNYXhYID0gMDsgfVxyXG4gICAgaWYoaU1pblkgPCAwKXsgaU1pblkgPSAwOyB9XHJcbiAgICBpZihpTWF4WSA8IDApeyBpTWF4WSA9IDA7IH1cclxuICAgIGlmKGlNaW5YID49IGRhdGEubGVuZ3RoKXsgaU1pblggPSBkYXRhLmxlbmd0aCAtIDE7IH1cclxuICAgIGlmKGlNYXhYID49IGRhdGEubGVuZ3RoKXsgaU1heFggPSBkYXRhLmxlbmd0aCAtIDE7IH1cclxuICAgIGlmKGlNYXhZID49IGRhdGFbMF0ubGVuZ3RoKXsgaU1heFkgPSBkYXRhWzBdLmxlbmd0aCAtIDE7IH1cclxuICAgIGlmKGlNaW5ZID49IGRhdGFbMF0ubGVuZ3RoKXsgaU1pblkgPSBkYXRhWzBdLmxlbmd0aCAtIDE7IH1cclxuXHJcbiAgICB2YXIgbWluTWF4ID0gW107XHJcbiAgICBoZlNoYXBlLmdldFJlY3RNaW5NYXgoaU1pblgsIGlNaW5ZLCBpTWF4WCwgaU1heFksIG1pbk1heCk7XHJcbiAgICB2YXIgbWluID0gbWluTWF4WzBdO1xyXG4gICAgdmFyIG1heCA9IG1pbk1heFsxXTtcclxuXHJcbiAgICAvLyBCYWlsIG91dCBpZiB3ZSdyZSBjYW50IHRvdWNoIHRoZSBib3VuZGluZyBoZWlnaHQgYm94XHJcbiAgICBpZihsb2NhbFNwaGVyZVBvcy56IC0gcmFkaXVzID4gbWF4IHx8IGxvY2FsU3BoZXJlUG9zLnogKyByYWRpdXMgPCBtaW4pe1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5yZXN1bHQ7XHJcbiAgICBmb3IodmFyIGkgPSBpTWluWDsgaSA8IGlNYXhYOyBpKyspe1xyXG4gICAgICAgIGZvcih2YXIgaiA9IGlNaW5ZOyBqIDwgaU1heFk7IGorKyl7XHJcblxyXG4gICAgICAgICAgICB2YXIgbnVtQ29udGFjdHNCZWZvcmUgPSByZXN1bHQubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgdmFyIGludGVyc2VjdGluZyA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgLy8gTG93ZXIgdHJpYW5nbGVcclxuICAgICAgICAgICAgaGZTaGFwZS5nZXRDb252ZXhUcmlhbmdsZVBpbGxhcihpLCBqLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIFRyYW5zZm9ybS5wb2ludFRvV29ybGRGcmFtZShoZlBvcywgaGZRdWF0LCBoZlNoYXBlLnBpbGxhck9mZnNldCwgd29ybGRQaWxsYXJPZmZzZXQpO1xyXG4gICAgICAgICAgICBpZiAoc3BoZXJlUG9zLmRpc3RhbmNlVG8od29ybGRQaWxsYXJPZmZzZXQpIDwgaGZTaGFwZS5waWxsYXJDb252ZXguYm91bmRpbmdTcGhlcmVSYWRpdXMgKyBzcGhlcmVTaGFwZS5ib3VuZGluZ1NwaGVyZVJhZGl1cykge1xyXG4gICAgICAgICAgICAgICAgaW50ZXJzZWN0aW5nID0gdGhpcy5zcGhlcmVDb252ZXgoc3BoZXJlU2hhcGUsIGhmU2hhcGUucGlsbGFyQ29udmV4LCBzcGhlcmVQb3MsIHdvcmxkUGlsbGFyT2Zmc2V0LCBzcGhlcmVRdWF0LCBoZlF1YXQsIHNwaGVyZUJvZHksIGhmQm9keSwgc3BoZXJlU2hhcGUsIGhmU2hhcGUsIGp1c3RUZXN0KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYoanVzdFRlc3QgJiYgaW50ZXJzZWN0aW5nKXtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBVcHBlciB0cmlhbmdsZVxyXG4gICAgICAgICAgICBoZlNoYXBlLmdldENvbnZleFRyaWFuZ2xlUGlsbGFyKGksIGosIHRydWUpO1xyXG4gICAgICAgICAgICBUcmFuc2Zvcm0ucG9pbnRUb1dvcmxkRnJhbWUoaGZQb3MsIGhmUXVhdCwgaGZTaGFwZS5waWxsYXJPZmZzZXQsIHdvcmxkUGlsbGFyT2Zmc2V0KTtcclxuICAgICAgICAgICAgaWYgKHNwaGVyZVBvcy5kaXN0YW5jZVRvKHdvcmxkUGlsbGFyT2Zmc2V0KSA8IGhmU2hhcGUucGlsbGFyQ29udmV4LmJvdW5kaW5nU3BoZXJlUmFkaXVzICsgc3BoZXJlU2hhcGUuYm91bmRpbmdTcGhlcmVSYWRpdXMpIHtcclxuICAgICAgICAgICAgICAgIGludGVyc2VjdGluZyA9IHRoaXMuc3BoZXJlQ29udmV4KHNwaGVyZVNoYXBlLCBoZlNoYXBlLnBpbGxhckNvbnZleCwgc3BoZXJlUG9zLCB3b3JsZFBpbGxhck9mZnNldCwgc3BoZXJlUXVhdCwgaGZRdWF0LCBzcGhlcmVCb2R5LCBoZkJvZHksIHNwaGVyZVNoYXBlLCBoZlNoYXBlLCBqdXN0VGVzdCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKGp1c3RUZXN0ICYmIGludGVyc2VjdGluZyl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIG51bUNvbnRhY3RzID0gcmVzdWx0Lmxlbmd0aCAtIG51bUNvbnRhY3RzQmVmb3JlO1xyXG5cclxuICAgICAgICAgICAgaWYobnVtQ29udGFjdHMgPiAyKXtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAvLyBTa2lwIGFsbCBidXQgMVxyXG4gICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IG51bUNvbnRhY3RzIC0gMTsgaysrKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQucG9wKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgKi9cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG59LHtcIi4uL2NvbGxpc2lvbi9BQUJCXCI6MyxcIi4uL2NvbGxpc2lvbi9SYXlcIjoxMCxcIi4uL2VxdWF0aW9ucy9Db250YWN0RXF1YXRpb25cIjoyMCxcIi4uL2VxdWF0aW9ucy9GcmljdGlvbkVxdWF0aW9uXCI6MjIsXCIuLi9tYXRoL1F1YXRlcm5pb25cIjoyOSxcIi4uL21hdGgvVHJhbnNmb3JtXCI6MzAsXCIuLi9tYXRoL1ZlYzNcIjozMSxcIi4uL29iamVjdHMvQm9keVwiOjMyLFwiLi4vc2hhcGVzL0NvbnZleFBvbHloZWRyb25cIjozOSxcIi4uL3NoYXBlcy9TaGFwZVwiOjQ0LFwiLi4vc29sdmVyL1NvbHZlclwiOjQ4LFwiLi4vdXRpbHMvVmVjM1Bvb2xcIjo1NX1dLDU3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcclxuKGZ1bmN0aW9uIChnbG9iYWwpe1xyXG4vKiBnbG9iYWwgcGVyZm9ybWFuY2UgKi9cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gV29ybGQ7XHJcblxyXG52YXIgU2hhcGUgPSBfZGVyZXFfKCcuLi9zaGFwZXMvU2hhcGUnKTtcclxudmFyIFZlYzMgPSBfZGVyZXFfKCcuLi9tYXRoL1ZlYzMnKTtcclxudmFyIFF1YXRlcm5pb24gPSBfZGVyZXFfKCcuLi9tYXRoL1F1YXRlcm5pb24nKTtcclxudmFyIEdTU29sdmVyID0gX2RlcmVxXygnLi4vc29sdmVyL0dTU29sdmVyJyk7XHJcbnZhciBDb250YWN0RXF1YXRpb24gPSBfZGVyZXFfKCcuLi9lcXVhdGlvbnMvQ29udGFjdEVxdWF0aW9uJyk7XHJcbnZhciBGcmljdGlvbkVxdWF0aW9uID0gX2RlcmVxXygnLi4vZXF1YXRpb25zL0ZyaWN0aW9uRXF1YXRpb24nKTtcclxudmFyIE5hcnJvd3BoYXNlID0gX2RlcmVxXygnLi9OYXJyb3dwaGFzZScpO1xyXG52YXIgRXZlbnRUYXJnZXQgPSBfZGVyZXFfKCcuLi91dGlscy9FdmVudFRhcmdldCcpO1xyXG52YXIgQXJyYXlDb2xsaXNpb25NYXRyaXggPSBfZGVyZXFfKCcuLi9jb2xsaXNpb24vQXJyYXlDb2xsaXNpb25NYXRyaXgnKTtcclxudmFyIE9iamVjdENvbGxpc2lvbk1hdHJpeCA9IF9kZXJlcV8oJy4uL2NvbGxpc2lvbi9PYmplY3RDb2xsaXNpb25NYXRyaXgnKTtcclxudmFyIE92ZXJsYXBLZWVwZXIgPSBfZGVyZXFfKCcuLi9jb2xsaXNpb24vT3ZlcmxhcEtlZXBlcicpO1xyXG52YXIgTWF0ZXJpYWwgPSBfZGVyZXFfKCcuLi9tYXRlcmlhbC9NYXRlcmlhbCcpO1xyXG52YXIgQ29udGFjdE1hdGVyaWFsID0gX2RlcmVxXygnLi4vbWF0ZXJpYWwvQ29udGFjdE1hdGVyaWFsJyk7XHJcbnZhciBCb2R5ID0gX2RlcmVxXygnLi4vb2JqZWN0cy9Cb2R5Jyk7XHJcbnZhciBUdXBsZURpY3Rpb25hcnkgPSBfZGVyZXFfKCcuLi91dGlscy9UdXBsZURpY3Rpb25hcnknKTtcclxudmFyIFJheWNhc3RSZXN1bHQgPSBfZGVyZXFfKCcuLi9jb2xsaXNpb24vUmF5Y2FzdFJlc3VsdCcpO1xyXG52YXIgQUFCQiA9IF9kZXJlcV8oJy4uL2NvbGxpc2lvbi9BQUJCJyk7XHJcbnZhciBSYXkgPSBfZGVyZXFfKCcuLi9jb2xsaXNpb24vUmF5Jyk7XHJcbnZhciBOYWl2ZUJyb2FkcGhhc2UgPSBfZGVyZXFfKCcuLi9jb2xsaXNpb24vTmFpdmVCcm9hZHBoYXNlJyk7XHJcblxyXG5pZiAoZ2xvYmFsKSB7XHJcbiAgICBnbG9iYWxbJ2RvUHJvZmlsaW5nJ10gPSBmYWxzZTtcclxuICAgIGdsb2JhbFsnREVCVUcnXSA9IHRydWU7XHJcbn0gZWxzZSBpZiAod2luZG93KSB7XHJcbiAgICB3aW5kb3dbJ2RvUHJvZmlsaW5nJ10gPSBmYWxzZTtcclxuICAgIHdpbmRvd1snREVCVUcnXSA9IHRydWU7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGUgcGh5c2ljcyB3b3JsZFxyXG4gKiBAY2xhc3MgV29ybGRcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBleHRlbmRzIEV2ZW50VGFyZ2V0XHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cclxuICogQHBhcmFtIHtWZWMzfSBbb3B0aW9ucy5ncmF2aXR5XVxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmFsbG93U2xlZXBdXHJcbiAqIEBwYXJhbSB7QnJvYWRwaGFzZX0gW29wdGlvbnMuYnJvYWRwaGFzZV1cclxuICogQHBhcmFtIHtTb2x2ZXJ9IFtvcHRpb25zLnNvbHZlcl1cclxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5xdWF0Tm9ybWFsaXplRmFzdF1cclxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnF1YXROb3JtYWxpemVTa2lwXVxyXG4gKi9cclxuZnVuY3Rpb24gV29ybGQgKG9wdGlvbnMpIHtcclxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgRXZlbnRUYXJnZXQuYXBwbHkodGhpcyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDdXJyZW50bHkgLyBsYXN0IHVzZWQgdGltZXN0ZXAuIElzIHNldCB0byAtMSBpZiBub3QgYXZhaWxhYmxlLiBUaGlzIHZhbHVlIGlzIHVwZGF0ZWQgYmVmb3JlIGVhY2ggaW50ZXJuYWwgc3RlcCwgd2hpY2ggbWVhbnMgdGhhdCBpdCBpcyBcImZyZXNoXCIgaW5zaWRlIGV2ZW50IGNhbGxiYWNrcy5cclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBkdFxyXG4gICAgICovXHJcbiAgICB0aGlzLmR0ID0gLTE7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYWtlcyBib2RpZXMgZ28gdG8gc2xlZXAgd2hlbiB0aGV5J3ZlIGJlZW4gaW5hY3RpdmVcclxuICAgICAqIEBwcm9wZXJ0eSBhbGxvd1NsZWVwXHJcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAqIEBkZWZhdWx0IGZhbHNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuYWxsb3dTbGVlcCA9ICEhb3B0aW9ucy5hbGxvd1NsZWVwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWxsIHRoZSBjdXJyZW50IGNvbnRhY3RzIChpbnN0YW5jZXMgb2YgQ29udGFjdEVxdWF0aW9uKSBpbiB0aGUgd29ybGQuXHJcbiAgICAgKiBAcHJvcGVydHkgY29udGFjdHNcclxuICAgICAqIEB0eXBlIHtBcnJheX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5jb250YWN0cyA9IFtdO1xyXG4gICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucyA9IFtdO1xyXG5cclxuICAgIHRoaXMuY29udGFjdHNEaWMgPSBuZXcgVHVwbGVEaWN0aW9uYXJ5KCk7XHJcbiAgICB0aGlzLm9sZENvbnRhY3RzRGljID0gbmV3IFR1cGxlRGljdGlvbmFyeSgpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSG93IG9mdGVuIHRvIG5vcm1hbGl6ZSBxdWF0ZXJuaW9ucy4gU2V0IHRvIDAgZm9yIGV2ZXJ5IHN0ZXAsIDEgZm9yIGV2ZXJ5IHNlY29uZCBldGMuLiBBIGxhcmdlciB2YWx1ZSBpbmNyZWFzZXMgcGVyZm9ybWFuY2UuIElmIGJvZGllcyB0ZW5kIHRvIGV4cGxvZGUsIHNldCB0byBhIHNtYWxsZXIgdmFsdWUgKHplcm8gdG8gYmUgc3VyZSBub3RoaW5nIGNhbiBnbyB3cm9uZykuXHJcbiAgICAgKiBAcHJvcGVydHkgcXVhdE5vcm1hbGl6ZVNraXBcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgKi9cclxuICAgIHRoaXMucXVhdE5vcm1hbGl6ZVNraXAgPSBvcHRpb25zLnF1YXROb3JtYWxpemVTa2lwICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnF1YXROb3JtYWxpemVTa2lwIDogMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0byB0cnVlIHRvIHVzZSBmYXN0IHF1YXRlcm5pb24gbm9ybWFsaXphdGlvbi4gSXQgaXMgb2Z0ZW4gZW5vdWdoIGFjY3VyYXRlIHRvIHVzZS4gSWYgYm9kaWVzIHRlbmQgdG8gZXhwbG9kZSwgc2V0IHRvIGZhbHNlLlxyXG4gICAgICogQHByb3BlcnR5IHF1YXROb3JtYWxpemVGYXN0XHJcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAqIEBzZWUgUXVhdGVybmlvbi5ub3JtYWxpemVGYXN0XHJcbiAgICAgKiBAc2VlIFF1YXRlcm5pb24ubm9ybWFsaXplXHJcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxyXG4gICAgICovXHJcbiAgICB0aGlzLnF1YXROb3JtYWxpemVGYXN0ID0gb3B0aW9ucy5xdWF0Tm9ybWFsaXplRmFzdCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5xdWF0Tm9ybWFsaXplRmFzdCA6IGZhbHNlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHdhbGwtY2xvY2sgdGltZSBzaW5jZSBzaW11bGF0aW9uIHN0YXJ0XHJcbiAgICAgKiBAcHJvcGVydHkgdGltZVxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy50aW1lID0gMC4wO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTnVtYmVyIG9mIHRpbWVzdGVwcyB0YWtlbiBzaW5jZSBzdGFydFxyXG4gICAgICogQHByb3BlcnR5IHN0ZXBudW1iZXJcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuc3RlcG51bWJlciA9IDA7XHJcblxyXG4gICAgdGhpcy5zdWJzdGVwcyA9IDA7XHJcblxyXG4gICAgLy8vIERlZmF1bHQgYW5kIGxhc3QgdGltZXN0ZXAgc2l6ZXNcclxuICAgIHRoaXMuZGVmYXVsdF9kdCA9IDEgLyA2MDtcclxuXHJcbiAgICB0aGlzLm5leHRJZCA9IDA7XHJcbiAgICAvKipcclxuICAgICAqIEBwcm9wZXJ0eSBncmF2aXR5XHJcbiAgICAgKiBAdHlwZSB7VmVjM31cclxuICAgICAqL1xyXG4gICAgdGhpcy5ncmF2aXR5ID0gbmV3IFZlYzMoKTtcclxuICAgIGlmIChvcHRpb25zLmdyYXZpdHkpIHtcclxuICAgICAgICB0aGlzLmdyYXZpdHkuY29weShvcHRpb25zLmdyYXZpdHkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGJyb2FkcGhhc2UgYWxnb3JpdGhtIHRvIHVzZS4gRGVmYXVsdCBpcyBOYWl2ZUJyb2FkcGhhc2VcclxuICAgICAqIEBwcm9wZXJ0eSBicm9hZHBoYXNlXHJcbiAgICAgKiBAdHlwZSB7QnJvYWRwaGFzZX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5icm9hZHBoYXNlID0gb3B0aW9ucy5icm9hZHBoYXNlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmJyb2FkcGhhc2UgOiBuZXcgTmFpdmVCcm9hZHBoYXNlKCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkgYm9kaWVzXHJcbiAgICAgKiBAdHlwZSB7QXJyYXl9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuYm9kaWVzID0gW107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgc29sdmVyIGFsZ29yaXRobSB0byB1c2UuIERlZmF1bHQgaXMgR1NTb2x2ZXJcclxuICAgICAqIEBwcm9wZXJ0eSBzb2x2ZXJcclxuICAgICAqIEB0eXBlIHtTb2x2ZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuc29sdmVyID0gb3B0aW9ucy5zb2x2ZXIgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuc29sdmVyIDogbmV3IEdTU29sdmVyKCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkgY29uc3RyYWludHNcclxuICAgICAqIEB0eXBlIHtBcnJheX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5jb25zdHJhaW50cyA9IFtdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IG5hcnJvd3BoYXNlXHJcbiAgICAgKiBAdHlwZSB7TmFycm93cGhhc2V9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubmFycm93cGhhc2UgPSBuZXcgTmFycm93cGhhc2UodGhpcyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkge09iamVjdENvbGxpc2lvbk1hdHJpeH0gY29sbGlzaW9uTWF0cml4XHJcblx0ICogQHR5cGUge09iamVjdENvbGxpc2lvbk1hdHJpeH1cclxuXHQgKi9cclxuICAgIHRoaXMuY29sbGlzaW9uTWF0cml4ID0gbmV3IE9iamVjdENvbGxpc2lvbk1hdHJpeCgpO1xyXG5cclxuICAgIHRoaXMudHJpZ2dlck1hdHJpeCA9IG5ldyBPYmplY3RDb2xsaXNpb25NYXRyaXgoKTtcclxuXHJcbiAgICB0aGlzLnNoYXBlT3ZlcmxhcEtlZXBlciA9IG5ldyBPdmVybGFwS2VlcGVyKCk7XHJcblxyXG4gICAgdGhpcy5zaGFwZU92ZXJsYXBLZWVwZXJFeGl0ID0gbmV3IE92ZXJsYXBLZWVwZXIoKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFsbCBhZGRlZCBtYXRlcmlhbHNcclxuICAgICAqIEBwcm9wZXJ0eSBtYXRlcmlhbHNcclxuICAgICAqIEB0eXBlIHtBcnJheX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5tYXRlcmlhbHMgPSBbXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcm9wZXJ0eSBjb250YWN0bWF0ZXJpYWxzXHJcbiAgICAgKiBAdHlwZSB7QXJyYXl9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuY29udGFjdG1hdGVyaWFscyA9IFtdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXNlZCB0byBsb29rIHVwIGEgQ29udGFjdE1hdGVyaWFsIGdpdmVuIHR3byBpbnN0YW5jZXMgb2YgTWF0ZXJpYWwuXHJcbiAgICAgKiBAcHJvcGVydHkge1R1cGxlRGljdGlvbmFyeX0gY29udGFjdE1hdGVyaWFsVGFibGVcclxuICAgICAqL1xyXG4gICAgdGhpcy5jb250YWN0TWF0ZXJpYWxUYWJsZSA9IG5ldyBUdXBsZURpY3Rpb25hcnkoKTtcclxuXHJcbiAgICB0aGlzLmRlZmF1bHRNYXRlcmlhbCA9IG5ldyBNYXRlcmlhbChcImRlZmF1bHRcIik7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGNvbnRhY3QgbWF0ZXJpYWwgaXMgdXNlZCBpZiBubyBzdWl0YWJsZSBjb250YWN0bWF0ZXJpYWwgaXMgZm91bmQgZm9yIGEgY29udGFjdC5cclxuICAgICAqIEBwcm9wZXJ0eSBkZWZhdWx0Q29udGFjdE1hdGVyaWFsXHJcbiAgICAgKiBAdHlwZSB7Q29udGFjdE1hdGVyaWFsfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmRlZmF1bHRDb250YWN0TWF0ZXJpYWwgPSBuZXcgQ29udGFjdE1hdGVyaWFsKHRoaXMuZGVmYXVsdE1hdGVyaWFsLCB0aGlzLmRlZmF1bHRNYXRlcmlhbCwgeyBmcmljdGlvbjogMC4zLCByZXN0aXR1dGlvbjogMC4wIH0pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IHByb2ZpbGVcclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKi9cclxuICAgIHRoaXMucHJvZmlsZSA9IHtcclxuICAgICAgICBzb2x2ZTogMCxcclxuICAgICAgICBtYWtlQ29udGFjdENvbnN0cmFpbnRzOiAwLFxyXG4gICAgICAgIGJyb2FkcGhhc2U6IDAsXHJcbiAgICAgICAgaW50ZWdyYXRlOiAwLFxyXG4gICAgICAgIG5hcnJvd3BoYXNlOiAwLFxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRpbWUgYWNjdW11bGF0b3IgZm9yIGludGVycG9sYXRpb24uIFNlZSBodHRwOi8vZ2FmZmVyb25nYW1lcy5jb20vZ2FtZS1waHlzaWNzL2ZpeC15b3VyLXRpbWVzdGVwL1xyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGFjY3VtdWxhdG9yXHJcbiAgICAgKi9cclxuICAgIHRoaXMuYWNjdW11bGF0b3IgPSAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IHN1YnN5c3RlbXNcclxuICAgICAqIEB0eXBlIHtBcnJheX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5zdWJzeXN0ZW1zID0gW107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEaXNwYXRjaGVkIGFmdGVyIGEgYm9keSBoYXMgYmVlbiBhZGRlZCB0byB0aGUgd29ybGQuXHJcbiAgICAgKiBAZXZlbnQgYWRkQm9keVxyXG4gICAgICogQHBhcmFtIHtCb2R5fSBib2R5IFRoZSBib2R5IHRoYXQgaGFzIGJlZW4gYWRkZWQgdG8gdGhlIHdvcmxkLlxyXG4gICAgICovXHJcbiAgICB0aGlzLmFkZEJvZHlFdmVudCA9IHtcclxuICAgICAgICB0eXBlOiBcImFkZEJvZHlcIixcclxuICAgICAgICBib2R5OiBudWxsXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGlzcGF0Y2hlZCBhZnRlciBhIGJvZHkgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSB3b3JsZC5cclxuICAgICAqIEBldmVudCByZW1vdmVCb2R5XHJcbiAgICAgKiBAcGFyYW0ge0JvZHl9IGJvZHkgVGhlIGJvZHkgdGhhdCBoYXMgYmVlbiByZW1vdmVkIGZyb20gdGhlIHdvcmxkLlxyXG4gICAgICovXHJcbiAgICB0aGlzLnJlbW92ZUJvZHlFdmVudCA9IHtcclxuICAgICAgICB0eXBlOiBcInJlbW92ZUJvZHlcIixcclxuICAgICAgICBib2R5OiBudWxsXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuYnJvYWRwaGFzZS5zZXRXb3JsZCh0aGlzKTtcclxufVxyXG5cclxuV29ybGQuaWRUb0JvZHlNYXAgPSB7fTtcclxuXHJcbldvcmxkLmlkVG9TaGFwZU1hcCA9IHt9O1xyXG5cclxuV29ybGQucHJvdG90eXBlID0gbmV3IEV2ZW50VGFyZ2V0KCk7XHJcblxyXG4vLyBUZW1wIHN0dWZmXHJcbi8vIHZhciB0bXBBQUJCMSA9IG5ldyBBQUJCKCk7XHJcbi8vIHZhciB0bXBBcnJheTEgPSBbXTtcclxudmFyIHRtcFJheSA9IG5ldyBSYXkoKTtcclxuXHJcbi8qKlxyXG4gKiBHZXQgdGhlIGNvbnRhY3QgbWF0ZXJpYWwgYmV0d2VlbiBtYXRlcmlhbHMgbTEgYW5kIG0yXHJcbiAqIEBtZXRob2QgZ2V0Q29udGFjdE1hdGVyaWFsXHJcbiAqIEBwYXJhbSB7TWF0ZXJpYWx9IG0xXHJcbiAqIEBwYXJhbSB7TWF0ZXJpYWx9IG0yXHJcbiAqIEByZXR1cm4ge0NvbnRhY3RNYXRlcmlhbH0gVGhlIGNvbnRhY3QgbWF0ZXJpYWwgaWYgaXQgd2FzIGZvdW5kLlxyXG4gKi9cclxuV29ybGQucHJvdG90eXBlLmdldENvbnRhY3RNYXRlcmlhbCA9IGZ1bmN0aW9uIChtMSwgbTIpIHtcclxuICAgIHJldHVybiB0aGlzLmNvbnRhY3RNYXRlcmlhbFRhYmxlLmdldChtMS5pZCwgbTIuaWQpOyAvL3RoaXMuY29udGFjdG1hdGVyaWFsc1t0aGlzLm1hdHMyY21hdFtpK2oqdGhpcy5tYXRlcmlhbHMubGVuZ3RoXV07XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0IG51bWJlciBvZiBvYmplY3RzIGluIHRoZSB3b3JsZC5cclxuICogQG1ldGhvZCBudW1PYmplY3RzXHJcbiAqIEByZXR1cm4ge051bWJlcn1cclxuICogQGRlcHJlY2F0ZWRcclxuICovXHJcbldvcmxkLnByb3RvdHlwZS5udW1PYmplY3RzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuYm9kaWVzLmxlbmd0aDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTdG9yZSBvbGQgY29sbGlzaW9uIHN0YXRlIGluZm9cclxuICogQG1ldGhvZCBjb2xsaXNpb25NYXRyaXhUaWNrXHJcbiAqL1xyXG5Xb3JsZC5wcm90b3R5cGUuY29sbGlzaW9uTWF0cml4VGljayA9IGZ1bmN0aW9uICgpIHtcclxuICAgIC8vIHRoaXMuc2hhcGVPdmVybGFwS2VlcGVyLnRpY2soKTtcclxuICAgIC8vIHRoaXMuc2hhcGVPdmVybGFwS2VlcGVyRXhpdC50aWNrKCk7XHJcbn07XHJcblxyXG4vKipcclxuICogQWRkIGEgcmlnaWQgYm9keSB0byB0aGUgc2ltdWxhdGlvbi5cclxuICogQG1ldGhvZCBhZGRcclxuICogQHBhcmFtIHtCb2R5fSBib2R5XHJcbiAqIEB0b2RvIElmIHRoZSBzaW11bGF0aW9uIGhhcyBub3QgeWV0IHN0YXJ0ZWQsIHdoeSByZWNyZXRlIGFuZCBjb3B5IGFycmF5cyBmb3IgZWFjaCBib2R5PyBBY2N1bXVsYXRlIGluIGR5bmFtaWMgYXJyYXlzIGluIHRoaXMgY2FzZS5cclxuICogQHRvZG8gQWRkaW5nIGFuIGFycmF5IG9mIGJvZGllcyBzaG91bGQgYmUgcG9zc2libGUuIFRoaXMgd291bGQgc2F2ZSBzb21lIGxvb3BzIHRvb1xyXG4gKiBAZGVwcmVjYXRlZCBVc2UgLmFkZEJvZHkgaW5zdGVhZFxyXG4gKi9cclxuV29ybGQucHJvdG90eXBlLmFkZCA9IFdvcmxkLnByb3RvdHlwZS5hZGRCb2R5ID0gZnVuY3Rpb24gKGJvZHkpIHtcclxuICAgIGlmICh0aGlzLmJvZGllcy5pbmRleE9mKGJvZHkpICE9PSAtMSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGJvZHkuaW5kZXggPSB0aGlzLmJvZGllcy5sZW5ndGg7XHJcbiAgICB0aGlzLmJvZGllcy5wdXNoKGJvZHkpO1xyXG4gICAgYm9keS53b3JsZCA9IHRoaXM7XHJcbiAgICBib2R5LmluaXRQb3NpdGlvbi5jb3B5KGJvZHkucG9zaXRpb24pO1xyXG4gICAgYm9keS5pbml0VmVsb2NpdHkuY29weShib2R5LnZlbG9jaXR5KTtcclxuICAgIGJvZHkudGltZUxhc3RTbGVlcHkgPSB0aGlzLnRpbWU7XHJcbiAgICBpZiAoYm9keSBpbnN0YW5jZW9mIEJvZHkpIHtcclxuICAgICAgICBib2R5LmluaXRBbmd1bGFyVmVsb2NpdHkuY29weShib2R5LmFuZ3VsYXJWZWxvY2l0eSk7XHJcbiAgICAgICAgYm9keS5pbml0UXVhdGVybmlvbi5jb3B5KGJvZHkucXVhdGVybmlvbik7XHJcbiAgICB9XHJcbiAgICB0aGlzLmNvbGxpc2lvbk1hdHJpeC5zZXROdW1PYmplY3RzKHRoaXMuYm9kaWVzLmxlbmd0aCk7XHJcbiAgICB0aGlzLmFkZEJvZHlFdmVudC5ib2R5ID0gYm9keTtcclxuICAgIFdvcmxkLmlkVG9Cb2R5TWFwW2JvZHkuaWRdID0gYm9keTtcclxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudCh0aGlzLmFkZEJvZHlFdmVudCk7XHJcbn07XHJcblxyXG4vKipcclxuICogQWRkIGEgY29uc3RyYWludCB0byB0aGUgc2ltdWxhdGlvbi5cclxuICogQG1ldGhvZCBhZGRDb25zdHJhaW50XHJcbiAqIEBwYXJhbSB7Q29uc3RyYWludH0gY1xyXG4gKi9cclxuV29ybGQucHJvdG90eXBlLmFkZENvbnN0cmFpbnQgPSBmdW5jdGlvbiAoYykge1xyXG4gICAgdGhpcy5jb25zdHJhaW50cy5wdXNoKGMpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlbW92ZXMgYSBjb25zdHJhaW50XHJcbiAqIEBtZXRob2QgcmVtb3ZlQ29uc3RyYWludFxyXG4gKiBAcGFyYW0ge0NvbnN0cmFpbnR9IGNcclxuICovXHJcbldvcmxkLnByb3RvdHlwZS5yZW1vdmVDb25zdHJhaW50ID0gZnVuY3Rpb24gKGMpIHtcclxuICAgIHZhciBpZHggPSB0aGlzLmNvbnN0cmFpbnRzLmluZGV4T2YoYyk7XHJcbiAgICBpZiAoaWR4ICE9PSAtMSkge1xyXG4gICAgICAgIHRoaXMuY29uc3RyYWludHMuc3BsaWNlKGlkeCwgMSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogUmF5Y2FzdCB0ZXN0XHJcbiAqIEBtZXRob2QgcmF5VGVzdFxyXG4gKiBAcGFyYW0ge1ZlYzN9IGZyb21cclxuICogQHBhcmFtIHtWZWMzfSB0b1xyXG4gKiBAcGFyYW0ge1JheWNhc3RSZXN1bHR9IHJlc3VsdFxyXG4gKiBAZGVwcmVjYXRlZCBVc2UgLnJheWNhc3RBbGwsIC5yYXljYXN0Q2xvc2VzdCBvciAucmF5Y2FzdEFueSBpbnN0ZWFkLlxyXG4gKi9cclxuV29ybGQucHJvdG90eXBlLnJheVRlc3QgPSBmdW5jdGlvbiAoZnJvbSwgdG8sIHJlc3VsdCkge1xyXG4gICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFJheWNhc3RSZXN1bHQpIHtcclxuICAgICAgICAvLyBEbyByYXljYXN0Y2xvc2VzdFxyXG4gICAgICAgIHRoaXMucmF5Y2FzdENsb3Nlc3QoZnJvbSwgdG8sIHtcclxuICAgICAgICAgICAgc2tpcEJhY2tmYWNlczogdHJ1ZVxyXG4gICAgICAgIH0sIHJlc3VsdCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIERvIHJheWNhc3RBbGxcclxuICAgICAgICB0aGlzLnJheWNhc3RBbGwoZnJvbSwgdG8sIHtcclxuICAgICAgICAgICAgc2tpcEJhY2tmYWNlczogdHJ1ZVxyXG4gICAgICAgIH0sIHJlc3VsdCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogUmF5IGNhc3QgYWdhaW5zdCBhbGwgYm9kaWVzLiBUaGUgcHJvdmlkZWQgY2FsbGJhY2sgd2lsbCBiZSBleGVjdXRlZCBmb3IgZWFjaCBoaXQgd2l0aCBhIFJheWNhc3RSZXN1bHQgYXMgc2luZ2xlIGFyZ3VtZW50LlxyXG4gKiBAbWV0aG9kIHJheWNhc3RBbGxcclxuICogQHBhcmFtICB7VmVjM30gZnJvbVxyXG4gKiBAcGFyYW0gIHtWZWMzfSB0b1xyXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcclxuICogQHBhcmFtICB7bnVtYmVyfSBbb3B0aW9ucy5jb2xsaXNpb25GaWx0ZXJNYXNrPS0xXVxyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFtvcHRpb25zLmNvbGxpc2lvbkZpbHRlckdyb3VwPS0xXVxyXG4gKiBAcGFyYW0gIHtib29sZWFufSBbb3B0aW9ucy5za2lwQmFja2ZhY2VzPWZhbHNlXVxyXG4gKiBAcGFyYW0gIHtib29sZWFufSBbb3B0aW9ucy5jaGVja0NvbGxpc2lvblJlc3BvbnNlPXRydWVdXHJcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYWxsYmFja1xyXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGFueSBib2R5IHdhcyBoaXQuXHJcbiAqL1xyXG5Xb3JsZC5wcm90b3R5cGUucmF5Y2FzdEFsbCA9IGZ1bmN0aW9uIChmcm9tLCB0bywgb3B0aW9ucywgY2FsbGJhY2spIHtcclxuICAgIG9wdGlvbnMubW9kZSA9IFJheS5BTEw7XHJcbiAgICBvcHRpb25zLmZyb20gPSBmcm9tO1xyXG4gICAgb3B0aW9ucy50byA9IHRvO1xyXG4gICAgb3B0aW9ucy5jYWxsYmFjayA9IGNhbGxiYWNrO1xyXG4gICAgcmV0dXJuIHRtcFJheS5pbnRlcnNlY3RXb3JsZCh0aGlzLCBvcHRpb25zKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSYXkgY2FzdCwgYW5kIHN0b3AgYXQgdGhlIGZpcnN0IHJlc3VsdC4gTm90ZSB0aGF0IHRoZSBvcmRlciBpcyByYW5kb20gLSBidXQgdGhlIG1ldGhvZCBpcyBmYXN0LlxyXG4gKiBAbWV0aG9kIHJheWNhc3RBbnlcclxuICogQHBhcmFtICB7VmVjM30gZnJvbVxyXG4gKiBAcGFyYW0gIHtWZWMzfSB0b1xyXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcclxuICogQHBhcmFtICB7bnVtYmVyfSBbb3B0aW9ucy5jb2xsaXNpb25GaWx0ZXJNYXNrPS0xXVxyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFtvcHRpb25zLmNvbGxpc2lvbkZpbHRlckdyb3VwPS0xXVxyXG4gKiBAcGFyYW0gIHtib29sZWFufSBbb3B0aW9ucy5za2lwQmFja2ZhY2VzPWZhbHNlXVxyXG4gKiBAcGFyYW0gIHtib29sZWFufSBbb3B0aW9ucy5jaGVja0NvbGxpc2lvblJlc3BvbnNlPXRydWVdXHJcbiAqIEBwYXJhbSAge1JheWNhc3RSZXN1bHR9IHJlc3VsdFxyXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGFueSBib2R5IHdhcyBoaXQuXHJcbiAqL1xyXG5Xb3JsZC5wcm90b3R5cGUucmF5Y2FzdEFueSA9IGZ1bmN0aW9uIChmcm9tLCB0bywgb3B0aW9ucywgcmVzdWx0KSB7XHJcbiAgICBvcHRpb25zLm1vZGUgPSBSYXkuQU5ZO1xyXG4gICAgb3B0aW9ucy5mcm9tID0gZnJvbTtcclxuICAgIG9wdGlvbnMudG8gPSB0bztcclxuICAgIG9wdGlvbnMucmVzdWx0ID0gcmVzdWx0O1xyXG4gICAgcmV0dXJuIHRtcFJheS5pbnRlcnNlY3RXb3JsZCh0aGlzLCBvcHRpb25zKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSYXkgY2FzdCwgYW5kIHJldHVybiBpbmZvcm1hdGlvbiBvZiB0aGUgY2xvc2VzdCBoaXQuXHJcbiAqIEBtZXRob2QgcmF5Y2FzdENsb3Nlc3RcclxuICogQHBhcmFtICB7VmVjM30gZnJvbVxyXG4gKiBAcGFyYW0gIHtWZWMzfSB0b1xyXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcclxuICogQHBhcmFtICB7bnVtYmVyfSBbb3B0aW9ucy5jb2xsaXNpb25GaWx0ZXJNYXNrPS0xXVxyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFtvcHRpb25zLmNvbGxpc2lvbkZpbHRlckdyb3VwPS0xXVxyXG4gKiBAcGFyYW0gIHtib29sZWFufSBbb3B0aW9ucy5za2lwQmFja2ZhY2VzPWZhbHNlXVxyXG4gKiBAcGFyYW0gIHtib29sZWFufSBbb3B0aW9ucy5jaGVja0NvbGxpc2lvblJlc3BvbnNlPXRydWVdXHJcbiAqIEBwYXJhbSAge1JheWNhc3RSZXN1bHR9IHJlc3VsdFxyXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGFueSBib2R5IHdhcyBoaXQuXHJcbiAqL1xyXG5Xb3JsZC5wcm90b3R5cGUucmF5Y2FzdENsb3Nlc3QgPSBmdW5jdGlvbiAoZnJvbSwgdG8sIG9wdGlvbnMsIHJlc3VsdCkge1xyXG4gICAgb3B0aW9ucy5tb2RlID0gUmF5LkNMT1NFU1Q7XHJcbiAgICBvcHRpb25zLmZyb20gPSBmcm9tO1xyXG4gICAgb3B0aW9ucy50byA9IHRvO1xyXG4gICAgb3B0aW9ucy5yZXN1bHQgPSByZXN1bHQ7XHJcbiAgICByZXR1cm4gdG1wUmF5LmludGVyc2VjdFdvcmxkKHRoaXMsIG9wdGlvbnMpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlbW92ZSBhIHJpZ2lkIGJvZHkgZnJvbSB0aGUgc2ltdWxhdGlvbi5cclxuICogQG1ldGhvZCByZW1vdmVcclxuICogQHBhcmFtIHtCb2R5fSBib2R5XHJcbiAqIEBkZXByZWNhdGVkIFVzZSAucmVtb3ZlQm9keSBpbnN0ZWFkXHJcbiAqL1xyXG5Xb3JsZC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGJvZHkpIHtcclxuICAgIGJvZHkud29ybGQgPSBudWxsO1xyXG4gICAgdmFyIG4gPSB0aGlzLmJvZGllcy5sZW5ndGggLSAxLFxyXG4gICAgICAgIGJvZGllcyA9IHRoaXMuYm9kaWVzLFxyXG4gICAgICAgIGlkeCA9IGJvZGllcy5pbmRleE9mKGJvZHkpO1xyXG4gICAgaWYgKGlkeCAhPT0gLTEpIHtcclxuICAgICAgICBib2RpZXMuc3BsaWNlKGlkeCwgMSk7IC8vIFRvZG86IHNob3VsZCB1c2UgYSBnYXJiYWdlIGZyZWUgbWV0aG9kXHJcblxyXG4gICAgICAgIC8vIFJlY29tcHV0ZSBpbmRleFxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpICE9PSBib2RpZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgYm9kaWVzW2ldLmluZGV4ID0gaTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuY29sbGlzaW9uTWF0cml4LnNldE51bU9iamVjdHMobik7XHJcbiAgICAgICAgdGhpcy5yZW1vdmVCb2R5RXZlbnQuYm9keSA9IGJvZHk7XHJcbiAgICAgICAgZGVsZXRlIFdvcmxkLmlkVG9Cb2R5TWFwW2JvZHkuaWRdO1xyXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCh0aGlzLnJlbW92ZUJvZHlFdmVudCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogUmVtb3ZlIGEgcmlnaWQgYm9keSBmcm9tIHRoZSBzaW11bGF0aW9uLlxyXG4gKiBAbWV0aG9kIHJlbW92ZUJvZHlcclxuICogQHBhcmFtIHtCb2R5fSBib2R5XHJcbiAqL1xyXG5Xb3JsZC5wcm90b3R5cGUucmVtb3ZlQm9keSA9IFdvcmxkLnByb3RvdHlwZS5yZW1vdmU7XHJcblxyXG5Xb3JsZC5wcm90b3R5cGUuZ2V0Qm9keUJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcclxuICAgIHJldHVybiBXb3JsZC5pZFRvQm9keU1hcFtpZF07XHJcbn07XHJcblxyXG5Xb3JsZC5wcm90b3R5cGUuZ2V0U2hhcGVCeUlkID0gZnVuY3Rpb24gKGlkKSB7XHJcbiAgICByZXR1cm4gV29ybGQuaWRUb1NoYXBlTWFwW2lkXTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBZGRzIGEgbWF0ZXJpYWwgdG8gdGhlIFdvcmxkLlxyXG4gKiBAbWV0aG9kIGFkZE1hdGVyaWFsXHJcbiAqIEBwYXJhbSB7TWF0ZXJpYWx9IG1cclxuICogQHRvZG8gTmVjZXNzYXJ5P1xyXG4gKi9cclxuV29ybGQucHJvdG90eXBlLmFkZE1hdGVyaWFsID0gZnVuY3Rpb24gKG0pIHtcclxuICAgIHRoaXMubWF0ZXJpYWxzLnB1c2gobSk7XHJcbn07XHJcblxyXG4vKipcclxuICogQWRkcyBhIGNvbnRhY3QgbWF0ZXJpYWwgdG8gdGhlIFdvcmxkXHJcbiAqIEBtZXRob2QgYWRkQ29udGFjdE1hdGVyaWFsXHJcbiAqIEBwYXJhbSB7Q29udGFjdE1hdGVyaWFsfSBjbWF0XHJcbiAqL1xyXG5Xb3JsZC5wcm90b3R5cGUuYWRkQ29udGFjdE1hdGVyaWFsID0gZnVuY3Rpb24gKGNtYXQpIHtcclxuXHJcbiAgICAvLyBBZGQgY29udGFjdCBtYXRlcmlhbFxyXG4gICAgdGhpcy5jb250YWN0bWF0ZXJpYWxzLnB1c2goY21hdCk7XHJcblxyXG4gICAgLy8gQWRkIGN1cnJlbnQgY29udGFjdCBtYXRlcmlhbCB0byB0aGUgbWF0ZXJpYWwgdGFibGVcclxuICAgIHRoaXMuY29udGFjdE1hdGVyaWFsVGFibGUuc2V0KGNtYXQubWF0ZXJpYWxzWzBdLmlkLCBjbWF0Lm1hdGVyaWFsc1sxXS5pZCwgY21hdCk7XHJcbn07XHJcblxyXG4vLyBwZXJmb3JtYW5jZS5ub3coKVxyXG5pZiAoREVCVUcpIHtcclxuICAgIGlmICh0eXBlb2YgcGVyZm9ybWFuY2UgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgcGVyZm9ybWFuY2UgPSB7fTtcclxuICAgIH1cclxuICAgIGlmICghcGVyZm9ybWFuY2Uubm93KSB7XHJcbiAgICAgICAgdmFyIG5vd09mZnNldCA9IERhdGUubm93KCk7XHJcbiAgICAgICAgaWYgKHBlcmZvcm1hbmNlLnRpbWluZyAmJiBwZXJmb3JtYW5jZS50aW1pbmcubmF2aWdhdGlvblN0YXJ0KSB7XHJcbiAgICAgICAgICAgIG5vd09mZnNldCA9IHBlcmZvcm1hbmNlLnRpbWluZy5uYXZpZ2F0aW9uU3RhcnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHBlcmZvcm1hbmNlLm5vdyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIERhdGUubm93KCkgLSBub3dPZmZzZXQ7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG5cclxuLy8gdmFyIHN0ZXBfdG1wMSA9IG5ldyBWZWMzKCk7XHJcblxyXG4vKipcclxuICogU3RlcCB0aGUgcGh5c2ljcyB3b3JsZCBmb3J3YXJkIGluIHRpbWUuXHJcbiAqXHJcbiAqIFRoZXJlIGFyZSB0d28gbW9kZXMuIFRoZSBzaW1wbGUgbW9kZSBpcyBmaXhlZCB0aW1lc3RlcHBpbmcgd2l0aG91dCBpbnRlcnBvbGF0aW9uLiBJbiB0aGlzIGNhc2UgeW91IG9ubHkgdXNlIHRoZSBmaXJzdCBhcmd1bWVudC4gVGhlIHNlY29uZCBjYXNlIHVzZXMgaW50ZXJwb2xhdGlvbi4gSW4gdGhhdCB5b3UgYWxzbyBwcm92aWRlIHRoZSB0aW1lIHNpbmNlIHRoZSBmdW5jdGlvbiB3YXMgbGFzdCB1c2VkLCBhcyB3ZWxsIGFzIHRoZSBtYXhpbXVtIGZpeGVkIHRpbWVzdGVwcyB0byB0YWtlLlxyXG4gKlxyXG4gKiBAbWV0aG9kIHN0ZXBcclxuICogQHBhcmFtIHtOdW1iZXJ9IGR0ICAgICAgICAgICAgICAgICAgICAgICBUaGUgZml4ZWQgdGltZSBzdGVwIHNpemUgdG8gdXNlLlxyXG4gKiBAcGFyYW0ge051bWJlcn0gW3RpbWVTaW5jZUxhc3RDYWxsZWRdICAgIFRoZSB0aW1lIGVsYXBzZWQgc2luY2UgdGhlIGZ1bmN0aW9uIHdhcyBsYXN0IGNhbGxlZC5cclxuICogQHBhcmFtIHtOdW1iZXJ9IFttYXhTdWJTdGVwcz0xMF0gICAgICAgICBNYXhpbXVtIG51bWJlciBvZiBmaXhlZCBzdGVwcyB0byB0YWtlIHBlciBmdW5jdGlvbiBjYWxsLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiAgICAgLy8gZml4ZWQgdGltZXN0ZXBwaW5nIHdpdGhvdXQgaW50ZXJwb2xhdGlvblxyXG4gKiAgICAgd29ybGQuc3RlcCgxLzYwKTtcclxuICpcclxuICogQHNlZSBodHRwOi8vYnVsbGV0cGh5c2ljcy5vcmcvbWVkaWF3aWtpLTEuNS44L2luZGV4LnBocC9TdGVwcGluZ19UaGVfV29ybGRcclxuICovXHJcbldvcmxkLnByb3RvdHlwZS5zdGVwID0gZnVuY3Rpb24gKGR0LCB0aW1lU2luY2VMYXN0Q2FsbGVkLCBtYXhTdWJTdGVwcykge1xyXG4gICAgbWF4U3ViU3RlcHMgPSBtYXhTdWJTdGVwcyB8fCAxMDtcclxuICAgIHRpbWVTaW5jZUxhc3RDYWxsZWQgPSB0aW1lU2luY2VMYXN0Q2FsbGVkIHx8IDA7XHJcbiAgICBcclxuICAgIGlmICh0aGlzLnN1YnN0ZXBzICE9IDApIHtcclxuICAgICAgICBXb3JsZF9zdGVwX29sZENvbnRhY3RzID0gdGhpcy5jb250YWN0cy5zbGljZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aW1lU2luY2VMYXN0Q2FsbGVkID09PSAwKSB7IC8vIEZpeGVkLCBzaW1wbGUgc3RlcHBpbmdcclxuXHJcbiAgICAgICAgdGhpcy5pbnRlcm5hbFN0ZXAoZHQpO1xyXG5cclxuICAgICAgICAvLyBJbmNyZW1lbnQgdGltZVxyXG4gICAgICAgIHRoaXMudGltZSArPSBkdDtcclxuICAgICAgICB0aGlzLnN1YnN0ZXBzID0gMTtcclxuXHJcbiAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICB0aGlzLmFjY3VtdWxhdG9yICs9IHRpbWVTaW5jZUxhc3RDYWxsZWQ7XHJcbiAgICAgICAgdGhpcy5zdWJzdGVwcyA9IDA7XHJcbiAgICAgICAgd2hpbGUgKHRoaXMuYWNjdW11bGF0b3IgPj0gZHQgJiYgdGhpcy5zdWJzdGVwcyA8IG1heFN1YlN0ZXBzKSB7XHJcbiAgICAgICAgICAgIC8vIERvIGZpeGVkIHN0ZXBzIHRvIGNhdGNoIHVwXHJcbiAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxTdGVwKGR0KTtcclxuICAgICAgICAgICAgdGhpcy5hY2N1bXVsYXRvciAtPSBkdDtcclxuICAgICAgICAgICAgdGhpcy5zdWJzdGVwcysrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHQgPSAodGhpcy5hY2N1bXVsYXRvciAlIGR0KSAvIGR0O1xyXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqICE9PSB0aGlzLmJvZGllcy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICB2YXIgYiA9IHRoaXMuYm9kaWVzW2pdO1xyXG4gICAgICAgICAgICBiLnByZXZpb3VzUG9zaXRpb24ubGVycChiLnBvc2l0aW9uLCB0LCBiLmludGVycG9sYXRlZFBvc2l0aW9uKTtcclxuICAgICAgICAgICAgYi5wcmV2aW91c1F1YXRlcm5pb24uc2xlcnAoYi5xdWF0ZXJuaW9uLCB0LCBiLmludGVycG9sYXRlZFF1YXRlcm5pb24pO1xyXG4gICAgICAgICAgICBiLnByZXZpb3VzUXVhdGVybmlvbi5ub3JtYWxpemUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy50aW1lICs9IHRpbWVTaW5jZUxhc3RDYWxsZWQ7XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuLyoqXHJcbiAqIERpc3BhdGNoZWQgYWZ0ZXIgdGhlIHdvcmxkIGhhcyBzdGVwcGVkIGZvcndhcmQgaW4gdGltZS5cclxuICogQGV2ZW50IHBvc3RTdGVwXHJcbiAqL1xyXG4vLyBXb3JsZF9zdGVwX3Bvc3RTdGVwRXZlbnQgPSB7dHlwZTpcInBvc3RTdGVwXCJ9LCAvLyBSZXVzYWJsZSBldmVudCBvYmplY3RzIHRvIHNhdmUgbWVtb3J5XHJcbi8qKlxyXG4gKiBEaXNwYXRjaGVkIGJlZm9yZSB0aGUgd29ybGQgc3RlcHMgZm9yd2FyZCBpbiB0aW1lLlxyXG4gKiBAZXZlbnQgcHJlU3RlcFxyXG4gKi9cclxuLy8gV29ybGRfc3RlcF9wcmVTdGVwRXZlbnQgPSB7dHlwZTpcInByZVN0ZXBcIn0sXHJcbnZhclxyXG4gICAgV29ybGRfc3RlcF9jb2xsaWRlRXZlbnQgPSB7XHJcbiAgICAgICAgdHlwZTogXCJjb2xsaWRlXCIsXHJcbiAgICAgICAgZXZlbnQ6ICcnLFxyXG4gICAgICAgIGJvZHk6IG51bGwsXHJcbiAgICAgICAgc2VsZlNoYXBlOiBudWxsLFxyXG4gICAgICAgIG90aGVyU2hhcGU6IG51bGwsXHJcbiAgICAgICAgY29udGFjdHM6IG51bGxcclxuICAgIH0sXHJcbiAgICBXb3JsZF9zdGVwX29sZENvbnRhY3RzID0gW10sIC8vIFBvb2xzIGZvciB1bnVzZWQgb2JqZWN0c1xyXG4gICAgV29ybGRfc3RlcF9mcmljdGlvbkVxdWF0aW9uUG9vbCA9IFtdLFxyXG4gICAgV29ybGRfc3RlcF9wMSA9IFtdLCAvLyBSZXVzYWJsZSBhcnJheXMgZm9yIGNvbGxpc2lvbiBwYWlyc1xyXG4gICAgV29ybGRfc3RlcF9wMiA9IFtdO1xyXG4vLyBXb3JsZF9zdGVwX2d2ZWMgPSBuZXcgVmVjMygpLCAvLyBUZW1wb3JhcnkgdmVjdG9ycyBhbmQgcXVhdHNcclxuLy8gV29ybGRfc3RlcF92aSA9IG5ldyBWZWMzKCksXHJcbi8vIFdvcmxkX3N0ZXBfdmogPSBuZXcgVmVjMygpLFxyXG4vLyBXb3JsZF9zdGVwX3dpID0gbmV3IFZlYzMoKSxcclxuLy8gV29ybGRfc3RlcF93aiA9IG5ldyBWZWMzKCksXHJcbi8vIFdvcmxkX3N0ZXBfdDEgPSBuZXcgVmVjMygpLFxyXG4vLyBXb3JsZF9zdGVwX3QyID0gbmV3IFZlYzMoKSxcclxuLy8gV29ybGRfc3RlcF9yaXhuID0gbmV3IFZlYzMoKSxcclxuLy8gV29ybGRfc3RlcF9yanhuID0gbmV3IFZlYzMoKSxcclxuLy8gV29ybGRfc3RlcF9zdGVwX3EgPSBuZXcgUXVhdGVybmlvbigpLFxyXG4vLyBXb3JsZF9zdGVwX3N0ZXBfdyA9IG5ldyBRdWF0ZXJuaW9uKCksXHJcbi8vIFdvcmxkX3N0ZXBfc3RlcF93cSA9IG5ldyBRdWF0ZXJuaW9uKCksXHJcbi8vIGludklfdGF1X2R0ID0gbmV3IFZlYzMoKVxyXG5cclxuV29ybGQucHJvdG90eXBlLmludGVybmFsU3RlcCA9IGZ1bmN0aW9uIChkdCkge1xyXG4gICAgdGhpcy5kdCA9IGR0O1xyXG5cclxuICAgIHZhciB3b3JsZCA9IHRoaXMsXHJcbiAgICAgICAgdGhhdCA9IHRoaXMsXHJcbiAgICAgICAgY29udGFjdHMgPSB0aGlzLmNvbnRhY3RzLFxyXG4gICAgICAgIHAxID0gV29ybGRfc3RlcF9wMSxcclxuICAgICAgICBwMiA9IFdvcmxkX3N0ZXBfcDIsXHJcbiAgICAgICAgTiA9IHRoaXMubnVtT2JqZWN0cygpLFxyXG4gICAgICAgIGJvZGllcyA9IHRoaXMuYm9kaWVzLFxyXG4gICAgICAgIHNvbHZlciA9IHRoaXMuc29sdmVyLFxyXG4gICAgICAgIGdyYXZpdHkgPSB0aGlzLmdyYXZpdHksXHJcbiAgICAgICAgcHJvZmlsZSA9IHRoaXMucHJvZmlsZSxcclxuICAgICAgICBEWU5BTUlDID0gQm9keS5EWU5BTUlDLFxyXG4gICAgICAgIHByb2ZpbGluZ1N0YXJ0LFxyXG4gICAgICAgIGNvbnN0cmFpbnRzID0gdGhpcy5jb25zdHJhaW50cyxcclxuICAgICAgICBmcmljdGlvbkVxdWF0aW9uUG9vbCA9IFdvcmxkX3N0ZXBfZnJpY3Rpb25FcXVhdGlvblBvb2wsXHJcbiAgICAgICAgLy8gZ25vcm0gPSBncmF2aXR5Lm5vcm0oKSxcclxuICAgICAgICBneCA9IGdyYXZpdHkueCxcclxuICAgICAgICBneSA9IGdyYXZpdHkueSxcclxuICAgICAgICBneiA9IGdyYXZpdHkueixcclxuICAgICAgICBpID0gMDtcclxuXHJcbiAgICBpZiAoZG9Qcm9maWxpbmcpIHtcclxuICAgICAgICBwcm9maWxpbmdTdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEFkZCBncmF2aXR5IHRvIGFsbCBvYmplY3RzXHJcbiAgICBmb3IgKGkgPSAwOyBpICE9PSBOOyBpKyspIHtcclxuICAgICAgICB2YXIgYmkgPSBib2RpZXNbaV07XHJcbiAgICAgICAgaWYgKGJpLnVzZUdyYXZpdHkgJiYgYmkudHlwZSA9PT0gRFlOQU1JQykgeyAvLyBPbmx5IGZvciBkeW5hbWljIGJvZGllc1xyXG4gICAgICAgICAgICB2YXIgZiA9IGJpLmZvcmNlLCBtID0gYmkubWFzcztcclxuICAgICAgICAgICAgZi54ICs9IG0gKiBneDtcclxuICAgICAgICAgICAgZi55ICs9IG0gKiBneTtcclxuICAgICAgICAgICAgZi56ICs9IG0gKiBnejtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVXBkYXRlIHN1YnN5c3RlbXNcclxuICAgIGZvciAodmFyIGkgPSAwLCBOc3Vic3lzdGVtcyA9IHRoaXMuc3Vic3lzdGVtcy5sZW5ndGg7IGkgIT09IE5zdWJzeXN0ZW1zOyBpKyspIHtcclxuICAgICAgICB0aGlzLnN1YnN5c3RlbXNbaV0udXBkYXRlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ29sbGlzaW9uIGRldGVjdGlvblxyXG4gICAgaWYgKGRvUHJvZmlsaW5nKSB7IHByb2ZpbGluZ1N0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7IH1cclxuICAgIHAxLmxlbmd0aCA9IDA7IC8vIENsZWFuIHVwIHBhaXIgYXJyYXlzIGZyb20gbGFzdCBzdGVwXHJcbiAgICBwMi5sZW5ndGggPSAwO1xyXG4gICAgdGhpcy5icm9hZHBoYXNlLmNvbGxpc2lvblBhaXJzKHRoaXMsIHAxLCBwMik7XHJcbiAgICBpZiAoZG9Qcm9maWxpbmcpIHsgcHJvZmlsZS5icm9hZHBoYXNlID0gcGVyZm9ybWFuY2Uubm93KCkgLSBwcm9maWxpbmdTdGFydDsgfVxyXG5cclxuICAgIC8vIFJlbW92ZSBjb25zdHJhaW5lZCBwYWlycyB3aXRoIGNvbGxpZGVDb25uZWN0ZWQgPT0gZmFsc2VcclxuICAgIHZhciBOY29uc3RyYWludHMgPSBjb25zdHJhaW50cy5sZW5ndGg7XHJcbiAgICBmb3IgKGkgPSAwOyBpICE9PSBOY29uc3RyYWludHM7IGkrKykge1xyXG4gICAgICAgIHZhciBjID0gY29uc3RyYWludHNbaV07XHJcbiAgICAgICAgaWYgKCFjLmNvbGxpZGVDb25uZWN0ZWQpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IHAxLmxlbmd0aCAtIDE7IGogPj0gMDsgaiAtPSAxKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoKGMuYm9keUEgPT09IHAxW2pdICYmIGMuYm9keUIgPT09IHAyW2pdKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIChjLmJvZHlCID09PSBwMVtqXSAmJiBjLmJvZHlBID09PSBwMltqXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBwMS5zcGxpY2UoaiwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcDIuc3BsaWNlKGosIDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEdlbmVyYXRlIGNvbnRhY3RzXHJcbiAgICBpZiAoZG9Qcm9maWxpbmcpIHsgcHJvZmlsaW5nU3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTsgfVxyXG5cclxuICAgIGNvbnRhY3RzLmxlbmd0aCA9IDA7XHJcblxyXG4gICAgLy8gVHJhbnNmZXIgRnJpY3Rpb25FcXVhdGlvbiBmcm9tIGN1cnJlbnQgbGlzdCB0byB0aGUgcG9vbCBmb3IgcmV1c2VcclxuICAgIHZhciBOb2xkRnJpY3Rpb25FcXVhdGlvbnMgPSB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLmxlbmd0aDtcclxuICAgIGZvciAoaSA9IDA7IGkgIT09IE5vbGRGcmljdGlvbkVxdWF0aW9uczsgaSsrKSB7XHJcbiAgICAgICAgZnJpY3Rpb25FcXVhdGlvblBvb2wucHVzaCh0aGlzLmZyaWN0aW9uRXF1YXRpb25zW2ldKTtcclxuICAgIH1cclxuICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMubGVuZ3RoID0gMDtcclxuXHJcbiAgICB0aGlzLm5hcnJvd3BoYXNlLmdldENvbnRhY3RzKFxyXG4gICAgICAgIHAxLFxyXG4gICAgICAgIHAyLFxyXG4gICAgICAgIHRoaXMsXHJcbiAgICAgICAgY29udGFjdHMsXHJcbiAgICAgICAgbnVsbCxcclxuICAgICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLFxyXG4gICAgICAgIGZyaWN0aW9uRXF1YXRpb25Qb29sXHJcbiAgICApO1xyXG5cclxuICAgIGlmIChkb1Byb2ZpbGluZykge1xyXG4gICAgICAgIHByb2ZpbGUubmFycm93cGhhc2UgPSBwZXJmb3JtYW5jZS5ub3coKSAtIHByb2ZpbGluZ1N0YXJ0O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIExvb3Agb3ZlciBhbGwgY29sbGlzaW9uc1xyXG4gICAgaWYgKGRvUHJvZmlsaW5nKSB7XHJcbiAgICAgICAgcHJvZmlsaW5nU3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBBZGQgYWxsIGZyaWN0aW9uIGVxc1xyXG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBzb2x2ZXIuYWRkRXF1YXRpb24odGhpcy5mcmljdGlvbkVxdWF0aW9uc1tpXSk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIG5jb250YWN0cyA9IGNvbnRhY3RzLmxlbmd0aDtcclxuICAgIGZvciAoaSA9IDA7IGkgIT09IG5jb250YWN0czsgaSsrKSB7XHJcbiAgICAgICAgc29sdmVyLmFkZEVxdWF0aW9uKGNvbnRhY3RzW2ldKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoZG9Qcm9maWxpbmcpIHtcclxuICAgICAgICBwcm9maWxlLm1ha2VDb250YWN0Q29uc3RyYWludHMgPSBwZXJmb3JtYW5jZS5ub3coKSAtIHByb2ZpbGluZ1N0YXJ0O1xyXG4gICAgICAgIHByb2ZpbGluZ1N0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vIEFkZCB1c2VyLWFkZGVkIGNvbnN0cmFpbnRzXHJcbiAgICB2YXIgTmNvbnN0cmFpbnRzID0gY29uc3RyYWludHMubGVuZ3RoO1xyXG4gICAgZm9yIChpID0gMDsgaSAhPT0gTmNvbnN0cmFpbnRzOyBpKyspIHtcclxuICAgICAgICB2YXIgYyA9IGNvbnN0cmFpbnRzW2ldO1xyXG4gICAgICAgIGMudXBkYXRlKCk7XHJcbiAgICAgICAgZm9yICh2YXIgaiA9IDAsIE5lcSA9IGMuZXF1YXRpb25zLmxlbmd0aDsgaiAhPT0gTmVxOyBqKyspIHtcclxuICAgICAgICAgICAgdmFyIGVxID0gYy5lcXVhdGlvbnNbal07XHJcbiAgICAgICAgICAgIHNvbHZlci5hZGRFcXVhdGlvbihlcSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFNvbHZlIHRoZSBjb25zdHJhaW5lZCBzeXN0ZW1cclxuICAgIHNvbHZlci5zb2x2ZShkdCwgdGhpcyk7XHJcblxyXG4gICAgaWYgKGRvUHJvZmlsaW5nKSB7XHJcbiAgICAgICAgcHJvZmlsZS5zb2x2ZSA9IHBlcmZvcm1hbmNlLm5vdygpIC0gcHJvZmlsaW5nU3RhcnQ7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmVtb3ZlIGFsbCBjb250YWN0cyBmcm9tIHNvbHZlclxyXG4gICAgc29sdmVyLnJlbW92ZUFsbEVxdWF0aW9ucygpO1xyXG5cclxuICAgIC8vIEFwcGx5IGRhbXBpbmcsIHNlZSBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvYnVsbGV0L2lzc3Vlcy9kZXRhaWw/aWQ9NzQgZm9yIGRldGFpbHNcclxuICAgIHZhciBwb3cgPSBNYXRoLnBvdztcclxuICAgIE4gPSB0aGlzLm51bU9iamVjdHMoKTtcclxuICAgIGZvciAoaSA9IDA7IGkgIT09IE47IGkrKykge1xyXG4gICAgICAgIHZhciBiaSA9IGJvZGllc1tpXTtcclxuICAgICAgICBpZiAoYmkudHlwZSAmIERZTkFNSUMpIHsgLy8gT25seSBmb3IgZHluYW1pYyBib2RpZXNcclxuICAgICAgICAgICAgdmFyIGxkID0gcG93KDEuMCAtIGJpLmxpbmVhckRhbXBpbmcsIGR0KTtcclxuICAgICAgICAgICAgdmFyIHYgPSBiaS52ZWxvY2l0eTtcclxuICAgICAgICAgICAgdi5tdWx0KGxkLCB2KTtcclxuICAgICAgICAgICAgdmFyIGF2ID0gYmkuYW5ndWxhclZlbG9jaXR5O1xyXG4gICAgICAgICAgICBpZiAoYXYpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhZCA9IHBvdygxLjAgLSBiaS5hbmd1bGFyRGFtcGluZywgZHQpO1xyXG4gICAgICAgICAgICAgICAgYXYubXVsdChhZCwgYXYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIHRoaXMuZGlzcGF0Y2hFdmVudChXb3JsZF9zdGVwX3ByZVN0ZXBFdmVudCk7XHJcblxyXG4gICAgLy8gLy8gSW52b2tlIHByZS1zdGVwIGNhbGxiYWNrc1xyXG4gICAgLy8gZm9yKGk9MDsgaSE9PU47IGkrKyl7XHJcbiAgICAvLyAgICAgdmFyIGJpID0gYm9kaWVzW2ldO1xyXG4gICAgLy8gICAgIGlmKGJpLnByZVN0ZXApe1xyXG4gICAgLy8gICAgICAgICBiaS5wcmVTdGVwLmNhbGwoYmkpO1xyXG4gICAgLy8gICAgIH1cclxuICAgIC8vIH1cclxuXHJcbiAgICAvLyBMZWFwIGZyb2dcclxuICAgIC8vIHZuZXcgPSB2ICsgaCpmL21cclxuICAgIC8vIHhuZXcgPSB4ICsgaCp2bmV3XHJcbiAgICBpZiAoZG9Qcm9maWxpbmcpIHtcclxuICAgICAgICBwcm9maWxpbmdTdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG4gICAgfVxyXG4gICAgdmFyIHN0ZXBudW1iZXIgPSB0aGlzLnN0ZXBudW1iZXI7XHJcbiAgICB2YXIgcXVhdE5vcm1hbGl6ZSA9IHN0ZXBudW1iZXIgJSAodGhpcy5xdWF0Tm9ybWFsaXplU2tpcCArIDEpID09PSAwO1xyXG4gICAgdmFyIHF1YXROb3JtYWxpemVGYXN0ID0gdGhpcy5xdWF0Tm9ybWFsaXplRmFzdDtcclxuXHJcbiAgICBmb3IgKGkgPSAwOyBpICE9PSBOOyBpKyspIHtcclxuICAgICAgICBib2RpZXNbaV0uaW50ZWdyYXRlKGR0LCBxdWF0Tm9ybWFsaXplLCBxdWF0Tm9ybWFsaXplRmFzdCk7XHJcbiAgICB9XHJcbiAgICB0aGlzLmNsZWFyRm9yY2VzKCk7XHJcblxyXG4gICAgdGhpcy5icm9hZHBoYXNlLmRpcnR5ID0gdHJ1ZTtcclxuXHJcbiAgICBpZiAoZG9Qcm9maWxpbmcpIHtcclxuICAgICAgICBwcm9maWxlLmludGVncmF0ZSA9IHBlcmZvcm1hbmNlLm5vdygpIC0gcHJvZmlsaW5nU3RhcnQ7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVXBkYXRlIHdvcmxkIHRpbWVcclxuICAgIHRoaXMudGltZSArPSBkdDtcclxuICAgIHRoaXMuc3RlcG51bWJlciArPSAxO1xyXG5cclxuICAgIC8vIHRoaXMuZGlzcGF0Y2hFdmVudChXb3JsZF9zdGVwX3Bvc3RTdGVwRXZlbnQpO1xyXG5cclxuICAgIC8vIC8vIEludm9rZSBwb3N0LXN0ZXAgY2FsbGJhY2tzXHJcbiAgICAvLyBmb3IoaT0wOyBpIT09TjsgaSsrKXtcclxuICAgIC8vICAgICB2YXIgYmkgPSBib2RpZXNbaV07XHJcbiAgICAvLyAgICAgdmFyIHBvc3RTdGVwID0gYmkucG9zdFN0ZXA7XHJcbiAgICAvLyAgICAgaWYocG9zdFN0ZXApe1xyXG4gICAgLy8gICAgICAgICBwb3N0U3RlcC5jYWxsKGJpKTtcclxuICAgIC8vICAgICB9XHJcbiAgICAvLyB9XHJcblxyXG4gICAgLy8gU2xlZXBpbmcgdXBkYXRlXHJcbiAgICBpZiAodGhpcy5hbGxvd1NsZWVwKSB7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSAhPT0gTjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGJvZGllc1tpXS5zbGVlcFRpY2sodGhpcy50aW1lKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG52YXIgYWRkaXRpb25zID0gW107XHJcbnZhciByZW1vdmFscyA9IFtdO1xyXG52YXIgdHJpZ2dlcmVkRXZlbnQgPSB7XHJcbiAgICB0eXBlOiAndHJpZ2dlcmVkJyxcclxuICAgIGV2ZW50OiAnJyxcclxuICAgIHNlbGZCb2R5OiBudWxsLCAvLyBuZWVkID9cclxuICAgIG90aGVyQm9keTogbnVsbCwgLy8gbmVlZCA/XHJcbiAgICBzZWxmU2hhcGU6IG51bGwsXHJcbiAgICBvdGhlclNoYXBlOiBudWxsXHJcbn07XHJcbldvcmxkLnByb3RvdHlwZS5lbWl0VHJpZ2dlcmVkRXZlbnRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKHRoaXMuc3Vic3RlcHMgPT0gMClcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgdmFyIGlkMTtcclxuICAgIHZhciBpZDI7XHJcblxyXG4gICAgYWRkaXRpb25zLmxlbmd0aCA9IHJlbW92YWxzLmxlbmd0aCA9IDA7XHJcbiAgICB0aGlzLnNoYXBlT3ZlcmxhcEtlZXBlckV4aXQuZ2V0RGlmZihhZGRpdGlvbnMsIHJlbW92YWxzKTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHJlbW92YWxzLmxlbmd0aDsgaSA8IGw7IGkgKz0gMikge1xyXG4gICAgICAgIHRyaWdnZXJlZEV2ZW50LmV2ZW50ID0gJ3RyaWdnZXItZXhpdCc7XHJcbiAgICAgICAgdmFyIHNoYXBlQSA9IHRoaXMuZ2V0U2hhcGVCeUlkKHJlbW92YWxzW2ldKTtcclxuICAgICAgICB2YXIgc2hhcGVCID0gdGhpcy5nZXRTaGFwZUJ5SWQocmVtb3ZhbHNbaSArIDFdKTtcclxuICAgICAgICAvLyBpZighc2hhcGVBLmJvZHkuaXNTbGVlcGluZyB8fCAhc2hhcGVCLmJvZHkuaXNTbGVlcGluZyl7XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyTWF0cml4LnNldChzaGFwZUEsIHNoYXBlQiwgZmFsc2UpO1xyXG4gICAgICAgIHRyaWdnZXJlZEV2ZW50LnNlbGZTaGFwZSA9IHNoYXBlQTtcclxuICAgICAgICB0cmlnZ2VyZWRFdmVudC5vdGhlclNoYXBlID0gc2hhcGVCO1xyXG4gICAgICAgIHRyaWdnZXJlZEV2ZW50LnNlbGZCb2R5ID0gc2hhcGVBLmJvZHk7XHJcbiAgICAgICAgdHJpZ2dlcmVkRXZlbnQub3RoZXJCb2R5ID0gc2hhcGVCLmJvZHk7XHJcbiAgICAgICAgc2hhcGVBLmRpc3BhdGNoRXZlbnQodHJpZ2dlcmVkRXZlbnQpO1xyXG5cclxuICAgICAgICB0cmlnZ2VyZWRFdmVudC5zZWxmU2hhcGUgPSBzaGFwZUI7XHJcbiAgICAgICAgdHJpZ2dlcmVkRXZlbnQub3RoZXJTaGFwZSA9IHNoYXBlQTtcclxuICAgICAgICB0cmlnZ2VyZWRFdmVudC5zZWxmQm9keSA9IHNoYXBlQi5ib2R5O1xyXG4gICAgICAgIHRyaWdnZXJlZEV2ZW50Lm90aGVyQm9keSA9IHNoYXBlQS5ib2R5O1xyXG4gICAgICAgIHNoYXBlQi5kaXNwYXRjaEV2ZW50KHRyaWdnZXJlZEV2ZW50KTtcclxuICAgICAgICAvLyB9XHJcbiAgICB9XHJcblxyXG4gICAgYWRkaXRpb25zLmxlbmd0aCA9IHJlbW92YWxzLmxlbmd0aCA9IDA7XHJcbiAgICB0aGlzLnNoYXBlT3ZlcmxhcEtlZXBlci5nZXREaWZmKGFkZGl0aW9ucywgcmVtb3ZhbHMpO1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhZGRpdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSArPSAyKSB7XHJcbiAgICAgICAgdmFyIGlkMSA9IGFkZGl0aW9uc1tpXTtcclxuICAgICAgICB2YXIgaWQyID0gYWRkaXRpb25zW2kgKyAxXTtcclxuICAgICAgICB2YXIgc2hhcGVBID0gdGhpcy5nZXRTaGFwZUJ5SWQoaWQxKTtcclxuICAgICAgICB2YXIgc2hhcGVCID0gdGhpcy5nZXRTaGFwZUJ5SWQoaWQyKTtcclxuICAgICAgICBpZiAoIXNoYXBlQSB8fCAhc2hhcGVCKSBjb250aW51ZTtcclxuICAgICAgICBcclxuICAgICAgICBpZiAodGhpcy50cmlnZ2VyTWF0cml4LmdldChzaGFwZUEsIHNoYXBlQikpIHtcclxuICAgICAgICAgICAgdHJpZ2dlcmVkRXZlbnQuZXZlbnQgPSAndHJpZ2dlci1zdGF5JztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXJNYXRyaXguc2V0KHNoYXBlQSwgc2hhcGVCLCB0cnVlKTtcclxuICAgICAgICAgICAgdHJpZ2dlcmVkRXZlbnQuZXZlbnQgPSAndHJpZ2dlci1lbnRlcic7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyaWdnZXJlZEV2ZW50LnNlbGZTaGFwZSA9IHNoYXBlQTtcclxuICAgICAgICB0cmlnZ2VyZWRFdmVudC5vdGhlclNoYXBlID0gc2hhcGVCO1xyXG4gICAgICAgIHRyaWdnZXJlZEV2ZW50LnNlbGZCb2R5ID0gc2hhcGVBLmJvZHk7XHJcbiAgICAgICAgdHJpZ2dlcmVkRXZlbnQub3RoZXJCb2R5ID0gc2hhcGVCLmJvZHk7XHJcbiAgICAgICAgc2hhcGVBLmRpc3BhdGNoRXZlbnQodHJpZ2dlcmVkRXZlbnQpO1xyXG5cclxuICAgICAgICB0cmlnZ2VyZWRFdmVudC5zZWxmU2hhcGUgPSBzaGFwZUI7XHJcbiAgICAgICAgdHJpZ2dlcmVkRXZlbnQub3RoZXJTaGFwZSA9IHNoYXBlQTtcclxuICAgICAgICB0cmlnZ2VyZWRFdmVudC5zZWxmQm9keSA9IHNoYXBlQi5ib2R5O1xyXG4gICAgICAgIHRyaWdnZXJlZEV2ZW50Lm90aGVyQm9keSA9IHNoYXBlQS5ib2R5O1xyXG4gICAgICAgIHNoYXBlQi5kaXNwYXRjaEV2ZW50KHRyaWdnZXJlZEV2ZW50KTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnNoYXBlT3ZlcmxhcEtlZXBlci5yZXNldCgpO1xyXG4gICAgdGhpcy5zaGFwZU92ZXJsYXBLZWVwZXJFeGl0LnRpY2soKTtcclxufTtcclxuXHJcbldvcmxkLnByb3RvdHlwZS5lbWl0Q29sbGlzaW9uRXZlbnRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKHRoaXMuc3Vic3RlcHMgPT0gMClcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgdmFyIGNvbnRhY3RzID0gdGhpcy5jb250YWN0cztcclxuICAgIHZhciBpID0gdGhpcy5jb250YWN0cy5sZW5ndGg7XHJcbiAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgICAgLy8gQ3VycmVudCBjb250YWN0XHJcbiAgICAgICAgdmFyIGMgPSBjb250YWN0c1tpXTtcclxuICAgICAgICAvLyBHZXQgY3VycmVudCBjb2xsaXNpb24gaW5kZWNlc1xyXG4gICAgICAgIHZhciBzaSA9IGMuc2k7XHJcbiAgICAgICAgdmFyIHNqID0gYy5zajtcclxuICAgICAgICB2YXIgaXRlbSA9IHRoaXMuY29udGFjdHNEaWMuZ2V0KHNpLmlkLCBzai5pZCk7XHJcbiAgICAgICAgaWYgKGl0ZW0gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBpdGVtID0gdGhpcy5jb250YWN0c0RpYy5zZXQoc2kuaWQsIHNqLmlkLCBbXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGl0ZW0ucHVzaChjKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIga2V5O1xyXG4gICAgdmFyIGRhdGE7XHJcbiAgICAvLyBpcyBjb2xsaXNpb24gZW50ZXIgb3Igc3RheVxyXG4gICAgdmFyIGkgPSB0aGlzLmNvbnRhY3RzRGljLmdldExlbmd0aCgpO1xyXG4gICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgIGtleSA9IHRoaXMuY29udGFjdHNEaWMuZ2V0S2V5QnlJbmRleChpKTtcclxuICAgICAgICBkYXRhID0gdGhpcy5jb250YWN0c0RpYy5nZXREYXRhQnlLZXkoa2V5KTtcclxuXHJcbiAgICAgICAgaWYgKGRhdGEgPT0gbnVsbClcclxuICAgICAgICAgICAgY29udGludWU7XHJcblxyXG4gICAgICAgIHZhciBiaSA9IGRhdGFbMF0uYmk7XHJcbiAgICAgICAgdmFyIGJqID0gZGF0YVswXS5iajtcclxuICAgICAgICB2YXIgc2kgPSBkYXRhWzBdLnNpO1xyXG4gICAgICAgIHZhciBzaiA9IGRhdGFbMF0uc2o7XHJcblxyXG4gICAgICAgIGlmIChiaS5hbGxvd1NsZWVwICYmXHJcbiAgICAgICAgICAgIGJpLnR5cGUgPT09IEJvZHkuRFlOQU1JQyAmJlxyXG4gICAgICAgICAgICBiaS5zbGVlcFN0YXRlID09PSBCb2R5LlNMRUVQSU5HICYmXHJcbiAgICAgICAgICAgIGJqLnNsZWVwU3RhdGUgPT09IEJvZHkuQVdBS0UgJiZcclxuICAgICAgICAgICAgYmoudHlwZSAhPT0gQm9keS5TVEFUSUNcclxuICAgICAgICApIHtcclxuICAgICAgICAgICAgdmFyIHNwZWVkU3F1YXJlZEIgPSBiai52ZWxvY2l0eS5ub3JtMigpICsgYmouYW5ndWxhclZlbG9jaXR5Lm5vcm0yKCk7XHJcbiAgICAgICAgICAgIHZhciBzcGVlZExpbWl0U3F1YXJlZEIgPSBNYXRoLnBvdyhiai5zbGVlcFNwZWVkTGltaXQsIDIpO1xyXG4gICAgICAgICAgICBpZiAoc3BlZWRTcXVhcmVkQiA+PSBzcGVlZExpbWl0U3F1YXJlZEIgKiAyKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBiaS5fd2FrZVVwQWZ0ZXJOYXJyb3dwaGFzZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBiaS53YWtlVXAoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGJqLmFsbG93U2xlZXAgJiZcclxuICAgICAgICAgICAgYmoudHlwZSA9PT0gQm9keS5EWU5BTUlDICYmXHJcbiAgICAgICAgICAgIGJqLnNsZWVwU3RhdGUgPT09IEJvZHkuU0xFRVBJTkcgJiZcclxuICAgICAgICAgICAgYmkuc2xlZXBTdGF0ZSA9PT0gQm9keS5BV0FLRSAmJlxyXG4gICAgICAgICAgICBiaS50eXBlICE9PSBCb2R5LlNUQVRJQ1xyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgICB2YXIgc3BlZWRTcXVhcmVkQSA9IGJpLnZlbG9jaXR5Lm5vcm0yKCkgKyBiaS5hbmd1bGFyVmVsb2NpdHkubm9ybTIoKTtcclxuICAgICAgICAgICAgdmFyIHNwZWVkTGltaXRTcXVhcmVkQSA9IE1hdGgucG93KGJpLnNsZWVwU3BlZWRMaW1pdCwgMik7XHJcbiAgICAgICAgICAgIGlmIChzcGVlZFNxdWFyZWRBID49IHNwZWVkTGltaXRTcXVhcmVkQSAqIDIpIHtcclxuICAgICAgICAgICAgICAgIC8vIGJqLl93YWtlVXBBZnRlck5hcnJvd3BoYXNlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGJqLndha2VVcCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBOb3cgd2Uga25vdyB0aGF0IGkgYW5kIGogYXJlIGluIGNvbnRhY3QuIFNldCBjb2xsaXNpb24gbWF0cml4IHN0YXRlXHRcdFxyXG4gICAgICAgIGlmICh0aGlzLmNvbGxpc2lvbk1hdHJpeC5nZXQoYmksIGJqKSkge1xyXG4gICAgICAgICAgICAvLyBjb2xsaXNpb24gc3RheVxyXG4gICAgICAgICAgICBXb3JsZF9zdGVwX2NvbGxpZGVFdmVudC5ldmVudCA9ICdjb2xsaXNpb24tc3RheSc7XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29sbGlzaW9uTWF0cml4LnNldChiaSwgYmosIHRydWUpO1xyXG4gICAgICAgICAgICAvLyBjb2xsaXNpb24gZW50ZXJcclxuICAgICAgICAgICAgV29ybGRfc3RlcF9jb2xsaWRlRXZlbnQuZXZlbnQgPSAnY29sbGlzaW9uLWVudGVyJztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChERUJVRyl7XHJcbiAgICAgICAgICAgIFdvcmxkX3N0ZXBfY29sbGlkZUV2ZW50LmJpID0gYmk7ICAgIFxyXG4gICAgICAgICAgICBXb3JsZF9zdGVwX2NvbGxpZGVFdmVudC5jb250YWN0ID0gZGF0YVswXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIFdvcmxkX3N0ZXBfY29sbGlkZUV2ZW50LmNvbnRhY3RzID0gZGF0YTtcclxuXHJcbiAgICAgICAgV29ybGRfc3RlcF9jb2xsaWRlRXZlbnQuYm9keSA9IHNqLmJvZHk7XHJcbiAgICAgICAgV29ybGRfc3RlcF9jb2xsaWRlRXZlbnQuc2VsZlNoYXBlID0gc2k7XHJcbiAgICAgICAgV29ybGRfc3RlcF9jb2xsaWRlRXZlbnQub3RoZXJTaGFwZSA9IHNqO1xyXG4gICAgICAgIHNpLmJvZHkuZGlzcGF0Y2hFdmVudChXb3JsZF9zdGVwX2NvbGxpZGVFdmVudCk7XHJcblxyXG4gICAgICAgIFdvcmxkX3N0ZXBfY29sbGlkZUV2ZW50LmJvZHkgPSBzaS5ib2R5O1xyXG4gICAgICAgIFdvcmxkX3N0ZXBfY29sbGlkZUV2ZW50LnNlbGZTaGFwZSA9IHNqO1xyXG4gICAgICAgIFdvcmxkX3N0ZXBfY29sbGlkZUV2ZW50Lm90aGVyU2hhcGUgPSBzaTtcclxuICAgICAgICBzai5ib2R5LmRpc3BhdGNoRXZlbnQoV29ybGRfc3RlcF9jb2xsaWRlRXZlbnQpO1xyXG4gICAgfVxyXG4gICAgdmFyIG9sZGNvbnRhY3RzID0gV29ybGRfc3RlcF9vbGRDb250YWN0cztcclxuICAgIGZvciAoaSA9IG9sZGNvbnRhY3RzLmxlbmd0aDsgaS0tOykge1xyXG4gICAgICAgIC8vIEN1cnJlbnQgY29udGFjdFxyXG4gICAgICAgIHZhciBjID0gb2xkY29udGFjdHNbaV07XHJcblxyXG4gICAgICAgIC8vIEdldCBjdXJyZW50IGNvbGxpc2lvbiBpbmRlY2VzXHJcbiAgICAgICAgdmFyIHNpID0gYy5zaTtcclxuICAgICAgICB2YXIgc2ogPSBjLnNqO1xyXG4gICAgICAgIGlmICh0aGlzLm9sZENvbnRhY3RzRGljLmdldChzaS5pZCwgc2ouaWQpID09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5vbGRDb250YWN0c0RpYy5zZXQoc2kuaWQsIHNqLmlkLCBjKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gaXMgY29sbGlzaW9uIGV4aXRcclxuICAgIGkgPSB0aGlzLm9sZENvbnRhY3RzRGljLmdldExlbmd0aCgpO1xyXG4gICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgIGtleSA9IHRoaXMub2xkQ29udGFjdHNEaWMuZ2V0S2V5QnlJbmRleChpKTtcclxuICAgICAgICBpZiAodGhpcy5jb250YWN0c0RpYy5nZXREYXRhQnlLZXkoa2V5KSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGRhdGEgPSB0aGlzLm9sZENvbnRhY3RzRGljLmdldERhdGFCeUtleShrZXkpO1xyXG4gICAgICAgICAgICB2YXIgYmkgPSBkYXRhLmJpO1xyXG4gICAgICAgICAgICB2YXIgYmogPSBkYXRhLmJqO1xyXG4gICAgICAgICAgICB2YXIgc2kgPSBkYXRhLnNpO1xyXG4gICAgICAgICAgICB2YXIgc2ogPSBkYXRhLnNqO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jb2xsaXNpb25NYXRyaXguZ2V0KGJpLCBiaikpIHtcclxuICAgICAgICAgICAgICAgIGlmICghYmkuaXNTbGVlcGluZygpIHx8ICFiai5pc1NsZWVwaW5nKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbGxpc2lvbk1hdHJpeC5zZXQoYmksIGJqLCBmYWxzZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChERUJVRyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFdvcmxkX3N0ZXBfY29sbGlkZUV2ZW50LmJpID0gYmk7ICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBXb3JsZF9zdGVwX2NvbGxpZGVFdmVudC5jb250YWN0ID0gZGF0YTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbGxpc2lvbiBleGl0XHJcbiAgICAgICAgICAgICAgICAgICAgV29ybGRfc3RlcF9jb2xsaWRlRXZlbnQuZXZlbnQgPSAnY29sbGlzaW9uLWV4aXQnO1xyXG4gICAgICAgICAgICAgICAgICAgIFdvcmxkX3N0ZXBfY29sbGlkZUV2ZW50LmJvZHkgPSBzai5ib2R5O1xyXG4gICAgICAgICAgICAgICAgICAgIFdvcmxkX3N0ZXBfY29sbGlkZUV2ZW50LnNlbGZTaGFwZSA9IHNpO1xyXG4gICAgICAgICAgICAgICAgICAgIFdvcmxkX3N0ZXBfY29sbGlkZUV2ZW50Lm90aGVyU2hhcGUgPSBzajtcclxuICAgICAgICAgICAgICAgICAgICBXb3JsZF9zdGVwX2NvbGxpZGVFdmVudC5jb250YWN0cy5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIFdvcmxkX3N0ZXBfY29sbGlkZUV2ZW50LmNvbnRhY3RzLnB1c2goZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2kuYm9keS5kaXNwYXRjaEV2ZW50KFdvcmxkX3N0ZXBfY29sbGlkZUV2ZW50KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgV29ybGRfc3RlcF9jb2xsaWRlRXZlbnQuYm9keSA9IHNpLmJvZHk7XHJcbiAgICAgICAgICAgICAgICAgICAgV29ybGRfc3RlcF9jb2xsaWRlRXZlbnQuc2VsZlNoYXBlID0gc2o7XHJcbiAgICAgICAgICAgICAgICAgICAgV29ybGRfc3RlcF9jb2xsaWRlRXZlbnQub3RoZXJTaGFwZSA9IHNpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNqLmJvZHkuZGlzcGF0Y2hFdmVudChXb3JsZF9zdGVwX2NvbGxpZGVFdmVudCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vdCBleGl0LCBkdWUgdG8gc2xlZXBpbmdcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmNvbnRhY3RzRGljLnJlc2V0KCk7XHJcbiAgICB0aGlzLm9sZENvbnRhY3RzRGljLnJlc2V0KCk7XHJcbn07XHJcblxyXG4vKipcclxuICogU2V0cyBhbGwgYm9keSBmb3JjZXMgaW4gdGhlIHdvcmxkIHRvIHplcm8uXHJcbiAqIEBtZXRob2QgY2xlYXJGb3JjZXNcclxuICovXHJcbldvcmxkLnByb3RvdHlwZS5jbGVhckZvcmNlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBib2RpZXMgPSB0aGlzLmJvZGllcztcclxuICAgIHZhciBOID0gYm9kaWVzLmxlbmd0aDtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpICE9PSBOOyBpKyspIHtcclxuICAgICAgICB2YXIgYiA9IGJvZGllc1tpXTtcclxuICAgICAgICBiLmZvcmNlLnNldCgwLCAwLCAwKTtcclxuICAgICAgICBiLnRvcnF1ZS5zZXQoMCwgMCwgMCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG59KS5jYWxsKHRoaXMsdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxyXG59LHtcIi4uL2NvbGxpc2lvbi9BQUJCXCI6MyxcIi4uL2NvbGxpc2lvbi9BcnJheUNvbGxpc2lvbk1hdHJpeFwiOjQsXCIuLi9jb2xsaXNpb24vTmFpdmVCcm9hZHBoYXNlXCI6NyxcIi4uL2NvbGxpc2lvbi9PYmplY3RDb2xsaXNpb25NYXRyaXhcIjo4LFwiLi4vY29sbGlzaW9uL092ZXJsYXBLZWVwZXJcIjo5LFwiLi4vY29sbGlzaW9uL1JheVwiOjEwLFwiLi4vY29sbGlzaW9uL1JheWNhc3RSZXN1bHRcIjoxMSxcIi4uL2VxdWF0aW9ucy9Db250YWN0RXF1YXRpb25cIjoyMCxcIi4uL2VxdWF0aW9ucy9GcmljdGlvbkVxdWF0aW9uXCI6MjIsXCIuLi9tYXRlcmlhbC9Db250YWN0TWF0ZXJpYWxcIjoyNSxcIi4uL21hdGVyaWFsL01hdGVyaWFsXCI6MjYsXCIuLi9tYXRoL1F1YXRlcm5pb25cIjoyOSxcIi4uL21hdGgvVmVjM1wiOjMxLFwiLi4vb2JqZWN0cy9Cb2R5XCI6MzIsXCIuLi9zaGFwZXMvU2hhcGVcIjo0NCxcIi4uL3NvbHZlci9HU1NvbHZlclwiOjQ3LFwiLi4vdXRpbHMvRXZlbnRUYXJnZXRcIjo1MCxcIi4uL3V0aWxzL1R1cGxlRGljdGlvbmFyeVwiOjUzLFwiLi9OYXJyb3dwaGFzZVwiOjU2fV19LHt9LFsyXSlcclxuKDIpXHJcbn0pOyJdLCJzb3VyY2VSb290IjoiLyJ9