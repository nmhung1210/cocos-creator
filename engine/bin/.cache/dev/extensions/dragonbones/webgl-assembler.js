
                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'engine-dev/extensions/dragonbones/webgl-assembler.js';
                    var __require = nodeEnv ? function (request) {
                        return require(request);
                    } : function (request) {
                        return __quick_compile_engine__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_engine__.registerModule(__filename, module);}"use strict";

exports.__esModule = true;
exports["default"] = void 0;

var _assembler = _interopRequireDefault(require("../../cocos2d/core/renderer/assembler"));

var _mat = _interopRequireDefault(require("../../cocos2d/core/value-types/mat4"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var Armature = require('./ArmatureDisplay');

var RenderFlow = require('../../cocos2d/core/renderer/render-flow');

var gfx = cc.gfx;
var NEED_COLOR = 0x01;
var NEED_BATCH = 0x10;

var _boneColor = cc.color(255, 0, 0, 255);

var _slotColor = cc.color(0, 0, 255, 255);

var _originColor = cc.color(0, 255, 0, 255);

var _nodeR, _nodeG, _nodeB, _nodeA, _premultipliedAlpha, _multiply, _mustFlush, _buffer, _node, _renderer, _comp, _vfOffset, _indexOffset, _vertexOffset, _vertexCount, _indexCount, _x, _y, _c, _r, _g, _b, _a, _handleVal, _m00, _m04, _m12, _m01, _m05, _m13;

function _getSlotMaterial(tex, blendMode) {
  if (!tex) return null;
  var src, dst;

  switch (blendMode) {
    case 1:
      //additive
      src = _premultipliedAlpha ? cc.macro.ONE : cc.macro.SRC_ALPHA;
      dst = cc.macro.ONE;
      break;

    case 10:
      //multiply
      src = cc.macro.DST_COLOR;
      dst = cc.macro.ONE_MINUS_SRC_ALPHA;
      break;

    case 12:
      //screen
      src = cc.macro.ONE;
      dst = cc.macro.ONE_MINUS_SRC_COLOR;
      break;

    case 0: //normal

    default:
      src = _premultipliedAlpha ? cc.macro.ONE : cc.macro.SRC_ALPHA;
      dst = cc.macro.ONE_MINUS_SRC_ALPHA;
      break;
  }

  var useModel = !_comp.enableBatch;
  var baseMaterial = _comp._materials[0];

  if (!baseMaterial) {
    return null;
  }

  var materialCache = _comp._materialCache; // The key use to find corresponding material

  var key = tex.getId() + src + dst + useModel;
  var material = materialCache[key];

  if (!material) {
    if (!materialCache.baseMaterial) {
      material = baseMaterial;
      materialCache.baseMaterial = baseMaterial;
    } else {
      material = cc.MaterialVariant.create(baseMaterial);
    }

    material.define('CC_USE_MODEL', useModel);
    material.setProperty('texture', tex); // update blend function

    material.setBlend(true, gfx.BLEND_FUNC_ADD, src, dst, gfx.BLEND_FUNC_ADD, src, dst);
    materialCache[key] = material;
  }

  return material;
}

function _handleColor(color, parentOpacity) {
  _a = color.a * parentOpacity * _nodeA;
  _multiply = _premultipliedAlpha ? _a / 255.0 : 1.0;
  _r = color.r * _nodeR * _multiply;
  _g = color.g * _nodeG * _multiply;
  _b = color.b * _nodeB * _multiply;
  _c = (_a << 24 >>> 0) + (_b << 16) + (_g << 8) + _r;
}

var ArmatureAssembler = /*#__PURE__*/function (_Assembler) {
  _inheritsLoose(ArmatureAssembler, _Assembler);

  function ArmatureAssembler() {
    return _Assembler.apply(this, arguments) || this;
  }

  var _proto = ArmatureAssembler.prototype;

  _proto.updateRenderData = function updateRenderData(comp, batchData) {};

  _proto.realTimeTraverse = function realTimeTraverse(armature, parentMat, parentOpacity) {
    var slots = armature._slots;
    var vbuf, ibuf, uintbuf;
    var material;
    var vertices, indices;
    var slotColor;
    var slot;
    var slotMat;
    var slotMatm;
    var offsetInfo;

    for (var i = 0, l = slots.length; i < l; i++) {
      slot = slots[i];
      slotColor = slot._color;
      if (!slot._visible || !slot._displayData) continue;

      if (parentMat) {
        slot._mulMat(slot._worldMatrix, parentMat, slot._matrix);
      } else {
        _mat["default"].copy(slot._worldMatrix, slot._matrix);
      }

      if (slot.childArmature) {
        this.realTimeTraverse(slot.childArmature, slot._worldMatrix, parentOpacity * slotColor.a / 255);
        continue;
      }

      material = _getSlotMaterial(slot.getTexture(), slot._blendMode);

      if (!material) {
        continue;
      }

      if (_mustFlush || material.getHash() !== _renderer.material.getHash()) {
        _mustFlush = false;

        _renderer._flush();

        _renderer.node = _node;
        _renderer.material = material;
      }

      _handleColor(slotColor, parentOpacity);

      slotMat = slot._worldMatrix;
      slotMatm = slotMat.m;
      vertices = slot._localVertices;
      _vertexCount = vertices.length >> 2;
      indices = slot._indices;
      _indexCount = indices.length;
      offsetInfo = _buffer.request(_vertexCount, _indexCount);
      _indexOffset = offsetInfo.indiceOffset;
      _vfOffset = offsetInfo.byteOffset >> 2;
      _vertexOffset = offsetInfo.vertexOffset;
      vbuf = _buffer._vData;
      ibuf = _buffer._iData;
      uintbuf = _buffer._uintVData;
      _m00 = slotMatm[0];
      _m04 = slotMatm[4];
      _m12 = slotMatm[12];
      _m01 = slotMatm[1];
      _m05 = slotMatm[5];
      _m13 = slotMatm[13];

      for (var vi = 0, vl = vertices.length; vi < vl;) {
        _x = vertices[vi++];
        _y = vertices[vi++];
        vbuf[_vfOffset++] = _x * _m00 + _y * _m04 + _m12; // x

        vbuf[_vfOffset++] = _x * _m01 + _y * _m05 + _m13; // y

        vbuf[_vfOffset++] = vertices[vi++]; // u

        vbuf[_vfOffset++] = vertices[vi++]; // v

        uintbuf[_vfOffset++] = _c; // color
      }

      for (var ii = 0, il = indices.length; ii < il; ii++) {
        ibuf[_indexOffset++] = _vertexOffset + indices[ii];
      }
    }
  };

  _proto.cacheTraverse = function cacheTraverse(frame, parentMat) {
    if (!frame) return;
    var segments = frame.segments;
    if (segments.length == 0) return;
    var vbuf, ibuf, uintbuf;
    var material;
    var offsetInfo;
    var vertices = frame.vertices;
    var indices = frame.indices;
    var frameVFOffset = 0,
        frameIndexOffset = 0,
        segVFCount = 0;

    if (parentMat) {
      var parentMatm = parentMat.m;
      _m00 = parentMatm[0];
      _m01 = parentMatm[1];
      _m04 = parentMatm[4];
      _m05 = parentMatm[5];
      _m12 = parentMatm[12];
      _m13 = parentMatm[13];
    }

    var justTranslate = _m00 === 1 && _m01 === 0 && _m04 === 0 && _m05 === 1;
    var needBatch = _handleVal & NEED_BATCH;
    var calcTranslate = needBatch && justTranslate;
    var colorOffset = 0;
    var colors = frame.colors;
    var nowColor = colors[colorOffset++];
    var maxVFOffset = nowColor.vfOffset;

    _handleColor(nowColor, 1.0);

    for (var i = 0, n = segments.length; i < n; i++) {
      var segInfo = segments[i];
      material = _getSlotMaterial(segInfo.tex, segInfo.blendMode);

      if (_mustFlush || material.getHash() !== _renderer.material.getHash()) {
        _mustFlush = false;

        _renderer._flush();

        _renderer.node = _node;
        _renderer.material = material;
      }

      _vertexCount = segInfo.vertexCount;
      _indexCount = segInfo.indexCount;
      offsetInfo = _buffer.request(_vertexCount, _indexCount);
      _indexOffset = offsetInfo.indiceOffset;
      _vertexOffset = offsetInfo.vertexOffset;
      _vfOffset = offsetInfo.byteOffset >> 2;
      vbuf = _buffer._vData;
      ibuf = _buffer._iData;
      uintbuf = _buffer._uintVData;

      for (var ii = _indexOffset, il = _indexOffset + _indexCount; ii < il; ii++) {
        ibuf[ii] = _vertexOffset + indices[frameIndexOffset++];
      }

      segVFCount = segInfo.vfCount;
      vbuf.set(vertices.subarray(frameVFOffset, frameVFOffset + segVFCount), _vfOffset);
      frameVFOffset += segVFCount;

      if (calcTranslate) {
        for (var _ii = _vfOffset, _il = _vfOffset + segVFCount; _ii < _il; _ii += 5) {
          vbuf[_ii] += _m12;
          vbuf[_ii + 1] += _m13;
        }
      } else if (needBatch) {
        for (var _ii2 = _vfOffset, _il2 = _vfOffset + segVFCount; _ii2 < _il2; _ii2 += 5) {
          _x = vbuf[_ii2];
          _y = vbuf[_ii2 + 1];
          vbuf[_ii2] = _x * _m00 + _y * _m04 + _m12;
          vbuf[_ii2 + 1] = _x * _m01 + _y * _m05 + _m13;
        }
      }

      if (!(_handleVal & NEED_COLOR)) continue; // handle color

      var frameColorOffset = frameVFOffset - segVFCount;

      for (var _ii3 = _vfOffset + 4, _il3 = _vfOffset + 4 + segVFCount; _ii3 < _il3; _ii3 += 5, frameColorOffset += 5) {
        if (frameColorOffset >= maxVFOffset) {
          nowColor = colors[colorOffset++];

          _handleColor(nowColor, 1.0);

          maxVFOffset = nowColor.vfOffset;
        }

        uintbuf[_ii3] = _c;
      }
    }
  };

  _proto.fillBuffers = function fillBuffers(comp, renderer) {
    comp.node._renderFlag |= RenderFlow.FLAG_UPDATE_RENDER_DATA;
    var armature = comp._armature;
    if (!armature) return; // Init temp var.

    _mustFlush = true;
    _premultipliedAlpha = comp.premultipliedAlpha;
    _node = comp.node;
    _buffer = renderer._meshBuffer;
    _renderer = renderer;
    _comp = comp;
    _handleVal = 0;
    var nodeColor = _node._color;
    _nodeR = nodeColor.r / 255;
    _nodeG = nodeColor.g / 255;
    _nodeB = nodeColor.b / 255;
    _nodeA = nodeColor.a / 255;

    if (nodeColor._val !== 0xffffffff) {
      _handleVal |= NEED_COLOR;
    }

    var worldMat = undefined;

    if (_comp.enableBatch) {
      worldMat = _node._worldMatrix;
      _mustFlush = false;
      _handleVal |= NEED_BATCH;
    }

    if (comp.isAnimationCached()) {
      // Traverse input assembler.
      this.cacheTraverse(comp._curFrame, worldMat);
    } else {
      // Traverse all armature.
      this.realTimeTraverse(armature, worldMat, 1.0);
      var graphics = comp._debugDraw;

      if (comp.debugBones && graphics) {
        graphics.clear();
        graphics.lineWidth = 5;
        graphics.strokeColor = _boneColor;
        graphics.fillColor = _slotColor; // Root bone color is same as slot color.

        var bones = armature.getBones();

        for (var i = 0, l = bones.length; i < l; i++) {
          var bone = bones[i];
          var boneLength = Math.max(bone.boneData.length, 5);
          var startX = bone.globalTransformMatrix.tx;
          var startY = bone.globalTransformMatrix.ty;
          var endX = startX + bone.globalTransformMatrix.a * boneLength;
          var endY = startY + bone.globalTransformMatrix.b * boneLength;
          graphics.moveTo(startX, startY);
          graphics.lineTo(endX, endY);
          graphics.stroke(); // Bone origins.

          graphics.circle(startX, startY, Math.PI * 2);
          graphics.fill();

          if (i === 0) {
            graphics.fillColor = _originColor;
          }
        }
      }
    } // sync attached node matrix


    renderer.worldMatDirty++;

    comp.attachUtil._syncAttachedNode(); // Clear temp var.


    _node = undefined;
    _buffer = undefined;
    _renderer = undefined;
    _comp = undefined;
  };

  _proto.postFillBuffers = function postFillBuffers(comp, renderer) {
    renderer.worldMatDirty--;
  };

  return ArmatureAssembler;
}(_assembler["default"]);

exports["default"] = ArmatureAssembler;

_assembler["default"].register(Armature, ArmatureAssembler);

module.exports = exports["default"];
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_engine__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImVuZ2luZS1kZXYvZXh0ZW5zaW9ucy9kcmFnb25ib25lcy93ZWJnbC1hc3NlbWJsZXIuanMiXSwibmFtZXMiOlsiQXJtYXR1cmUiLCJyZXF1aXJlIiwiUmVuZGVyRmxvdyIsImdmeCIsImNjIiwiTkVFRF9DT0xPUiIsIk5FRURfQkFUQ0giLCJfYm9uZUNvbG9yIiwiY29sb3IiLCJfc2xvdENvbG9yIiwiX29yaWdpbkNvbG9yIiwiX25vZGVSIiwiX25vZGVHIiwiX25vZGVCIiwiX25vZGVBIiwiX3ByZW11bHRpcGxpZWRBbHBoYSIsIl9tdWx0aXBseSIsIl9tdXN0Rmx1c2giLCJfYnVmZmVyIiwiX25vZGUiLCJfcmVuZGVyZXIiLCJfY29tcCIsIl92Zk9mZnNldCIsIl9pbmRleE9mZnNldCIsIl92ZXJ0ZXhPZmZzZXQiLCJfdmVydGV4Q291bnQiLCJfaW5kZXhDb3VudCIsIl94IiwiX3kiLCJfYyIsIl9yIiwiX2ciLCJfYiIsIl9hIiwiX2hhbmRsZVZhbCIsIl9tMDAiLCJfbTA0IiwiX20xMiIsIl9tMDEiLCJfbTA1IiwiX20xMyIsIl9nZXRTbG90TWF0ZXJpYWwiLCJ0ZXgiLCJibGVuZE1vZGUiLCJzcmMiLCJkc3QiLCJtYWNybyIsIk9ORSIsIlNSQ19BTFBIQSIsIkRTVF9DT0xPUiIsIk9ORV9NSU5VU19TUkNfQUxQSEEiLCJPTkVfTUlOVVNfU1JDX0NPTE9SIiwidXNlTW9kZWwiLCJlbmFibGVCYXRjaCIsImJhc2VNYXRlcmlhbCIsIl9tYXRlcmlhbHMiLCJtYXRlcmlhbENhY2hlIiwiX21hdGVyaWFsQ2FjaGUiLCJrZXkiLCJnZXRJZCIsIm1hdGVyaWFsIiwiTWF0ZXJpYWxWYXJpYW50IiwiY3JlYXRlIiwiZGVmaW5lIiwic2V0UHJvcGVydHkiLCJzZXRCbGVuZCIsIkJMRU5EX0ZVTkNfQUREIiwiX2hhbmRsZUNvbG9yIiwicGFyZW50T3BhY2l0eSIsImEiLCJyIiwiZyIsImIiLCJBcm1hdHVyZUFzc2VtYmxlciIsInVwZGF0ZVJlbmRlckRhdGEiLCJjb21wIiwiYmF0Y2hEYXRhIiwicmVhbFRpbWVUcmF2ZXJzZSIsImFybWF0dXJlIiwicGFyZW50TWF0Iiwic2xvdHMiLCJfc2xvdHMiLCJ2YnVmIiwiaWJ1ZiIsInVpbnRidWYiLCJ2ZXJ0aWNlcyIsImluZGljZXMiLCJzbG90Q29sb3IiLCJzbG90Iiwic2xvdE1hdCIsInNsb3RNYXRtIiwib2Zmc2V0SW5mbyIsImkiLCJsIiwibGVuZ3RoIiwiX2NvbG9yIiwiX3Zpc2libGUiLCJfZGlzcGxheURhdGEiLCJfbXVsTWF0IiwiX3dvcmxkTWF0cml4IiwiX21hdHJpeCIsIk1hdDQiLCJjb3B5IiwiY2hpbGRBcm1hdHVyZSIsImdldFRleHR1cmUiLCJfYmxlbmRNb2RlIiwiZ2V0SGFzaCIsIl9mbHVzaCIsIm5vZGUiLCJtIiwiX2xvY2FsVmVydGljZXMiLCJfaW5kaWNlcyIsInJlcXVlc3QiLCJpbmRpY2VPZmZzZXQiLCJieXRlT2Zmc2V0IiwidmVydGV4T2Zmc2V0IiwiX3ZEYXRhIiwiX2lEYXRhIiwiX3VpbnRWRGF0YSIsInZpIiwidmwiLCJpaSIsImlsIiwiY2FjaGVUcmF2ZXJzZSIsImZyYW1lIiwic2VnbWVudHMiLCJmcmFtZVZGT2Zmc2V0IiwiZnJhbWVJbmRleE9mZnNldCIsInNlZ1ZGQ291bnQiLCJwYXJlbnRNYXRtIiwianVzdFRyYW5zbGF0ZSIsIm5lZWRCYXRjaCIsImNhbGNUcmFuc2xhdGUiLCJjb2xvck9mZnNldCIsImNvbG9ycyIsIm5vd0NvbG9yIiwibWF4VkZPZmZzZXQiLCJ2Zk9mZnNldCIsIm4iLCJzZWdJbmZvIiwidmVydGV4Q291bnQiLCJpbmRleENvdW50IiwidmZDb3VudCIsInNldCIsInN1YmFycmF5IiwiZnJhbWVDb2xvck9mZnNldCIsImZpbGxCdWZmZXJzIiwicmVuZGVyZXIiLCJfcmVuZGVyRmxhZyIsIkZMQUdfVVBEQVRFX1JFTkRFUl9EQVRBIiwiX2FybWF0dXJlIiwicHJlbXVsdGlwbGllZEFscGhhIiwiX21lc2hCdWZmZXIiLCJub2RlQ29sb3IiLCJfdmFsIiwid29ybGRNYXQiLCJ1bmRlZmluZWQiLCJpc0FuaW1hdGlvbkNhY2hlZCIsIl9jdXJGcmFtZSIsImdyYXBoaWNzIiwiX2RlYnVnRHJhdyIsImRlYnVnQm9uZXMiLCJjbGVhciIsImxpbmVXaWR0aCIsInN0cm9rZUNvbG9yIiwiZmlsbENvbG9yIiwiYm9uZXMiLCJnZXRCb25lcyIsImJvbmUiLCJib25lTGVuZ3RoIiwiTWF0aCIsIm1heCIsImJvbmVEYXRhIiwic3RhcnRYIiwiZ2xvYmFsVHJhbnNmb3JtTWF0cml4IiwidHgiLCJzdGFydFkiLCJ0eSIsImVuZFgiLCJlbmRZIiwibW92ZVRvIiwibGluZVRvIiwic3Ryb2tlIiwiY2lyY2xlIiwiUEkiLCJmaWxsIiwid29ybGRNYXREaXJ0eSIsImF0dGFjaFV0aWwiLCJfc3luY0F0dGFjaGVkTm9kZSIsInBvc3RGaWxsQnVmZmVycyIsIkFzc2VtYmxlciIsInJlZ2lzdGVyIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBeUJBOztBQUNBOzs7Ozs7QUFFQSxJQUFNQSxRQUFRLEdBQUdDLE9BQU8sQ0FBQyxtQkFBRCxDQUF4Qjs7QUFDQSxJQUFNQyxVQUFVLEdBQUdELE9BQU8sQ0FBQyx5Q0FBRCxDQUExQjs7QUFDQSxJQUFNRSxHQUFHLEdBQUdDLEVBQUUsQ0FBQ0QsR0FBZjtBQUNBLElBQU1FLFVBQVUsR0FBRyxJQUFuQjtBQUNBLElBQU1DLFVBQVUsR0FBRyxJQUFuQjs7QUFFQSxJQUFJQyxVQUFVLEdBQUdILEVBQUUsQ0FBQ0ksS0FBSCxDQUFTLEdBQVQsRUFBYyxDQUFkLEVBQWlCLENBQWpCLEVBQW9CLEdBQXBCLENBQWpCOztBQUNBLElBQUlDLFVBQVUsR0FBR0wsRUFBRSxDQUFDSSxLQUFILENBQVMsQ0FBVCxFQUFZLENBQVosRUFBZSxHQUFmLEVBQW9CLEdBQXBCLENBQWpCOztBQUNBLElBQUlFLFlBQVksR0FBR04sRUFBRSxDQUFDSSxLQUFILENBQVMsQ0FBVCxFQUFZLEdBQVosRUFBaUIsQ0FBakIsRUFBb0IsR0FBcEIsQ0FBbkI7O0FBRUEsSUFBSUcsTUFBSixFQUFZQyxNQUFaLEVBQW9CQyxNQUFwQixFQUE0QkMsTUFBNUIsRUFDSUMsbUJBREosRUFDeUJDLFNBRHpCLEVBRUlDLFVBRkosRUFFZ0JDLE9BRmhCLEVBRXlCQyxLQUZ6QixFQUdJQyxTQUhKLEVBR2VDLEtBSGYsRUFJSUMsU0FKSixFQUllQyxZQUpmLEVBSTZCQyxhQUo3QixFQUtJQyxZQUxKLEVBS2tCQyxXQUxsQixFQU1JQyxFQU5KLEVBTVFDLEVBTlIsRUFNWUMsRUFOWixFQU1nQkMsRUFOaEIsRUFNb0JDLEVBTnBCLEVBTXdCQyxFQU54QixFQU00QkMsRUFONUIsRUFNZ0NDLFVBTmhDLEVBT0lDLElBUEosRUFPVUMsSUFQVixFQU9nQkMsSUFQaEIsRUFRSUMsSUFSSixFQVFVQyxJQVJWLEVBUWdCQyxJQVJoQjs7QUFVQSxTQUFTQyxnQkFBVCxDQUEyQkMsR0FBM0IsRUFBZ0NDLFNBQWhDLEVBQTJDO0FBQ3ZDLE1BQUcsQ0FBQ0QsR0FBSixFQUFRLE9BQU8sSUFBUDtBQUVSLE1BQUlFLEdBQUosRUFBU0MsR0FBVDs7QUFDQSxVQUFRRixTQUFSO0FBQ0ksU0FBSyxDQUFMO0FBQU87QUFDSEMsTUFBQUEsR0FBRyxHQUFHN0IsbUJBQW1CLEdBQUdYLEVBQUUsQ0FBQzBDLEtBQUgsQ0FBU0MsR0FBWixHQUFrQjNDLEVBQUUsQ0FBQzBDLEtBQUgsQ0FBU0UsU0FBcEQ7QUFDQUgsTUFBQUEsR0FBRyxHQUFHekMsRUFBRSxDQUFDMEMsS0FBSCxDQUFTQyxHQUFmO0FBQ0E7O0FBQ0osU0FBSyxFQUFMO0FBQVE7QUFDSkgsTUFBQUEsR0FBRyxHQUFHeEMsRUFBRSxDQUFDMEMsS0FBSCxDQUFTRyxTQUFmO0FBQ0FKLE1BQUFBLEdBQUcsR0FBR3pDLEVBQUUsQ0FBQzBDLEtBQUgsQ0FBU0ksbUJBQWY7QUFDQTs7QUFDSixTQUFLLEVBQUw7QUFBUTtBQUNKTixNQUFBQSxHQUFHLEdBQUd4QyxFQUFFLENBQUMwQyxLQUFILENBQVNDLEdBQWY7QUFDQUYsTUFBQUEsR0FBRyxHQUFHekMsRUFBRSxDQUFDMEMsS0FBSCxDQUFTSyxtQkFBZjtBQUNBOztBQUNKLFNBQUssQ0FBTCxDQWJKLENBYVc7O0FBQ1A7QUFDSVAsTUFBQUEsR0FBRyxHQUFHN0IsbUJBQW1CLEdBQUdYLEVBQUUsQ0FBQzBDLEtBQUgsQ0FBU0MsR0FBWixHQUFrQjNDLEVBQUUsQ0FBQzBDLEtBQUgsQ0FBU0UsU0FBcEQ7QUFDQUgsTUFBQUEsR0FBRyxHQUFHekMsRUFBRSxDQUFDMEMsS0FBSCxDQUFTSSxtQkFBZjtBQUNBO0FBakJSOztBQW9CQSxNQUFJRSxRQUFRLEdBQUcsQ0FBQy9CLEtBQUssQ0FBQ2dDLFdBQXRCO0FBQ0EsTUFBSUMsWUFBWSxHQUFHakMsS0FBSyxDQUFDa0MsVUFBTixDQUFpQixDQUFqQixDQUFuQjs7QUFDQSxNQUFJLENBQUNELFlBQUwsRUFBbUI7QUFDZixXQUFPLElBQVA7QUFDSDs7QUFDRCxNQUFJRSxhQUFhLEdBQUduQyxLQUFLLENBQUNvQyxjQUExQixDQTdCdUMsQ0ErQnZDOztBQUNBLE1BQUlDLEdBQUcsR0FBR2hCLEdBQUcsQ0FBQ2lCLEtBQUosS0FBY2YsR0FBZCxHQUFvQkMsR0FBcEIsR0FBMEJPLFFBQXBDO0FBQ0EsTUFBSVEsUUFBUSxHQUFHSixhQUFhLENBQUNFLEdBQUQsQ0FBNUI7O0FBQ0EsTUFBSSxDQUFDRSxRQUFMLEVBQWU7QUFDWCxRQUFJLENBQUNKLGFBQWEsQ0FBQ0YsWUFBbkIsRUFBaUM7QUFDN0JNLE1BQUFBLFFBQVEsR0FBR04sWUFBWDtBQUNBRSxNQUFBQSxhQUFhLENBQUNGLFlBQWQsR0FBNkJBLFlBQTdCO0FBQ0gsS0FIRCxNQUdPO0FBQ0hNLE1BQUFBLFFBQVEsR0FBR3hELEVBQUUsQ0FBQ3lELGVBQUgsQ0FBbUJDLE1BQW5CLENBQTBCUixZQUExQixDQUFYO0FBQ0g7O0FBRURNLElBQUFBLFFBQVEsQ0FBQ0csTUFBVCxDQUFnQixjQUFoQixFQUFnQ1gsUUFBaEM7QUFDQVEsSUFBQUEsUUFBUSxDQUFDSSxXQUFULENBQXFCLFNBQXJCLEVBQWdDdEIsR0FBaEMsRUFUVyxDQVdYOztBQUNBa0IsSUFBQUEsUUFBUSxDQUFDSyxRQUFULENBQ0ksSUFESixFQUVJOUQsR0FBRyxDQUFDK0QsY0FGUixFQUdJdEIsR0FISixFQUdTQyxHQUhULEVBSUkxQyxHQUFHLENBQUMrRCxjQUpSLEVBS0l0QixHQUxKLEVBS1NDLEdBTFQ7QUFPQVcsSUFBQUEsYUFBYSxDQUFDRSxHQUFELENBQWIsR0FBcUJFLFFBQXJCO0FBQ0g7O0FBQ0QsU0FBT0EsUUFBUDtBQUNIOztBQUVELFNBQVNPLFlBQVQsQ0FBdUIzRCxLQUF2QixFQUE4QjRELGFBQTlCLEVBQTZDO0FBQ3pDbkMsRUFBQUEsRUFBRSxHQUFHekIsS0FBSyxDQUFDNkQsQ0FBTixHQUFVRCxhQUFWLEdBQTBCdEQsTUFBL0I7QUFDQUUsRUFBQUEsU0FBUyxHQUFHRCxtQkFBbUIsR0FBRWtCLEVBQUUsR0FBRyxLQUFQLEdBQWUsR0FBOUM7QUFDQUgsRUFBQUEsRUFBRSxHQUFHdEIsS0FBSyxDQUFDOEQsQ0FBTixHQUFVM0QsTUFBVixHQUFtQkssU0FBeEI7QUFDQWUsRUFBQUEsRUFBRSxHQUFHdkIsS0FBSyxDQUFDK0QsQ0FBTixHQUFVM0QsTUFBVixHQUFtQkksU0FBeEI7QUFDQWdCLEVBQUFBLEVBQUUsR0FBR3hCLEtBQUssQ0FBQ2dFLENBQU4sR0FBVTNELE1BQVYsR0FBbUJHLFNBQXhCO0FBQ0FhLEVBQUFBLEVBQUUsR0FBRyxDQUFFSSxFQUFFLElBQUUsRUFBTCxLQUFhLENBQWQsS0FBb0JELEVBQUUsSUFBRSxFQUF4QixLQUErQkQsRUFBRSxJQUFFLENBQW5DLElBQXdDRCxFQUE3QztBQUNIOztJQUVvQjJDOzs7Ozs7Ozs7U0FDakJDLG1CQUFBLDBCQUFrQkMsSUFBbEIsRUFBd0JDLFNBQXhCLEVBQW1DLENBQUU7O1NBRXJDQyxtQkFBQSwwQkFBa0JDLFFBQWxCLEVBQTRCQyxTQUE1QixFQUF1Q1gsYUFBdkMsRUFBc0Q7QUFDbEQsUUFBSVksS0FBSyxHQUFHRixRQUFRLENBQUNHLE1BQXJCO0FBQ0EsUUFBSUMsSUFBSixFQUFVQyxJQUFWLEVBQWdCQyxPQUFoQjtBQUNBLFFBQUl4QixRQUFKO0FBQ0EsUUFBSXlCLFFBQUosRUFBY0MsT0FBZDtBQUNBLFFBQUlDLFNBQUo7QUFDQSxRQUFJQyxJQUFKO0FBQ0EsUUFBSUMsT0FBSjtBQUNBLFFBQUlDLFFBQUo7QUFDQSxRQUFJQyxVQUFKOztBQUVBLFNBQUssSUFBSUMsQ0FBQyxHQUFHLENBQVIsRUFBV0MsQ0FBQyxHQUFHYixLQUFLLENBQUNjLE1BQTFCLEVBQWtDRixDQUFDLEdBQUdDLENBQXRDLEVBQXlDRCxDQUFDLEVBQTFDLEVBQThDO0FBQzFDSixNQUFBQSxJQUFJLEdBQUdSLEtBQUssQ0FBQ1ksQ0FBRCxDQUFaO0FBQ0FMLE1BQUFBLFNBQVMsR0FBR0MsSUFBSSxDQUFDTyxNQUFqQjtBQUVBLFVBQUksQ0FBQ1AsSUFBSSxDQUFDUSxRQUFOLElBQWtCLENBQUNSLElBQUksQ0FBQ1MsWUFBNUIsRUFBMEM7O0FBRTFDLFVBQUlsQixTQUFKLEVBQWU7QUFDWFMsUUFBQUEsSUFBSSxDQUFDVSxPQUFMLENBQWFWLElBQUksQ0FBQ1csWUFBbEIsRUFBZ0NwQixTQUFoQyxFQUEyQ1MsSUFBSSxDQUFDWSxPQUFoRDtBQUNILE9BRkQsTUFFTztBQUNIQyx3QkFBS0MsSUFBTCxDQUFVZCxJQUFJLENBQUNXLFlBQWYsRUFBNkJYLElBQUksQ0FBQ1ksT0FBbEM7QUFDSDs7QUFFRCxVQUFJWixJQUFJLENBQUNlLGFBQVQsRUFBd0I7QUFDcEIsYUFBSzFCLGdCQUFMLENBQXNCVyxJQUFJLENBQUNlLGFBQTNCLEVBQTBDZixJQUFJLENBQUNXLFlBQS9DLEVBQTZEL0IsYUFBYSxHQUFHbUIsU0FBUyxDQUFDbEIsQ0FBMUIsR0FBOEIsR0FBM0Y7QUFDQTtBQUNIOztBQUVEVCxNQUFBQSxRQUFRLEdBQUduQixnQkFBZ0IsQ0FBQytDLElBQUksQ0FBQ2dCLFVBQUwsRUFBRCxFQUFvQmhCLElBQUksQ0FBQ2lCLFVBQXpCLENBQTNCOztBQUNBLFVBQUksQ0FBQzdDLFFBQUwsRUFBZTtBQUNYO0FBQ0g7O0FBRUQsVUFBSTNDLFVBQVUsSUFBSTJDLFFBQVEsQ0FBQzhDLE9BQVQsT0FBdUJ0RixTQUFTLENBQUN3QyxRQUFWLENBQW1COEMsT0FBbkIsRUFBekMsRUFBdUU7QUFDbkV6RixRQUFBQSxVQUFVLEdBQUcsS0FBYjs7QUFDQUcsUUFBQUEsU0FBUyxDQUFDdUYsTUFBVjs7QUFDQXZGLFFBQUFBLFNBQVMsQ0FBQ3dGLElBQVYsR0FBaUJ6RixLQUFqQjtBQUNBQyxRQUFBQSxTQUFTLENBQUN3QyxRQUFWLEdBQXFCQSxRQUFyQjtBQUNIOztBQUVETyxNQUFBQSxZQUFZLENBQUNvQixTQUFELEVBQVluQixhQUFaLENBQVo7O0FBQ0FxQixNQUFBQSxPQUFPLEdBQUdELElBQUksQ0FBQ1csWUFBZjtBQUNBVCxNQUFBQSxRQUFRLEdBQUdELE9BQU8sQ0FBQ29CLENBQW5CO0FBRUF4QixNQUFBQSxRQUFRLEdBQUdHLElBQUksQ0FBQ3NCLGNBQWhCO0FBQ0FyRixNQUFBQSxZQUFZLEdBQUc0RCxRQUFRLENBQUNTLE1BQVQsSUFBbUIsQ0FBbEM7QUFFQVIsTUFBQUEsT0FBTyxHQUFHRSxJQUFJLENBQUN1QixRQUFmO0FBQ0FyRixNQUFBQSxXQUFXLEdBQUc0RCxPQUFPLENBQUNRLE1BQXRCO0FBRUFILE1BQUFBLFVBQVUsR0FBR3pFLE9BQU8sQ0FBQzhGLE9BQVIsQ0FBZ0J2RixZQUFoQixFQUE4QkMsV0FBOUIsQ0FBYjtBQUNBSCxNQUFBQSxZQUFZLEdBQUdvRSxVQUFVLENBQUNzQixZQUExQjtBQUNBM0YsTUFBQUEsU0FBUyxHQUFHcUUsVUFBVSxDQUFDdUIsVUFBWCxJQUF5QixDQUFyQztBQUNBMUYsTUFBQUEsYUFBYSxHQUFHbUUsVUFBVSxDQUFDd0IsWUFBM0I7QUFDQWpDLE1BQUFBLElBQUksR0FBR2hFLE9BQU8sQ0FBQ2tHLE1BQWY7QUFDQWpDLE1BQUFBLElBQUksR0FBR2pFLE9BQU8sQ0FBQ21HLE1BQWY7QUFDQWpDLE1BQUFBLE9BQU8sR0FBR2xFLE9BQU8sQ0FBQ29HLFVBQWxCO0FBRUFuRixNQUFBQSxJQUFJLEdBQUd1RCxRQUFRLENBQUMsQ0FBRCxDQUFmO0FBQ0F0RCxNQUFBQSxJQUFJLEdBQUdzRCxRQUFRLENBQUMsQ0FBRCxDQUFmO0FBQ0FyRCxNQUFBQSxJQUFJLEdBQUdxRCxRQUFRLENBQUMsRUFBRCxDQUFmO0FBQ0FwRCxNQUFBQSxJQUFJLEdBQUdvRCxRQUFRLENBQUMsQ0FBRCxDQUFmO0FBQ0FuRCxNQUFBQSxJQUFJLEdBQUdtRCxRQUFRLENBQUMsQ0FBRCxDQUFmO0FBQ0FsRCxNQUFBQSxJQUFJLEdBQUdrRCxRQUFRLENBQUMsRUFBRCxDQUFmOztBQUVBLFdBQUssSUFBSTZCLEVBQUUsR0FBRyxDQUFULEVBQVlDLEVBQUUsR0FBR25DLFFBQVEsQ0FBQ1MsTUFBL0IsRUFBdUN5QixFQUFFLEdBQUdDLEVBQTVDLEdBQWlEO0FBQzdDN0YsUUFBQUEsRUFBRSxHQUFHMEQsUUFBUSxDQUFDa0MsRUFBRSxFQUFILENBQWI7QUFDQTNGLFFBQUFBLEVBQUUsR0FBR3lELFFBQVEsQ0FBQ2tDLEVBQUUsRUFBSCxDQUFiO0FBRUFyQyxRQUFBQSxJQUFJLENBQUM1RCxTQUFTLEVBQVYsQ0FBSixHQUFvQkssRUFBRSxHQUFHUSxJQUFMLEdBQVlQLEVBQUUsR0FBR1EsSUFBakIsR0FBd0JDLElBQTVDLENBSjZDLENBSUs7O0FBQ2xENkMsUUFBQUEsSUFBSSxDQUFDNUQsU0FBUyxFQUFWLENBQUosR0FBb0JLLEVBQUUsR0FBR1csSUFBTCxHQUFZVixFQUFFLEdBQUdXLElBQWpCLEdBQXdCQyxJQUE1QyxDQUw2QyxDQUtLOztBQUVsRDBDLFFBQUFBLElBQUksQ0FBQzVELFNBQVMsRUFBVixDQUFKLEdBQW9CK0QsUUFBUSxDQUFDa0MsRUFBRSxFQUFILENBQTVCLENBUDZDLENBT1Q7O0FBQ3BDckMsUUFBQUEsSUFBSSxDQUFDNUQsU0FBUyxFQUFWLENBQUosR0FBb0IrRCxRQUFRLENBQUNrQyxFQUFFLEVBQUgsQ0FBNUIsQ0FSNkMsQ0FRVDs7QUFDcENuQyxRQUFBQSxPQUFPLENBQUM5RCxTQUFTLEVBQVYsQ0FBUCxHQUF1Qk8sRUFBdkIsQ0FUNkMsQ0FTbEI7QUFDOUI7O0FBRUQsV0FBSyxJQUFJNEYsRUFBRSxHQUFHLENBQVQsRUFBWUMsRUFBRSxHQUFHcEMsT0FBTyxDQUFDUSxNQUE5QixFQUFzQzJCLEVBQUUsR0FBR0MsRUFBM0MsRUFBK0NELEVBQUUsRUFBakQsRUFBc0Q7QUFDbER0QyxRQUFBQSxJQUFJLENBQUM1RCxZQUFZLEVBQWIsQ0FBSixHQUF1QkMsYUFBYSxHQUFHOEQsT0FBTyxDQUFDbUMsRUFBRCxDQUE5QztBQUNIO0FBQ0o7QUFDSjs7U0FFREUsZ0JBQUEsdUJBQWVDLEtBQWYsRUFBc0I3QyxTQUF0QixFQUFpQztBQUM3QixRQUFJLENBQUM2QyxLQUFMLEVBQVk7QUFDWixRQUFJQyxRQUFRLEdBQUdELEtBQUssQ0FBQ0MsUUFBckI7QUFDQSxRQUFJQSxRQUFRLENBQUMvQixNQUFULElBQW1CLENBQXZCLEVBQTBCO0FBRTFCLFFBQUlaLElBQUosRUFBVUMsSUFBVixFQUFnQkMsT0FBaEI7QUFDQSxRQUFJeEIsUUFBSjtBQUNBLFFBQUkrQixVQUFKO0FBQ0EsUUFBSU4sUUFBUSxHQUFHdUMsS0FBSyxDQUFDdkMsUUFBckI7QUFDQSxRQUFJQyxPQUFPLEdBQUdzQyxLQUFLLENBQUN0QyxPQUFwQjtBQUVBLFFBQUl3QyxhQUFhLEdBQUcsQ0FBcEI7QUFBQSxRQUF1QkMsZ0JBQWdCLEdBQUcsQ0FBMUM7QUFBQSxRQUE2Q0MsVUFBVSxHQUFHLENBQTFEOztBQUNBLFFBQUlqRCxTQUFKLEVBQWU7QUFDWCxVQUFJa0QsVUFBVSxHQUFHbEQsU0FBUyxDQUFDOEIsQ0FBM0I7QUFDQTFFLE1BQUFBLElBQUksR0FBRzhGLFVBQVUsQ0FBQyxDQUFELENBQWpCO0FBQ0EzRixNQUFBQSxJQUFJLEdBQUcyRixVQUFVLENBQUMsQ0FBRCxDQUFqQjtBQUNBN0YsTUFBQUEsSUFBSSxHQUFHNkYsVUFBVSxDQUFDLENBQUQsQ0FBakI7QUFDQTFGLE1BQUFBLElBQUksR0FBRzBGLFVBQVUsQ0FBQyxDQUFELENBQWpCO0FBQ0E1RixNQUFBQSxJQUFJLEdBQUc0RixVQUFVLENBQUMsRUFBRCxDQUFqQjtBQUNBekYsTUFBQUEsSUFBSSxHQUFHeUYsVUFBVSxDQUFDLEVBQUQsQ0FBakI7QUFDSDs7QUFFRCxRQUFJQyxhQUFhLEdBQUcvRixJQUFJLEtBQUssQ0FBVCxJQUFjRyxJQUFJLEtBQUssQ0FBdkIsSUFBNEJGLElBQUksS0FBSyxDQUFyQyxJQUEwQ0csSUFBSSxLQUFLLENBQXZFO0FBQ0EsUUFBSTRGLFNBQVMsR0FBSWpHLFVBQVUsR0FBRzVCLFVBQTlCO0FBQ0EsUUFBSThILGFBQWEsR0FBR0QsU0FBUyxJQUFJRCxhQUFqQztBQUVBLFFBQUlHLFdBQVcsR0FBRyxDQUFsQjtBQUNBLFFBQUlDLE1BQU0sR0FBR1YsS0FBSyxDQUFDVSxNQUFuQjtBQUNBLFFBQUlDLFFBQVEsR0FBR0QsTUFBTSxDQUFDRCxXQUFXLEVBQVosQ0FBckI7QUFDQSxRQUFJRyxXQUFXLEdBQUdELFFBQVEsQ0FBQ0UsUUFBM0I7O0FBQ0F0RSxJQUFBQSxZQUFZLENBQUNvRSxRQUFELEVBQVcsR0FBWCxDQUFaOztBQUVBLFNBQUssSUFBSTNDLENBQUMsR0FBRyxDQUFSLEVBQVc4QyxDQUFDLEdBQUdiLFFBQVEsQ0FBQy9CLE1BQTdCLEVBQXFDRixDQUFDLEdBQUc4QyxDQUF6QyxFQUE0QzlDLENBQUMsRUFBN0MsRUFBaUQ7QUFDN0MsVUFBSStDLE9BQU8sR0FBR2QsUUFBUSxDQUFDakMsQ0FBRCxDQUF0QjtBQUNBaEMsTUFBQUEsUUFBUSxHQUFHbkIsZ0JBQWdCLENBQUNrRyxPQUFPLENBQUNqRyxHQUFULEVBQWNpRyxPQUFPLENBQUNoRyxTQUF0QixDQUEzQjs7QUFDQSxVQUFJMUIsVUFBVSxJQUFJMkMsUUFBUSxDQUFDOEMsT0FBVCxPQUF1QnRGLFNBQVMsQ0FBQ3dDLFFBQVYsQ0FBbUI4QyxPQUFuQixFQUF6QyxFQUF1RTtBQUNuRXpGLFFBQUFBLFVBQVUsR0FBRyxLQUFiOztBQUNBRyxRQUFBQSxTQUFTLENBQUN1RixNQUFWOztBQUNBdkYsUUFBQUEsU0FBUyxDQUFDd0YsSUFBVixHQUFpQnpGLEtBQWpCO0FBQ0FDLFFBQUFBLFNBQVMsQ0FBQ3dDLFFBQVYsR0FBcUJBLFFBQXJCO0FBQ0g7O0FBRURuQyxNQUFBQSxZQUFZLEdBQUdrSCxPQUFPLENBQUNDLFdBQXZCO0FBQ0FsSCxNQUFBQSxXQUFXLEdBQUdpSCxPQUFPLENBQUNFLFVBQXRCO0FBRUFsRCxNQUFBQSxVQUFVLEdBQUd6RSxPQUFPLENBQUM4RixPQUFSLENBQWdCdkYsWUFBaEIsRUFBOEJDLFdBQTlCLENBQWI7QUFDQUgsTUFBQUEsWUFBWSxHQUFHb0UsVUFBVSxDQUFDc0IsWUFBMUI7QUFDQXpGLE1BQUFBLGFBQWEsR0FBR21FLFVBQVUsQ0FBQ3dCLFlBQTNCO0FBQ0E3RixNQUFBQSxTQUFTLEdBQUdxRSxVQUFVLENBQUN1QixVQUFYLElBQXlCLENBQXJDO0FBQ0FoQyxNQUFBQSxJQUFJLEdBQUdoRSxPQUFPLENBQUNrRyxNQUFmO0FBQ0FqQyxNQUFBQSxJQUFJLEdBQUdqRSxPQUFPLENBQUNtRyxNQUFmO0FBQ0FqQyxNQUFBQSxPQUFPLEdBQUdsRSxPQUFPLENBQUNvRyxVQUFsQjs7QUFFQSxXQUFLLElBQUlHLEVBQUUsR0FBR2xHLFlBQVQsRUFBdUJtRyxFQUFFLEdBQUduRyxZQUFZLEdBQUdHLFdBQWhELEVBQTZEK0YsRUFBRSxHQUFHQyxFQUFsRSxFQUFzRUQsRUFBRSxFQUF4RSxFQUE0RTtBQUN4RXRDLFFBQUFBLElBQUksQ0FBQ3NDLEVBQUQsQ0FBSixHQUFXakcsYUFBYSxHQUFHOEQsT0FBTyxDQUFDeUMsZ0JBQWdCLEVBQWpCLENBQWxDO0FBQ0g7O0FBRURDLE1BQUFBLFVBQVUsR0FBR1csT0FBTyxDQUFDRyxPQUFyQjtBQUNBNUQsTUFBQUEsSUFBSSxDQUFDNkQsR0FBTCxDQUFTMUQsUUFBUSxDQUFDMkQsUUFBVCxDQUFrQmxCLGFBQWxCLEVBQWlDQSxhQUFhLEdBQUdFLFVBQWpELENBQVQsRUFBdUUxRyxTQUF2RTtBQUNBd0csTUFBQUEsYUFBYSxJQUFJRSxVQUFqQjs7QUFFQSxVQUFJSSxhQUFKLEVBQW1CO0FBQ2YsYUFBSyxJQUFJWCxHQUFFLEdBQUduRyxTQUFULEVBQW9Cb0csR0FBRSxHQUFHcEcsU0FBUyxHQUFHMEcsVUFBMUMsRUFBc0RQLEdBQUUsR0FBR0MsR0FBM0QsRUFBK0RELEdBQUUsSUFBSSxDQUFyRSxFQUF3RTtBQUNwRXZDLFVBQUFBLElBQUksQ0FBQ3VDLEdBQUQsQ0FBSixJQUFZcEYsSUFBWjtBQUNBNkMsVUFBQUEsSUFBSSxDQUFDdUMsR0FBRSxHQUFHLENBQU4sQ0FBSixJQUFnQmpGLElBQWhCO0FBQ0g7QUFDSixPQUxELE1BS08sSUFBSTJGLFNBQUosRUFBZTtBQUNsQixhQUFLLElBQUlWLElBQUUsR0FBR25HLFNBQVQsRUFBb0JvRyxJQUFFLEdBQUdwRyxTQUFTLEdBQUcwRyxVQUExQyxFQUFzRFAsSUFBRSxHQUFHQyxJQUEzRCxFQUErREQsSUFBRSxJQUFJLENBQXJFLEVBQXdFO0FBQ3BFOUYsVUFBQUEsRUFBRSxHQUFHdUQsSUFBSSxDQUFDdUMsSUFBRCxDQUFUO0FBQ0E3RixVQUFBQSxFQUFFLEdBQUdzRCxJQUFJLENBQUN1QyxJQUFFLEdBQUcsQ0FBTixDQUFUO0FBQ0F2QyxVQUFBQSxJQUFJLENBQUN1QyxJQUFELENBQUosR0FBVzlGLEVBQUUsR0FBR1EsSUFBTCxHQUFZUCxFQUFFLEdBQUdRLElBQWpCLEdBQXdCQyxJQUFuQztBQUNBNkMsVUFBQUEsSUFBSSxDQUFDdUMsSUFBRSxHQUFHLENBQU4sQ0FBSixHQUFlOUYsRUFBRSxHQUFHVyxJQUFMLEdBQVlWLEVBQUUsR0FBR1csSUFBakIsR0FBd0JDLElBQXZDO0FBQ0g7QUFDSjs7QUFFRCxVQUFLLEVBQUVOLFVBQVUsR0FBRzdCLFVBQWYsQ0FBTCxFQUFrQyxTQTNDVyxDQTZDN0M7O0FBQ0EsVUFBSTRJLGdCQUFnQixHQUFHbkIsYUFBYSxHQUFHRSxVQUF2Qzs7QUFDQSxXQUFLLElBQUlQLElBQUUsR0FBR25HLFNBQVMsR0FBRyxDQUFyQixFQUF3Qm9HLElBQUUsR0FBR3BHLFNBQVMsR0FBRyxDQUFaLEdBQWdCMEcsVUFBbEQsRUFBOERQLElBQUUsR0FBR0MsSUFBbkUsRUFBdUVELElBQUUsSUFBSSxDQUFOLEVBQVN3QixnQkFBZ0IsSUFBSSxDQUFwRyxFQUF1RztBQUNuRyxZQUFJQSxnQkFBZ0IsSUFBSVQsV0FBeEIsRUFBcUM7QUFDakNELFVBQUFBLFFBQVEsR0FBR0QsTUFBTSxDQUFDRCxXQUFXLEVBQVosQ0FBakI7O0FBQ0FsRSxVQUFBQSxZQUFZLENBQUNvRSxRQUFELEVBQVcsR0FBWCxDQUFaOztBQUNBQyxVQUFBQSxXQUFXLEdBQUdELFFBQVEsQ0FBQ0UsUUFBdkI7QUFDSDs7QUFDRHJELFFBQUFBLE9BQU8sQ0FBQ3FDLElBQUQsQ0FBUCxHQUFjNUYsRUFBZDtBQUNIO0FBQ0o7QUFDSjs7U0FFRHFILGNBQUEscUJBQWF2RSxJQUFiLEVBQW1Cd0UsUUFBbkIsRUFBNkI7QUFDekJ4RSxJQUFBQSxJQUFJLENBQUNpQyxJQUFMLENBQVV3QyxXQUFWLElBQXlCbEosVUFBVSxDQUFDbUosdUJBQXBDO0FBRUEsUUFBSXZFLFFBQVEsR0FBR0gsSUFBSSxDQUFDMkUsU0FBcEI7QUFDQSxRQUFJLENBQUN4RSxRQUFMLEVBQWUsT0FKVSxDQU16Qjs7QUFDQTdELElBQUFBLFVBQVUsR0FBRyxJQUFiO0FBQ0FGLElBQUFBLG1CQUFtQixHQUFHNEQsSUFBSSxDQUFDNEUsa0JBQTNCO0FBQ0FwSSxJQUFBQSxLQUFLLEdBQUd3RCxJQUFJLENBQUNpQyxJQUFiO0FBQ0ExRixJQUFBQSxPQUFPLEdBQUdpSSxRQUFRLENBQUNLLFdBQW5CO0FBQ0FwSSxJQUFBQSxTQUFTLEdBQUcrSCxRQUFaO0FBQ0E5SCxJQUFBQSxLQUFLLEdBQUdzRCxJQUFSO0FBQ0F6QyxJQUFBQSxVQUFVLEdBQUcsQ0FBYjtBQUVBLFFBQUl1SCxTQUFTLEdBQUd0SSxLQUFLLENBQUM0RSxNQUF0QjtBQUNBcEYsSUFBQUEsTUFBTSxHQUFHOEksU0FBUyxDQUFDbkYsQ0FBVixHQUFjLEdBQXZCO0FBQ0ExRCxJQUFBQSxNQUFNLEdBQUc2SSxTQUFTLENBQUNsRixDQUFWLEdBQWMsR0FBdkI7QUFDQTFELElBQUFBLE1BQU0sR0FBRzRJLFNBQVMsQ0FBQ2pGLENBQVYsR0FBYyxHQUF2QjtBQUNBMUQsSUFBQUEsTUFBTSxHQUFHMkksU0FBUyxDQUFDcEYsQ0FBVixHQUFjLEdBQXZCOztBQUNBLFFBQUlvRixTQUFTLENBQUNDLElBQVYsS0FBbUIsVUFBdkIsRUFBbUM7QUFDL0J4SCxNQUFBQSxVQUFVLElBQUk3QixVQUFkO0FBQ0g7O0FBRUQsUUFBSXNKLFFBQVEsR0FBR0MsU0FBZjs7QUFDQSxRQUFJdkksS0FBSyxDQUFDZ0MsV0FBVixFQUF1QjtBQUNuQnNHLE1BQUFBLFFBQVEsR0FBR3hJLEtBQUssQ0FBQ2dGLFlBQWpCO0FBQ0FsRixNQUFBQSxVQUFVLEdBQUcsS0FBYjtBQUNBaUIsTUFBQUEsVUFBVSxJQUFJNUIsVUFBZDtBQUNIOztBQUVELFFBQUlxRSxJQUFJLENBQUNrRixpQkFBTCxFQUFKLEVBQThCO0FBQzFCO0FBQ0EsV0FBS2xDLGFBQUwsQ0FBbUJoRCxJQUFJLENBQUNtRixTQUF4QixFQUFtQ0gsUUFBbkM7QUFDSCxLQUhELE1BR087QUFDSDtBQUNBLFdBQUs5RSxnQkFBTCxDQUFzQkMsUUFBdEIsRUFBZ0M2RSxRQUFoQyxFQUEwQyxHQUExQztBQUVBLFVBQUlJLFFBQVEsR0FBR3BGLElBQUksQ0FBQ3FGLFVBQXBCOztBQUNBLFVBQUlyRixJQUFJLENBQUNzRixVQUFMLElBQW1CRixRQUF2QixFQUFpQztBQUM3QkEsUUFBQUEsUUFBUSxDQUFDRyxLQUFUO0FBRUFILFFBQUFBLFFBQVEsQ0FBQ0ksU0FBVCxHQUFxQixDQUFyQjtBQUNBSixRQUFBQSxRQUFRLENBQUNLLFdBQVQsR0FBdUI3SixVQUF2QjtBQUNBd0osUUFBQUEsUUFBUSxDQUFDTSxTQUFULEdBQXFCNUosVUFBckIsQ0FMNkIsQ0FLSTs7QUFFakMsWUFBSTZKLEtBQUssR0FBR3hGLFFBQVEsQ0FBQ3lGLFFBQVQsRUFBWjs7QUFDQSxhQUFLLElBQUkzRSxDQUFDLEdBQUcsQ0FBUixFQUFXQyxDQUFDLEdBQUd5RSxLQUFLLENBQUN4RSxNQUExQixFQUFrQ0YsQ0FBQyxHQUFHQyxDQUF0QyxFQUF5Q0QsQ0FBQyxFQUExQyxFQUE4QztBQUMxQyxjQUFJNEUsSUFBSSxHQUFJRixLQUFLLENBQUMxRSxDQUFELENBQWpCO0FBQ0EsY0FBSTZFLFVBQVUsR0FBR0MsSUFBSSxDQUFDQyxHQUFMLENBQVNILElBQUksQ0FBQ0ksUUFBTCxDQUFjOUUsTUFBdkIsRUFBK0IsQ0FBL0IsQ0FBakI7QUFDQSxjQUFJK0UsTUFBTSxHQUFHTCxJQUFJLENBQUNNLHFCQUFMLENBQTJCQyxFQUF4QztBQUNBLGNBQUlDLE1BQU0sR0FBR1IsSUFBSSxDQUFDTSxxQkFBTCxDQUEyQkcsRUFBeEM7QUFDQSxjQUFJQyxJQUFJLEdBQUdMLE1BQU0sR0FBR0wsSUFBSSxDQUFDTSxxQkFBTCxDQUEyQnpHLENBQTNCLEdBQStCb0csVUFBbkQ7QUFDQSxjQUFJVSxJQUFJLEdBQUdILE1BQU0sR0FBR1IsSUFBSSxDQUFDTSxxQkFBTCxDQUEyQnRHLENBQTNCLEdBQStCaUcsVUFBbkQ7QUFFQVYsVUFBQUEsUUFBUSxDQUFDcUIsTUFBVCxDQUFnQlAsTUFBaEIsRUFBd0JHLE1BQXhCO0FBQ0FqQixVQUFBQSxRQUFRLENBQUNzQixNQUFULENBQWdCSCxJQUFoQixFQUFzQkMsSUFBdEI7QUFDQXBCLFVBQUFBLFFBQVEsQ0FBQ3VCLE1BQVQsR0FWMEMsQ0FZMUM7O0FBQ0F2QixVQUFBQSxRQUFRLENBQUN3QixNQUFULENBQWdCVixNQUFoQixFQUF3QkcsTUFBeEIsRUFBZ0NOLElBQUksQ0FBQ2MsRUFBTCxHQUFVLENBQTFDO0FBQ0F6QixVQUFBQSxRQUFRLENBQUMwQixJQUFUOztBQUNBLGNBQUk3RixDQUFDLEtBQUssQ0FBVixFQUFhO0FBQ1RtRSxZQUFBQSxRQUFRLENBQUNNLFNBQVQsR0FBcUIzSixZQUFyQjtBQUNIO0FBQ0o7QUFDSjtBQUNKLEtBbkV3QixDQXFFekI7OztBQUNBeUksSUFBQUEsUUFBUSxDQUFDdUMsYUFBVDs7QUFDQS9HLElBQUFBLElBQUksQ0FBQ2dILFVBQUwsQ0FBZ0JDLGlCQUFoQixHQXZFeUIsQ0F5RXpCOzs7QUFDQXpLLElBQUFBLEtBQUssR0FBR3lJLFNBQVI7QUFDQTFJLElBQUFBLE9BQU8sR0FBRzBJLFNBQVY7QUFDQXhJLElBQUFBLFNBQVMsR0FBR3dJLFNBQVo7QUFDQXZJLElBQUFBLEtBQUssR0FBR3VJLFNBQVI7QUFDSDs7U0FFRGlDLGtCQUFBLHlCQUFpQmxILElBQWpCLEVBQXVCd0UsUUFBdkIsRUFBaUM7QUFDN0JBLElBQUFBLFFBQVEsQ0FBQ3VDLGFBQVQ7QUFDSDs7O0VBbFEwQ0k7Ozs7QUFxUS9DQSxzQkFBVUMsUUFBVixDQUFtQi9MLFFBQW5CLEVBQTZCeUUsaUJBQTdCIiwic291cmNlc0NvbnRlbnQiOlsiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiBDb3B5cmlnaHQgKGMpIDIwMTctMjAxOCBYaWFtZW4gWWFqaSBTb2Z0d2FyZSBDby4sIEx0ZC5cblxuIGh0dHBzOi8vd3d3LmNvY29zLmNvbS9cblxuIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGVuZ2luZSBzb3VyY2UgY29kZSAodGhlIFwiU29mdHdhcmVcIiksIGEgbGltaXRlZCxcbiB3b3JsZHdpZGUsIHJveWFsdHktZnJlZSwgbm9uLWFzc2lnbmFibGUsIHJldm9jYWJsZSBhbmQgbm9uLWV4Y2x1c2l2ZSBsaWNlbnNlXG4gdG8gdXNlIENvY29zIENyZWF0b3Igc29sZWx5IHRvIGRldmVsb3AgZ2FtZXMgb24geW91ciB0YXJnZXQgcGxhdGZvcm1zLiBZb3Ugc2hhbGxcbiBub3QgdXNlIENvY29zIENyZWF0b3Igc29mdHdhcmUgZm9yIGRldmVsb3Bpbmcgb3RoZXIgc29mdHdhcmUgb3IgdG9vbHMgdGhhdCdzXG4gdXNlZCBmb3IgZGV2ZWxvcGluZyBnYW1lcy4gWW91IGFyZSBub3QgZ3JhbnRlZCB0byBwdWJsaXNoLCBkaXN0cmlidXRlLFxuIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiBDb2NvcyBDcmVhdG9yLlxuXG4gVGhlIHNvZnR3YXJlIG9yIHRvb2xzIGluIHRoaXMgTGljZW5zZSBBZ3JlZW1lbnQgYXJlIGxpY2Vuc2VkLCBub3Qgc29sZC5cbiBYaWFtZW4gWWFqaSBTb2Z0d2FyZSBDby4sIEx0ZC4gcmVzZXJ2ZXMgYWxsIHJpZ2h0cyBub3QgZXhwcmVzc2x5IGdyYW50ZWQgdG8geW91LlxuXG4gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiBUSEUgU09GVFdBUkUuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuaW1wb3J0IEFzc2VtYmxlciBmcm9tICcuLi8uLi9jb2NvczJkL2NvcmUvcmVuZGVyZXIvYXNzZW1ibGVyJztcbmltcG9ydCBNYXQ0IGZyb20gJy4uLy4uL2NvY29zMmQvY29yZS92YWx1ZS10eXBlcy9tYXQ0JztcblxuY29uc3QgQXJtYXR1cmUgPSByZXF1aXJlKCcuL0FybWF0dXJlRGlzcGxheScpO1xuY29uc3QgUmVuZGVyRmxvdyA9IHJlcXVpcmUoJy4uLy4uL2NvY29zMmQvY29yZS9yZW5kZXJlci9yZW5kZXItZmxvdycpO1xuY29uc3QgZ2Z4ID0gY2MuZ2Z4O1xuY29uc3QgTkVFRF9DT0xPUiA9IDB4MDE7XG5jb25zdCBORUVEX0JBVENIID0gMHgxMDtcblxubGV0IF9ib25lQ29sb3IgPSBjYy5jb2xvcigyNTUsIDAsIDAsIDI1NSk7XG5sZXQgX3Nsb3RDb2xvciA9IGNjLmNvbG9yKDAsIDAsIDI1NSwgMjU1KTtcbmxldCBfb3JpZ2luQ29sb3IgPSBjYy5jb2xvcigwLCAyNTUsIDAsIDI1NSk7XG5cbmxldCBfbm9kZVIsIF9ub2RlRywgX25vZGVCLCBfbm9kZUEsXG4gICAgX3ByZW11bHRpcGxpZWRBbHBoYSwgX211bHRpcGx5LFxuICAgIF9tdXN0Rmx1c2gsIF9idWZmZXIsIF9ub2RlLFxuICAgIF9yZW5kZXJlciwgX2NvbXAsXG4gICAgX3ZmT2Zmc2V0LCBfaW5kZXhPZmZzZXQsIF92ZXJ0ZXhPZmZzZXQsXG4gICAgX3ZlcnRleENvdW50LCBfaW5kZXhDb3VudCxcbiAgICBfeCwgX3ksIF9jLCBfciwgX2csIF9iLCBfYSwgX2hhbmRsZVZhbCxcbiAgICBfbTAwLCBfbTA0LCBfbTEyLFxuICAgIF9tMDEsIF9tMDUsIF9tMTM7XG5cbmZ1bmN0aW9uIF9nZXRTbG90TWF0ZXJpYWwgKHRleCwgYmxlbmRNb2RlKSB7XG4gICAgaWYoIXRleClyZXR1cm4gbnVsbDtcblxuICAgIGxldCBzcmMsIGRzdDtcbiAgICBzd2l0Y2ggKGJsZW5kTW9kZSkge1xuICAgICAgICBjYXNlIDE6Ly9hZGRpdGl2ZVxuICAgICAgICAgICAgc3JjID0gX3ByZW11bHRpcGxpZWRBbHBoYSA/IGNjLm1hY3JvLk9ORSA6IGNjLm1hY3JvLlNSQ19BTFBIQTtcbiAgICAgICAgICAgIGRzdCA9IGNjLm1hY3JvLk9ORTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEwOi8vbXVsdGlwbHlcbiAgICAgICAgICAgIHNyYyA9IGNjLm1hY3JvLkRTVF9DT0xPUjtcbiAgICAgICAgICAgIGRzdCA9IGNjLm1hY3JvLk9ORV9NSU5VU19TUkNfQUxQSEE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMjovL3NjcmVlblxuICAgICAgICAgICAgc3JjID0gY2MubWFjcm8uT05FO1xuICAgICAgICAgICAgZHN0ID0gY2MubWFjcm8uT05FX01JTlVTX1NSQ19DT0xPUjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDA6Ly9ub3JtYWxcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHNyYyA9IF9wcmVtdWx0aXBsaWVkQWxwaGEgPyBjYy5tYWNyby5PTkUgOiBjYy5tYWNyby5TUkNfQUxQSEE7XG4gICAgICAgICAgICBkc3QgPSBjYy5tYWNyby5PTkVfTUlOVVNfU1JDX0FMUEhBO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgbGV0IHVzZU1vZGVsID0gIV9jb21wLmVuYWJsZUJhdGNoO1xuICAgIGxldCBiYXNlTWF0ZXJpYWwgPSBfY29tcC5fbWF0ZXJpYWxzWzBdO1xuICAgIGlmICghYmFzZU1hdGVyaWFsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBsZXQgbWF0ZXJpYWxDYWNoZSA9IF9jb21wLl9tYXRlcmlhbENhY2hlO1xuXG4gICAgLy8gVGhlIGtleSB1c2UgdG8gZmluZCBjb3JyZXNwb25kaW5nIG1hdGVyaWFsXG4gICAgbGV0IGtleSA9IHRleC5nZXRJZCgpICsgc3JjICsgZHN0ICsgdXNlTW9kZWw7XG4gICAgbGV0IG1hdGVyaWFsID0gbWF0ZXJpYWxDYWNoZVtrZXldO1xuICAgIGlmICghbWF0ZXJpYWwpIHtcbiAgICAgICAgaWYgKCFtYXRlcmlhbENhY2hlLmJhc2VNYXRlcmlhbCkge1xuICAgICAgICAgICAgbWF0ZXJpYWwgPSBiYXNlTWF0ZXJpYWw7XG4gICAgICAgICAgICBtYXRlcmlhbENhY2hlLmJhc2VNYXRlcmlhbCA9IGJhc2VNYXRlcmlhbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1hdGVyaWFsID0gY2MuTWF0ZXJpYWxWYXJpYW50LmNyZWF0ZShiYXNlTWF0ZXJpYWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgbWF0ZXJpYWwuZGVmaW5lKCdDQ19VU0VfTU9ERUwnLCB1c2VNb2RlbCk7XG4gICAgICAgIG1hdGVyaWFsLnNldFByb3BlcnR5KCd0ZXh0dXJlJywgdGV4KTtcblxuICAgICAgICAvLyB1cGRhdGUgYmxlbmQgZnVuY3Rpb25cbiAgICAgICAgbWF0ZXJpYWwuc2V0QmxlbmQoXG4gICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgZ2Z4LkJMRU5EX0ZVTkNfQURELFxuICAgICAgICAgICAgc3JjLCBkc3QsXG4gICAgICAgICAgICBnZnguQkxFTkRfRlVOQ19BREQsXG4gICAgICAgICAgICBzcmMsIGRzdFxuICAgICAgICApO1xuICAgICAgICBtYXRlcmlhbENhY2hlW2tleV0gPSBtYXRlcmlhbDtcbiAgICB9XG4gICAgcmV0dXJuIG1hdGVyaWFsO1xufVxuXG5mdW5jdGlvbiBfaGFuZGxlQ29sb3IgKGNvbG9yLCBwYXJlbnRPcGFjaXR5KSB7XG4gICAgX2EgPSBjb2xvci5hICogcGFyZW50T3BhY2l0eSAqIF9ub2RlQTtcbiAgICBfbXVsdGlwbHkgPSBfcHJlbXVsdGlwbGllZEFscGhhPyBfYSAvIDI1NS4wIDogMS4wO1xuICAgIF9yID0gY29sb3IuciAqIF9ub2RlUiAqIF9tdWx0aXBseTtcbiAgICBfZyA9IGNvbG9yLmcgKiBfbm9kZUcgKiBfbXVsdGlwbHk7XG4gICAgX2IgPSBjb2xvci5iICogX25vZGVCICogX211bHRpcGx5O1xuICAgIF9jID0gKChfYTw8MjQpID4+PiAwKSArIChfYjw8MTYpICsgKF9nPDw4KSArIF9yO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBcm1hdHVyZUFzc2VtYmxlciBleHRlbmRzIEFzc2VtYmxlciB7XG4gICAgdXBkYXRlUmVuZGVyRGF0YSAoY29tcCwgYmF0Y2hEYXRhKSB7fVxuXG4gICAgcmVhbFRpbWVUcmF2ZXJzZSAoYXJtYXR1cmUsIHBhcmVudE1hdCwgcGFyZW50T3BhY2l0eSkge1xuICAgICAgICBsZXQgc2xvdHMgPSBhcm1hdHVyZS5fc2xvdHM7XG4gICAgICAgIGxldCB2YnVmLCBpYnVmLCB1aW50YnVmO1xuICAgICAgICBsZXQgbWF0ZXJpYWw7XG4gICAgICAgIGxldCB2ZXJ0aWNlcywgaW5kaWNlcztcbiAgICAgICAgbGV0IHNsb3RDb2xvcjtcbiAgICAgICAgbGV0IHNsb3Q7XG4gICAgICAgIGxldCBzbG90TWF0O1xuICAgICAgICBsZXQgc2xvdE1hdG07XG4gICAgICAgIGxldCBvZmZzZXRJbmZvO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gc2xvdHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBzbG90ID0gc2xvdHNbaV07XG4gICAgICAgICAgICBzbG90Q29sb3IgPSBzbG90Ll9jb2xvcjtcblxuICAgICAgICAgICAgaWYgKCFzbG90Ll92aXNpYmxlIHx8ICFzbG90Ll9kaXNwbGF5RGF0YSkgY29udGludWU7XG5cbiAgICAgICAgICAgIGlmIChwYXJlbnRNYXQpIHtcbiAgICAgICAgICAgICAgICBzbG90Ll9tdWxNYXQoc2xvdC5fd29ybGRNYXRyaXgsIHBhcmVudE1hdCwgc2xvdC5fbWF0cml4KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgTWF0NC5jb3B5KHNsb3QuX3dvcmxkTWF0cml4LCBzbG90Ll9tYXRyaXgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2xvdC5jaGlsZEFybWF0dXJlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWFsVGltZVRyYXZlcnNlKHNsb3QuY2hpbGRBcm1hdHVyZSwgc2xvdC5fd29ybGRNYXRyaXgsIHBhcmVudE9wYWNpdHkgKiBzbG90Q29sb3IuYSAvIDI1NSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1hdGVyaWFsID0gX2dldFNsb3RNYXRlcmlhbChzbG90LmdldFRleHR1cmUoKSwgc2xvdC5fYmxlbmRNb2RlKTtcbiAgICAgICAgICAgIGlmICghbWF0ZXJpYWwpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKF9tdXN0Rmx1c2ggfHwgbWF0ZXJpYWwuZ2V0SGFzaCgpICE9PSBfcmVuZGVyZXIubWF0ZXJpYWwuZ2V0SGFzaCgpKSB7XG4gICAgICAgICAgICAgICAgX211c3RGbHVzaCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIF9yZW5kZXJlci5fZmx1c2goKTtcbiAgICAgICAgICAgICAgICBfcmVuZGVyZXIubm9kZSA9IF9ub2RlO1xuICAgICAgICAgICAgICAgIF9yZW5kZXJlci5tYXRlcmlhbCA9IG1hdGVyaWFsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfaGFuZGxlQ29sb3Ioc2xvdENvbG9yLCBwYXJlbnRPcGFjaXR5KTtcbiAgICAgICAgICAgIHNsb3RNYXQgPSBzbG90Ll93b3JsZE1hdHJpeDtcbiAgICAgICAgICAgIHNsb3RNYXRtID0gc2xvdE1hdC5tO1xuXG4gICAgICAgICAgICB2ZXJ0aWNlcyA9IHNsb3QuX2xvY2FsVmVydGljZXM7XG4gICAgICAgICAgICBfdmVydGV4Q291bnQgPSB2ZXJ0aWNlcy5sZW5ndGggPj4gMjtcblxuICAgICAgICAgICAgaW5kaWNlcyA9IHNsb3QuX2luZGljZXM7XG4gICAgICAgICAgICBfaW5kZXhDb3VudCA9IGluZGljZXMubGVuZ3RoO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBvZmZzZXRJbmZvID0gX2J1ZmZlci5yZXF1ZXN0KF92ZXJ0ZXhDb3VudCwgX2luZGV4Q291bnQpO1xuICAgICAgICAgICAgX2luZGV4T2Zmc2V0ID0gb2Zmc2V0SW5mby5pbmRpY2VPZmZzZXQ7XG4gICAgICAgICAgICBfdmZPZmZzZXQgPSBvZmZzZXRJbmZvLmJ5dGVPZmZzZXQgPj4gMjtcbiAgICAgICAgICAgIF92ZXJ0ZXhPZmZzZXQgPSBvZmZzZXRJbmZvLnZlcnRleE9mZnNldDtcbiAgICAgICAgICAgIHZidWYgPSBfYnVmZmVyLl92RGF0YTtcbiAgICAgICAgICAgIGlidWYgPSBfYnVmZmVyLl9pRGF0YTtcbiAgICAgICAgICAgIHVpbnRidWYgPSBfYnVmZmVyLl91aW50VkRhdGE7XG5cbiAgICAgICAgICAgIF9tMDAgPSBzbG90TWF0bVswXTtcbiAgICAgICAgICAgIF9tMDQgPSBzbG90TWF0bVs0XTtcbiAgICAgICAgICAgIF9tMTIgPSBzbG90TWF0bVsxMl07XG4gICAgICAgICAgICBfbTAxID0gc2xvdE1hdG1bMV07XG4gICAgICAgICAgICBfbTA1ID0gc2xvdE1hdG1bNV07XG4gICAgICAgICAgICBfbTEzID0gc2xvdE1hdG1bMTNdO1xuXG4gICAgICAgICAgICBmb3IgKGxldCB2aSA9IDAsIHZsID0gdmVydGljZXMubGVuZ3RoOyB2aSA8IHZsOykge1xuICAgICAgICAgICAgICAgIF94ID0gdmVydGljZXNbdmkrK107IFxuICAgICAgICAgICAgICAgIF95ID0gdmVydGljZXNbdmkrK107XG5cbiAgICAgICAgICAgICAgICB2YnVmW192Zk9mZnNldCsrXSA9IF94ICogX20wMCArIF95ICogX20wNCArIF9tMTI7IC8vIHhcbiAgICAgICAgICAgICAgICB2YnVmW192Zk9mZnNldCsrXSA9IF94ICogX20wMSArIF95ICogX20wNSArIF9tMTM7IC8vIHlcblxuICAgICAgICAgICAgICAgIHZidWZbX3ZmT2Zmc2V0KytdID0gdmVydGljZXNbdmkrK107IC8vIHVcbiAgICAgICAgICAgICAgICB2YnVmW192Zk9mZnNldCsrXSA9IHZlcnRpY2VzW3ZpKytdOyAvLyB2XG4gICAgICAgICAgICAgICAgdWludGJ1ZltfdmZPZmZzZXQrK10gPSBfYzsgLy8gY29sb3JcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChsZXQgaWkgPSAwLCBpbCA9IGluZGljZXMubGVuZ3RoOyBpaSA8IGlsOyBpaSArKykge1xuICAgICAgICAgICAgICAgIGlidWZbX2luZGV4T2Zmc2V0KytdID0gX3ZlcnRleE9mZnNldCArIGluZGljZXNbaWldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2FjaGVUcmF2ZXJzZSAoZnJhbWUsIHBhcmVudE1hdCkge1xuICAgICAgICBpZiAoIWZyYW1lKSByZXR1cm47XG4gICAgICAgIGxldCBzZWdtZW50cyA9IGZyYW1lLnNlZ21lbnRzO1xuICAgICAgICBpZiAoc2VnbWVudHMubGVuZ3RoID09IDApIHJldHVybjtcblxuICAgICAgICBsZXQgdmJ1ZiwgaWJ1ZiwgdWludGJ1ZjtcbiAgICAgICAgbGV0IG1hdGVyaWFsO1xuICAgICAgICBsZXQgb2Zmc2V0SW5mbztcbiAgICAgICAgbGV0IHZlcnRpY2VzID0gZnJhbWUudmVydGljZXM7XG4gICAgICAgIGxldCBpbmRpY2VzID0gZnJhbWUuaW5kaWNlcztcbiAgICAgICAgXG4gICAgICAgIGxldCBmcmFtZVZGT2Zmc2V0ID0gMCwgZnJhbWVJbmRleE9mZnNldCA9IDAsIHNlZ1ZGQ291bnQgPSAwO1xuICAgICAgICBpZiAocGFyZW50TWF0KSB7XG4gICAgICAgICAgICBsZXQgcGFyZW50TWF0bSA9IHBhcmVudE1hdC5tO1xuICAgICAgICAgICAgX20wMCA9IHBhcmVudE1hdG1bMF07XG4gICAgICAgICAgICBfbTAxID0gcGFyZW50TWF0bVsxXTtcbiAgICAgICAgICAgIF9tMDQgPSBwYXJlbnRNYXRtWzRdO1xuICAgICAgICAgICAgX20wNSA9IHBhcmVudE1hdG1bNV07XG4gICAgICAgICAgICBfbTEyID0gcGFyZW50TWF0bVsxMl07XG4gICAgICAgICAgICBfbTEzID0gcGFyZW50TWF0bVsxM107XG4gICAgICAgIH1cblxuICAgICAgICBsZXQganVzdFRyYW5zbGF0ZSA9IF9tMDAgPT09IDEgJiYgX20wMSA9PT0gMCAmJiBfbTA0ID09PSAwICYmIF9tMDUgPT09IDE7XG4gICAgICAgIGxldCBuZWVkQmF0Y2ggPSAoX2hhbmRsZVZhbCAmIE5FRURfQkFUQ0gpO1xuICAgICAgICBsZXQgY2FsY1RyYW5zbGF0ZSA9IG5lZWRCYXRjaCAmJiBqdXN0VHJhbnNsYXRlO1xuXG4gICAgICAgIGxldCBjb2xvck9mZnNldCA9IDA7XG4gICAgICAgIGxldCBjb2xvcnMgPSBmcmFtZS5jb2xvcnM7XG4gICAgICAgIGxldCBub3dDb2xvciA9IGNvbG9yc1tjb2xvck9mZnNldCsrXTtcbiAgICAgICAgbGV0IG1heFZGT2Zmc2V0ID0gbm93Q29sb3IudmZPZmZzZXQ7XG4gICAgICAgIF9oYW5kbGVDb2xvcihub3dDb2xvciwgMS4wKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgbGV0IHNlZ0luZm8gPSBzZWdtZW50c1tpXTtcbiAgICAgICAgICAgIG1hdGVyaWFsID0gX2dldFNsb3RNYXRlcmlhbChzZWdJbmZvLnRleCwgc2VnSW5mby5ibGVuZE1vZGUpO1xuICAgICAgICAgICAgaWYgKF9tdXN0Rmx1c2ggfHwgbWF0ZXJpYWwuZ2V0SGFzaCgpICE9PSBfcmVuZGVyZXIubWF0ZXJpYWwuZ2V0SGFzaCgpKSB7XG4gICAgICAgICAgICAgICAgX211c3RGbHVzaCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIF9yZW5kZXJlci5fZmx1c2goKTtcbiAgICAgICAgICAgICAgICBfcmVuZGVyZXIubm9kZSA9IF9ub2RlO1xuICAgICAgICAgICAgICAgIF9yZW5kZXJlci5tYXRlcmlhbCA9IG1hdGVyaWFsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfdmVydGV4Q291bnQgPSBzZWdJbmZvLnZlcnRleENvdW50O1xuICAgICAgICAgICAgX2luZGV4Q291bnQgPSBzZWdJbmZvLmluZGV4Q291bnQ7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIG9mZnNldEluZm8gPSBfYnVmZmVyLnJlcXVlc3QoX3ZlcnRleENvdW50LCBfaW5kZXhDb3VudCk7XG4gICAgICAgICAgICBfaW5kZXhPZmZzZXQgPSBvZmZzZXRJbmZvLmluZGljZU9mZnNldDtcbiAgICAgICAgICAgIF92ZXJ0ZXhPZmZzZXQgPSBvZmZzZXRJbmZvLnZlcnRleE9mZnNldDtcbiAgICAgICAgICAgIF92Zk9mZnNldCA9IG9mZnNldEluZm8uYnl0ZU9mZnNldCA+PiAyO1xuICAgICAgICAgICAgdmJ1ZiA9IF9idWZmZXIuX3ZEYXRhO1xuICAgICAgICAgICAgaWJ1ZiA9IF9idWZmZXIuX2lEYXRhO1xuICAgICAgICAgICAgdWludGJ1ZiA9IF9idWZmZXIuX3VpbnRWRGF0YTtcblxuICAgICAgICAgICAgZm9yIChsZXQgaWkgPSBfaW5kZXhPZmZzZXQsIGlsID0gX2luZGV4T2Zmc2V0ICsgX2luZGV4Q291bnQ7IGlpIDwgaWw7IGlpKyspIHtcbiAgICAgICAgICAgICAgICBpYnVmW2lpXSA9IF92ZXJ0ZXhPZmZzZXQgKyBpbmRpY2VzW2ZyYW1lSW5kZXhPZmZzZXQrK107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlZ1ZGQ291bnQgPSBzZWdJbmZvLnZmQ291bnQ7XG4gICAgICAgICAgICB2YnVmLnNldCh2ZXJ0aWNlcy5zdWJhcnJheShmcmFtZVZGT2Zmc2V0LCBmcmFtZVZGT2Zmc2V0ICsgc2VnVkZDb3VudCksIF92Zk9mZnNldCk7XG4gICAgICAgICAgICBmcmFtZVZGT2Zmc2V0ICs9IHNlZ1ZGQ291bnQ7XG5cbiAgICAgICAgICAgIGlmIChjYWxjVHJhbnNsYXRlKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaWkgPSBfdmZPZmZzZXQsIGlsID0gX3ZmT2Zmc2V0ICsgc2VnVkZDb3VudDsgaWkgPCBpbDsgaWkgKz0gNSkge1xuICAgICAgICAgICAgICAgICAgICB2YnVmW2lpXSArPSBfbTEyO1xuICAgICAgICAgICAgICAgICAgICB2YnVmW2lpICsgMV0gKz0gX20xMztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5lZWRCYXRjaCkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGlpID0gX3ZmT2Zmc2V0LCBpbCA9IF92Zk9mZnNldCArIHNlZ1ZGQ291bnQ7IGlpIDwgaWw7IGlpICs9IDUpIHtcbiAgICAgICAgICAgICAgICAgICAgX3ggPSB2YnVmW2lpXTtcbiAgICAgICAgICAgICAgICAgICAgX3kgPSB2YnVmW2lpICsgMV07XG4gICAgICAgICAgICAgICAgICAgIHZidWZbaWldID0gX3ggKiBfbTAwICsgX3kgKiBfbTA0ICsgX20xMjtcbiAgICAgICAgICAgICAgICAgICAgdmJ1ZltpaSArIDFdID0gX3ggKiBfbTAxICsgX3kgKiBfbTA1ICsgX20xMztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggIShfaGFuZGxlVmFsICYgTkVFRF9DT0xPUikgKSBjb250aW51ZTtcblxuICAgICAgICAgICAgLy8gaGFuZGxlIGNvbG9yXG4gICAgICAgICAgICBsZXQgZnJhbWVDb2xvck9mZnNldCA9IGZyYW1lVkZPZmZzZXQgLSBzZWdWRkNvdW50O1xuICAgICAgICAgICAgZm9yIChsZXQgaWkgPSBfdmZPZmZzZXQgKyA0LCBpbCA9IF92Zk9mZnNldCArIDQgKyBzZWdWRkNvdW50OyBpaSA8IGlsOyBpaSArPSA1LCBmcmFtZUNvbG9yT2Zmc2V0ICs9IDUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZnJhbWVDb2xvck9mZnNldCA+PSBtYXhWRk9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICBub3dDb2xvciA9IGNvbG9yc1tjb2xvck9mZnNldCsrXTtcbiAgICAgICAgICAgICAgICAgICAgX2hhbmRsZUNvbG9yKG5vd0NvbG9yLCAxLjApO1xuICAgICAgICAgICAgICAgICAgICBtYXhWRk9mZnNldCA9IG5vd0NvbG9yLnZmT2Zmc2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB1aW50YnVmW2lpXSA9IF9jO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZmlsbEJ1ZmZlcnMgKGNvbXAsIHJlbmRlcmVyKSB7XG4gICAgICAgIGNvbXAubm9kZS5fcmVuZGVyRmxhZyB8PSBSZW5kZXJGbG93LkZMQUdfVVBEQVRFX1JFTkRFUl9EQVRBO1xuICAgICAgICBcbiAgICAgICAgbGV0IGFybWF0dXJlID0gY29tcC5fYXJtYXR1cmU7XG4gICAgICAgIGlmICghYXJtYXR1cmUpIHJldHVybjtcblxuICAgICAgICAvLyBJbml0IHRlbXAgdmFyLlxuICAgICAgICBfbXVzdEZsdXNoID0gdHJ1ZTtcbiAgICAgICAgX3ByZW11bHRpcGxpZWRBbHBoYSA9IGNvbXAucHJlbXVsdGlwbGllZEFscGhhO1xuICAgICAgICBfbm9kZSA9IGNvbXAubm9kZTtcbiAgICAgICAgX2J1ZmZlciA9IHJlbmRlcmVyLl9tZXNoQnVmZmVyO1xuICAgICAgICBfcmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgX2NvbXAgPSBjb21wO1xuICAgICAgICBfaGFuZGxlVmFsID0gMDtcblxuICAgICAgICBsZXQgbm9kZUNvbG9yID0gX25vZGUuX2NvbG9yO1xuICAgICAgICBfbm9kZVIgPSBub2RlQ29sb3IuciAvIDI1NTtcbiAgICAgICAgX25vZGVHID0gbm9kZUNvbG9yLmcgLyAyNTU7XG4gICAgICAgIF9ub2RlQiA9IG5vZGVDb2xvci5iIC8gMjU1O1xuICAgICAgICBfbm9kZUEgPSBub2RlQ29sb3IuYSAvIDI1NTtcbiAgICAgICAgaWYgKG5vZGVDb2xvci5fdmFsICE9PSAweGZmZmZmZmZmKSB7XG4gICAgICAgICAgICBfaGFuZGxlVmFsIHw9IE5FRURfQ09MT1I7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgd29ybGRNYXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChfY29tcC5lbmFibGVCYXRjaCkge1xuICAgICAgICAgICAgd29ybGRNYXQgPSBfbm9kZS5fd29ybGRNYXRyaXg7XG4gICAgICAgICAgICBfbXVzdEZsdXNoID0gZmFsc2U7XG4gICAgICAgICAgICBfaGFuZGxlVmFsIHw9IE5FRURfQkFUQ0g7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29tcC5pc0FuaW1hdGlvbkNhY2hlZCgpKSB7XG4gICAgICAgICAgICAvLyBUcmF2ZXJzZSBpbnB1dCBhc3NlbWJsZXIuXG4gICAgICAgICAgICB0aGlzLmNhY2hlVHJhdmVyc2UoY29tcC5fY3VyRnJhbWUsIHdvcmxkTWF0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRyYXZlcnNlIGFsbCBhcm1hdHVyZS5cbiAgICAgICAgICAgIHRoaXMucmVhbFRpbWVUcmF2ZXJzZShhcm1hdHVyZSwgd29ybGRNYXQsIDEuMCk7XG5cbiAgICAgICAgICAgIGxldCBncmFwaGljcyA9IGNvbXAuX2RlYnVnRHJhdztcbiAgICAgICAgICAgIGlmIChjb21wLmRlYnVnQm9uZXMgJiYgZ3JhcGhpY3MpIHtcbiAgICAgICAgICAgICAgICBncmFwaGljcy5jbGVhcigpO1xuXG4gICAgICAgICAgICAgICAgZ3JhcGhpY3MubGluZVdpZHRoID0gNTtcbiAgICAgICAgICAgICAgICBncmFwaGljcy5zdHJva2VDb2xvciA9IF9ib25lQ29sb3I7XG4gICAgICAgICAgICAgICAgZ3JhcGhpY3MuZmlsbENvbG9yID0gX3Nsb3RDb2xvcjsgLy8gUm9vdCBib25lIGNvbG9yIGlzIHNhbWUgYXMgc2xvdCBjb2xvci5cblxuICAgICAgICAgICAgICAgIGxldCBib25lcyA9IGFybWF0dXJlLmdldEJvbmVzKCk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBib25lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGJvbmUgPSAgYm9uZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGxldCBib25lTGVuZ3RoID0gTWF0aC5tYXgoYm9uZS5ib25lRGF0YS5sZW5ndGgsIDUpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgc3RhcnRYID0gYm9uZS5nbG9iYWxUcmFuc2Zvcm1NYXRyaXgudHg7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzdGFydFkgPSBib25lLmdsb2JhbFRyYW5zZm9ybU1hdHJpeC50eTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGVuZFggPSBzdGFydFggKyBib25lLmdsb2JhbFRyYW5zZm9ybU1hdHJpeC5hICogYm9uZUxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGVuZFkgPSBzdGFydFkgKyBib25lLmdsb2JhbFRyYW5zZm9ybU1hdHJpeC5iICogYm9uZUxlbmd0aDtcblxuICAgICAgICAgICAgICAgICAgICBncmFwaGljcy5tb3ZlVG8oc3RhcnRYLCBzdGFydFkpO1xuICAgICAgICAgICAgICAgICAgICBncmFwaGljcy5saW5lVG8oZW5kWCwgZW5kWSk7XG4gICAgICAgICAgICAgICAgICAgIGdyYXBoaWNzLnN0cm9rZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEJvbmUgb3JpZ2lucy5cbiAgICAgICAgICAgICAgICAgICAgZ3JhcGhpY3MuY2lyY2xlKHN0YXJ0WCwgc3RhcnRZLCBNYXRoLlBJICogMik7XG4gICAgICAgICAgICAgICAgICAgIGdyYXBoaWNzLmZpbGwoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyYXBoaWNzLmZpbGxDb2xvciA9IF9vcmlnaW5Db2xvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gc3luYyBhdHRhY2hlZCBub2RlIG1hdHJpeFxuICAgICAgICByZW5kZXJlci53b3JsZE1hdERpcnR5Kys7XG4gICAgICAgIGNvbXAuYXR0YWNoVXRpbC5fc3luY0F0dGFjaGVkTm9kZSgpO1xuXG4gICAgICAgIC8vIENsZWFyIHRlbXAgdmFyLlxuICAgICAgICBfbm9kZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgX2J1ZmZlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgX3JlbmRlcmVyID0gdW5kZWZpbmVkO1xuICAgICAgICBfY29tcCA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBwb3N0RmlsbEJ1ZmZlcnMgKGNvbXAsIHJlbmRlcmVyKSB7XG4gICAgICAgIHJlbmRlcmVyLndvcmxkTWF0RGlydHktLTtcbiAgICB9XG59XG5cbkFzc2VtYmxlci5yZWdpc3RlcihBcm1hdHVyZSwgQXJtYXR1cmVBc3NlbWJsZXIpO1xuIl0sInNvdXJjZVJvb3QiOiIvIn0=