
                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'engine-dev/cocos2d/core/renderer/webgl/assemblers/motion-streak.js';
                    var __require = nodeEnv ? function (request) {
                        return require(request);
                    } : function (request) {
                        return __quick_compile_engine__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_engine__.registerModule(__filename, module);}"use strict";

exports.__esModule = true;
exports["default"] = void 0;

var _assembler2d = _interopRequireDefault(require("../../assembler-2d"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var MotionStreak = require('../../../components/CCMotionStreak');

var RenderFlow = require('../../render-flow');

function Point(point, dir) {
  this.point = point || cc.v2();
  this.dir = dir || cc.v2();
  this.distance = 0;
  this.time = 0;
}

Point.prototype.setPoint = function (x, y) {
  this.point.x = x;
  this.point.y = y;
};

Point.prototype.setDir = function (x, y) {
  this.dir.x = x;
  this.dir.y = y;
};

var _tangent = cc.v2();

var _miter = cc.v2();

var _normal = cc.v2();

var _vec2 = cc.v2();

function normal(out, dir) {
  //get perpendicular
  out.x = -dir.y;
  out.y = dir.x;
  return out;
}

function computeMiter(miter, lineA, lineB, halfThick, maxMultiple) {
  //get tangent line
  lineA.add(lineB, _tangent);

  _tangent.normalizeSelf(); //get miter as a unit vector


  miter.x = -_tangent.y;
  miter.y = _tangent.x;
  _vec2.x = -lineA.y;
  _vec2.y = lineA.x; //get the necessary length of our miter

  var multiple = 1 / miter.dot(_vec2);

  if (maxMultiple) {
    multiple = Math.min(multiple, maxMultiple);
  }

  return halfThick * multiple;
}

var MotionStreakAssembler = /*#__PURE__*/function (_Assembler2D) {
  _inheritsLoose(MotionStreakAssembler, _Assembler2D);

  function MotionStreakAssembler() {
    return _Assembler2D.apply(this, arguments) || this;
  }

  var _proto = MotionStreakAssembler.prototype;

  _proto.initData = function initData() {
    this._renderData.createFlexData(0, 16, (16 - 2) * 3);
  };

  _proto.update = function update(comp, dt) {
    if (CC_EDITOR && !comp.preview) return;
    var stroke = comp._stroke / 2;
    var node = comp.node;
    var matrix = node._worldMatrix.m;
    var tx = matrix[12],
        ty = matrix[13];
    var points = comp._points;
    var cur;

    if (points.length > 1) {
      var difx = points[0].point.x - tx;
      var dify = points[0].point.y - ty;

      if (difx * difx + dify * dify < comp.minSeg) {
        cur = points[0];
      }
    }

    if (!cur) {
      cur = new Point();
      points.splice(0, 0, cur);
    }

    cur.setPoint(tx, ty);
    cur.time = comp._fadeTime + dt;
    var verticesCount = 0;
    var indicesCount = 0;

    if (points.length < 2) {
      return;
    }

    var color = comp._color,
        cr = color.r,
        cg = color.g,
        cb = color.b,
        ca = color.a;
    var prev = points[1];
    prev.distance = cur.point.sub(prev.point, _vec2).mag();

    _vec2.normalizeSelf();

    prev.setDir(_vec2.x, _vec2.y);
    cur.setDir(_vec2.x, _vec2.y);
    var flexBuffer = this._renderData._flexBuffer;
    flexBuffer.reserve(points.length * 2, (points.length - 1) * 6);
    var vData = flexBuffer.vData;
    var uintVData = flexBuffer.uintVData;
    var vertsOffset = 5;
    var fadeTime = comp._fadeTime;
    var findLast = false;

    for (var i = points.length - 1; i >= 0; i--) {
      var p = points[i];
      var point = p.point;
      var dir = p.dir;
      p.time -= dt;

      if (p.time < 0) {
        points.splice(i, 1);
        continue;
      }

      var progress = p.time / fadeTime;
      var next = points[i - 1];

      if (!findLast) {
        if (!next) {
          points.splice(i, 1);
          continue;
        }

        point.x = next.point.x - dir.x * progress;
        point.y = next.point.y - dir.y * progress;
      }

      findLast = true;
      normal(_normal, dir);
      var da = progress * ca;
      var c = (da << 24 >>> 0) + (cb << 16) + (cg << 8) + cr;
      var offset = verticesCount * vertsOffset;
      vData[offset] = point.x + _normal.x * stroke;
      vData[offset + 1] = point.y + _normal.y * stroke;
      vData[offset + 2] = 1;
      vData[offset + 3] = progress;
      uintVData[offset + 4] = c;
      offset += vertsOffset;
      vData[offset] = point.x - _normal.x * stroke;
      vData[offset + 1] = point.y - _normal.y * stroke;
      vData[offset + 2] = 0;
      vData[offset + 3] = progress;
      uintVData[offset + 4] = c;
      verticesCount += 2;
    }

    indicesCount = verticesCount <= 2 ? 0 : (verticesCount - 2) * 3;
    flexBuffer.used(verticesCount, indicesCount);
  };

  _proto.fillBuffers = function fillBuffers(comp, renderer) {
    var _this$_renderData$_fl = this._renderData._flexBuffer,
        vData = _this$_renderData$_fl.vData,
        usedVertices = _this$_renderData$_fl.usedVertices,
        usedIndices = _this$_renderData$_fl.usedIndices,
        usedVerticesFloats = _this$_renderData$_fl.usedVerticesFloats;
    var buffer = renderer._meshBuffer;
    var offsetInfo = buffer.request(usedVertices, usedIndices); // buffer data may be realloc, need get reference after request.
    // fill vertices

    var vertexOffset = offsetInfo.byteOffset >> 2,
        vbuf = buffer._vData;

    if (vData.length + vertexOffset > vbuf.length) {
      vbuf.set(vData.subarray(0, usedVerticesFloats), vertexOffset);
    } else {
      vbuf.set(vData, vertexOffset);
    } // fill indices


    var ibuf = buffer._iData,
        indiceOffset = offsetInfo.indiceOffset,
        vertexId = offsetInfo.vertexOffset; // index buffer

    for (var i = 0, l = usedVertices; i < l; i += 2) {
      var start = vertexId + i;
      ibuf[indiceOffset++] = start;
      ibuf[indiceOffset++] = start + 2;
      ibuf[indiceOffset++] = start + 1;
      ibuf[indiceOffset++] = start + 1;
      ibuf[indiceOffset++] = start + 2;
      ibuf[indiceOffset++] = start + 3;
    }

    comp.node._renderFlag |= RenderFlow.FLAG_UPDATE_RENDER_DATA;
  };

  return MotionStreakAssembler;
}(_assembler2d["default"]);

exports["default"] = MotionStreakAssembler;
MotionStreakAssembler.register(MotionStreak, MotionStreakAssembler);
module.exports = exports["default"];
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_engine__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImVuZ2luZS1kZXYvY29jb3MyZC9jb3JlL3JlbmRlcmVyL3dlYmdsL2Fzc2VtYmxlcnMvbW90aW9uLXN0cmVhay5qcyJdLCJuYW1lcyI6WyJNb3Rpb25TdHJlYWsiLCJyZXF1aXJlIiwiUmVuZGVyRmxvdyIsIlBvaW50IiwicG9pbnQiLCJkaXIiLCJjYyIsInYyIiwiZGlzdGFuY2UiLCJ0aW1lIiwicHJvdG90eXBlIiwic2V0UG9pbnQiLCJ4IiwieSIsInNldERpciIsIl90YW5nZW50IiwiX21pdGVyIiwiX25vcm1hbCIsIl92ZWMyIiwibm9ybWFsIiwib3V0IiwiY29tcHV0ZU1pdGVyIiwibWl0ZXIiLCJsaW5lQSIsImxpbmVCIiwiaGFsZlRoaWNrIiwibWF4TXVsdGlwbGUiLCJhZGQiLCJub3JtYWxpemVTZWxmIiwibXVsdGlwbGUiLCJkb3QiLCJNYXRoIiwibWluIiwiTW90aW9uU3RyZWFrQXNzZW1ibGVyIiwiaW5pdERhdGEiLCJfcmVuZGVyRGF0YSIsImNyZWF0ZUZsZXhEYXRhIiwidXBkYXRlIiwiY29tcCIsImR0IiwiQ0NfRURJVE9SIiwicHJldmlldyIsInN0cm9rZSIsIl9zdHJva2UiLCJub2RlIiwibWF0cml4IiwiX3dvcmxkTWF0cml4IiwibSIsInR4IiwidHkiLCJwb2ludHMiLCJfcG9pbnRzIiwiY3VyIiwibGVuZ3RoIiwiZGlmeCIsImRpZnkiLCJtaW5TZWciLCJzcGxpY2UiLCJfZmFkZVRpbWUiLCJ2ZXJ0aWNlc0NvdW50IiwiaW5kaWNlc0NvdW50IiwiY29sb3IiLCJfY29sb3IiLCJjciIsInIiLCJjZyIsImciLCJjYiIsImIiLCJjYSIsImEiLCJwcmV2Iiwic3ViIiwibWFnIiwiZmxleEJ1ZmZlciIsIl9mbGV4QnVmZmVyIiwicmVzZXJ2ZSIsInZEYXRhIiwidWludFZEYXRhIiwidmVydHNPZmZzZXQiLCJmYWRlVGltZSIsImZpbmRMYXN0IiwiaSIsInAiLCJwcm9ncmVzcyIsIm5leHQiLCJkYSIsImMiLCJvZmZzZXQiLCJ1c2VkIiwiZmlsbEJ1ZmZlcnMiLCJyZW5kZXJlciIsInVzZWRWZXJ0aWNlcyIsInVzZWRJbmRpY2VzIiwidXNlZFZlcnRpY2VzRmxvYXRzIiwiYnVmZmVyIiwiX21lc2hCdWZmZXIiLCJvZmZzZXRJbmZvIiwicmVxdWVzdCIsInZlcnRleE9mZnNldCIsImJ5dGVPZmZzZXQiLCJ2YnVmIiwiX3ZEYXRhIiwic2V0Iiwic3ViYXJyYXkiLCJpYnVmIiwiX2lEYXRhIiwiaW5kaWNlT2Zmc2V0IiwidmVydGV4SWQiLCJsIiwic3RhcnQiLCJfcmVuZGVyRmxhZyIsIkZMQUdfVVBEQVRFX1JFTkRFUl9EQVRBIiwiQXNzZW1ibGVyMkQiLCJyZWdpc3RlciJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQXlCQTs7Ozs7O0FBRUEsSUFBTUEsWUFBWSxHQUFHQyxPQUFPLENBQUMsb0NBQUQsQ0FBNUI7O0FBQ0EsSUFBTUMsVUFBVSxHQUFHRCxPQUFPLENBQUMsbUJBQUQsQ0FBMUI7O0FBRUEsU0FBU0UsS0FBVCxDQUFnQkMsS0FBaEIsRUFBdUJDLEdBQXZCLEVBQTRCO0FBQ3hCLE9BQUtELEtBQUwsR0FBYUEsS0FBSyxJQUFJRSxFQUFFLENBQUNDLEVBQUgsRUFBdEI7QUFDQSxPQUFLRixHQUFMLEdBQVdBLEdBQUcsSUFBSUMsRUFBRSxDQUFDQyxFQUFILEVBQWxCO0FBQ0EsT0FBS0MsUUFBTCxHQUFnQixDQUFoQjtBQUNBLE9BQUtDLElBQUwsR0FBWSxDQUFaO0FBQ0g7O0FBRUROLEtBQUssQ0FBQ08sU0FBTixDQUFnQkMsUUFBaEIsR0FBMkIsVUFBVUMsQ0FBVixFQUFhQyxDQUFiLEVBQWdCO0FBQ3ZDLE9BQUtULEtBQUwsQ0FBV1EsQ0FBWCxHQUFlQSxDQUFmO0FBQ0EsT0FBS1IsS0FBTCxDQUFXUyxDQUFYLEdBQWVBLENBQWY7QUFDSCxDQUhEOztBQUtBVixLQUFLLENBQUNPLFNBQU4sQ0FBZ0JJLE1BQWhCLEdBQXlCLFVBQVVGLENBQVYsRUFBYUMsQ0FBYixFQUFnQjtBQUNyQyxPQUFLUixHQUFMLENBQVNPLENB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QUNFLFlBQVksRUFBYixDQUFKLEdBQXVCRyxLQUFLLEdBQUcsQ0FBL0I7QUFDQUwsTUFBQUEsSUFBSSxDQUFDRSxZQUFZLEVBQWIsQ0FBSixHQUF1QkcsS0FBSyxHQUFHLENBQS9CO0FBQ0FMLE1BQUFBLElBQUksQ0FBQ0UsWUFBWSxFQUFiLENBQUosR0FBdUJHLEtBQUssR0FBRyxDQUEvQjtBQUNIOztBQUVEeEUsSUFBQUEsSUFBSSxDQUFDTSxJQUFMLENBQVVtRSxXQUFWLElBQXlCN0csVUFBVSxDQUFDOEcsdUJBQXBDO0FBQ0g7OztFQXBKOENDOzs7QUF1Sm5EaEYscUJBQXFCLENBQUNpRixRQUF0QixDQUErQmxILFlBQS9CLEVBQTZDaUMscUJBQTdDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiBDb3B5cmlnaHQgKGMpIDIwMTctMjAxOCBYaWFtZW4gWWFqaSBTb2Z0d2FyZSBDby4sIEx0ZC5cblxuIGh0dHBzOi8vd3d3LmNvY29zLmNvbS9cblxuIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGVuZ2luZSBzb3VyY2UgY29kZSAodGhlIFwiU29mdHdhcmVcIiksIGEgbGltaXRlZCxcbiB3b3JsZHdpZGUsIHJveWFsdHktZnJlZSwgbm9uLWFzc2lnbmFibGUsIHJldm9jYWJsZSBhbmQgbm9uLWV4Y2x1c2l2ZSBsaWNlbnNlXG4gdG8gdXNlIENvY29zIENyZWF0b3Igc29sZWx5IHRvIGRldmVsb3AgZ2FtZXMgb24geW91ciB0YXJnZXQgcGxhdGZvcm1zLiBZb3Ugc2hhbGxcbiBub3QgdXNlIENvY29zIENyZWF0b3Igc29mdHdhcmUgZm9yIGRldmVsb3Bpbmcgb3RoZXIgc29mdHdhcmUgb3IgdG9vbHMgdGhhdCdzXG4gdXNlZCBmb3IgZGV2ZWxvcGluZyBnYW1lcy4gWW91IGFyZSBub3QgZ3JhbnRlZCB0byBwdWJsaXNoLCBkaXN0cmlidXRlLFxuIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiBDb2NvcyBDcmVhdG9yLlxuXG4gVGhlIHNvZnR3YXJlIG9yIHRvb2xzIGluIHRoaXMgTGljZW5zZSBBZ3JlZW1lbnQgYXJlIGxpY2Vuc2VkLCBub3Qgc29sZC5cbiBYaWFtZW4gWWFqaSBTb2Z0d2FyZSBDby4sIEx0ZC4gcmVzZXJ2ZXMgYWxsIHJpZ2h0cyBub3QgZXhwcmVzc2x5IGdyYW50ZWQgdG8geW91LlxuXG4gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiBUSEUgU09GVFdBUkUuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuaW1wb3J0IEFzc2VtYmxlcjJEIGZyb20gJy4uLy4uL2Fzc2VtYmxlci0yZCc7XG5cbmNvbnN0IE1vdGlvblN0cmVhayA9IHJlcXVpcmUoJy4uLy4uLy4uL2NvbXBvbmVudHMvQ0NNb3Rpb25TdHJlYWsnKTtcbmNvbnN0IFJlbmRlckZsb3cgPSByZXF1aXJlKCcuLi8uLi9yZW5kZXItZmxvdycpO1xuXG5mdW5jdGlvbiBQb2ludCAocG9pbnQsIGRpcikge1xuICAgIHRoaXMucG9pbnQgPSBwb2ludCB8fCBjYy52MigpO1xuICAgIHRoaXMuZGlyID0gZGlyIHx8IGNjLnYyKCk7XG4gICAgdGhpcy5kaXN0YW5jZSA9IDA7XG4gICAgdGhpcy50aW1lID0gMDtcbn1cblxuUG9pbnQucHJvdG90eXBlLnNldFBvaW50ID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICB0aGlzLnBvaW50LnggPSB4O1xuICAgIHRoaXMucG9pbnQueSA9IHk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuc2V0RGlyID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICB0aGlzLmRpci54ID0geDtcbiAgICB0aGlzLmRpci55ID0geTtcbn07XG5cbmxldCBfdGFuZ2VudCA9IGNjLnYyKCk7XG5sZXQgX21pdGVyID0gY2MudjIoKTtcbmxldCBfbm9ybWFsID0gY2MudjIoKTtcbmxldCBfdmVjMiA9IGNjLnYyKCk7XG5cbmZ1bmN0aW9uIG5vcm1hbCAob3V0LCBkaXIpIHtcbiAgICAvL2dldCBwZXJwZW5kaWN1bGFyXG4gICAgb3V0LnggPSAtZGlyLnk7XG4gICAgb3V0LnkgPSBkaXIueDtcbiAgICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVNaXRlciAobWl0ZXIsIGxpbmVBLCBsaW5lQiwgaGFsZlRoaWNrLCBtYXhNdWx0aXBsZSkge1xuICAgIC8vZ2V0IHRhbmdlbnQgbGluZVxuICAgIGxpbmVBLmFkZChsaW5lQiwgX3RhbmdlbnQpO1xuICAgIF90YW5nZW50Lm5vcm1hbGl6ZVNlbGYoKTtcblxuICAgIC8vZ2V0IG1pdGVyIGFzIGEgdW5pdCB2ZWN0b3JcbiAgICBtaXRlci54ID0gLV90YW5nZW50Lnk7XG4gICAgbWl0ZXIueSA9IF90YW5nZW50Lng7XG4gICAgX3ZlYzIueCA9IC1saW5lQS55OyBcbiAgICBfdmVjMi55ID0gbGluZUEueDtcblxuICAgIC8vZ2V0IHRoZSBuZWNlc3NhcnkgbGVuZ3RoIG9mIG91ciBtaXRlclxuICAgIGxldCBtdWx0aXBsZSA9IDEgLyBtaXRlci5kb3QoX3ZlYzIpO1xuICAgIGlmIChtYXhNdWx0aXBsZSkge1xuICAgICAgICBtdWx0aXBsZSA9IE1hdGgubWluKG11bHRpcGxlLCBtYXhNdWx0aXBsZSk7XG4gICAgfVxuICAgIHJldHVybiBoYWxmVGhpY2sgKiBtdWx0aXBsZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTW90aW9uU3RyZWFrQXNzZW1ibGVyIGV4dGVuZHMgQXNzZW1ibGVyMkQge1xuICAgIGluaXREYXRhICgpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyRGF0YS5jcmVhdGVGbGV4RGF0YSgwLCAxNiwgKDE2IC0gMikgKiAzKTtcbiAgICB9XG5cbiAgICB1cGRhdGUgKGNvbXAsIGR0KSB7XG4gICAgICAgIGlmIChDQ19FRElUT1IgJiYgIWNvbXAucHJldmlldykgcmV0dXJuO1xuXG4gICAgICAgIGxldCBzdHJva2UgPSBjb21wLl9zdHJva2UgLyAyO1xuXG4gICAgICAgIGxldCBub2RlID0gY29tcC5ub2RlO1xuICAgICAgICBsZXQgbWF0cml4ID0gbm9kZS5fd29ybGRNYXRyaXgubTtcbiAgICAgICAgbGV0IHR4ID0gbWF0cml4WzEyXSwgdHkgPSBtYXRyaXhbMTNdO1xuXG4gICAgICAgIGxldCBwb2ludHMgPSBjb21wLl9wb2ludHM7XG5cbiAgICAgICAgbGV0IGN1cjtcbiAgICAgICAgaWYgKHBvaW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBsZXQgZGlmeCA9IHBvaW50c1swXS5wb2ludC54IC0gdHg7XG4gICAgICAgICAgICBsZXQgZGlmeSA9IHBvaW50c1swXS5wb2ludC55IC0gdHk7XG4gICAgICAgICAgICBpZiAoKGRpZngqZGlmeCArIGRpZnkqZGlmeSkgPCBjb21wLm1pblNlZykge1xuICAgICAgICAgICAgICAgIGN1ciA9IHBvaW50c1swXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghY3VyKSB7XG4gICAgICAgICAgICBjdXIgPSBuZXcgUG9pbnQoKTtcbiAgICAgICAgICAgIHBvaW50cy5zcGxpY2UoMCwgMCwgY3VyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1ci5zZXRQb2ludCh0eCwgdHkpO1xuICAgICAgICBjdXIudGltZSA9IGNvbXAuX2ZhZGVUaW1lICsgZHQ7XG4gICAgICAgIFxuICAgICAgICBsZXQgdmVydGljZXNDb3VudCA9IDA7XG4gICAgICAgIGxldCBpbmRpY2VzQ291bnQgPSAwO1xuXG4gICAgICAgIGlmIChwb2ludHMubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGNvbG9yID0gY29tcC5fY29sb3IsXG4gICAgICAgICAgICBjciA9IGNvbG9yLnIsIGNnID0gY29sb3IuZywgY2IgPSBjb2xvci5iLCBjYSA9IGNvbG9yLmE7XG5cbiAgICAgICAgbGV0IHByZXYgPSBwb2ludHNbMV07XG4gICAgICAgIHByZXYuZGlzdGFuY2UgPSBjdXIucG9pbnQuc3ViKHByZXYucG9pbnQsIF92ZWMyKS5tYWcoKTtcbiAgICAgICAgX3ZlYzIubm9ybWFsaXplU2VsZigpO1xuICAgICAgICBwcmV2LnNldERpcihfdmVjMi54LCBfdmVjMi55KTtcbiAgICAgICAgY3VyLnNldERpcihfdmVjMi54LCBfdmVjMi55KTtcblxuICAgICAgICBsZXQgZmxleEJ1ZmZlciA9IHRoaXMuX3JlbmRlckRhdGEuX2ZsZXhCdWZmZXI7XG4gICAgICAgIGZsZXhCdWZmZXIucmVzZXJ2ZShwb2ludHMubGVuZ3RoKjIsIChwb2ludHMubGVuZ3RoLTEpKjYpO1xuICAgICAgICBsZXQgdkRhdGEgPSBmbGV4QnVmZmVyLnZEYXRhO1xuICAgICAgICBsZXQgdWludFZEYXRhID0gZmxleEJ1ZmZlci51aW50VkRhdGE7XG4gICAgICAgIGxldCB2ZXJ0c09mZnNldCA9IDU7XG5cbiAgICAgICAgbGV0IGZhZGVUaW1lID0gY29tcC5fZmFkZVRpbWU7XG4gICAgICAgIGxldCBmaW5kTGFzdCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gcG9pbnRzLmxlbmd0aCAtIDE7IGkgPj0wIDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgcCA9IHBvaW50c1tpXTtcbiAgICAgICAgICAgIGxldCBwb2ludCA9IHAucG9pbnQ7XG4gICAgICAgICAgICBsZXQgZGlyID0gcC5kaXI7XG4gICAgICAgICAgICBwLnRpbWUgLT0gZHQ7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChwLnRpbWUgPCAwKSB7XG4gICAgICAgICAgICAgICAgcG9pbnRzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IHByb2dyZXNzID0gcC50aW1lIC8gZmFkZVRpbWU7XG5cbiAgICAgICAgICAgIGxldCBuZXh0ID0gcG9pbnRzW2kgLSAxXTtcbiAgICAgICAgICAgIGlmICghZmluZExhc3QpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHBvaW50LnggPSBuZXh0LnBvaW50LnggLSBkaXIueCAqIHByb2dyZXNzO1xuICAgICAgICAgICAgICAgIHBvaW50LnkgPSBuZXh0LnBvaW50LnkgLSBkaXIueSAqIHByb2dyZXNzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluZExhc3QgPSB0cnVlO1xuXG4gICAgICAgICAgICBub3JtYWwoX25vcm1hbCwgZGlyKTtcblxuICAgICAgICAgICAgXG4gICAgICAgICAgICBsZXQgZGEgPSBwcm9ncmVzcypjYTtcbiAgICAgICAgICAgIGxldCBjID0gKChkYTw8MjQpID4+PiAwKSArIChjYjw8MTYpICsgKGNnPDw4KSArIGNyO1xuXG4gICAgICAgICAgICBsZXQgb2Zmc2V0ID0gdmVydGljZXNDb3VudCAqIHZlcnRzT2Zmc2V0O1xuXG4gICAgICAgICAgICB2RGF0YVtvZmZzZXRdID0gcG9pbnQueCArIF9ub3JtYWwueCAqIHN0cm9rZTtcbiAgICAgICAgICAgIHZEYXRhW29mZnNldCArIDFdID0gcG9pbnQueSArIF9ub3JtYWwueSAqIHN0cm9rZTtcbiAgICAgICAgICAgIHZEYXRhW29mZnNldCArIDJdID0gMTtcbiAgICAgICAgICAgIHZEYXRhW29mZnNldCArIDNdID0gcHJvZ3Jlc3M7XG4gICAgICAgICAgICB1aW50VkRhdGFbb2Zmc2V0ICsgNF0gPSBjO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBvZmZzZXQgKz0gdmVydHNPZmZzZXQ7XG5cbiAgICAgICAgICAgIHZEYXRhW29mZnNldF0gPSBwb2ludC54IC0gX25vcm1hbC54ICogc3Ryb2tlO1xuICAgICAgICAgICAgdkRhdGFbb2Zmc2V0ICsgMV0gPSBwb2ludC55IC0gX25vcm1hbC55ICogc3Ryb2tlO1xuICAgICAgICAgICAgdkRhdGFbb2Zmc2V0ICsgMl0gPSAwO1xuICAgICAgICAgICAgdkRhdGFbb2Zmc2V0ICsgM10gPSBwcm9ncmVzcztcbiAgICAgICAgICAgIHVpbnRWRGF0YVtvZmZzZXQgKyA0XSA9IGM7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZlcnRpY2VzQ291bnQgKz0gMjtcbiAgICAgICAgfVxuXG4gICAgICAgIGluZGljZXNDb3VudCA9IHZlcnRpY2VzQ291bnQgPD0gMiA/IDAgOiAodmVydGljZXNDb3VudCAtIDIpKjM7XG5cbiAgICAgICAgZmxleEJ1ZmZlci51c2VkKHZlcnRpY2VzQ291bnQsIGluZGljZXNDb3VudCk7XG4gICAgfVxuXG4gICAgZmlsbEJ1ZmZlcnMgKGNvbXAsIHJlbmRlcmVyKSB7XG4gICAgICAgIGxldCB7IHZEYXRhLCB1c2VkVmVydGljZXMsIHVzZWRJbmRpY2VzLCB1c2VkVmVydGljZXNGbG9hdHMgfSA9IHRoaXMuX3JlbmRlckRhdGEuX2ZsZXhCdWZmZXI7XG5cbiAgICAgICAgbGV0IGJ1ZmZlciA9IHJlbmRlcmVyLl9tZXNoQnVmZmVyO1xuICAgICAgICBsZXQgb2Zmc2V0SW5mbyA9IGJ1ZmZlci5yZXF1ZXN0KHVzZWRWZXJ0aWNlcywgdXNlZEluZGljZXMpO1xuXG4gICAgICAgIC8vIGJ1ZmZlciBkYXRhIG1heSBiZSByZWFsbG9jLCBuZWVkIGdldCByZWZlcmVuY2UgYWZ0ZXIgcmVxdWVzdC5cblxuICAgICAgICAvLyBmaWxsIHZlcnRpY2VzXG4gICAgICAgIGxldCB2ZXJ0ZXhPZmZzZXQgPSBvZmZzZXRJbmZvLmJ5dGVPZmZzZXQgPj4gMixcbiAgICAgICAgICAgIHZidWYgPSBidWZmZXIuX3ZEYXRhO1xuXG4gICAgICAgIGlmICh2RGF0YS5sZW5ndGggKyB2ZXJ0ZXhPZmZzZXQgPiB2YnVmLmxlbmd0aCkge1xuICAgICAgICAgICAgdmJ1Zi5zZXQodkRhdGEuc3ViYXJyYXkoMCwgdXNlZFZlcnRpY2VzRmxvYXRzKSwgdmVydGV4T2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZidWYuc2V0KHZEYXRhLCB2ZXJ0ZXhPZmZzZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmlsbCBpbmRpY2VzXG4gICAgICAgIGxldCBpYnVmID0gYnVmZmVyLl9pRGF0YSxcbiAgICAgICAgICAgIGluZGljZU9mZnNldCA9IG9mZnNldEluZm8uaW5kaWNlT2Zmc2V0LFxuICAgICAgICAgICAgdmVydGV4SWQgPSBvZmZzZXRJbmZvLnZlcnRleE9mZnNldDtcblxuICAgICAgICAvLyBpbmRleCBidWZmZXJcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSB1c2VkVmVydGljZXM7IGkgPCBsOyBpICs9IDIpIHtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IHZlcnRleElkICsgaTtcbiAgICAgICAgICAgIGlidWZbaW5kaWNlT2Zmc2V0KytdID0gc3RhcnQ7XG4gICAgICAgICAgICBpYnVmW2luZGljZU9mZnNldCsrXSA9IHN0YXJ0ICsgMjtcbiAgICAgICAgICAgIGlidWZbaW5kaWNlT2Zmc2V0KytdID0gc3RhcnQgKyAxO1xuICAgICAgICAgICAgaWJ1ZltpbmRpY2VPZmZzZXQrK10gPSBzdGFydCArIDE7XG4gICAgICAgICAgICBpYnVmW2luZGljZU9mZnNldCsrXSA9IHN0YXJ0ICsgMjtcbiAgICAgICAgICAgIGlidWZbaW5kaWNlT2Zmc2V0KytdID0gc3RhcnQgKyAzO1xuICAgICAgICB9XG5cbiAgICAgICAgY29tcC5ub2RlLl9yZW5kZXJGbGFnIHw9IFJlbmRlckZsb3cuRkxBR19VUERBVEVfUkVOREVSX0RBVEE7XG4gICAgfVxufVxuXG5Nb3Rpb25TdHJlYWtBc3NlbWJsZXIucmVnaXN0ZXIoTW90aW9uU3RyZWFrLCBNb3Rpb25TdHJlYWtBc3NlbWJsZXIpO1xuIl0sInNvdXJjZVJvb3QiOiIvIn0=