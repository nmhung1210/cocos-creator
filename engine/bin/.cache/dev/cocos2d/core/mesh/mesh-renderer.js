
                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'engine-dev/cocos2d/core/mesh/mesh-renderer.js';
                    var __require = nodeEnv ? function (request) {
                        return require(request);
                    } : function (request) {
                        return __quick_compile_engine__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_engine__.registerModule(__filename, module);}"use strict";

exports.__esModule = true;
exports["default"] = void 0;

var _assembler = _interopRequireDefault(require("../renderer/assembler"));

var _gfx = _interopRequireDefault(require("../../renderer/gfx"));

var _vec = _interopRequireDefault(require("../value-types/vec3"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var MeshRenderer = require('./CCMeshRenderer');

var _tmp_vec3 = new _vec["default"]();

var MeshRendererAssembler = /*#__PURE__*/function (_Assembler) {
  _inheritsLoose(MeshRendererAssembler, _Assembler);

  function MeshRendererAssembler() {
    return _Assembler.apply(this, arguments) || this;
  }

  var _proto = MeshRendererAssembler.prototype;

  _proto.init = function init(renderComp) {
    _Assembler.prototype.init.call(this, renderComp);

    this._worldDatas = {};
    this._renderNode = null;
  };

  _proto.setRenderNode = function setRenderNode(node) {
    this._renderNode = node;
  };

  _proto.fillBuffers = function fillBuffers(comp, renderer) {
    if (!comp.mesh) return;

    comp.mesh._uploadData(); // update culling mask


    var isCullingMaskSame = renderer.cullingMask === comp.node._cullingMask;
    var enableAutoBatch = comp.enableAutoBatch;
    var materials = comp._materials;
    var submeshes = comp.mesh._subMeshes;
    var subDatas = comp.mesh.subDatas;

    for (var i = 0; i < submeshes.length; i++) {
      var ia = submeshes[i];
      var meshData = subDatas[i];
      var material = materials[i] || materials[0];

      if (!enableAutoBatch || !meshData.canBatch || ia._primitiveType !== _gfx["default"].PT_TRIANGLES) {
        renderer._flush();

        renderer.material = material;
        renderer.cullingMask = comp.node._cullingMask;
        renderer.node = this._renderNode;

        renderer._flushIA(ia);

        continue;
      }

      if (!isCullingMaskSame || material.getHash() !== renderer.material.getHash()) {
        renderer._flush();
      }

      renderer.material = material;
      renderer.cullingMask = comp.node._cullingMask;
      renderer.node = renderer._dummyNode;

      this._fillBuffer(comp, meshData, renderer, i);
    }

    if (CC_DEBUG && (cc.macro.SHOW_MESH_WIREFRAME || cc.macro.SHOW_MESH_NORMAL) && !(comp.node._cullingMask & 1 << cc.Node.BuiltinGroupIndex.DEBUG)) {
      renderer._flush();

      renderer.node = this._renderNode;

      comp._updateDebugDatas();

      if (cc.macro.SHOW_MESH_WIREFRAME) {
        this._drawDebugDatas(comp, renderer, 'wireFrame');
      }

      if (cc.macro.SHOW_MESH_NORMAL) {
        this._drawDebugDatas(comp, renderer, 'normal');
      }
    }
  };

  _proto._fillBuffer = function _fillBuffer(comp, meshData, renderer, dataIndex) {
    var vData = meshData.getVData(Float32Array);
    var vtxFormat = meshData.vfm;
    var vertexCount = vData.byteLength / vtxFormat._bytes | 0;
    var indices = meshData.getIData(Uint16Array);
    var indicesCount = indices.length;
    var buffer = renderer.getBuffer('mesh', vtxFormat);
    var offsetInfo = buffer.request(vertexCount, indicesCount); // buffer data may be realloc, need get reference after request.

    var indiceOffset = offsetInfo.indiceOffset,
        vertexOffset = offsetInfo.byteOffset >> 2,
        vertexId = offsetInfo.vertexOffset,
        vbuf = buffer._vData,
        ibuf = buffer._iData;

    if (renderer.worldMatDirty || !this._worldDatas[dataIndex]) {
      this._updateWorldVertices(dataIndex, vertexCount, vData, vtxFormat, comp.node._worldMatrix);
    }

    vbuf.set(this._worldDatas[dataIndex], vertexOffset);

    for (var i = 0; i < indicesCount; i++) {
      ibuf[indiceOffset + i] = vertexId + indices[i];
    }
  };

  _proto._updateWorldVertices = function _updateWorldVertices(dataIndex, vertexCount, local, vtxFormat, wolrdMatrix) {
    var world = this._worldDatas[dataIndex];

    if (!world) {
      world = this._worldDatas[dataIndex] = new Float32Array(local.length);
      world.set(local);
    }

    var floatCount = vtxFormat._bytes / 4;
    var elements = vtxFormat._elements;

    for (var i = 0, n = elements.length; i < n; i++) {
      var element = elements[i];
      var attrOffset = element.offset / 4;

      if (element.name === _gfx["default"].ATTR_POSITION || element.name === _gfx["default"].ATTR_NORMAL) {
        var transformMat4 = element.name === _gfx["default"].ATTR_NORMAL ? _vec["default"].transformMat4Normal : _vec["default"].transformMat4;

        for (var j = 0; j < vertexCount; j++) {
          var offset = j * floatCount + attrOffset;
          _tmp_vec3.x = local[offset];
          _tmp_vec3.y = local[offset + 1];
          _tmp_vec3.z = local[offset + 2];
          transformMat4(_tmp_vec3, _tmp_vec3, wolrdMatrix);
          world[offset] = _tmp_vec3.x;
          world[offset + 1] = _tmp_vec3.y;
          world[offset + 2] = _tmp_vec3.z;
        }
      }
    }
  };

  _proto._drawDebugDatas = function _drawDebugDatas(comp, renderer, name) {
    var debugDatas = comp._debugDatas[name];
    if (!debugDatas) return;

    for (var i = 0; i < debugDatas.length; i++) {
      var debugData = debugDatas[i];
      if (!debugData) continue;
      var material = debugData.material;
      renderer.material = material;

      renderer._flushIA(debugData.ia);
    }
  };

  return MeshRendererAssembler;
}(_assembler["default"]);

exports["default"] = MeshRendererAssembler;

_assembler["default"].register(MeshRenderer, MeshRendererAssembler);

module.exports = exports["default"];
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_engine__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImVuZ2luZS1kZXYvY29jb3MyZC9jb3JlL21lc2gvbWVzaC1yZW5kZXJlci5qcyJdLCJuYW1lcyI6WyJNZXNoUmVuZGVyZXIiLCJyZXF1aXJlIiwiX3RtcF92ZWMzIiwiVmVjMyIsIk1lc2hSZW5kZXJlckFzc2VtYmxlciIsImluaXQiLCJyZW5kZXJDb21wIiwiX3dvcmxkRGF0YXMiLCJfcmVuZGVyTm9kZSIsInNldFJlbmRlck5vZGUiLCJub2RlIiwiZmlsbEJ1ZmZlcnMiLCJjb21wIiwicmVuZGVyZXIiLCJtZXNoIiwiX3VwbG9hZERhdGEiLCJpc0N1bGxpbmdNYXNrU2FtZSIsImN1bGxpbmdNYXNrIiwiX2N1bGxpbmdNYXNrIiwiZW5hYmxlQXV0b0JhdGNoIiwibWF0ZXJpYWxzIiwiX21hdGVyaWFscyIsInN1Ym1lc2hlcyIsIl9zdWJNZXNoZXMiLCJzdWJEYXRhcyIsImkiLCJsZW5ndGgiLCJpYSIsIm1lc2hEYXRhIiwibWF0ZXJpYWwiLCJjYW5CYXRjaCIsIl9wcmltaXRpdmVUeXBlIiwiZ2Z4IiwiUFRfVFJJQU5HTEVTIiwiX2ZsdXNoIiwiX2ZsdXNoSUEiLCJnZXRIYXNoIiwiX2R1bW15Tm9kZSIsIl9maWxsQnVmZmVyIiwiQ0NfREVCVUciLCJjYyIsIm1hY3JvIiwiU0hPV19NRVNIX1dJUkVGUkFNRSIsIlNIT1dfTUVTSF9OT1JNQUwiLCJOb2RlIiwiQnVpbHRpbkdyb3VwSW5kZXgiLCJERUJVRyIsIl91cGRhdGVEZWJ1Z0RhdGFzIiwiX2RyYXdEZWJ1Z0RhdGFzIiwiZGF0YUluZGV4IiwidkRhdGEiLCJnZXRWRGF0YSIsIkZsb2F0MzJBcnJheSIsInZ0eEZvcm1hdCIsInZmbSIsInZlcnRleENvdW50IiwiYnl0ZUxlbmd0aCIsIl9ieXRlcyIsImluZGljZXMiLCJnZXRJRGF0YSIsIlVpbnQxNkFycmF5IiwiaW5kaWNlc0NvdW50IiwiYnVmZmVyIiwiZ2V0QnVmZmVyIiwib2Zmc2V0SW5mbyIsInJlcXVlc3QiLCJpbmRpY2VPZmZzZXQiLCJ2ZXJ0ZXhPZmZzZXQiLCJieXRlT2Zmc2V0IiwidmVydGV4SWQiLCJ2YnVmIiwiX3ZEYXRhIiwiaWJ1ZiIsIl9pRGF0YSIsIndvcmxkTWF0RGlydHkiLCJfdXBkYXRlV29ybGRWZXJ0aWNlcyIsIl93b3JsZE1hdHJpeCIsInNldCIsImxvY2FsIiwid29scmRNYXRyaXgiLCJ3b3JsZCIsImZsb2F0Q291bnQiLCJlbGVtZW50cyIsIl9lbGVtZW50cyIsIm4iLCJlbGVtZW50IiwiYXR0ck9mZnNldCIsIm9mZnNldCIsIm5hbWUiLCJBVFRSX1BPU0lUSU9OIiwiQVRUUl9OT1JNQUwiLCJ0cmFuc2Zvcm1NYXQ0IiwidHJhbnNmb3JtTWF0NE5vcm1hbCIsImoiLCJ4IiwieSIsInoiLCJkZWJ1Z0RhdGFzIiwiX2RlYnVnRGF0YXMiLCJkZWJ1Z0RhdGEiLCJBc3NlbWJsZXIiLCJyZWdpc3RlciJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQXlCQTs7QUFDQTs7QUFDQTs7Ozs7O0FBRUEsSUFBTUEsWUFBWSxHQUFHQyxPQUFPLENBQUMsa0JBQUQsQ0FBNUI7O0FBRUEsSUFBSUMsU0FBUyxHQUFHLElBQUlDLGVBQUosRUFBaEI7O0lBRXFCQzs7Ozs7Ozs7O1NBQ2pCQyxPQUFBLGNBQU1DLFVBQU4sRUFBa0I7QUFDZCx5QkFBTUQsSUFBTixZQUFXQyxVQUFYOztBQUVBLFNBQUtDLFdBQUwsR0FBbUIsRUFBbkI7QUFDQSxTQUFLQyxXQUFMLEdBQW1CLElBQW5CO0FBQ0g7O1NBRURDLGdCQUFBLHVCQUFlQyxJQUFmLEVBQXFCO0FBQ2pCLFNBQUtGLFdBQUwsR0FBbUJFLElBQW5CO0FBQ0g7O1NBRURDLGNBQUEscUJBQWFDLElBQWIsRUFBbUJDLFFBQW5CLEVBQTZCO0FBQ3pCLFFBQUksQ0FBQ0QsSUFBSSxDQUFDRSxJQUFWLEVBQWdCOztBQUVoQkYsSUFBQUEsSUFBSSxDQUFDRSxJQUFMLENBQVVDLFdBQVYsR0FIeUIsQ0FLekI7OztBQUNBLFFBQUlDLGlCQUFpQixHQUFHSCxRQUFRLENBQUNJLFdBQVQsS0FBeUJM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QUFDdkUsTUFBL0IsRUFBdUNELENBQUMsRUFBeEMsRUFBNEM7QUFDeEMsVUFBSTBFLFNBQVMsR0FBR0YsVUFBVSxDQUFDeEUsQ0FBRCxDQUExQjtBQUNBLFVBQUksQ0FBQzBFLFNBQUwsRUFBZ0I7QUFDaEIsVUFBSXRFLFFBQVEsR0FBR3NFLFNBQVMsQ0FBQ3RFLFFBQXpCO0FBQ0FoQixNQUFBQSxRQUFRLENBQUNnQixRQUFULEdBQW9CQSxRQUFwQjs7QUFDQWhCLE1BQUFBLFFBQVEsQ0FBQ3NCLFFBQVQsQ0FBa0JnRSxTQUFTLENBQUN4RSxFQUE1QjtBQUNIO0FBQ0o7OztFQWhKOEN5RTs7OztBQW1KbkRBLHNCQUFVQyxRQUFWLENBQW1CckcsWUFBbkIsRUFBaUNJLHFCQUFqQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gQ29weXJpZ2h0IChjKSAyMDE3LTIwMTggWGlhbWVuIFlhamkgU29mdHdhcmUgQ28uLCBMdGQuXG5cbiBodHRwOi8vd3d3LmNvY29zLmNvbVxuXG4gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZW5naW5lIHNvdXJjZSBjb2RlICh0aGUgXCJTb2Z0d2FyZVwiKSwgYSBsaW1pdGVkLFxuIHdvcmxkd2lkZSwgcm95YWx0eS1mcmVlLCBub24tYXNzaWduYWJsZSwgcmV2b2NhYmxlIGFuZCBub24tZXhjbHVzaXZlIGxpY2Vuc2VcbiB0byB1c2UgQ29jb3MgQ3JlYXRvciBzb2xlbHkgdG8gZGV2ZWxvcCBnYW1lcyBvbiB5b3VyIHRhcmdldCBwbGF0Zm9ybXMuIFlvdSBzaGFsbFxuIG5vdCB1c2UgQ29jb3MgQ3JlYXRvciBzb2Z0d2FyZSBmb3IgZGV2ZWxvcGluZyBvdGhlciBzb2Z0d2FyZSBvciB0b29scyB0aGF0J3NcbiB1c2VkIGZvciBkZXZlbG9waW5nIGdhbWVzLiBZb3UgYXJlIG5vdCBncmFudGVkIHRvIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsXG4gc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIENvY29zIENyZWF0b3IuXG5cbiBUaGUgc29mdHdhcmUgb3IgdG9vbHMgaW4gdGhpcyBMaWNlbnNlIEFncmVlbWVudCBhcmUgbGljZW5zZWQsIG5vdCBzb2xkLlxuIFhpYW1lbiBZYWppIFNvZnR3YXJlIENvLiwgTHRkLiByZXNlcnZlcyBhbGwgcmlnaHRzIG5vdCBleHByZXNzbHkgZ3JhbnRlZCB0byB5b3UuXG5cbiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuIFRIRSBTT0ZUV0FSRS5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5pbXBvcnQgQXNzZW1ibGVyIGZyb20gJy4uL3JlbmRlcmVyL2Fzc2VtYmxlcic7XG5pbXBvcnQgZ2Z4IGZyb20gJy4uLy4uL3JlbmRlcmVyL2dmeCc7XG5pbXBvcnQgVmVjMyBmcm9tICcuLi92YWx1ZS10eXBlcy92ZWMzJztcblxuY29uc3QgTWVzaFJlbmRlcmVyID0gcmVxdWlyZSgnLi9DQ01lc2hSZW5kZXJlcicpO1xuXG5sZXQgX3RtcF92ZWMzID0gbmV3IFZlYzMoKTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWVzaFJlbmRlcmVyQXNzZW1ibGVyIGV4dGVuZHMgQXNzZW1ibGVyIHtcbiAgICBpbml0IChyZW5kZXJDb21wKSB7XG4gICAgICAgIHN1cGVyLmluaXQocmVuZGVyQ29tcCk7XG4gICAgICAgIFxuICAgICAgICB0aGlzLl93b3JsZERhdGFzID0ge307XG4gICAgICAgIHRoaXMuX3JlbmRlck5vZGUgPSBudWxsO1xuICAgIH1cblxuICAgIHNldFJlbmRlck5vZGUgKG5vZGUpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyTm9kZSA9IG5vZGU7XG4gICAgfVxuXG4gICAgZmlsbEJ1ZmZlcnMgKGNvbXAsIHJlbmRlcmVyKSB7XG4gICAgICAgIGlmICghY29tcC5tZXNoKSByZXR1cm47XG5cbiAgICAgICAgY29tcC5tZXNoLl91cGxvYWREYXRhKCk7XG5cbiAgICAgICAgLy8gdXBkYXRlIGN1bGxpbmcgbWFza1xuICAgICAgICBsZXQgaXNDdWxsaW5nTWFza1NhbWUgPSByZW5kZXJlci5jdWxsaW5nTWFzayA9PT0gY29tcC5ub2RlLl9jdWxsaW5nTWFzaztcblxuICAgICAgICBsZXQgZW5hYmxlQXV0b0JhdGNoID0gY29tcC5lbmFibGVBdXRvQmF0Y2g7XG5cbiAgICAgICAgbGV0IG1hdGVyaWFscyA9IGNvbXAuX21hdGVyaWFscztcbiAgICAgICAgbGV0IHN1Ym1lc2hlcyA9IGNvbXAubWVzaC5fc3ViTWVzaGVzO1xuICAgICAgICBsZXQgc3ViRGF0YXMgPSBjb21wLm1lc2guc3ViRGF0YXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3VibWVzaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgaWEgPSBzdWJtZXNoZXNbaV07XG4gICAgICAgICAgICBsZXQgbWVzaERhdGEgPSBzdWJEYXRhc1tpXTtcblxuICAgICAgICAgICAgbGV0IG1hdGVyaWFsID0gbWF0ZXJpYWxzW2ldIHx8IG1hdGVyaWFsc1swXTtcblxuICAgICAgICAgICAgaWYgKCFlbmFibGVBdXRvQmF0Y2ggfHwgIW1lc2hEYXRhLmNhbkJhdGNoIHx8IGlhLl9wcmltaXRpdmVUeXBlICE9PSBnZnguUFRfVFJJQU5HTEVTKSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyZXIuX2ZsdXNoKCk7XG5cbiAgICAgICAgICAgICAgICByZW5kZXJlci5tYXRlcmlhbCA9IG1hdGVyaWFsO1xuICAgICAgICAgICAgICAgIHJlbmRlcmVyLmN1bGxpbmdNYXNrID0gY29tcC5ub2RlLl9jdWxsaW5nTWFzaztcbiAgICAgICAgICAgICAgICByZW5kZXJlci5ub2RlID0gdGhpcy5fcmVuZGVyTm9kZTtcblxuICAgICAgICAgICAgICAgIHJlbmRlcmVyLl9mbHVzaElBKGlhKTtcblxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWlzQ3VsbGluZ01hc2tTYW1lIHx8XG4gICAgICAgICAgICAgICAgbWF0ZXJpYWwuZ2V0SGFzaCgpICE9PSByZW5kZXJlci5tYXRlcmlhbC5nZXRIYXNoKCkpIHtcbiAgICAgICAgICAgICAgICByZW5kZXJlci5fZmx1c2goKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVuZGVyZXIubWF0ZXJpYWwgPSBtYXRlcmlhbDtcbiAgICAgICAgICAgIHJlbmRlcmVyLmN1bGxpbmdNYXNrID0gY29tcC5ub2RlLl9jdWxsaW5nTWFzaztcbiAgICAgICAgICAgIHJlbmRlcmVyLm5vZGUgPSByZW5kZXJlci5fZHVtbXlOb2RlO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLl9maWxsQnVmZmVyKGNvbXAsIG1lc2hEYXRhLCByZW5kZXJlciwgaSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoQ0NfREVCVUcgJiZcbiAgICAgICAgICAgIChjYy5tYWNyby5TSE9XX01FU0hfV0lSRUZSQU1FIHx8IGNjLm1hY3JvLlNIT1dfTUVTSF9OT1JNQUwpICYmIFxuICAgICAgICAgICAgIShjb21wLm5vZGUuX2N1bGxpbmdNYXNrICYgKDE8PGNjLk5vZGUuQnVpbHRpbkdyb3VwSW5kZXguREVCVUcpKSkge1xuICAgICAgICAgICAgcmVuZGVyZXIuX2ZsdXNoKCk7XG4gICAgICAgICAgICByZW5kZXJlci5ub2RlID0gdGhpcy5fcmVuZGVyTm9kZTtcbiAgICAgICAgICAgIGNvbXAuX3VwZGF0ZURlYnVnRGF0YXMoKTtcbiAgICAgICAgXG4gICAgICAgICAgICBpZiAoY2MubWFjcm8uU0hPV19NRVNIX1dJUkVGUkFNRSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RyYXdEZWJ1Z0RhdGFzKGNvbXAsIHJlbmRlcmVyLCAnd2lyZUZyYW1lJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2MubWFjcm8uU0hPV19NRVNIX05PUk1BTCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RyYXdEZWJ1Z0RhdGFzKGNvbXAsIHJlbmRlcmVyLCAnbm9ybWFsJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfZmlsbEJ1ZmZlciAoY29tcCwgbWVzaERhdGEsIHJlbmRlcmVyLCBkYXRhSW5kZXgpIHtcbiAgICAgICAgbGV0IHZEYXRhID0gbWVzaERhdGEuZ2V0VkRhdGEoRmxvYXQzMkFycmF5KTtcblxuICAgICAgICBsZXQgdnR4Rm9ybWF0ID0gbWVzaERhdGEudmZtO1xuICAgICAgICBsZXQgdmVydGV4Q291bnQgPSAodkRhdGEuYnl0ZUxlbmd0aCAvIHZ0eEZvcm1hdC5fYnl0ZXMpIHwgMDtcbiAgICAgICAgXG4gICAgICAgIGxldCBpbmRpY2VzID0gbWVzaERhdGEuZ2V0SURhdGEoVWludDE2QXJyYXkpO1xuICAgICAgICBsZXQgaW5kaWNlc0NvdW50ID0gaW5kaWNlcy5sZW5ndGg7XG5cbiAgICAgICAgbGV0IGJ1ZmZlciA9IHJlbmRlcmVyLmdldEJ1ZmZlcignbWVzaCcsIHZ0eEZvcm1hdCk7XG4gICAgICAgIGxldCBvZmZzZXRJbmZvID0gYnVmZmVyLnJlcXVlc3QodmVydGV4Q291bnQsIGluZGljZXNDb3VudCk7XG4gICAgICAgIFxuICAgICAgICAvLyBidWZmZXIgZGF0YSBtYXkgYmUgcmVhbGxvYywgbmVlZCBnZXQgcmVmZXJlbmNlIGFmdGVyIHJlcXVlc3QuXG4gICAgICAgIGxldCBpbmRpY2VPZmZzZXQgPSBvZmZzZXRJbmZvLmluZGljZU9mZnNldCxcbiAgICAgICAgICAgIHZlcnRleE9mZnNldCA9IG9mZnNldEluZm8uYnl0ZU9mZnNldCA+PiAyLFxuICAgICAgICAgICAgdmVydGV4SWQgPSBvZmZzZXRJbmZvLnZlcnRleE9mZnNldCxcbiAgICAgICAgICAgIHZidWYgPSBidWZmZXIuX3ZEYXRhLFxuICAgICAgICAgICAgaWJ1ZiA9IGJ1ZmZlci5faURhdGE7XG5cbiAgICAgICAgaWYgKHJlbmRlcmVyLndvcmxkTWF0RGlydHkgfHwgIXRoaXMuX3dvcmxkRGF0YXNbZGF0YUluZGV4XSkge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlV29ybGRWZXJ0aWNlcyhkYXRhSW5kZXgsIHZlcnRleENvdW50LCB2RGF0YSwgdnR4Rm9ybWF0LCBjb21wLm5vZGUuX3dvcmxkTWF0cml4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZidWYuc2V0KHRoaXMuX3dvcmxkRGF0YXNbZGF0YUluZGV4XSwgdmVydGV4T2Zmc2V0KTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZGljZXNDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBpYnVmW2luZGljZU9mZnNldCArIGldID0gdmVydGV4SWQgKyBpbmRpY2VzW2ldO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX3VwZGF0ZVdvcmxkVmVydGljZXMgKGRhdGFJbmRleCwgdmVydGV4Q291bnQsIGxvY2FsLCB2dHhGb3JtYXQsIHdvbHJkTWF0cml4KSB7XG4gICAgICAgIGxldCB3b3JsZCA9IHRoaXMuX3dvcmxkRGF0YXNbZGF0YUluZGV4XTtcbiAgICAgICAgaWYgKCF3b3JsZCkge1xuICAgICAgICAgICAgd29ybGQgPSB0aGlzLl93b3JsZERhdGFzW2RhdGFJbmRleF0gPSBuZXcgRmxvYXQzMkFycmF5KGxvY2FsLmxlbmd0aCk7XG4gICAgICAgICAgICB3b3JsZC5zZXQobG9jYWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGZsb2F0Q291bnQgPSB2dHhGb3JtYXQuX2J5dGVzIC8gNDtcbiAgICAgICAgXG4gICAgICAgIGxldCBlbGVtZW50cyA9IHZ0eEZvcm1hdC5fZWxlbWVudHM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gZWxlbWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgZWxlbWVudCA9IGVsZW1lbnRzW2ldO1xuICAgICAgICAgICAgbGV0IGF0dHJPZmZzZXQgPSBlbGVtZW50Lm9mZnNldCAvIDQ7XG4gICAgICAgICBcbiAgICAgICAgICAgIGlmIChlbGVtZW50Lm5hbWUgPT09IGdmeC5BVFRSX1BPU0lUSU9OIHx8IGVsZW1lbnQubmFtZSA9PT0gZ2Z4LkFUVFJfTk9STUFMKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRyYW5zZm9ybU1hdDQgPSBlbGVtZW50Lm5hbWUgPT09IGdmeC5BVFRSX05PUk1BTCA/IFZlYzMudHJhbnNmb3JtTWF0NE5vcm1hbCA6IFZlYzMudHJhbnNmb3JtTWF0NDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHZlcnRleENvdW50OyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG9mZnNldCA9IGogKiBmbG9hdENvdW50ICsgYXR0ck9mZnNldDtcblxuICAgICAgICAgICAgICAgICAgICBfdG1wX3ZlYzMueCA9IGxvY2FsW29mZnNldF07XG4gICAgICAgICAgICAgICAgICAgIF90bXBfdmVjMy55ID0gbG9jYWxbb2Zmc2V0ICsgMV07XG4gICAgICAgICAgICAgICAgICAgIF90bXBfdmVjMy56ID0gbG9jYWxbb2Zmc2V0ICsgMl07XG4gICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1NYXQ0KF90bXBfdmVjMywgX3RtcF92ZWMzLCB3b2xyZE1hdHJpeCk7XG5cbiAgICAgICAgICAgICAgICAgICAgd29ybGRbb2Zmc2V0XSA9IF90bXBfdmVjMy54O1xuICAgICAgICAgICAgICAgICAgICB3b3JsZFtvZmZzZXQgKyAxXSA9IF90bXBfdmVjMy55O1xuICAgICAgICAgICAgICAgICAgICB3b3JsZFtvZmZzZXQgKyAyXSA9IF90bXBfdmVjMy56O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9kcmF3RGVidWdEYXRhcyAoY29tcCwgcmVuZGVyZXIsIG5hbWUpIHtcbiAgICAgICAgbGV0IGRlYnVnRGF0YXMgPSBjb21wLl9kZWJ1Z0RhdGFzW25hbWVdO1xuICAgICAgICBpZiAoIWRlYnVnRGF0YXMpIHJldHVybjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZWJ1Z0RhdGFzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgZGVidWdEYXRhID0gZGVidWdEYXRhc1tpXTtcbiAgICAgICAgICAgIGlmICghZGVidWdEYXRhKSBjb250aW51ZTtcbiAgICAgICAgICAgIGxldCBtYXRlcmlhbCA9IGRlYnVnRGF0YS5tYXRlcmlhbDtcbiAgICAgICAgICAgIHJlbmRlcmVyLm1hdGVyaWFsID0gbWF0ZXJpYWw7XG4gICAgICAgICAgICByZW5kZXJlci5fZmx1c2hJQShkZWJ1Z0RhdGEuaWEpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5Bc3NlbWJsZXIucmVnaXN0ZXIoTWVzaFJlbmRlcmVyLCBNZXNoUmVuZGVyZXJBc3NlbWJsZXIpO1xuIl0sInNvdXJjZVJvb3QiOiIvIn0=